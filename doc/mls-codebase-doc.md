# Documentation of the MLscript Codebase

This is the documentation of the MLscript codebase.

## Overview

This codebase of the MLscript Programming Language has all the basic components
of a static-typed programming language compiler: lexer, parser, typer, and code generator.
For testing, there is a web demo of MLscript as well as a test suite.
We now give a high-level introduction to each compiler component and its correspondence to
our Scala sources. Note that source file paths are rooted in `/shared/src/main/scala/mlscript`.

### Lexing

The lexer accepts source strings and returns tokens to be parsed.
The corresponding files are:

- `NewLexer.scala` contains the lexer class.
- `Token.scala` contains the token data types.

### Parsing

The parser accepts tokens generated by the lexer and
returns an abstract syntax tree of the input program in the surface syntax.
The corresponding files are:

- `NewParser.scala` contains the parser class.
- `syntax.scala` contains the **surface** syntax data types of the language.

### Typing

The typer accepts an abstract syntax tree of a program
and performs type checking.
MLscript's typer supports principal type inference with subtyping.
For more information about the type system,
please refer to [MLstruct](https://dl.acm.org/doi/abs/10.1145/3563304).

The corresponding files are:
- `Typer.scala` contains the typer class.
- `TypeSimplifier.scala` contains type simplification algorithms to simplify
inferred types.
- `ucs/Desugarer.scala` contains class `ucs.Desugarer` which implements desugaring
methods.
- `TypeDefs.scala` and `NuTypeDefs.scala` contain class `TypeDef` and methods for
declarations like classes, interfaces, and type aliases.
- `ConstraitSolver.scala` contains class `ConstraintSolver` which solves subtyping
constraints.
- `NormalForms.scala` contains class `NormalForms` which provides the infrastructure
to solve tricky subtyping constraints with disjunct normal forms (DNF) on the left
and conjunct normal forms (CNF) on the right.
- `TyperDatatypes.scala` contains class `TyperDatatypes` which includes
data types to support **internal** representation of types with mutable states to support
type inference with subtyping.
- `TyperHelpers.scala` contains class `TyperHelpers` that provides helper methods
for the typer.

Note that the inheritance relationships between these typer classes do *not* have any actual semantics
- we are following Scala's *Cake Pattern*. Typer classes will be finally composed
into the `Typer` class by inheritance.

### Code Generation

The code generator translates MLscript AST into JavaScript AST and generates the corresponding JavaScript code.

The corresponding files are:

- `codegen/Codegen.scala` contains definitions of JavaScript AST nodes
  and methods for JavaScript code generation.
- `codegen/Scope.scala` contains class `Scope` which manages symbols
  and provides hygienic runtime name generation.
- `codegen/Symbol.scala` contains classes `NewClassSymbol`, `MixinSymbol`,
  and `ModuleSymbol` which include information on `class`, `mixin` and `module` definitions.
- `JSBackend.scala` contains class `JSBackend` that translates an MLscript AST
  into a JavaScript AST. Classes `JSWebBackend` and `JSTestBackend` inherit class `JSBackend`
  and generate adapted code for the web demo and the test suite.

### Web Demo and Testing


Testing of MLscript works as follows:
 - the MLscript compiler reads the given test file one code block at a time (code blocks are separated by empty lines);
 - after reading the code block, it outputs the inferred types as well as any type errors encountered;
 - after that, it executes the code block in NodeJS (by shelling out to a `node` process) and outputs the results.

We have a web demo for users to test our implementation in any modern browser.
It has a textbox for MLscript source code input and it produces typing and running
results live. The implementation can be tried online at https://hkust-taco.github.io/superoop/
and locally in `/js/src/main/scala/Main.scala`.

We have a "`diff`-based" test suite for our implementation.
It detects changes to MLscript test sources (using git),
generates typing and running results, and inserts those results
into test sources. The diff-based testing implementation is in
`/shared/src/test/scala/mlscript/DiffTests.scala`.
MLscript test sources are in `/shared/src/test/diff`.

## Detailed Introduction

We now introduce the implementation of each compiler component
in more detail.

### Lexing

Class `NewLexer` in `NewLexer.scala` is the lexer class. It takes an `origin` object,
which contains the original source string together with the source file name,
the number of the first line, and some helper functions. Lazy value `tokens` generates
a list of tokens with their location in the source code. Lazy value `bracketedTokens`
converts the lexed tokens into *structured tokens*,
which use `BRACKETS` constructs instead of `OPEN_BRACKET`/`CLOSE_BRACKET` and `INDENT`/`DEINDENT`.
Token and structured token data types can be found in `Tokens.scala`.

### Parsing

Class `NewParser` in `NewParser.scala` is the parser class. It takes a list
of structured tokens with their location information. Method `typingUnit`
calls method `block` to parse the token list into a list of `Statement` or
`IfBody` (defined in `syntax.scala`), filters out unexpected `then/else`
clauses introduced by `Ifbody`, and returns a `TypingUnit` (a list of `Statement`).

File `syntax.scala` contains *immutable* surface syntax data types of MLscript,
which are different from the internal representations in the typer for later type inference.
Here we introduce several surface syntax data types:

- Classes `Decl`, `TypeDef`, `MethodDef` are deprecated.
- Class `TypeDefKind` includes type definition kinds: classes and mixins, etc.
- Class `Term` includes MLscript term data types. Case class `Bind` is no longer used.
Case class `Splc` is for the rest of a parameter list, similar to the rest parameter in JavaScript.
Case classes `Forall` and `Inst` are for first-class polymorphism.
- Class `IfBody` includes if-then-else structure data types.
- Class `CaseBranches` includes case branch data types for MLscript pattern matching.
- Class `TypeLike` includes `Type`, `Signature`, and `NuDecl`.
- Class `Type` includes MLscript type data types. Case class `Rem` is for record member removal.
Case class `WithExtension` is for record type extension. For example, `A with {x : int}`
is equivalent to `A\x & {x : int}`.
- Class `TypeVar` represents the type variable. Its identifier can be an `Int`
generated internally by the compiler or `Str` specified by the user.
- Class `NuTypeDef` is a `NuDecl` for type definitions.
Note that it has optional `superAnnot`
and `thisAnnot` for precisely-typed open recursion.
- Class `NuFunDef` is a `NuDecl` for function and let-bindings.

### Typing

The MLscript typer (class `Typer`) works with a typing context (class `Ctx`) which
mainly maintains all global and local bindings of names to their types.
The typer accepts a typing unit from the parser, types the typing unit, and returns a typed typing unit.
The typed typing unit
is sent to the type simplifier and is finally expanded, i.e., converted
back to types in the surface syntax for presentation.
The typer has **internal** representations of types
(defined in `TyperDatatypes.scala`)
with mutable states for type inference with subtyping. 

We first introduce several typer data types defined in `TyperDatatypes.scala`:

- Class `TypeProvenance` stores the location where a type is introduced.
- Class `LazyTypeInfo` is for type definitions including classes, mixins, modules.
Its type is lazily computed to support *mutual recursive* type
definitions. It has a `complete` method to complete typing lazily typed definitions.
- Class `PolymorphicType` represents a type with universally quantified type variables.
By convention, in the type body, type variables of levels greater than
the polymorphic type's level are polymorphic.
- Class `SimpleType` is a general type form of all types.
It requires a method `level` for level-based polymorphism.
- Class `BaseType` includes base types such as function, array, tuple, and class tag types.
It can later be refined by `RecordType`.
- Class `RecordType` is a record type. It has a list of bindings from record fields to their types.
- Class `SpliceType` is not used for now.
- Class `ProxyType` is a derived type form to store more type provenance information.
- Class `TypeRef` is a reference to named types such as type definitions like classes.
It has a list of type arguments. A type reference with type arguments is expanded to
a class tag type with the class's type parameters refined by the corresponding type arguments as type members.
For example, `Foo[Int]` is expanded to `#Foo & {Foo.A: int..int}`.
- Class `TypeTag` has different kinds of type tags including class tags and abstract tags, etc.
- Class `FieldType` represents a term field type or a type member.
When it represents a term field type, `lb` represents if the type is mutable.
Otherwise, `lb` is the lower bound of the type member.
- Class `TypeVariable` represents a type variable, which has upper and lower bounds
for type inference with subtyping.

Method `typeTypingUnit` in class `NuTypeDefs` accepts the typing unit to type. It inspects each statement
in the typing unit. If the statement is a type definition, a `DelayedTypeInfo` (which is a subclass of `LazyTypeInfo`)
is produced and stored in the typing context (note the typing context only uses `tyDefs2` to store
type definitions). Otherwise, it desugars the statement and calls `typeTerms` to type
the desugared statements. For a single `Term`, it is passed to `typeTerm` to type.
Method `typeTerm` in class `Typer` types a term. If the term needs type information of a `LazyTypeInfo`,
the typing of that lazily typed definition will be completed. Subtyping constraints are generated during typing
and sent to `ConstraintSolver` to propagate constraints to type variables.
For more about type inference of subtyping, please refer to [MLstruct](https://dl.acm.org/doi/abs/10.1145/3563304).

Of particular interest,
we introduce how classes and mixins are typed to implement precisely-typed open recursion in more detail.
Method `complete` of `DelayedTypeInfoImpl`,
types type definitions: classes, modules, and mixins and let-/fun-bindings.

When a class (`Cls` which is a `NuTypeDef`) is typed, class fields are first
added into the typing context, and `this` is associated with a fresh type variable.
The `inherit` helper methods deal with the inheritance clauses of the type definitions.
The inheritance process starts with an empty record type as the initial `super` type.
It inspects each parent, accumulates members of parents, and updates the `super` type on the way.
For each parent,
if it is a mixin, and the typing context has that mixin defined, it completes the type of the mixin
and freshens each type variable of the mixin, as each mixin's type should be constrained
differently at different use-sites. Then, two subtyping constraints are generated:
the current `super` type and the final
object type (`this` type) should be subtypes of the mixin's `super` and `this` type refinements.
Finally, the mixin's members are accumulated to the class, and the current `super` type is
updated using `WithType` because methods in mixins are always *overriding*.
After processing the whole inheritance clause,
we update the current `super` type with the class fields' types as `thisType`, and we constrain that
the resulting `thisType` (i.e. the final object type) should be a subtype of `finalType`
which is a type variable with all `this` type refinements of mixins accumulated.

Typing of mixins is not that surprising. We associate `this` and `super`
with fresh type variables in the typing context and then type the mixin body.

### Code Generation

The code generation consists of three steps.
Firstly, class `JSBackend` translates MLscript data types (i.e. class `NuTypeDef`)
into corresponding symbols. Then class `JSBackend` generates JavaScript AST nodes
based on those symbols.
Finally, we generate JavaScript code from JavaScript AST nodes.

The first step is implemented in the method `declareNewTypeDefs`.
Here we extract information (including name, parameter list, type, members, parents, and so on)
of classes, mixins, and modules from the given `NuTypeDef` list and generate 
a hygienic runtime name for each symbol.

In the second step, we translate `NewClassSymbol`, `MixinSymbol`, and `ModuleSymbol`
into JavaScript AST nodes by using methods `translateNewClassDeclaration`, `translateMixinDeclaration`, and `translateModuleDeclaration`.
These three methods invoke another method `translateNewTypeDefinition` to translate
classes, mixins, and modules into JavaScript classes.
The method `translateNewClassMember` contains the translation of members.
We call `translateParents` to get the parent class of a type.
Assuming we have code:
```ts
module A extends B, C
```

The method `translateParents` processes the inheritance clause in a left-to-right way:

- First, we process the parent `B`:
  - If `B` is a `class` or a `module`, the JS class definition would be `class A extends B`.
  - If `B` is a `mixin`, we need a base class for `B`.
    Here we choose `Object` in JavaScript and the JS class definition would be `class A extends B(Object)`
- Then we process the parent `C`:
  - If `C` is a `mixin`, we can use `B(Object)` as `C`'s base class.
    The JS class definition would be `class A extends C(B(Object))`.
  - Otherwise, we reject the code because a JavaScript class can have only one parent class.
  - If module `A` has more parents on the right of `C`, 
    we process them similarly as we deal with `C`.

If there are initialization parameters in the parent list,
we move the arguments into the class constructor and pass them to `super()`.
Note we need to reverse the order of arguments of `mixin`.
For example, assume we have MLscript code below:

```ts
module A extends MixinA(1), MixinB(2, 3), MixinC(4)
```

The parameters in `super()` of `A` would be:
```js
super(4, 2, 3, 1);
```

We generate the JavaScript classes inside `typing_unit` objects.
Note we create `...rest` parameters in each constructor of `mixin`
because we have no information about the actual parent mixin until the mixin composition is finished.
For modules, we store the instance of the JavaScript class in the cache.
For classes, if they have primitive parameter lists,
we store the arrow functions in the cache as class constructors that instantiate classes.
Mixins have no constructor because of the uncertainty of the `base` parameter of mixins.

In the final step, we emit the JavaScript code by using `toSourceCode` methods in each JavaScript AST node class.

For a class in MLscript:
```ts
class Lit(n: int)
```

The generated code would be:
```js
class TypingUnit {
  #Lit;
  constructor() {
  }
  get Lit() {
    const qualifier = this;
    if (this.#Lit === undefined) {
      class Lit {
        #n;
        constructor(n) {
          this.#n = n;
        }
      static
        unapply(x) {
          return [x.#n];
        }
      };
      this.#Lit = ((n) => Object.freeze(new Lit(n)));
      this.#Lit.class = Lit;
      this.#Lit.unapply = Lit.unapply;
    }
    return this.#Lit;
  }
}
const typing_unit = new TypingUnit;
globalThis.Lit = typing_unit.Lit;
```

For a mixin in MLscript:
```ts
mixin EvalBase {
  fun eval(e) =
    if e is
      Lit(n) then n: int
}
```

The generated code would be:
```js
class TypingUnit {
  constructor() {
  }
  EvalBase(base) {
    const qualifier = this;
    return (class EvalBase extends base {
      constructor(...rest) {
        super(...rest);
      }
      eval(e) {
        return ((() => {
          let a;
          return (a = e, a instanceof Lit.class ? (([n]) => n)(Lit.unapply(e)) : (() => {
            throw new Error("non-exhaustive case expression");
          })());
        })());
      }
    });
  }
}
const typing_unit = new TypingUnit;
globalThis.EvalBase = ((base) => typing_unit.EvalBase(base));
```

For a module in MLscript:
```ts
module TestLang extends EvalBase, EvalNeg, EvalNegNeg
```

The generated code would be like this:
```js
class TypingUnit {
  #TestLang;
  constructor() {
  }
  get TestLang() {
    const qualifier = this;
    if (this.#TestLang === undefined) {
      class TestLang extends EvalNegNeg(EvalNeg(EvalBase(Object))) {
        constructor() {
          super();
        }
      }
      this.#TestLang = new TestLang();
      this.#TestLang.class = TestLang;
    }
    return this.#TestLang;
  }
}
const typing_unit = new TypingUnit;
globalThis.TestLang = typing_unit.TestLang;
```

For more code generation examples, please check the test source `shared/src/test/diff/codegen/Mixin.mls`.
