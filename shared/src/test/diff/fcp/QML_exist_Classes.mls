// * Adaptation of QML's original existentials example; using encoded existentials and classes


:NoRecursiveTypes
:GeneralizeCurriedFunctions
// :DistributeForalls
// :ArgGen
// :NoConstrainedTypes

// TODO with :NoRecursiveTypes
// TODO without some signatures



class ArraysRep[A, Rep]
  method Init: A -> Rep
  method Sub: Rep -> int -> A
  method Update: Rep -> int -> A -> Rep
  method Fold: (A -> 'b -> 'b) -> 'b -> Rep -> 'b
//│ Defined class ArraysRep[=A, =Rep]
//│ Declared ArraysRep.Init: ArraysRep['A, 'Rep] -> 'A -> 'Rep
//│ Declared ArraysRep.Sub: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A
//│ Declared ArraysRep.Update: ArraysRep['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Declared ArraysRep.Fold: ArraysRep['A, 'Rep] -> ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b

class ArraysImpl[A, Rep]: ArraysRep[A, Rep] & {
    init: A -> Rep;
    sub: Rep -> int -> A;
    update: Rep -> int -> A -> Rep;
    fold: forall 'b. (A -> 'b -> 'b) -> 'b -> Rep -> 'b
  }
  method Init = this.init
  method Sub = this.sub
  method Update = this.update
  method Fold = this.fold
//│ Defined class ArraysImpl[=A, =Rep]
//│ Defined ArraysImpl.Init: ArraysImpl['A, 'Rep] -> 'A -> 'Rep
//│ Defined ArraysImpl.Sub: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A
//│ Defined ArraysImpl.Update: ArraysImpl['A, 'Rep] -> 'Rep -> int -> 'A -> 'Rep
//│ Defined ArraysImpl.Fold: ArraysImpl['A, 'Rep] -> (forall 'b. ('A -> 'b -> 'b) -> 'b -> 'Rep -> 'b)

type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ Defined type alias Arrays[=A]



baseImpl = ArraysImpl {
    init   = fun a -> a;
    sub    = fun r -> fun (i : int) -> r;
    update = fun r -> fun (i : int) -> fun a -> a;
    fold   = fun f -> fun b -> fun r -> f r b
  }
//│ baseImpl: ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     'a <: 'c -> ('b -> 'd & 'e)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}
//│         = ArraysImpl {
//│             init: [Function: init],
//│             sub: [Function: sub],
//│             update: [Function: update],
//│             fold: [Function: fold]
//│           }

def base: Arrays['a]
def base f = f baseImpl
//│ base: Arrays['a]
//│     = <missing implementation>
//│ ((forall 'Rep. ArraysImpl['Rep, 'Rep] with {fold: forall 'a. 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e. ('c -> 'd
//│   where
//│     'a <: 'c -> ('b -> 'd & 'e)))), init: forall 'f. 'f -> 'f, sub: forall 'g. 'g -> int -> 'g, update: forall 'h. 'h -> int -> (forall 'i. 'i -> 'i)}) -> 'j & 'k) -> 'j
//│   <:  base:
//│ Arrays['a]
//│     = [Function: base]



def simpleStepImpl arrImpl = ArraysImpl {
    init   = fun a -> (arrImpl.Init a, "initialized");
    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
    update = fun ((r0, r1)) -> fun i -> fun a -> (arrImpl.Update r0 i a, "updated");
    fold   = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f b r0
  }
//│ simpleStepImpl: (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A & 'A0 & 'A3 & ('A2 | 'A4), in 'Rep | 'a & 'c & 'd & 'e & 'Rep0 & 'Rep1 | 'a & 'c & 'e & 'Rep0 & 'f & 'Rep2 | 'Rep3 out 'Rep2 & ('a | 'Rep) & ('c | 'Rep1) & ('Rep0 | 'Rep3 | 'Rep4)] & 'g) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'h. 'h -> (forall 'i. 'i -> (forall 'g, 'h, 'i, 'A5, 'Rep6, 'b, 'j, 'k, 'l. (('Rep6 & 'k, 'l,) -> ('i | 'j)
//│   where
//│     'g <: ArraysRep['A5, 'Rep6]
//│     'h <: 'A5 -> ('b | 'i) -> ('b & 'j)))) | 'fold, init: forall 'g, 'A6, 'Rep7, 'm, 'n, 'init. (('A6 & 'n) -> ('m, "initialized",) | 'init
//│   where
//│     'g <: ArraysRep['A6, 'Rep7]), sub: forall 'o, 'p. ('o, 'p,) -> (forall 'g, 'o, 'A7, 'q, 'Rep8, 'r. ((int & 'r) -> 'q
//│   where
//│     'g <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 's, 't. ('s, 't,) -> (forall 'r, 'u. (int & 'u & 'r) -> (forall 'g, 's, 'A8, 'Rep9, 'v, 'w. (('A8 & 'w) -> ('s | 'v, "updated",)
//│   where
//│     'g <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'x)
//│   where
//│     'Rep9 :> 's
//│           <: 'v
//│     'Rep8 :> 'o
//│     'A7 <: 'q
//│     'Rep7 <: 'm
//│     'Rep5 :> ('f | 'c | 'd, "initialized" | "updated",)
//│           <: ('a & 'c & 'e & 'Rep0, 'y & 'z & 'a1,)
//│     'A1 <: 'b1 & 'A & 'c1 & 'A0
//│               = [Function: simpleStepImpl]

simpleStepImpl : ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string)]
//│ res: ArraysImpl['a, 'r] -> ArraysImpl['a, ('r, string,)]
//│    = [Function: simpleStepImpl]

// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, ('_, string)]
// def simpleStepImpl2_ty: Arrays['a] -> ArraysImpl['a, '_]
// def simpleStepImpl2 arr = arr simpleStepImpl

def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = <missing implementation>


def simpleStepImpl2 arr = arr simpleStepImpl
//│ simpleStepImpl2: ((forall 'A, 'A0, 'A1, 'a, 'c, 'A2, 'A3, 'A4, 'Rep, 'Rep0, 'd, 'e, 'f, 'g, 'Rep1, 'Rep2, 'h, 'Rep3, 'Rep4, 'i, 'Rep5, 'j, 'k, 'l. (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A & 'A0 & 'A3 & ('A2 | 'A4), in 'Rep | 'd & 'e & 'f & 'g & 'Rep1 & 'Rep0 | 'd & 'e & 'g & 'Rep1 & 'h & 'Rep2 | 'Rep3 out 'Rep2 & ('d | 'Rep) & ('e | 'Rep0) & ('Rep1 | 'Rep3 | 'Rep4)] & 'i) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'm. 'm -> (forall 'n. 'n -> (forall 'i, 'm, 'n, 'A5, 'Rep6, 'b, 'o, 'p, 'q. (('Rep6 & 'p, 'q,) -> ('n | 'o)
//│   where
//│     'i <: ArraysRep['A5, 'Rep6]
//│     'm <: 'A5 -> ('b | 'n) -> ('b & 'o)))) | 'fold, init: forall 'i, 'A6, 'Rep7, 'r, 's, 'init. (('A6 & 's) -> ('r, "initialized",) | 'init
//│   where
//│     'i <: ArraysRep['A6, 'Rep7]), sub: forall 't, 'u. ('t, 'u,) -> (forall 'i, 't, 'A7, 'v, 'Rep8, 'w. ((int & 'w) -> 'v
//│   where
//│     'i <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'x, 'y. ('x, 'y,) -> (forall 'w, 'z. (int & 'z & 'w) -> (forall 'i, 'x, 'A8, 'Rep9, 'a1, 'b1. (('A8 & 'b1) -> ('x | 'a1, "updated",)
//│   where
//│     'i <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'c1)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'x
//│           <: 'a1
//│     'Rep8 :> 't
//│     'A7 <: 'v
//│     'Rep7 <: 'r
//│     'Rep5 :> ('h | 'e | 'f, "initialized" | "updated",)
//│           <: ('d & 'e & 'g & 'Rep1, 'j & 'k & 'l,)
//│     'A1 <: 'a & 'A & 'c & 'A0
//│                = [Function: simpleStepImpl2]

simpleStepImpl2_ty = simpleStepImpl2
//│ ((forall 'A, 'A0, 'A1, 'a, 'c, 'A2, 'A3, 'A4, 'Rep, 'Rep0, 'd, 'e, 'f, 'g, 'Rep1, 'Rep2, 'h, 'Rep3, 'Rep4, 'i, 'Rep5, 'j, 'k, 'l. (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A3 & 'A & 'A0 & ('A2 | 'A4), in 'Rep | 'd & 'e & 'f & 'g & 'Rep1 & 'Rep0 | 'd & 'e & 'g & 'Rep1 & 'h & 'Rep2 | 'Rep3 out ('d | 'Rep) & ('e | 'Rep0) & 'Rep2 & ('Rep1 | 'Rep3 | 'Rep4)] & 'i) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'm. 'm -> (forall 'n. 'n -> (forall 'i, 'm, 'n, 'A5, 'Rep6, 'b, 'o, 'p, 'q. (('Rep6 & 'p, 'q,) -> ('n | 'o)
//│   where
//│     'i <: ArraysRep['A5, 'Rep6]
//│     'm <: 'A5 -> ('b | 'n) -> ('b & 'o)))) | 'fold, init: forall 'i, 'A6, 'Rep7, 'r, 's, 'init. (('A6 & 's) -> ('r, "initialized",) | 'init
//│   where
//│     'i <: ArraysRep['A6, 'Rep7]), sub: forall 't, 'u. ('t, 'u,) -> (forall 'i, 't, 'A7, 'v, 'Rep8, 'w. ((int & 'w) -> 'v
//│   where
//│     'i <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'x, 'y. ('x, 'y,) -> (forall 'w, 'z. (int & 'z & 'w) -> (forall 'i, 'x, 'A8, 'Rep9, 'a1, 'b1. (('A8 & 'b1) -> ('x | 'a1, "updated",)
//│   where
//│     'i <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'c1)) -> 'd1 & 'e1) -> 'd1
//│   where
//│     'Rep9 :> 'x
//│           <: 'a1
//│     'Rep8 :> 't
//│     'A7 <: 'v
//│     'Rep7 <: 'r
//│     'Rep5 :> ('h | 'e | 'f, "initialized" | "updated",)
//│           <: ('d & 'e & 'g & 'Rep1, 'j & 'k & 'l,)
//│     'A1 <: 'a & 'A & 'c & 'A0
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│                   = [Function: simpleStepImpl2]

:e // * Annotation is actually counter-productive... probably because the rigid universal in Arrays gets extruded!
def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ Arrays['a] -> ((ArraysImpl[in 'A & 'c & 'A0 & 'a0 & 'd & 'A1 out 'a0 | 'A | 'A2, in (‘Rep_1320_1423 & 'e & 'Rep & 'f & 'g, 'h & 'i & 'j,) & 'Rep0 out (‘Rep_1320_1423 | 'f | 'k | 'l | 'm, "initialized" | "updated",) | 'Rep0 | 'Rep1] with {fold: forall 'n. 'n -> (forall 'o. 'o -> (forall 'n, 'o, 'p, 'A3, 'Rep2, 'b, 'q, 'r, 's. (('Rep2 & 'r, 's,) -> ('q | 'o)
//│   where
//│     'p <: ArraysRep['A3, 'Rep2]
//│     'n <: 'A3 -> ('b | 'o) -> ('b & 'q)))) | 'fold, init: forall 'p, 'A4, 'Rep3, 't, 'u, 'init. (('A4 & 'u) -> ('t, "initialized",) | 'init
//│   where
//│     'p <: ArraysRep['A4, in 'Rep3 & 't out 'Rep3]), sub: forall 'v, 'w. ('v, 'w,) -> (forall 'p, 'v, 'A5, 'x, 'Rep4, 'y. ((int & 'y) -> 'x
//│   where
//│     'p <: ArraysRep[in 'A5 & 'x out 'A5, in 'Rep4 out 'Rep4 | 'v])) | 'sub, update: forall 'z, 'a1. ('z, 'a1,) -> (forall 'y, 'b1. (int & 'b1 & 'y) -> (forall 'p, 'z, 'A6, 'Rep5, 'c1, 'd1. (('A6 & 'd1) -> ('c1 | 'z, "updated",)
//│   where
//│     'p <: ArraysRep['A6, in 'Rep5 & 'c1 out 'Rep5 | 'z]))) | 'update}) | 'e1)
//│   <:  simpleStepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string,)]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.163: 	def simpleStepImpl2_ty (arr: Arrays['a]) = arr simpleStepImpl
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_1671` is not an instance of type `'Rep_1320_1423`
//│ ║  l.111: 	def simpleStepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, string)]
//│ ║         	                                                                                          ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from reference:
//│ ║  l.78: 	    sub    = fun ((r0, r1)) -> fun i -> arrImpl.Sub r0 i;
//│ ╙──      	                                                    ^^
//│                   = [Function: simpleStepImpl2_ty1]

def simpleStep: Arrays['a] -> Arrays['a]
//│ simpleStep: Arrays['a] -> Arrays['a]
//│           = <missing implementation>

def simpleStep arr f = f (simpleStepImpl2 arr)
//│ 'a -> (forall 'a. (('c -> 'd & 'e) -> 'd
//│   where
//│     'a <: (forall 'A, 'A0, 'A1, 'f, 'g, 'A2, 'A3, 'A4, 'Rep, 'Rep0, 'h, 'i, 'j, 'k, 'Rep1, 'Rep2, 'l, 'Rep3, 'Rep4, 'm, 'Rep5, 'n, 'o, 'p. (ArraysRep[in 'A | 'A0 | 'A1 & 'A2 out 'A3 & 'A & 'A0 & ('A2 | 'A4), in 'Rep | 'h & 'i & 'j & 'k & 'Rep1 & 'Rep0 | 'h & 'i & 'k & 'Rep1 & 'l & 'Rep2 | 'Rep3 out 'Rep2 & ('h | 'Rep) & ('i | 'Rep0) & ('Rep1 | 'Rep3 | 'Rep4)] & 'm) -> ((ArraysImpl['A1, 'Rep5] with {fold: forall 'q. 'q -> (forall 'r. 'r -> (forall 'm, 'q, 'r, 'A5, 'Rep6, 'b, 's, 't, 'u. (('Rep6 & 't, 'u,) -> ('r | 's)
//│   where
//│     'm <: ArraysRep['A5, 'Rep6]
//│     'q <: 'A5 -> ('b | 'r) -> ('b & 's)))) | 'fold, init: forall 'm, 'A6, 'Rep7, 'v, 'w, 'init. (('A6 & 'w) -> ('v, "initialized",) | 'init
//│   where
//│     'm <: ArraysRep['A6, 'Rep7]), sub: forall 'x, 'y. ('x, 'y,) -> (forall 'm, 'x, 'A7, 'z, 'Rep8, 'a1. ((int & 'a1) -> 'z
//│   where
//│     'm <: ArraysRep['A7, 'Rep8])) | 'sub, update: forall 'b1, 'c1. ('b1, 'c1,) -> (forall 'a1, 'd1. (int & 'd1 & 'a1) -> (forall 'm, 'b1, 'A8, 'Rep9, 'e1, 'f1. (('A8 & 'f1) -> ('b1 | 'e1, "updated",)
//│   where
//│     'm <: ArraysRep['A8, 'Rep9]))) | 'update}) | 'g1)) -> ('h1 & 'c)))
//│   where
//│     'Rep9 :> 'b1
//│           <: 'e1
//│     'Rep8 :> 'x
//│     'A7 <: 'z
//│     'Rep7 <: 'v
//│     'Rep5 :> ('l | 'i | 'j, "initialized" | "updated",)
//│           <: ('h & 'i & 'k & 'Rep1, 'n & 'o & 'p,)
//│     'A1 <: 'f & 'A & 'g & 'A0
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│           = [Function: simpleStep]

:e // TODO update: seems like the given type for `simpleStepImpl2_ty` is not precise enough
def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ 'a -> (forall 'a, 'A, 'Rep, 'b, 'c, 'd. (((ArraysImpl['A, ('Rep, string,)] | 'b) -> 'c & 'd) -> 'c
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  simpleStep:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.221: 	def simpleStep arr f = f (simpleStepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2111_2112` is not an instance of type `'Rep_2111_2113`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│           = [Function: simpleStep1]

sb = simpleStep base
//│ sb: Arrays['a]
//│   = [Function (anonymous)]

sb (fun arr -> arr.Init true)
//│ res: ‘Rep_2144_2150
//│    = [ true, 'initialized' ]

sb (fun arr -> arr.Sub (arr.Init true) 1)
//│ res: true
//│    = true

:e // * Expected – argument order confusion
sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.251: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2215` is not an instance of type `int`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.17: 	  method Sub: Rep -> int -> A
//│ ║        	                     ^^^
//│ ╟── from application:
//│ ║  l.251: 	sb (fun arr -> arr.Sub 0 (arr.Init true))
//│ ║         	                          ^^^^^^^^^^^^^
//│ ╟── Note: class type parameter Rep is defined at:
//│ ║  l.15: 	class ArraysRep[A, Rep]
//│ ╙──      	                   ^^^
//│ res: error
//│ Runtime error:
//│   TypeError: number 0 is not iterable (cannot read property Symbol(Symbol.iterator))

sb (fun arr -> arr.Update (arr.Init true) 1 false)
//│ res: ‘Rep_2253_2263 | ‘Rep_2253_2264
//│    = [ false, 'updated' ]

:e // * Rightly prevent skolem confusion
sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.276: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_2326` is not an instance of type `'Rep_2291_2308`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── from application:
//│ ║  l.276: 	sb (fun arr1 -> sb (fun arr2 -> arr2.Update (arr1.Init true)))
//│ ╙──       	                                             ^^^^^^^^^^^^^^
//│ res: error
//│    = [Function (anonymous)]

sb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ false, false ]



:escape
def Math: nothing
//│ Math: nothing
//│     = <missing implementation>

def div: int -> int -> int
def div a b = Math.trunc(a/b)
//│ div: int -> int -> int
//│    = <missing implementation>
//│ (number & 'a & 'b) -> (forall 'b, 'c. (number & 'b) -> 'c)
//│   <:  div:
//│ int -> int -> int
//│    = [Function: div1]

def mod: int -> int -> int
rec def mod a b = if a < b then a else mod (a - b) b
//│ mod: int -> int -> int
//│    = <missing implementation>
//│ int -> int -> int
//│   <:  mod:
//│ int -> int -> int
//│    = [Function: mod]

def stepImpl arrImpl = ArraysImpl {
    init = fun a -> (arrImpl.Init a, arrImpl.Init a);
    sub = fun ((r0, r1)) -> fun i ->
      if mod i 2 == 0
      then arrImpl.Sub r0 (div i 2)
      else arrImpl.Sub r1 (div i 2);
    update = fun ((r0, r1)) -> fun i -> fun a ->
      if mod i 2 == 0
      then (arrImpl.Update r0 (div i 2) a, r1)
      else (r0, arrImpl.Update r1 (div i 2) a);
    fold = fun f -> fun b -> fun ((r0, r1)) -> arrImpl.Fold f (arrImpl.Fold f b r0) r1
  }
//│ stepImpl: (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'a & 'c & 'A3 & 'd & 'A4 | 'A3 & ('A5 | 'A6) out 'A7 & 'A & 'A0 & 'A1 & 'A2 & 'A4 & ('A8 & ('A6 | 'A9) | 'A5 & ('A6 | 'A9)), in 'Rep | 'Rep0 | 'e & 'f & 'g & 'h & 'Rep1 & 'Rep2 & 'Rep3 | 'i & 'j & 'k & 'l & 'Rep4 & 'Rep5 & 'Rep6 | 'e & 'f & 'h & 'Rep1 & 'Rep2 & 'm & 'Rep7 | 'i & 'j & 'l & 'Rep4 & 'Rep5 & 'n & 'Rep8 | 'Rep9 | 'Rep10 out ('e | 'Rep) & ('i | 'Rep0) & ('f | 'Rep3) & 'Rep2 & ('j | 'Rep6) & 'Rep5 & 'Rep7 & 'Rep8] & 'o) -> ((ArraysImpl['A3, 'Rep11] with {fold: forall 'p. 'p -> (forall 'q. 'q -> (forall 'o, 'p, 'q, 'A10, 'Rep12, 'A11, 'Rep13, 'b, 'r, 'b0, 's, 't, 'u. (('Rep13 & 't, 'Rep12 & 'u,) -> ('q | 'r)
//│   where
//│     'o <: ArraysRep['A10, 'Rep12] & ArraysRep['A11, 'Rep13]
//│     'p <: 'A10 -> ('b | 'q) -> ('b & 'r) & 'A11 -> ('b0 | 'q) -> ('b & 'r & 'b0 & 's)))) | 'fold, init: forall 'o, 'A12, 'Rep14, 'v, 'A13, 'Rep15, 'w, 'x, 'init. (('A12 & 'A13 & 'x) -> ('v, 'w,) | 'init
//│   where
//│     'o <: ArraysRep['A12, 'Rep14] & ArraysRep['A13, 'Rep15]), sub: forall 'y, 'z. ('y, 'z,) -> (forall 'o, 'y, 'z, 'A14, 'a1, 'b1, 'c1, 'Rep16, 'A15, 'd1, 'Rep17, 'e1. ((int & 'e1) -> 'c1
//│   where
//│     'o <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep17])) | 'sub, update: forall 'f1, 'g1. ('f1, 'g1,) -> (forall 'e1, 'h1. (int & 'h1 & 'e1) -> (forall 'o, 'f1, 'g1, 'A16, 'Rep18, 'i1, 'A17, 'Rep19, 'j1, 'k1, 'l1. (('A16 & 'A17 & 'k1) -> (('f1 | 'i1, 'g1 | 'j1,) | 'l1)
//│   where
//│     'o <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 'm1)
//│   where
//│     'Rep19 :> 'g1
//│            <: 'j1
//│     'Rep18 :> 'f1
//│            <: 'i1
//│     'Rep17 :> 'z
//│     'A15 <: 'b1 & 'c1 & 'd1
//│     'Rep16 :> 'y
//│     'A14 <: 'a1 & 'b1 & 'c1
//│     'Rep15 <: 'w
//│     'Rep14 <: 'v
//│     'Rep11 :> ('n | 'j | 'k, 'm | 'f | 'g,)
//│            <: ('i & 'j & 'l & 'Rep4 & 'Rep5, 'e & 'f & 'h & 'Rep1 & 'Rep2,)
//│     'A3 <: 'n1 & 'A & 'A0 & 'o1 & 'A1 & 'A2
//│         = [Function: stepImpl]

def stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep)]
//│ stepImpl2_ty: (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = <missing implementation>

def stepImpl2 arr = arr stepImpl
//│ stepImpl2: ((forall 'A, 'A0, 'A1, 'A2, 'A3, 'a, 'c, 'A4, 'd, 'e, 'f, 'A5, 'A6, 'A7, 'A8, 'A9, 'Rep, 'Rep0, 'Rep1, 'g, 'h, 'i, 'j, 'Rep2, 'Rep3, 'Rep4, 'k, 'l, 'm, 'n, 'Rep5, 'Rep6, 'Rep7, 'o, 'Rep8, 'p, 'Rep9, 'Rep10, 'q, 'Rep11. (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'a & 'c & 'A4 & 'f & 'A3 | 'A4 & ('A5 | 'A6) out 'A & 'A0 & 'A1 & 'A2 & 'A3 & 'A7 & ('A8 & ('A5 | 'A9) | 'A6 & ('A5 | 'A9)), in 'Rep | 'Rep0 | 'g & 'h & 'i & 'j & 'Rep2 & 'Rep3 & 'Rep1 | 'k & 'l & 'm & 'n & 'Rep5 & 'Rep6 & 'Rep4 | 'g & 'h & 'j & 'Rep2 & 'Rep3 & 'o & 'Rep7 | 'k & 'l & 'n & 'Rep5 & 'Rep6 & 'p & 'Rep8 | 'Rep9 | 'Rep10 out ('g | 'Rep) & ('k | 'Rep0) & ('h | 'Rep1) & 'Rep3 & ('l | 'Rep4) & 'Rep6 & 'Rep7 & 'Rep8] & 'q) -> ((ArraysImpl['A4, 'Rep11] with {fold: forall 'r. 'r -> (forall 's. 's -> (forall 'q, 'r, 's, 'A10, 'Rep12, 'A11, 'Rep13, 'b, 't, 'b0, 'u, 'v, 'w. (('Rep13 & 'v, 'Rep12 & 'w,) -> ('s | 't)
//│   where
//│     'q <: ArraysRep['A10, 'Rep12] & ArraysRep['A11, 'Rep13]
//│     'r <: 'A10 -> ('b | 's) -> ('b & 't) & 'A11 -> ('b0 | 's) -> ('b & 't & 'b0 & 'u)))) | 'fold, init: forall 'q, 'A12, 'Rep14, 'x, 'A13, 'Rep15, 'y, 'z, 'init. (('A12 & 'A13 & 'z) -> ('x, 'y,) | 'init
//│   where
//│     'q <: ArraysRep['A12, 'Rep14] & ArraysRep['A13, 'Rep15]), sub: forall 'a1, 'b1. ('a1, 'b1,) -> (forall 'q, 'a1, 'b1, 'A14, 'c1, 'd1, 'e1, 'Rep16, 'A15, 'f1, 'Rep17, 'g1. ((int & 'g1) -> 'e1
//│   where
//│     'q <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep17])) | 'sub, update: forall 'h1, 'i1. ('h1, 'i1,) -> (forall 'g1, 'j1. (int & 'j1 & 'g1) -> (forall 'q, 'h1, 'i1, 'A16, 'Rep18, 'k1, 'A17, 'Rep19, 'l1, 'm1, 'n1. (('A16 & 'A17 & 'm1) -> (('h1 | 'k1, 'i1 | 'l1,) | 'n1)
//│   where
//│     'q <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 'o1)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep19 :> 'i1
//│            <: 'l1
//│     'Rep18 :> 'h1
//│            <: 'k1
//│     'Rep17 :> 'b1
//│     'A15 <: 'd1 & 'e1 & 'f1
//│     'Rep16 :> 'a1
//│     'A14 <: 'c1 & 'd1 & 'e1
//│     'Rep15 <: 'y
//│     'Rep14 <: 'x
//│     'Rep11 :> ('p | 'l | 'm, 'o | 'h | 'i,)
//│            <: ('k & 'l & 'n & 'Rep5 & 'Rep6, 'g & 'h & 'j & 'Rep2 & 'Rep3,)
//│     'A4 <: 'd & 'A & 'A0 & 'e & 'A1 & 'A2
//│          = [Function: stepImpl2]

stepImpl2_ty = stepImpl2
//│ ((forall 'A, 'A0, 'A1, 'A2, 'A3, 'a, 'c, 'A4, 'd, 'e, 'f, 'A5, 'A6, 'A7, 'A8, 'A9, 'Rep, 'Rep0, 'Rep1, 'g, 'h, 'i, 'j, 'Rep2, 'Rep3, 'Rep4, 'k, 'l, 'm, 'n, 'Rep5, 'Rep6, 'Rep7, 'o, 'Rep8, 'p, 'Rep9, 'Rep10, 'q, 'Rep11. (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'a & 'c & 'A4 & 'f & 'A3 | 'A4 & ('A5 | 'A6) out 'A3 & 'A7 & 'A & 'A0 & 'A1 & 'A2 & ('A8 & ('A5 | 'A9) | 'A6 & ('A5 | 'A9)), in 'Rep | 'Rep0 | 'g & 'h & 'i & 'j & 'Rep2 & 'Rep3 & 'Rep1 | 'k & 'l & 'm & 'n & 'Rep5 & 'Rep6 & 'Rep4 | 'g & 'h & 'j & 'Rep2 & 'Rep3 & 'o & 'Rep7 | 'k & 'l & 'n & 'Rep5 & 'Rep6 & 'p & 'Rep8 | 'Rep9 | 'Rep10 out ('g | 'Rep) & ('k | 'Rep0) & ('h | 'Rep1) & 'Rep3 & ('l | 'Rep4) & 'Rep6 & 'Rep7 & 'Rep8] & 'q) -> ((ArraysImpl['A4, 'Rep11] with {fold: forall 'r. 'r -> (forall 's. 's -> (forall 'q, 'r, 's, 'A10, 'Rep12, 'A11, 'Rep13, 'b, 't, 'b0, 'u, 'v, 'w. (('Rep13 & 'v, 'Rep12 & 'w,) -> ('s | 't)
//│   where
//│     'q <: ArraysRep['A10, 'Rep12] & ArraysRep['A11, 'Rep13]
//│     'r <: 'A10 -> ('b | 's) -> ('b & 't) & 'A11 -> ('b0 | 's) -> ('b & 't & 'b0 & 'u)))) | 'fold, init: forall 'q, 'A12, 'Rep14, 'x, 'A13, 'Rep15, 'y, 'z, 'init. (('A12 & 'A13 & 'z) -> ('x, 'y,) | 'init
//│   where
//│     'q <: ArraysRep['A12, 'Rep14] & ArraysRep['A13, 'Rep15]), sub: forall 'a1, 'b1. ('a1, 'b1,) -> (forall 'q, 'a1, 'b1, 'A14, 'c1, 'd1, 'e1, 'Rep16, 'A15, 'f1, 'Rep17, 'g1. ((int & 'g1) -> 'e1
//│   where
//│     'q <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep17])) | 'sub, update: forall 'h1, 'i1. ('h1, 'i1,) -> (forall 'g1, 'j1. (int & 'j1 & 'g1) -> (forall 'q, 'h1, 'i1, 'A16, 'Rep18, 'k1, 'A17, 'Rep19, 'l1, 'm1, 'n1. (('A16 & 'A17 & 'm1) -> (('h1 | 'k1, 'i1 | 'l1,) | 'n1)
//│   where
//│     'q <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 'o1)) -> 'p1 & 'q1) -> 'p1
//│   where
//│     'Rep19 :> 'i1
//│            <: 'l1
//│     'Rep18 :> 'h1
//│            <: 'k1
//│     'Rep17 :> 'b1
//│     'A15 <: 'd1 & 'e1 & 'f1
//│     'Rep16 :> 'a1
//│     'A14 <: 'c1 & 'd1 & 'e1
//│     'Rep15 <: 'y
//│     'Rep14 <: 'x
//│     'Rep11 :> ('p | 'l | 'm, 'o | 'h | 'i,)
//│            <: ('k & 'l & 'n & 'Rep5 & 'Rep6, 'g & 'h & 'j & 'Rep2 & 'Rep3,)
//│     'A4 <: 'd & 'A & 'A0 & 'e & 'A1 & 'A2
//│   <:  stepImpl2_ty:
//│ (forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r) -> ArraysImpl['A, ('Rep, 'Rep,)]
//│             = [Function: stepImpl2]


def step: Arrays['a] -> Arrays['a]
//│ step: Arrays['a] -> Arrays['a]
//│     = <missing implementation>

def step arr f = f (stepImpl2 arr)
//│ 'a -> (forall 'a. (('c -> 'd & 'e) -> 'd
//│   where
//│     'a <: (forall 'A, 'A0, 'A1, 'A2, 'A3, 'f, 'g, 'A4, 'h, 'i, 'j, 'A5, 'A6, 'A7, 'A8, 'A9, 'Rep, 'Rep0, 'Rep1, 'k, 'l, 'm, 'n, 'Rep2, 'Rep3, 'Rep4, 'o, 'p, 'q, 'r, 'Rep5, 'Rep6, 'Rep7, 's, 'Rep8, 't, 'Rep9, 'Rep10, 'u, 'Rep11. (ArraysRep[in 'A | 'A0 | 'A1 | 'A2 | 'f & 'g & 'A4 & 'j & 'A3 | 'A4 & ('A5 | 'A6) out 'A2 & 'A3 & 'A7 & 'A & 'A0 & 'A1 & ('A8 & ('A5 | 'A9) | 'A6 & ('A5 | 'A9)), in 'Rep | 'Rep0 | 'k & 'l & 'm & 'n & 'Rep2 & 'Rep3 & 'Rep1 | 'o & 'p & 'q & 'r & 'Rep5 & 'Rep6 & 'Rep4 | 'k & 'l & 'n & 'Rep2 & 'Rep3 & 's & 'Rep7 | 'o & 'p & 'r & 'Rep5 & 'Rep6 & 't & 'Rep8 | 'Rep9 | 'Rep10 out ('k | 'Rep) & ('o | 'Rep0) & ('l | 'Rep1) & 'Rep3 & ('p | 'Rep4) & 'Rep6 & 'Rep7 & 'Rep8] & 'u) -> ((ArraysImpl['A4, 'Rep11] with {fold: forall 'v. 'v -> (forall 'w. 'w -> (forall 'u, 'v, 'w, 'A10, 'Rep12, 'A11, 'Rep13, 'b, 'x, 'b0, 'y, 'z, 'a1. (('Rep13 & 'z, 'Rep12 & 'a1,) -> ('w | 'x)
//│   where
//│     'u <: ArraysRep['A10, 'Rep12] & ArraysRep['A11, 'Rep13]
//│     'v <: 'A10 -> ('b | 'w) -> ('b & 'x) & 'A11 -> ('b0 | 'w) -> ('b & 'x & 'b0 & 'y)))) | 'fold, init: forall 'u, 'A12, 'Rep14, 'b1, 'A13, 'Rep15, 'c1, 'd1, 'init. (('A12 & 'A13 & 'd1) -> ('b1, 'c1,) | 'init
//│   where
//│     'u <: ArraysRep['A12, 'Rep14] & ArraysRep['A13, 'Rep15]), sub: forall 'e1, 'f1. ('e1, 'f1,) -> (forall 'u, 'e1, 'f1, 'A14, 'g1, 'h1, 'i1, 'Rep16, 'A15, 'j1, 'Rep17, 'k1. ((int & 'k1) -> 'i1
//│   where
//│     'u <: ArraysRep['A14, 'Rep16] & ArraysRep['A15, 'Rep17])) | 'sub, update: forall 'l1, 'm1. ('l1, 'm1,) -> (forall 'k1, 'n1. (int & 'n1 & 'k1) -> (forall 'u, 'l1, 'm1, 'A16, 'Rep18, 'o1, 'A17, 'Rep19, 'p1, 'q1, 'r1. (('A16 & 'A17 & 'q1) -> (('l1 | 'o1, 'm1 | 'p1,) | 'r1)
//│   where
//│     'u <: ArraysRep['A16, 'Rep18] & ArraysRep['A17, 'Rep19]))) | 'update}) | 's1)) -> ('t1 & 'c)))
//│   where
//│     'Rep19 :> 'm1
//│            <: 'p1
//│     'Rep18 :> 'l1
//│            <: 'o1
//│     'Rep17 :> 'f1
//│     'A15 <: 'h1 & 'i1 & 'j1
//│     'Rep16 :> 'e1
//│     'A14 <: 'g1 & 'h1 & 'i1
//│     'Rep15 <: 'c1
//│     'Rep14 <: 'b1
//│     'Rep11 :> ('t | 'p | 'q, 's | 'l | 'm,)
//│            <: ('o & 'p & 'r & 'Rep5 & 'Rep6, 'k & 'l & 'n & 'Rep2 & 'Rep3,)
//│     'A4 <: 'h & 'A & 'A0 & 'i & 'A1 & 'A2
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step]

// * Now the annotation is okay because the result no longer extrudes it...
def step (arr: Arrays['a]) f = f (stepImpl2 arr)
//│ Arrays['a] -> (forall 'A, 'c, 'A0, 'a0, 'A1, 'd, 'A2, 'A3, 'A4, 'e, 'Rep, 'f, 'g, 'Rep0, 'Rep1, 'h, 'i, 'j, 'Rep2, 'Rep3, 'k, 'l, 'm, 'n, 'o, 'p, 'Rep4. (((ArraysImpl[in 'A & 'c & 'A0 & 'a0 & 'A1 & 'd & 'A2 & 'A3 out 'a0 | 'A | 'A4, in (‘Rep_4315_4487 & 'e & 'Rep & 'f & 'g & 'Rep0 & 'Rep1, ‘Rep_4315_4487 & 'Rep & 'h & 'i & 'j & 'Rep2,) & 'Rep3 out (‘Rep_4315_4487 | 'f | 'k | 'l | 'm | 'n, ‘Rep_4315_4487 | 'i | 'o | 'p | 'n,) | 'Rep3 | 'Rep4] with {fold: forall 'q. 'q -> (forall 'r. 'r -> (forall 'q, 'r, 's, 'A5, 'Rep5, 'A6, 'Rep6, 'b, 't, 'b0, 'u, 'v, 'w. (('Rep6 & 'v, 'Rep5 & 'w,) -> ('r | 't)
//│   where
//│     's <: ArraysRep['A5, 'Rep5] & ArraysRep['A6, 'Rep6]
//│     'q <: 'A5 -> ('b | 'r) -> ('b & 't) & 'A6 -> ('b0 | 'r) -> ('b & 't & 'b0 & 'u)))) | 'fold, init: forall 's, 'A7, 'Rep7, 'x, 'A8, 'Rep8, 'y, 'z, 'init. (('A7 & 'A8 & 'z) -> ('x, 'y,) | 'init
//│   where
//│     's <: ArraysRep['A7, in 'Rep7 & 'x out 'Rep7] & ArraysRep['A8, in 'Rep8 & 'y out 'Rep8]), sub: forall 'a1, 'b1. ('a1, 'b1,) -> (forall 's, 'a1, 'b1, 'A9, 'c1, 'd1, 'e1, 'Rep9, 'A10, 'f1, 'Rep10, 'g1. ((int & 'g1) -> 'e1
//│   where
//│     's <: ArraysRep[in 'A9 & 'c1 & 'd1 & 'e1 out 'A9, in 'Rep9 out 'Rep9 | 'a1] & ArraysRep[in 'd1 & 'e1 & 'A10 & 'f1 out 'A10, in 'Rep10 out 'Rep10 | 'b1])) | 'sub, update: forall 'h1, 'i1. ('h1, 'i1,) -> (forall 'g1, 'j1. (int & 'j1 & 'g1) -> (forall 's, 'h1, 'i1, 'A11, 'Rep11, 'k1, 'A12, 'Rep12, 'l1, 'm1, 'n1. (('A11 & 'A12 & 'm1) -> (('h1 | 'k1, 'i1 | 'l1,) | 'n1)
//│   where
//│     's <: ArraysRep['A11, in 'Rep11 & 'k1 out 'Rep11 | 'h1] & ArraysRep['A12, in 'Rep12 & 'l1 out 'Rep12 | 'i1]))) | 'update}) | 'o1) -> 'p1 & 'q1) -> 'p1)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step1]

// * Don't know why these don't work:
:e
def step arr f = f (stepImpl2_ty arr)
//│ 'a -> (forall 'a, 'A, 'Rep, 'b, 'c, 'd. (((ArraysImpl['A, ('Rep, 'Rep,)] | 'b) -> 'c & 'd) -> 'c
//│   where
//│     'a <: forall 'r. (ArraysRep['A, 'Rep] -> 'r) -> 'r))
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.476: 	def step arr f = f (stepImpl2_ty arr)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_5003_5004` is not an instance of type `'Rep_5003_5005`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│     = [Function: step2]
:e
def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.493: 	def step (arr: Arrays['a]) f = f (stepImpl2_ty arr)
//│ ║         	                                  ^^^^^^^^^^^^^^^^
//│ ╟── type `‘Rep_5018_5019` is not an instance of type `'Rep_5018_5020`
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ║        	                         ^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	type Arrays[A] = (forall 'Rep. ArraysRep[A, 'Rep] -> 'r) -> 'r
//│ ╙──      	                         ^^^^
//│ Arrays['a] -> (forall 'b, 'c, 'd. ((error | 'b) -> 'c & 'd) -> 'c)
//│   <:  step:
//│ Arrays['a] -> Arrays['a]
//│     = [Function: step3]


ssb = step (step base)
//│ ssb: Arrays['a]
//│    = [Function (anonymous)]

ssb (fun arr ->
    let r2 = arr.Update (arr.Init true) 1 false
    in (arr.Sub r2 0, arr.Sub r2 1)
  )
//│ res: (bool, bool,)
//│    = [ true, false ]



rec def mkMonoArray n =
  if n == 0 then base else step (mkMonoArray(n - 1))
//│ mkMonoArray: int -> (forall 'a. Arrays['a])
//│            = [Function: mkMonoArray]

snb = mkMonoArray 5
//│ snb: Arrays['a]
//│    = [Function (anonymous)]

snb (fun arr -> arr.Init true)
//│ res: ‘Rep_5219_5225 | ‘Rep_5229_5235
//│    = [
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ],
//│        [ [ [Array], [Array] ], [ [Array], [Array] ] ]
//│      ]


// * From the paper:
// let mkPolyArray n = {∀α(∃ρ.∀β.sig(α,ρ,β))} (mkMonoArray n)





