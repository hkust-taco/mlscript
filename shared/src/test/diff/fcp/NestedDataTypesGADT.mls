// :NoRecursiveTypes
:GeneralizeCurriedFunctions
:IrregularTypes


// * Perfect Trees (https://www.cis.upenn.edu/~plclub/blog/2020-12-04-nested-datatypes/)

// * Representing perfect trees with GADTs

// data HTree (h :: Nat) (a :: Type) where
//   DLeaf :: a -> HTree Z a
//   DNode :: Two (HTree h a) -> HTree (S h) a


type Two[A] = (A, A)
//│ Defined type alias Two[+A]

def mapTwo f ((a, b)) = (f a, f b)
//│ mapTwo: 'a -> (forall 'a, 'b, 'c, 'd, 'e. (('b, 'd,) -> ('c, 'e,)
//│   where
//│     'a <: 'b -> 'c & 'd -> 'e))
//│       = [Function: mapTwo]

// class Z
// class S: { value: Nat }
// type NAT = S | Z
class Z
class S[P]
  method Inv: P -> P
  method Inv = id
//│ Defined class Z
//│ Defined class S[=P]
//│ Declared S.Inv: S['P] -> 'P -> 'P
//│ Defined S.Inv: S['P] -> (forall 'a. 'a -> 'a)

:w
class HTreeBase[N, A]: { n: N }
class DLeaf[A]: HTreeBase[Z, A] & { value: A }
class DNode[N, A]: HTreeBase[S[N], A] & { subTree: Two[HTree[N, A]] }
type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ Defined class HTreeBase[+N, ±A]
//│ Defined class DLeaf[+A]
//│ Defined class DNode[=N, ±A]
//│ Defined type alias HTree[±N, ±A]
//│ ╔══[WARNING] Type definition DNode has bivariant type parameters:
//│ ║  l.39: 	class DNode[N, A]: HTreeBase[S[N], A] & { subTree: Two[HTree[N, A]] }
//│ ║        	      ^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.39: 	class DNode[N, A]: HTreeBase[S[N], A] & { subTree: Two[HTree[N, A]] }
//│ ╙──      	               ^
//│ ╔══[WARNING] Type definition HTree has bivariant type parameters:
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ║        	     ^^^^^
//│ ╟── N is irrelevant and may be removed
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ║        	           ^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ╙──      	              ^
//│ ╔══[WARNING] Type definition HTreeBase has bivariant type parameters:
//│ ║  l.37: 	class HTreeBase[N, A]: { n: N }
//│ ║        	      ^^^^^^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.37: 	class HTreeBase[N, A]: { n: N }
//│ ╙──      	                   ^


d1 = DLeaf { value = 1; n = Z{} }
//│ d1: DLeaf[1]
//│   = DLeaf { n: Z {}, value: 1 }
d1: HTreeBase[Z, int]
//│ res: HTreeBase[Z, ?]
//│    = DLeaf { n: Z {}, value: 1 }

d1_ k = k d1
//│ d1_: (DLeaf[1] -> 'a) -> 'a
//│    = [Function: d1_]

:e // fails after new-refreshing-extrusion
d1_ : HTree[Z, int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.80: 	d1_ : HTree[Z, int]
//│ ║        	^^^
//│ ╟── integer literal of type `1` is not an instance of type `A`
//│ ║  l.68: 	d1 = DLeaf { value = 1; n = Z{} }
//│ ║        	                     ^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ╙──      	              ^
//│ res: HTree[?, ?]
//│    = [Function: d1_]

// FIXME
d2 = DNode { subTree = (d1_, d1_); n = S{} }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.94: 	d2 = DNode { subTree = (d1_, d1_); n = S{} }
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `A`
//│ ║  l.68: 	d1 = DLeaf { value = 1; n = Z{} }
//│ ║        	                     ^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ╙──      	              ^
//│ d2: error
//│   = DNode { n: S {}, subTree: [ [Function: d1_], [Function: d1_] ] }

def d1_ty: HTree[Z, int]
//│ d1_ty: HTree[?, ?]
//│      = <missing implementation>

d2 = DNode { subTree = (d1_ty, d1_ty); n = S{} }
//│ d2: DNode['P, ?] with {subTree: (HTree[?, ?], HTree[?, ?],)}
//│   = <no result>
//│     d1_ty is not implemented
d2: DNode[Z, int]
d2: HTreeBase[S[Z], int]
//│ res: DNode[Z, ?]
//│    = <no result>
//│      d2 and d1_ty are not implemented
//│ res: HTreeBase[S[Z], ?]
//│    = <no result>
//│      d2 and d1_ty are not implemented

d2_ k = k d2
//│ d2_: ((forall 'P. DNode['P, ?] with {subTree: (HTree[?, ?], HTree[?, ?],)}) -> 'a) -> 'a
//│    = <no result>
//│      d2 and d1_ty are not implemented

// FIXME
d2_ : HTree[S[Z], int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.130: 	d2_ : HTree[S[Z], int]
//│ ║         	^^^
//│ ╟── type `S[?p]` is not an instance of type `N`
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ║        	                                                            ^^^^^
//│ ╟── Note: constraint arises from type alias type parameter:
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ╙──      	           ^
//│ res: HTree[?, ?]
//│    = <no result>
//│      d2_, d2 and d1_ty are not implemented

// FIXME
d2_ k = k (d2:HTreeBase[S[Z], int])
d2_ : HTree[S[Z], int]
//│ d2_: (HTreeBase[S[Z], ?] -> 'a) -> 'a
//│    = <no result>
//│      d2 and d1_ty are not implemented
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.146: 	d2_ : HTree[S[Z], int]
//│ ║         	^^^
//│ ╟── type `HTreeBase[S[Z], ?]` does not match type `DLeaf[A] | DNode[in S[?p] | N out S[?p] & N, ?]`
//│ ║  l.145: 	d2_ k = k (d2:HTreeBase[S[Z], int])
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.40: 	type HTree[N, A] = forall 'r. (forall 'p. (DLeaf[A] | DNode[S['p], A] & DNode[N, A]) -> 'r) -> 'r
//│ ╙──      	                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: HTree[?, ?]
//│    = <no result>
//│      d2_, d2 and d1_ty are not implemented




