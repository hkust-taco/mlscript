:NoJS


class Expr[A]
  method Inv: A -> A
//│ Defined class Expr[=A]
//│ Declared Expr.Inv: Expr['A] -> 'A -> 'A

class Program
//│ Defined class Program

def mapExprs: (forall 'a. Expr['a] -> Expr['a]) -> Program -> Program
//│ /!\ Parse error: Expected ")":1:23, found "'a. Expr['" at l.12:23: def mapExprs: (forall 'a. Expr['a] -> Expr['a]) -> Program -> Program

def print_int: int -> unit
def size: Expr['a] -> int
//│ print_int: int -> unit
//│ size: Expr['a] -> int

def asExpr: Expr['a] -> Expr['a]
//│ asExpr: Expr['a] -> Expr['a]

def alsoPrintSizeSimple f =
  let rec nested expr =
    f (asExpr expr)
  in nested
//│ alsoPrintSizeSimple: (Expr['a] -> 'b) -> Expr['a] -> 'b

def alsoPrintSizeSimple f =
  let rec nested expr =
    asExpr (f (asExpr expr))
  in nested
//│ alsoPrintSizeSimple: (Expr['a] -> Expr['a0]) -> Expr['a] -> Expr['a0]

// :ds
// :d
def alsoPrintSizeSimple f =
  let rec nested expr =
    f (asExpr expr) nested
  in nested
//│ alsoPrintSizeSimple: (Expr[in 'a out 'a | 'a0] -> (Expr[in 'a0 & 'a1 out 'a2] -> 'b) -> 'b) -> Expr['a2] -> 'b
//│   where
//│     'a2 :> 'a | 'a1
//│         <: 'a0


def e: Expr[?]
def f: Expr[?] -> Expr[?]
//│ e: Expr[?]
//│ f: Expr[?] -> Expr[?]

f e
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	f e
//│ ║        	^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.47: 	def e: Expr[?]
//│ ║        	            ^
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.48: 	def f: Expr[?] -> Expr[?]
//│ ╙──      	            ^
//│ res: error | Expr[?]


