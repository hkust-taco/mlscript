:NoRecursiveTypes
:GeneralizeCurriedFunctions
:NoConstrainedTypes
:DistributeForalls

:NoJS



def f1: 'a -> (forall 'b. 'b -> ('a, 'b))
def f2: 'a -> 'b -> ('a, 'b)
//│ f1: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ f2: 'a -> 'b -> ('a, 'b,)


// * With distributivity, f1 and f2 have equivalent types, as shown below

f1 = f2
//│ 'a -> 'b -> ('a, 'b,)
//│   <:  f1:
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))

f2 = f1
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│   <:  f2:
//│ 'a -> 'b -> ('a, 'b,)


// * However, f2 currently is not as flexible:

def test: (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ test: (forall 'b. 'b -> (int, 'b,)) -> (int, bool,)

test (f1 42)
//│ res: (int, bool,)

// TODO this is currently not handled because we don't yet try to split
//    type parameters in order to distribute only *part* of the quantification
:e
test (f2 42)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	test (f2 42)
//│ ║        	^^^^^^^^^^^^
//│ ╟── type `‘b_92_93` is not an instance of type `'b_92_94`
//│ ║  l.31: 	def test: (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ║        	                  ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.31: 	def test: (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ╙──      	                  ^^
//│ res: error


// * Though these work!

f1_42 = f1 42
f2_42 = f2 42
//│ f1_42: 'b -> (42, 'b,)
//│ f2_42: 'b -> (42, 'b,)

test f1_42
test f2_42
//│ res: (int, bool,)
//│ res: (int, bool,)



def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ test: (forall 'b. 'b -> (int, 'b,)) -> (int, bool,)

def f1_1: forall 'a. 'a -> (forall 'b. 'b -> ('a, 'b))
//│ f1_1: 'a -> (forall 'b. 'b -> ('a, 'b,))

def f2_1: forall 'a. forall 'b. 'a -> 'b -> ('a, 'b)
def f2_2: forall 'b. forall 'a. 'a -> 'b -> ('a, 'b)
def f2_3: forall 'a 'b. 'a -> 'b -> ('a, 'b)
//│ f2_1: 'a -> 'b -> ('a, 'b,)
//│ f2_2: 'a -> 'b -> ('a, 'b,)
//│ f2_3: 'a -> 'b -> ('a, 'b,)

test (f1_1 42)
//│ res: (int, bool,)

// TODO
test (f2_1 42)
test (f2_2 42)
test (f2_3 42)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.84: 	test (f2_1 42)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `‘b_185_186` is not an instance of type `'b_185_187`
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ║        	                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ╙──      	                             ^^
//│ res: error
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.85: 	test (f2_2 42)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `‘b_193_194` is not an instance of type `'b_193_195`
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ║        	                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ╙──      	                             ^^
//│ res: error
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.86: 	test (f2_3 42)
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── type `‘b_201_202` is not an instance of type `'b_201_203`
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ║        	                             ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.67: 	def test: forall 'a. (forall 'b. 'b -> (int, 'b)) -> (int, bool)
//│ ╙──      	                             ^^
//│ res: error


f1_1_42 = f1_1 42
f2_1_42 = f2_1 42
f2_2_42 = f2_2 42
f2_3_42 = f2_3 42
//│ f1_1_42: 'b -> (42, 'b,)
//│ f2_1_42: 'b -> (42, 'b,)
//│ f2_2_42: 'b -> (42, 'b,)
//│ f2_3_42: 'b -> (42, 'b,)

test f1_1_42
test f2_1_42
test f2_2_42
test f2_3_42
//│ res: (int, bool,)
//│ res: (int, bool,)
//│ res: (int, bool,)
//│ res: (int, bool,)



// * Note: without distributivity:

:DontDistributeForalls

:e
f1 = f2
//│ 'a -> 'b -> ('a, 'b,)
//│   <:  f1:
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.144: 	f1 = f2
//│ ║         	^^^^^^^
//│ ╟── type `‘b_278_279` is not an instance of type `'b_278_280`
//│ ║  l.10: 	def f1: 'a -> (forall 'b. 'b -> ('a, 'b))
//│ ║        	                      ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.10: 	def f1: 'a -> (forall 'b. 'b -> ('a, 'b))
//│ ╙──      	                      ^^

f2 = f1
//│ 'a -> (forall 'b. 'b -> ('a, 'b,))
//│   <:  f2:
//│ 'a -> 'b -> ('a, 'b,)


