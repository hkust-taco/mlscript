:GeneralizeCurriedFunctions
:ArgGen
:NoRecursiveTypes
:DistributeForalls

type ChurchInt = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ Defined type alias ChurchInt

def zero f x = x
//│ zero: 'a -> (forall 'b. 'b -> 'b)
//│     = [Function: zero]

zero: ChurchInt
//│ res: ChurchInt
//│    = [Function: zero]

def succ: ChurchInt -> ChurchInt
def succ n f x = f (n f x)
//│ succ: ChurchInt -> ChurchInt
//│     = <missing implementation>
//│ 'a -> (forall 'b. 'b -> (forall 'b, 'c, 'd. ('c -> 'd
//│   where
//│     'b <: (forall 'c, 'b, 'e, 'a, 'f. ('f
//│   where
//│     'a <: 'b -> ('c -> 'f & 'e))) -> 'd)))
//│   <:  succ:
//│ ChurchInt -> ChurchInt
//│     = [Function: succ1]

// def to_church: int -> ChurchInt
rec def to_church n =
  if n == 0 then zero
  else succ (to_church (n - 1))
//│ to_church: int -> (forall 'a. 'a -> (forall 'b. 'b -> 'b) | ChurchInt)
//│          = [Function: to_church]

to_church: int -> ChurchInt
//│ res: int -> ChurchInt
//│    = [Function: to_church]

// def add: ChurchInt -> ChurchInt -> ChurchInt
def add n m = n succ m
//│ add: 'a -> (forall 'a, 'b, 'c, 'd. ('b -> 'c
//│   where
//│     'a <: (ChurchInt -> ChurchInt) -> ('b -> 'c & 'd)))
//│    = [Function: add]

add: ChurchInt -> ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: add]

// def mul: ChurchInt -> ChurchInt -> ChurchInt
def mul n m = n (add m) zero
//│ mul: 'a -> (forall 'b, 'c, 'd, 'a. ('b -> 'c
//│   where
//│     'a <: (forall 'e, 'b, 'f, 'g, 'h, 'i. ('f -> 'g | 'h
//│   where
//│     'i | 'b <: (ChurchInt -> ChurchInt) -> ('f -> 'g & 'e))) -> ((forall 'j. 'j -> (forall 'k. 'k -> 'k)) -> 'c & 'd)))
//│    = [Function: mul]

:e // fails since the fix to spurious-TV-cycles
mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing type ascription; a type annotation may be required
//│ ║  l.62: 	mul: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ChurchInt  <:  'a21_268    TypeRef  TypeVariable
//│ ╙──  ... looks like:  ChurchInt  <:  'a21_22''
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: mul]

// def pow: ChurchInt -> ChurchInt -> ChurchInt
def pow n m = n (mul m) (succ zero)
//│ pow: 'a -> (forall 'b, 'a, 'c, 'd. ('d -> 'b
//│   where
//│     'a <: (forall 'e, 'f, 'g, 'h, 'd, 'i. ('e -> 'i | 'f
//│   where
//│     'g | 'd <: (forall 'e, 'j, 'k, 'l, 'm, 'n, 'o. ('m -> 'k | 'j
//│   where
//│     'n | 'e <: (ChurchInt -> (ChurchInt | 'l)) -> ('m -> 'k & 'o))) -> ((forall 'p. 'p -> (forall 'q. 'q -> 'q)) -> 'i & 'h))) -> ((forall 'l. ChurchInt | 'l) -> 'b & 'c)))
//│    = [Function: pow]

:e
pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ╔══[ERROR] Cyclic-looking constraint while typing type ascription; a type annotation may be required
//│ ║  l.84: 	pow: ChurchInt -> ChurchInt -> ChurchInt
//│ ║        	^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α24_27'' -> ‹∀ 2. (α25_26''' -> α25_26''')›)››  <:  'a21_449    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α24_27'' -> ‹∀ 2. (α25_26''' -> α25_26''')›)››  <:  'a21_22''
//│ res: ChurchInt -> ChurchInt -> ChurchInt
//│    = [Function: pow]

def unit = id
//│ unit: 'a -> 'a
//│     = [Function: unit]

type Unit_t = 'a -> 'a
unit : Unit_t
//│ Defined type alias Unit_t
//│ res: Unit_t
//│    = [Function: id]

def tru x _ = x unit
//│ tru: 'a -> (forall 'a, 'b, 'c. ('c -> 'b
//│   where
//│     'a <: (forall 'd. 'd -> 'd) -> 'b))
//│    = [Function: tru]

def fls _ x = x unit
//│ fls: 'a -> (forall 'b, 'c. ((forall 'd. 'd -> 'd) -> 'b & 'c) -> 'b)
//│    = [Function: fls]

type If_t = (Unit_t -> 'a) -> (Unit_t -> 'a) -> 'a
tru : If_t
fls : If_t
//│ Defined type alias If_t
//│ res: If_t
//│    = [Function: tru]
//│ res: If_t
//│    = [Function: fls]

def iszero n = n (fun _ -> fls) tru
//│ iszero: ((forall 'a. 'a -> (forall 'b. 'b -> (forall 'c, 'd. ((forall 'e. 'e -> 'e) -> 'c & 'd) -> 'c))) -> ((forall 'f. 'f -> (forall 'g, 'f, 'h. ('g -> 'h
//│   where
//│     'f <: (forall 'e. 'e -> 'e) -> 'h))) -> 'i & 'j) & 'k) -> 'i
//│       = [Function: iszero]

iszero : ChurchInt -> If_t
//│ res: ChurchInt -> If_t
//│    = [Function: iszero]

def pair x y f = f x y
//│ pair: 'a -> (forall 'b. 'b -> (forall 'c, 'd, 'e. ('a -> ('b -> 'c & 'd) & 'e) -> 'c))
//│     = [Function: pair]

def fst p = p (fun x -> fun _ -> x)
//│ fst: ((forall 'a. 'a -> (forall 'b. 'b -> 'a)) -> 'c & 'd) -> 'c
//│    = [Function: fst]

def snd p = p (fun _ -> fun x -> x)
//│ snd: ((forall 'a. 'a -> (forall 'b. 'b -> 'b)) -> 'c & 'd) -> 'c
//│    = [Function: snd]

def pred n =
  let s p = pair (snd p) (succ (snd p)) in
  let z = pair zero zero in
  fst (n s z)
//│ pred: ((forall 'a, 'b, 'c, 'd, 'e. ((forall 'f. 'f -> (forall 'g. 'g -> 'g)) -> ((‘a_681_686 -> ‘a_681_686) -> ‘a_681_686 -> ‘a_681_686 & 'e & 'a) & 'c) -> (forall 'h, 'i, 'j. ((forall 'k, 'l, 'c, 'm. ('l | 'k
//│   where
//│     'c <: (forall 'f. 'f -> (forall 'g. 'g -> 'g)) -> ('m & 'k))) -> ((forall 'n. ChurchInt | 'b | 'n) -> 'h & 'i) & 'j) -> 'h | 'd)) -> ((forall 'o, 'p, 'q, 'r. ((forall 's, 't, 'u. 's -> (forall 'v. 'v -> 'v) | 't | 'u) -> ((forall 's, 'u. 's -> (forall 'v. 'v -> 'v) | 'u) -> 'o & 'p) & 'q) -> 'o | 'r) -> ((forall 'w. 'w -> (forall 'x. 'x -> 'w)) -> ('y & 'z) & 'a1) & 'b1) & 'c1) -> 'z
//│     = [Function: pred]

pred : ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: pred]

:e
rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.159: 	rec def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n (fact (pred n)))
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── ————————— Additional debugging info: —————————
//│ ╟── this constraint:  ‹∀ 0. ‹∀ 1. (α24_27'' -> ‹∀ 2. (α25_26''' -> α25_26''')›)››  <:  α132_1007'    PolymorphicType  TypeVariable
//│ ╙──  ... looks like:  ‹∀ 0. ‹∀ 1. (α24_27'' -> ‹∀ 2. (α25_26''' -> α25_26''')›)››  <:  α132_1007'
//│ fact: ChurchInt -> (forall 'a. 'a -> (forall 'b. 'b -> 'b) | ChurchInt)
//│     = [Function: fact]

:e
def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.170: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                    ^^^^^^^^
//│ ╟── record literal of type `anything` is not a function
//│ ║  l.170: 	def fact (n: ChurchInt) = (iszero n) (fun _ -> succ zero) (fun _ -> mul n {})
//│ ║         	                                                                          ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.42: 	def add n m = n succ m
//│ ║        	              ^^^^^^
//│ ╟── from reference:
//│ ║  l.53: 	def mul n m = n (add m) zero
//│ ╙──      	                     ^
//│ fact: ChurchInt -> (error | ChurchInt | 'a)
//│     = [Function: fact1]

fact : ChurchInt -> ChurchInt
//│ res: ChurchInt -> ChurchInt
//│    = [Function: fact1]

:re
(fact (to_church 1)) (fun x -> x + 1) 0
//│ res: error | int
//│ Runtime error:
//│   TypeError: n is not a function

