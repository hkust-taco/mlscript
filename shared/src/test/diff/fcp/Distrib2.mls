:NoRecursiveTypes
:DistributeForalls
:NoJS



type BTB = forall 'b. 'b -> 'b
//â”‚ Defined type alias BTB



// * ========= This first version works fine because the LHS `forall 'a.` can be distributed. =========


def ty_1: (nothing -> 'a) -> 'a
//â”‚ ty_1: (nothing -> 'a) -> 'a

def ty_2: (forall 'c. 'c -> 'c -> 'c) -> BTB
//â”‚ ty_2: (forall 'c. 'c -> 'c -> 'c) -> BTB

// * Works thanks to `:DistributeForalls`, distributing the LHS (`forall 'a`)
ty_2 = ty_1
//â”‚ (nothing -> 'a) -> 'a
//â”‚   <:  ty_2:
//â”‚ (forall 'c. 'c -> 'c -> 'c) -> BTB

def ty_1_2: (nothing -> BTB) -> BTB
//â”‚ ty_1_2: (nothing -> BTB) -> BTB

ty_1_2 = ty_1
//â”‚ (nothing -> 'a) -> 'a
//â”‚   <:  ty_1_2:
//â”‚ (nothing -> BTB) -> BTB

ty_2 = ty_1_2
//â”‚ (nothing -> BTB) -> BTB
//â”‚   <:  ty_2:
//â”‚ (forall 'c. 'c -> 'c -> 'c) -> BTB



// * ========= Here the `forall 'a.` can't be distributed. =========
// * (Unless we somehow knew to widen the function to `nothing -> ...` and then distribute.)


def ty_1: 'a -> (nothing -> 'a) -> 'a
//â”‚ ty_1: 'a -> (nothing -> 'a) -> 'a

def ty_2: nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB
//â”‚ ty_2: nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB

// * But this still works thanks to `:DistributeForalls`, distributing the RHS (`forall 'b` out of BTB)
ty_2 = ty_1
//â”‚ 'a -> (nothing -> 'a) -> 'a
//â”‚   <:  ty_2:
//â”‚ nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB



// * ========= Now without distributivity. =========


:DontDistributeForalls


// * This fails to constrain, as expected
:e
ty_2 = ty_1
//â”‚ 'a -> (nothing -> 'a) -> 'a
//â”‚   <:  ty_2:
//â”‚ nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB
//â”‚ â•”â•â•[ERROR] Type error in def definition
//â”‚ â•‘  l.68: 	ty_2 = ty_1
//â”‚ â•‘        	^^^^^^^^^^^
//â”‚ â•Ÿâ”€â”€ type variable `'b` leaks out of its scope
//â”‚ â•‘  l.7: 	type BTB = forall 'b. 'b -> 'b
//â”‚ â•‘       	                      ^^
//â”‚ â•Ÿâ”€â”€ back into type variable `'b`
//â”‚ â•‘  l.7: 	type BTB = forall 'b. 'b -> 'b
//â”‚ â•‘       	                            ^^
//â”‚ â•Ÿâ”€â”€ adding a type annotation to any of the following terms may help resolve the problem
//â”‚ â•Ÿâ”€â”€ â€¢ this reference:
//â”‚ â•‘  l.68: 	ty_2 = ty_1
//â”‚ â•™â”€â”€      	       ^^^^


// * We can manually take ty_1 closer to ty_2

def ty_1_2: BTB -> (nothing -> BTB) -> BTB
//â”‚ ty_1_2: BTB -> (nothing -> BTB) -> BTB

ty_1_2 = ty_1
//â”‚ 'a -> (nothing -> 'a) -> 'a
//â”‚   <:  ty_1_2:
//â”‚ BTB -> (nothing -> BTB) -> BTB

// * But it still need distributivity for the inner comparison
:e
ty_2 = ty_1_2
//â”‚ BTB -> (nothing -> BTB) -> BTB
//â”‚   <:  ty_2:
//â”‚ nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB
//â”‚ â•”â•â•[ERROR] Type error in def definition
//â”‚ â•‘  l.99: 	ty_2 = ty_1_2
//â”‚ â•‘        	^^^^^^^^^^^^^
//â”‚ â•Ÿâ”€â”€ type variable `'b` leaks out of its scope
//â”‚ â•‘  l.7: 	type BTB = forall 'b. 'b -> 'b
//â”‚ â•‘       	                      ^^
//â”‚ â•Ÿâ”€â”€ back into type variable `'b`
//â”‚ â•‘  l.7: 	type BTB = forall 'b. 'b -> 'b
//â”‚ â•™â”€â”€     	                            ^^

// * Note
def ty_1_3: BTB -> (nothing -> anything -> nothing) -> BTB
//â”‚ ty_1_3: BTB -> (nothing -> anything -> nothing) -> BTB
ty_1_3 = ty_1_2
//â”‚ BTB -> (nothing -> BTB) -> BTB
//â”‚   <:  ty_1_3:
//â”‚ BTB -> (nothing -> anything -> nothing) -> BTB


// * Again, with distrib.

:DistributeForalls

ty_2 = ty_1_2
//â”‚ BTB -> (nothing -> BTB) -> BTB
//â”‚   <:  ty_2:
//â”‚ nothing -> (forall 'c. 'c -> 'c -> 'c) -> BTB



// * ========= Some additional semi-random tests. =========


def ty_0: nothing -> BTB
//â”‚ ty_0: nothing -> BTB


ty_0 = id
//â”‚ 'a -> 'a
//â”‚   <:  ty_0:
//â”‚ nothing -> BTB

ty_0 = (fun x -> fun y -> y)
//â”‚ anything -> 'a -> 'a
//â”‚   <:  ty_0:
//â”‚ nothing -> BTB

idid = id (fun x -> id (fun y -> id y))
//â”‚ idid: anything -> 'a -> 'a

def foo: 'a -> 'a -> 'a
//â”‚ foo: 'a -> 'a -> 'a

idid x = foo (x (fun y -> y))
//â”‚ idid: ((forall 'b. 'b -> 'b) -> 'a) -> 'a -> 'a

ty_0 = idid
//â”‚ ((forall 'b. 'b -> 'b) -> 'a) -> 'a -> 'a
//â”‚   <:  ty_0:
//â”‚ nothing -> BTB

// âˆ€ð›¼{ð›½â‰¤ð›¼}.ð›¼â†’ð›¼ â‰¤ âŠ¤â†’(âˆ€ð›¾.ð›¾â†’ð›¾)
ty_0 = idid id
//â”‚ 'a -> ('b -> 'b | 'a)
//â”‚   <:  ty_0:
//â”‚ nothing -> BTB

def idid = let x = (fun y -> y) : 'a in id : 'a -> 'a
//â”‚ idid: 'a -> 'a

ty_0 = idid id
//â”‚ 'a -> 'a
//â”‚   <:  ty_0:
//â”‚ nothing -> BTB


