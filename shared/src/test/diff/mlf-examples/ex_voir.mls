:NoRecursiveTypes
:GeneralizeCurriedFunctions

// ============ Dummy classes to represent the types in the examples ============

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ 'b -> (forall 'c. (List['c] & 'c) -> (forall 'b, 'c, 'head, 'a, 'tail. (Cons['a] with {head: 'head, tail: 'tail}
//│   where
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail
//│     'b <: 'head & 'a
//│     'c <: List['a] & 'tail)))
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│ /!!!\ Uncaught error: java.util.NoSuchElementException: key not found: List
//│ 	at: scala.collection.immutable.BitmapIndexedMapNode.apply(HashMap.scala:631)
//│ 	at: scala.collection.immutable.HashMap.apply(HashMap.scala:132)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65(ConstraintSolver.scala:659)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$65$adapted(ConstraintSolver.scala:432)
//│ 	at: mlscript.utils.package$GenHelper$.$bar$greater$extension(package.scala:101)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$62(ConstraintSolver.scala:432)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:30)
//│ 	at: mlscript.ConstraintSolver.recImpl$1(ConstraintSolver.scala:390)
//│ 	at: mlscript.ConstraintSolver.rec$1(ConstraintSolver.scala:375)

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
def nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}



// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let choose x y = if true then x else y
// let choose3 x y z = (choose (choose x y) z)
// let id = (fun x -> x : sid)
// let succ n = n + 1
def choose x y = if true then x else y
def choose3 x y z = choose (choose x y) z
def id = (fun x -> x) : Sid
def id_ = fun x -> x
def succ n = n + 1
//│ choose: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c. ('c
//│   where
//│     'a <: 'c
//│     'b <: 'c)))
//│       = [Function: choose]
//│ choose3: 'a -> (forall 'b. 'b -> (forall 'c, 'd. ('c & 'd) -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('d
//│   where
//│     'e <: 'd
//│     'f <: 'd
//│     'g <: 'd
//│     'h <: 'd
//│     'a <: 'h
//│     'b <: 'f
//│     'c <: 'd & 'h
//│     'g <: 'd
//│     'h <: 'd
//│     'a <: 'h
//│     'b <: 'f
//│     'c <: 'd & 'h))))
//│        = [Function: choose3]
//│ id: Sid
//│   = [Function: id]
//│ id_: 'a -> 'a
//│    = [Function: id_]
//│ succ: int -> int
//│     = [Function: succ]

// let test = choose3 id
// let test2 = test succ
def test = choose3 id
def test_ = choose3 id_
def test2 = test succ
def test2_ = test_ succ
//│ test: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('d
//│   where
//│     'c <: 'd
//│     'e <: 'd
//│     'f <: 'd
//│     'g <: 'd
//│     'h <: 'b
//│     'a <: 'b
//│     'b <: 'b
//│     'f <: 'd
//│     'g <: 'd
//│     'h <: 'b
//│     'a <: 'b
//│     'b <: 'b)))
//│     = [Function (anonymous)]
//│ test_: 'a -> (forall 'b. 'b -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('d
//│   where
//│     'c <: 'd
//│     'e <: 'd
//│     'f <: 'd
//│     'g <: 'd
//│     'h <: 'b
//│     'a <: 'b
//│     'b <: 'b
//│     'f <: 'd
//│     'g <: 'd
//│     'h <: 'b
//│     'a <: 'b
//│     'b <: 'b)))
//│      = [Function (anonymous)]
//│ test2: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('c
//│   where
//│     'b <: 'c
//│     'd <: 'c
//│     'e <: 'c
//│     'f <: 'c
//│     'g <: 'a
//│     'h <: 'a
//│     'a <: 'a
//│     'e <: 'c
//│     'f <: 'c
//│     'g <: 'a
//│     'h <: 'a
//│     'a <: 'a))
//│      = [Function (anonymous)]
//│ test2_: 'a -> (forall 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h. ('c
//│   where
//│     'b <: 'c
//│     'd <: 'c
//│     'e <: 'c
//│     'f <: 'c
//│     'g <: 'a
//│     'h <: 'a
//│     'a <: 'a
//│     'e <: 'c
//│     'f <: 'c
//│     'g <: 'a
//│     'h <: 'a
//│     'a <: 'a))
//│       = [Function (anonymous)]

// (* Messages d'erreur foireux : *)
// type s1 = ['a] 'a -> int * int ;;
// type s2 = ['a] 'a -> bool * bool ;
// fun x y -> ((x:s1),(y:s2), if true then x else y) ;; 
// fun x y -> ((x:s1),(y:s2), x x) ;; 
type S1 = forall 'a. 'a -> (int, int)
type S2 = forall 'a. 'a -> (bool, bool)
fun x -> fun y -> ((x : S1), (y : S2), if true then x else y)
fun x -> fun y -> ((x : S1), (y : S2), x x)
//│ Defined type alias S1
//│ Defined type alias S2
//│ res: (S1 & 'a) -> (forall 'b. (S2 & 'b) -> (forall 'a, 'b, 'c. ((S1, S2, 'c,)
//│   where
//│     'a <: 'c
//│     'b <: 'c)))
//│    = [Function: res]
//│ res: (S1 & 'a -> anything & 'a) -> S2 -> (forall 'a, 'b. ((S1, S2, 'b,)
//│   where
//│     'a <: 'a -> 'b))
//│    = [Function: res]

// (* please onlyweak ['b = sid] 'b -> 'b : sid -> sid *)

// (*
// let example f = (f:['a] 'a -> int -> 'b) f
// let mkpair x y = (x,y)
def example f = (f: forall 'a. 'a -> int -> 'b) f
def example_ f = f f
def mkpair x y = (x, y)
//│ example: (nothing -> int -> 'a & 'a) -> (forall 'a, 'b. (int -> 'b
//│   where
//│     'a <: nothing -> int -> 'b & 'a))
//│        = [Function: example]
//│ example_: ('a -> anything & 'a) -> (forall 'a, 'b. ('b
//│   where
//│     'a <: 'a -> 'b))
//│         = [Function: example_]
//│ mkpair: 'a -> (forall 'b. 'b -> ('a, 'b,))
//│       = [Function: mkpair]

// untype example mkpair
// (* �a echoue parce qu'on instancie 'b avec un type contenant 'a *)
// (* Il faudrait que le message d'erreur soit plus clair. *)
// *)
example mkpair
example_ mkpair
//│ res: int -> ('b | (‘a1042, int,))
//│   where
//│     'a <: nothing -> int -> 'b
//│    = [Function (anonymous)]
//│ res: 'a
//│   where
//│     'b <: 'b -> 'a
//│    = [Function (anonymous)]

// let make_ex3 x (f:['a > sid] 'a -> 'b ) = f x 
def make_ex3 x (f: forall 'a. ('a | Sid) -> 'b) = f x
//│ make_ex3: 'a -> (forall 'a. ((Sid -> anything) -> (forall 'a, 'b, 'c. ('c
//│   where
//│     'b <: 'a -> 'c))
//│   where
//│     'a <: anything))
//│         = [Function: make_ex3]

// let ex_list3 = [ make_ex3 succ ;
// 		 make_ex3 id ;
// 		 make_ex3 not ]

// FIXME
// :e
// def ex_list3 = cons (make_ex3 succ) (
//       cons (make_ex3 id) (
//       cons (make_ex3 not) nil))

// FIXME: what is `open`?
// (*let test3 = listiter (open (fun v -> choose v id)) ex_list3  *)
// (* Meme message d'erreur je crois. *)

// type i = int
// (* Affichage : nom des variables ??? *)
// please unify ['a1 = ['a2 = ['a3 = ['a4 = ['a5 = 0] 'a5 -> i]
//                                         ('a4 -> i) -> i]
//                                         ('a3 -> i) -> i] 'a2 -> i] 'a1 -> i
//          :   ['b1 = ['b2 = ['b3 = ['b4 = 0] ('b4 -> i) -> i]
//                                         ('b3 -> i) -> i]
//                                         ('b2 -> i) -> i] 'b1 -> i

// (* Cet exemple cr�e un graphe mal form�. *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> list ('c)] 'b -> 'a

// (* Plus simple *)
// please failon_unify ['a] ['b = ['c] 'c -> 'a] 'b -> 'a
//          :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a

// (* Extrusion automatique de binders. *)
// please unify  ['a] ['b > ['c] 'c -> 'a] 'b -> 'a
//           :   ['a] ['b > ['c] 'c -> 'c] 'b -> 'a
//           =   ['c] ('c -> 'c) -> 'c


