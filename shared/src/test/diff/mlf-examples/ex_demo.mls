:NoRecursiveTypes


// ============ Dummy classes to represent the types in the examples ============

class None
class Some[a]: { val: a }
type Option[a] = None | Some[a]
//│ Defined class None
//│ Defined class Some[+a]
//│ Defined type alias Option[+a]

class List[a]
  method Head: a
  method Tail: List[a]
//│ Defined class List[+a]
//│ Declared List.Head: List['a] -> 'a
//│ Declared List.Tail: List['a] -> List['a]

class Cons[a]: List[a] & { head: a; tail: List[a] }
  method Head = this.head
  method Tail = this.tail
def cons[a]: a -> List[a] -> List[a]
def cons head tail = Cons { head; tail }
//│ Defined class Cons[+a]
//│ Defined Cons.Head: Cons['a] -> 'a
//│ Defined Cons.Tail: Cons['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]
//│     = <missing implementation>
//│ ('head & 'a) -> (List['a] & 'tail) -> (Cons['a] with {head: 'head, tail: 'tail})
//│   <:  cons:
//│ 'a -> List['a] -> List['a]
//│     = [Function: cons]

class Nil[a]: List[a]
  method Head = error
  method Tail = this
def nil: List['a]
nil = Nil {}
//│ Defined class Nil[+a]
//│ Defined Nil.Head: Nil[?] -> nothing
//│ Defined Nil.Tail: (Nil['a] & 'this) -> (Nil['a] & 'this)
//│ nil: List[nothing]
//│    = <missing implementation>
//│ Nil[nothing]
//│   <:  nil:
//│ List[nothing]
//│    = Nil {}

// ============ Type signatures for functions used in the examples ============

def head: forall 'a. List['a] -> 'a
def head l = l.Head
//│ head: List['a] -> 'a
//│     = <missing implementation>
//│ List['a] -> 'a
//│   <:  head:
//│ List['a] -> 'a
//│     = [Function: head]

def tail: forall 'a. List['a] -> List['a]
def tail l = l.Tail
//│ tail: List['a] -> List['a]
//│     = <missing implementation>
//│ List['a] -> List['a]
//│   <:  tail:
//│ List['a] -> List['a]
//│     = [Function: tail]

def print_bool: bool -> unit
def print_bool b = log b
//│ print_bool: bool -> unit
//│           = <missing implementation>
//│ anything -> unit
//│   <:  print_bool:
//│ bool -> unit
//│           = [Function: print_bool]

def print_int: int -> unit
def print_int i = log i
//│ print_int: int -> unit
//│          = <missing implementation>
//│ anything -> unit
//│   <:  print_int:
//│ int -> unit
//│          = [Function: print_int]

def print_string: string -> unit
def print_string s = log s
//│ print_string: string -> unit
//│             = <missing implementation>
//│ anything -> unit
//│   <:  print_string:
//│ string -> unit
//│             = [Function: print_string]



// (* A quick demo of MLF *)

// (* In the following, "untype expr" means that the expression expr should not be typable. *)

// type sid = ['a] 'a -> 'a
type Sid = forall 'a. 'a -> 'a
//│ Defined type alias Sid

// let id = fun x -> x
def id = fun x -> x
//│ id: 'a -> 'a
//│   = [Function: id]

// let delta = fun (x:sid) -> x x
def delta = fun (x: Sid) -> x x
def delta_ = fun x -> x x
//│ delta: Sid -> Sid
//│      = [Function: delta]
//│ delta_: ('a -> 'b & 'a) -> 'b
//│       = [Function: delta_]

// let choose x y = if true then x else y
def choose x y = if true then x else y
//│ choose: 'a -> 'a -> 'a
//│       = [Function: choose]

// let succ n = n + 1
// ;;
def succ n = n + 1
//│ succ: int -> int
//│     = [Function: succ]

// let test1 = delta id
test1 = delta id
//│ test1: Sid
//│      = [Function: id]

// untype delta succ
:e
delta succ
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.138: 	delta succ
//│ ║         	^^^^^^^^^^
//│ ╟── type `'a` is not an instance of type `int`
//│ ║  l.104: 	type Sid = forall 'a. 'a -> 'a
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.127: 	def succ n = n + 1
//│ ║         	             ^
//│ ╟── Note: quantified type variable 'a is defined at:
//│ ║  l.104: 	type Sid = forall 'a. 'a -> 'a
//│ ╙──       	                  ^^
//│ res: error | Sid
//│    = 'function succ(n) {  return n + 1;}1'

// let test2 = delta (choose id id)
test2 = delta (choose id id)
//│ test2: Sid
//│      = [Function: id]

test2 = delta_ (choose id id)
//│ test2: 'a -> 'a
//│      = [Function: id]

// untype delta (choose id succ)
:e
delta (choose id succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.165: 	delta (choose id succ)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not an instance of type `int`
//│ ║  l.104: 	type Sid = forall 'a. 'a -> 'a
//│ ║         	                      ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.127: 	def succ n = n + 1
//│ ║         	             ^
//│ ╟── Note: quantified type variable 'a is defined at:
//│ ║  l.104: 	type Sid = forall 'a. 'a -> 'a
//│ ╙──       	                  ^^
//│ res: error | Sid
//│    = [Function: id]

// let test3 = choose id succ
test3 = choose id succ
//│ test3: int -> int
//│      = [Function: id]

// let test4 = choose succ id
// ;;
test4 = choose succ id
//│ test4: int -> int
//│      = [Function: succ]


// let eqstring s1 s2 = (s1^"A" = s2^"A")
def eqstring s1 s2 = eq (concat s1 "A") (concat s2 "A")
//│ eqstring: string -> string -> bool
//│         = [Function: eqstring]

// let eqint i1 i2 = (i1 - i2) = 0
def eqint i1 i2 = (i1 - i2) == 0
//│ eqint: int -> int -> bool
//│      = [Function: eqint]

// let eqbool b1 b2 = if b1 then b2 else (not b2)
def eqbool b1 b2 = if b1 then b2 else (not b2)
//│ eqbool: bool -> bool -> bool
//│       = [Function: eqbool]

// let ignore x = ()
def ignore x = null
//│ ignore: anything -> null
//│       = [Function: ignore]


// let rec listiter f ll =
//   if ll = [] then ()
//   else begin ignore (f (car ll)) ; listiter f (cdr ll) end
// ;;

rec def listiter f ll =
  if eq ll nil then unit
  else
    let _ = ignore (f (head ll)) in 
    listiter f (tail ll)
//│ listiter: ('a -> anything) -> List['a] -> unit
//│         = [Function: listiter]

def listiterA: ('a -> unit) -> List['a] -> unit
//│ listiterA: ('a -> unit) -> List['a] -> unit
//│          = <missing implementation>

listiterA = listiter
//│ ('a -> anything) -> List['a] -> unit
//│   <:  listiterA:
//│ ('a -> unit) -> List['a] -> unit
//│          = [Function: listiter]



// (* Polymorphic recursion. *)

// untype let rec id x = if true then x else id id x in id
:e
rec def id1 x = if true then x else id1 id1 x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: 'b -> 'c
//│     'b :> 'b -> 'c
//│        <: 'c
//│     'c :> 'b -> 'c
//│        <: 'a
//│ ║  l.243: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──       	                                    ^^^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.243: 	rec def id1 x = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ id1: 'a -> 'b
//│   where
//│     'a :> 'a -> 'b
//│        <: 'b
//│     'b := 'a -> 'b
//│    = [Function: id1]



// * === \ Below, some of our own variations ===

// * With annotated recursive calls
def idy_ty: forall 'a. 'a -> 'a
def id1 x = if true then x else idy_ty idy_ty x
//│ idy_ty: 'a -> 'a
//│       = <missing implementation>
//│ id1: 'a -> 'a
//│    = <no result>
//│      idy_ty is not implemented

// * This definition does not actually seem to require general polymorphic recursion,
// *  but it does need at least recursive types:
:RecursiveTypes
rec def id1 x = if true then x else id1 id1 x
//│ id1: 'a -> 'b
//│   where
//│     'a :> 'a -> 'b
//│        <: 'b
//│     'b := 'a -> 'b
//│    = [Function: id11]
id1 id
//│ res: ('a & 'b) -> 'b | 'c
//│   where
//│     'a :> ('a & 'b) -> 'b
//│        <: 'b
//│     'b :> ('a & 'b) -> 'b
//│        <: 'a -> 'b & 'c
//│    = [Function: id]
id1 id1
//│ res: ('a & 'b) -> 'a
//│   where
//│     'a :> forall 'c 'd. ('a & 'b & 'c) -> ('a | 'd)
//│        <: ((forall 'c 'd. 'c -> 'd) | 'b) -> 'a
//│     'c :> 'c -> 'd
//│        <: 'd
//│     'd := 'c -> 'd
//│    = [Function: id11]
// * Note that it can't be applied when typed with :precise-rec-typing AND :DontDistributeForalls
:DontDistributeForalls
:precise-rec-typing
rec def id1_p x = if true then x else id1_p id1_p x
//│ id1_p: 'a -> 'b
//│   where
//│     'a <: 'b & 'c
//│     'b :> 'd
//│     'd :> forall 'a 'b. 'a -> 'b
//│        <: 'c -> 'd
//│     'c :> forall 'a 'b. 'a -> 'b
//│        <: 'd
//│      = [Function: id1_p]
// * Can't apply it:
:e
id1_p id
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.319: 	id1_p id
//│ ║         	^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ res: error | ('a & 'b) -> 'a | 'c
//│   where
//│     'a :> 'd
//│     'd :> forall 'a 'b. ('a & 'b) -> 'a
//│        <: 'e -> 'd & 'c
//│     'b <: 'a & 'e
//│     'e :> forall 'a 'b. ('a & 'b) -> 'a
//│        <: 'd
//│    = [Function: id]
:DistributeForalls
:NoRecursiveTypes

// * TODO type pp – inline id1?
:e
id1
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a :> 'a -> 'b
//│        <: 'b
//│     'b := 'a -> 'b
//│ ╙──
//│ res: 'a -> 'b
//│   where
//│     'a :> 'a -> 'b
//│        <: 'b
//│     'b := 'a -> 'b
//│    = [Function: id11]

:e
id1: nothing
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a := 'b -> 'a
//│     'b :> 'b -> 'a
//│        <: 'a
//│ ║  l.280: 	rec def id1 x = if true then x else id1 id1 x
//│ ╙──       	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.353: 	id1: nothing
//│ ║         	^^^
//│ ╟── function of type `?a -> ?b` does not match type `nothing`
//│ ║  l.280: 	rec def id1 x = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.353: 	id1: nothing
//│ ║         	^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.353: 	id1: nothing
//│ ╙──       	     ^^^^^^^
//│ res: nothing
//│    = [Function: id11]

:e
rec def id1_ x = id1_ id1_ x
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: ('b -> 'c | 'b) -> 'c
//│     'c <: 'a
//│ ║  l.377: 	rec def id1_ x = id1_ id1_ x
//│ ╙──       	                 ^^^^^^^^^
//│ id1_: anything -> nothing
//│     = [Function: id1_]

:e // * Incorrect annotation
rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ╔══[ERROR] Inferred recursive type: 'b
//│   where
//│     'b <: (forall 'a. 'a -> 'a) -> (??a & 'b)
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ╙──       	                                                           ^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not a function
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	                           ^^
//│ ╟── but it flows into quantified type variable with expected type `'a0 -> 'a0`
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	                       ^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ╙──       	                           ^^^^^^^^
//│ ╔══[ERROR] Type error in binding of lambda expression
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'a` leaks out of its scope
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	                           ^^^^^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this application:
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ╙──       	                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing binding of lambda expression; a type annotation may be required
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Type error in binding of lambda expression
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `'a` leaks out of its scope
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	                           ^^^^^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this application:
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ║         	                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.388: 	rec def id1 (x: forall 'a. 'a -> 'a) = if true then x else id1 id1 x
//│ ╙──       	                                                           ^^^^^^^^^
//│ id1: (forall 'a. 'a -> 'a) -> 'a0 -> 'a0
//│    = [Function: id12]

// * === / ===



// let rec (id:sid) x = if true then x else id id x

def id2: Sid
//│ id2: Sid
//│    = <missing implementation>

// * (Note: absence of `rec` emulates annotated rec def.)
def id2 x = if true then x else id2 id2 x
//│ 'a -> 'a
//│   <:  id2:
//│ Sid
//│    = <no result>
//│      id2 is not implemented




// (* Existential types. *)
// (* Creating an encapsulation is explicit (unavoidable). *)
// (* Here, we build (Exist 'a . 'a * ('a -> unit))              *)
// (*        then    (Exist 'a . 'a * 'a * ('a -> 'a -> bool))   *)


// let make_ex1 x (f:['a] ('a * ('a -> 'c)) -> 'b) = f x
def make_ex1 x (f: forall 'a. (('a, 'a -> 'c),) -> 'b) = f x
//│ make_ex1: (('a, 'a -> 'c,),) -> (forall 'a0. (('a0, 'a0 -> 'c,),) -> 'b) -> 'b
//│         = [Function: make_ex1]

ex1_1 = make_ex1 (("A String", print_string))
//│ ex1_1: (forall 'a. (('a, 'a -> unit,),) -> 'b) -> 'b
//│      = [Function (anonymous)]

ex1_1 (fun ((x, f)) -> f x)
//│ = undefined
//│ // Output
//│ A String

ex1_2 = if true then make_ex1 ((42, print_int)) else ex1_1
//│ ex1_2: (forall 'a 'a0. (('a, 'a -> unit,),) -> 'b & (('a0, 'a0 -> unit,),) -> 'b) -> 'b
//│      = [Function (anonymous)]

ex1_2 (fun ((x, f)) -> f x)
//│ = undefined
//│ // Output
//│ 42


// let make_ex2 x (f:['a] ('a * 'a * ('a -> 'a -> 'c)) -> 'b) = f x
// ;;
def make_ex2 x (f: forall 'a. (('a, 'a, 'a -> 'a -> 'c),) -> 'b) = f x
//│ make_ex2: (('a, 'a, 'a -> 'a -> 'c,),) -> (forall 'a0. (('a0, 'a0, 'a0 -> 'a0 -> 'c,),) -> 'b) -> 'b
//│         = [Function: make_ex2]

// let ex_list1 = [ make_ex1 ("A String", print_string) ; 
// 		 make_ex1 (8250, print_int) ;
// 		 make_ex1 (true, print_bool) ]
// ;;
ex_list1 = cons (make_ex1 (("A String", print_string)))
  (cons (make_ex1 ((8250, print_int)))
  (cons (make_ex1 ((true, print_bool))) nil))
//│ ex_list1: List[forall 'b. (forall 'a 'a0 'a1. (('a, 'a -> unit,),) -> 'b & (('a0, 'a0 -> unit,),) -> 'b & (('a1, 'a1 -> unit,),) -> 'b) -> 'b]
//│         = Cons {
//│             head: [Function (anonymous)],
//│             tail: Cons {
//│               head: [Function (anonymous)],
//│               tail: Cons { head: [Function (anonymous)], tail: Nil {} }
//│             }
//│           }

// let ex_list2 = [ make_ex2 ("String", "String", eqstring) ;
// 		 make_ex2 ( 1250, 4890, eqint) ;
// 		 make_ex2 ( true, false, eqbool) ]
// ;;
ex_list2 = cons (make_ex2 (("String", "String", eqstring)))
  (cons (make_ex2 ((1250, 4890, eqint)))
  (cons (make_ex2 ((true, false, eqbool))) nil))
//│ ex_list2: List[forall 'b. (forall 'a 'a0 'a1. (('a, 'a, 'a -> 'a -> bool,),) -> 'b & (('a0, 'a0, 'a0 -> 'a0 -> (bool | false),),) -> 'b & (('a1, 'a1, 'a1 -> 'a1 -> bool,),) -> 'b) -> 'b]
//│         = Cons {
//│             head: [Function (anonymous)],
//│             tail: Cons {
//│               head: [Function (anonymous)],
//│               tail: Cons { head: [Function (anonymous)], tail: Nil {} }
//│             }
//│           }


h = head ex_list1
//│ h: (forall 'a 'a0 'a1. (('a, 'a -> unit,),) -> 'b & (('a0, 'a0 -> unit,),) -> 'b & (('a1, 'a1 -> unit,),) -> 'b) -> 'b
//│  = [Function (anonymous)]

h (fun ((x, f)) -> f x)
//│ = undefined
//│ // Output
//│ A String

// * _n accessors not yet implemented in JS backend:
// test1 = listiterA (fun ex -> ex (fun p -> p._2 p._1)) ex_list1

test1 = listiterA (fun ex -> ex (fun ((p1, p2)) -> p2 p1)) ex_list1
//│ test1: unit
//│      = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true

// let test1 = listiter (fun ex -> ex (fun p -> (snd p) (fst p))) ex_list1
// ;;
test1 = listiter (fun ex -> ex (fun ((p1, p2)) -> p2 p1)) ex_list1
//│ test1: unit
//│      = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true

test1_ = listiter (fun ex -> ex (fun ((p1, p2)) -> p2 p1))
//│ test1_: List[(forall 'a 'b. (('a, 'a -> 'b,),) -> 'b) -> anything] -> unit
//│       = [Function (anonymous)]

test1_ ex_list1
//│ = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true

process ex = ex (fun ((p1, p2)) -> p2 p1)
//│ process: ((forall 'a 'b. (('a, 'a -> 'b,),) -> 'b) -> 'c) -> 'c
//│        = [Function: process]

process h
//│ = undefined
//│ // Output
//│ A String

listiter process ex_list1
//│ = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true


// let test2 = listiter (fun ex -> ex (fun t -> 
//   let arg1 = fst t
//   and arg2 = fst (snd t)
//   and eqf  = snd (snd t) in
//   let areequal = eqf arg1 arg2
//   in print_bool areequal )) ex_list2
// ;;
test2 = listiterA (fun ex -> ex (fun ((t1, t2, t3)) ->
  let arg1 = t1 in
  let arg2 = t2 in
  let eqf = t3 in
  let areequal = eqf arg1 arg2 in
  print_bool areequal )) ex_list2
//│ test2: unit
//│      = [Function: unit]
//│ // Output
//│ true
//│ false
//│ false

test2_ = listiter (fun ex -> ex (fun ((t1, t2, t3)) ->
  let arg1 = t1 in
  let arg2 = t2 in
  let eqf = t3 in
  let areequal = eqf arg1 arg2 in
  print_bool areequal ))
//│ test2_: List[(forall 'a 'b. (('a, 'b, 'a -> 'b -> bool,),) -> unit) -> anything] -> unit
//│       = [Function (anonymous)]

test2_ ex_list2
//│ = [Function: unit]
//│ // Output
//│ true
//│ false
//│ false



// * ============ Annotated+untupled versions: ============

def make_ex1: ('x, 'x -> 'c) -> (forall 'b. (forall 'a. ('a, 'a -> 'c) -> 'b) -> 'b)
//│ make_ex1: ('x, 'x -> 'c,) -> (forall 'a. ('a, 'a -> 'c,) -> 'b) -> 'b
//│         = <missing implementation>

make_ex1 (x, f) k = k (x, f)
//│ ('a, 'b,) -> (('a, 'b,) -> 'c) -> 'c
//│   <:  make_ex1:
//│ ('x, 'x -> 'c,) -> (forall 'a. ('a, 'a -> 'c,) -> 'b) -> 'b
//│         = [Function: make_ex11]

ex1_1 = make_ex1 ("A String", print_string)
//│ ex1_1: (forall 'a. ('a, 'a -> unit,) -> 'b) -> 'b
//│      = [Function (anonymous)]

ex1_1 (fun (x, f) -> f x)
//│ = undefined
//│ // Output
//│ A String

ex1_2 = if true then make_ex1 (42, print_int) else ex1_1
//│ ex1_2: (forall 'a 'a0. ('a, 'a -> unit,) -> 'b & ('a0, 'a0 -> unit,) -> 'b) -> 'b
//│      = [Function (anonymous)]

ex1_2 (fun (x, f) -> f x)
//│ = undefined
//│ // Output
//│ 42


// let make_ex2 x (f:['a] ('a * 'a * ('a -> 'a -> 'c)) -> 'b) = f x
// ;;
def make_ex2: ('x, 'x, 'x -> 'c) -> (forall 'b. (forall 'a. ('a, 'a, 'a -> 'c) -> 'b) -> 'b)
//│ make_ex2: ('x, 'x, 'x -> 'c,) -> (forall 'a. ('a, 'a, 'a -> 'c,) -> 'b) -> 'b
//│         = <missing implementation>

make_ex2 (x, y, f) k = k (x, y, f)
//│ ('a, 'b, 'c,) -> (('a, 'b, 'c,) -> 'd) -> 'd
//│   <:  make_ex2:
//│ ('x, 'x, 'x -> 'c,) -> (forall 'a. ('a, 'a, 'a -> 'c,) -> 'b) -> 'b
//│         = [Function: make_ex21]

// let ex_list1 = [ make_ex1 ("A String", print_string) ; 
// 		 make_ex1 (8250, print_int) ;
// 		 make_ex1 (true, print_bool) ]
// ;;
//
ex_list1 = cons (make_ex1 ("A String", print_string))
  (cons (make_ex1 (8250, print_int))
  (cons (make_ex1 (true, print_bool)) nil))
//│ ex_list1: List[forall 'b. (forall 'a 'a0 'a1. ('a, 'a -> unit,) -> 'b & ('a0, 'a0 -> unit,) -> 'b & ('a1, 'a1 -> unit,) -> 'b) -> 'b]
//│         = Cons {
//│             head: [Function (anonymous)],
//│             tail: Cons {
//│               head: [Function (anonymous)],
//│               tail: Cons { head: [Function (anonymous)], tail: Nil {} }
//│             }
//│           }

// let ex_list2 = [ make_ex2 ("String", "String", eqstring) ;
// 		 make_ex2 ( 1250, 4890, eqint) ;
// 		 make_ex2 ( true, false, eqbool) ]
// ;;
ex_list2 = cons (make_ex2 ("String", "String", eqstring))
  (cons (make_ex2 (1250, 4890, eqint))
  (cons (make_ex2 (true, false, eqbool)) nil))
//│ ex_list2: List[forall 'b. (forall 'a 'a0 'a1. ('a, 'a, 'a -> string -> bool,) -> 'b & ('a0, 'a0, 'a0 -> bool -> bool,) -> 'b & ('a1, 'a1, 'a1 -> int -> bool,) -> 'b) -> 'b]
//│         = Cons {
//│             head: [Function (anonymous)],
//│             tail: Cons {
//│               head: [Function (anonymous)],
//│               tail: Cons { head: [Function (anonymous)], tail: Nil {} }
//│             }
//│           }

// let test1 = listiter (fun ex -> ex (fun p -> (snd p) (fst p))) ex_list1
// ;;

test1 = listiterA (fun ex -> ex (fun (a, b) -> b a)) ex_list1
//│ test1: unit
//│      = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true

test1_ = listiterA (fun ex -> ex (fun (a, b) -> b a))
//│ test1_: List[(forall 'a 'b. ('a, 'a -> 'b,) -> 'b) -> unit] -> unit
//│       = [Function (anonymous)]

test1_ ex_list1
//│ = [Function: unit]
//│ // Output
//│ A String
//│ 8250
//│ true




// (* Some examples for MLF inspired by standard encoding in System F. *)

// type Void   = ['x] 'x
// type Unit   = ['x] 'x -> 'x
// type Int    = ['x] ('x -> 'x) -> ('x -> 'x)
// type Bool   = ['x] (Unit -> 'x) -> (Unit -> 'x) -> 'x 
type Fvoid = forall 'a. 'a
type Funit = forall 'a. 'a -> 'a
type Fint  = forall 'a. ('a -> 'a) -> ('a -> 'a)
type Fbool = forall 'a. (Funit -> 'a) -> (Funit -> 'a) -> 'a
//│ Defined type alias Fvoid
//│ Defined type alias Funit
//│ Defined type alias Fint
//│ Defined type alias Fbool

// type Sum    = ['x] (Int -> 'x) -> (Int -> 'x) -> 'x
// type Pair   = ['x] (Int -> Int -> 'x) -> 'x
// type Triple = ['x] (Int -> Int -> Int -> 'x) -> 'x
type Sum    = forall 'a. (Fint -> 'a) -> (Fint -> 'a) -> 'a
type Pair   = forall 'a. (Fint -> Fint -> 'a) -> 'a
type Triple = forall 'a. (Fint -> Fint -> Fint -> 'a) -> 'a
//│ Defined type alias Sum
//│ Defined type alias Pair
//│ Defined type alias Triple

// (* Unit *)
// let c_unit = fun x -> x
def c_unit = fun x -> x
//│ c_unit: 'a -> 'a
//│       = [Function: c_unit]


// (* BOOLEANS, IFS, AND, OR, NOT. *)
// let c_true  = fun a b -> a c_unit
def c_true = fun a -> fun b -> a c_unit
//│ c_true: ((forall 'a. 'a -> 'a) -> 'b) -> anything -> 'b
//│       = [Function: c_true]

// let c_false = fun a b -> b c_unit
def c_false = fun a -> fun b -> b c_unit
//│ c_false: anything -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│        = [Function: c_false]

// let c_if (cond:Bool) c_then c_else = cond c_then c_else 
def c_if (cond: Fbool) c_then c_else = cond c_then c_else
def c_if_ cond c_then c_else = cond c_then c_else
//│ c_if: Fbool -> (Funit -> 'a) -> (Funit -> 'a) -> 'a
//│     = [Function: c_if]
//│ c_if_: ('a -> 'b -> 'c) -> 'a -> 'b -> 'c
//│      = [Function: c_if_]

// let c_and (a:Bool) (b:Bool) = c_if a (fun z -> b) (fun z -> c_false)
def c_and (a: Fbool) (b: Fbool) = c_if a (fun z -> b) (fun z -> c_false)
def c_and_ a b = c_if a (fun z -> b) (fun z -> c_false)
//│ c_and: Fbool -> Fbool -> (anything -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b | Fbool)
//│      = [Function: c_and]
//│ c_and_: Fbool -> 'a -> (anything -> ((forall 'b. 'b -> 'b) -> 'c) -> 'c | 'a)
//│       = [Function: c_and_]

// let c_or  (a:Bool) (b:Bool) = c_if a (fun z -> c_true) (fun z -> b)
def c_or (a: Fbool) (b: Fbool) = c_if a (fun z -> c_true) (fun z -> b)
def c_or_ a b = c_if a (fun z -> c_true) (fun z -> b)
//│ c_or: Fbool -> Fbool -> (((forall 'a. 'a -> 'a) -> 'b) -> anything -> 'b | Fbool)
//│     = [Function: c_or]
//│ c_or_: Fbool -> 'a -> (((forall 'b. 'b -> 'b) -> 'c) -> anything -> 'c | 'a)
//│      = [Function: c_or_]

// let c_not (a:Bool) = c_if a (fun z -> c_false) (fun z -> c_true)
def c_not (a: Fbool) = c_if a (fun z -> c_false) (fun z -> c_true)
def c_not_ a = c_if a (fun z -> c_false) (fun z -> c_true)
//│ c_not: Fbool -> ((forall 'a. 'a -> 'a) -> 'b) -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│      = [Function: c_not]
//│ c_not_: Fbool -> ((forall 'a. 'a -> 'a) -> 'b) -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│       = [Function: c_not_]

// let c_or = (c_or : Bool -> Bool -> Bool)

def c_or2 = c_or : Fbool -> Fbool -> Fbool
//│ c_or2: Fbool -> Fbool -> Fbool
//│      = [Function: c_or2]

def c_or2_ = c_or_ : Fbool -> Fbool -> Fbool
//│ c_or2_: Fbool -> Fbool -> Fbool
//│       = [Function: c_or2_]


// (* CONSTRUCTORS FOR PAIRS ET TRIPLES. *)
// let c_pair x y   = fun f -> f x y
def c_pair x y = fun f -> f x y
//│ c_pair: 'a -> 'b -> ('a -> 'b -> 'c) -> 'c
//│       = [Function: c_pair]

// let c_trip x y z = fun f -> f x y z
def c_trip x y z = fun f -> f x y z
//│ c_trip: 'a -> 'b -> 'c -> ('a -> 'b -> 'c -> 'd) -> 'd
//│       = [Function: c_trip]


// (* PROJECTIONS FOR PRODUCTS. *)
// let c_1_2 (p:Pair) = p (fun x y -> x) 
def c_1_2 (p: Pair) = p (fun x -> fun y -> x)
def c_1_2_ p = p (fun x -> fun y -> x)
//│ c_1_2: Pair -> Fint
//│      = [Function: c_1_2]
//│ c_1_2_: ((forall 'a. 'a -> anything -> 'a) -> 'b) -> 'b
//│       = [Function: c_1_2_]

// let c_2_2 (p:Pair) = p (fun x y -> y) 
def c_2_2 (p: Pair) = p (fun x -> fun y -> y)
def c_2_2_ p = p (fun x -> fun y -> y)
//│ c_2_2: Pair -> Fint
//│      = [Function: c_2_2]
//│ c_2_2_: ((forall 'a. anything -> 'a -> 'a) -> 'b) -> 'b
//│       = [Function: c_2_2_]

// let c_1_3 (t:Triple) = t (fun x y z -> x)
def c_1_3 (t: Triple) = t (fun x -> fun y -> fun z -> x)
def c_1_3_ t = t (fun x -> fun y -> fun z -> x)
//│ c_1_3: Triple -> Fint
//│      = [Function: c_1_3]
//│ c_1_3_: ((forall 'a. 'a -> anything -> anything -> 'a) -> 'b) -> 'b
//│       = [Function: c_1_3_]

// let c_2_3 (t:Triple) = t (fun x y z -> y) 
def c_2_3 (t: Triple) = t (fun x -> fun y -> fun z -> y)
def c_2_3_ t = t (fun x -> fun y -> fun z -> y)
//│ c_2_3: Triple -> Fint
//│      = [Function: c_2_3]
//│ c_2_3_: ((forall 'a. anything -> 'a -> anything -> 'a) -> 'b) -> 'b
//│       = [Function: c_2_3_]

// let c_3_3 (t:Triple) = t (fun x y z -> z) 
def c_3_3 (t: Triple) = t (fun x -> fun y -> fun z -> z)
def c_3_3_ t = t (fun x -> fun y -> fun z -> z)
//│ c_3_3: Triple -> Fint
//│      = [Function: c_3_3]
//│ c_3_3_: ((forall 'a. anything -> anything -> 'a -> 'a) -> 'b) -> 'b
//│       = [Function: c_3_3_]


// (* CONSTRUCTOR FOR A BINARY SUM. *)
// let c_sumg = fun x fg fd -> fg x
def c_sumg = fun x -> fun fg -> fun fd -> fg x
//│ c_sumg: 'a -> ('a -> 'b) -> anything -> 'b
//│       = [Function: c_sumg]

// let c_sumd = fun x fg fd -> fd x
def c_sumd = fun x -> fun fg -> fun fd -> fd x
//│ c_sumd: 'a -> anything -> ('a -> 'b) -> 'b
//│       = [Function: c_sumd]


// (* CASE FOR A SUM. *)
// let c_case (s:Sum) g d = s g d
def c_case (s: Sum) g d = s g d
def c_case_ s g d = s g d
//│ c_case: Sum -> (Fint -> 'a) -> (Fint -> 'a) -> 'a
//│       = [Function: c_case]
//│ c_case_: ('a -> 'b -> 'c) -> 'a -> 'b -> 'c
//│        = [Function: c_case_]


// (* Integers. *)
// let c_i0 = fun f x ->   x
def c_i0 = fun f -> fun x -> x
//│ c_i0: anything -> 'a -> 'a
//│     = [Function: c_i0]

// let c_i1 = fun f x -> f x
def c_i1 = fun f -> fun x -> f x
//│ c_i1: ('a -> 'b) -> 'a -> 'b
//│     = [Function: c_i1]

// let c_i2 = fun f x -> f (f x)
def c_i2 = fun f -> fun x -> f (f x)
//│ c_i2: ('a -> 'b & 'b -> 'c) -> 'a -> 'c
//│     = [Function: c_i2]

// let c_succ (n:Int) = fun f x -> n f (f x)
def c_succ (n: Fint) = fun f -> fun x -> n f (f x)
def c_succ_ n = fun f -> fun x -> n f (f x)
//│ c_succ: Fint -> (('a | 'b) -> 'a) -> 'b -> 'a
//│       = [Function: c_succ]
//│ c_succ_: ('a -> 'b -> 'c) -> ('d -> 'b & 'a) -> 'd -> 'c
//│        = [Function: c_succ_]

// let c_iszero (n:Int) = n (fun x -> c_false) c_true
def c_iszero (n: Fint) = n (fun x -> c_false) c_true
def c_iszero_ n = n (fun x -> c_false) c_true
//│ c_iszero: Fint -> ((forall 'a. 'a -> 'a) -> 'b) -> ((forall 'a. 'a -> 'a) -> 'b) -> 'b
//│         = [Function: c_iszero]
//│ c_iszero_: ((forall 'a. anything -> anything -> ((forall 'b. 'b -> 'b) -> 'a) -> 'a) -> (forall 'c. ((forall 'b. 'b -> 'b) -> 'c) -> anything -> 'c) -> 'd) -> 'd
//│          = [Function: c_iszero_]

// let c_add n (m:Int) = m c_succ n

def c_add n (m: Fint) = m c_succ n
//│ c_add: (Fint & 'b) -> Fint -> ((('a | 'c) -> 'a) -> 'c -> 'a | 'b)
//│      = [Function: c_add]

def c_add_ n m = m c_succ_ n
//│ c_add_: 'a -> ((forall 'b 'c 'd 'e. ('b -> 'c -> 'd) -> ('e -> 'c & 'b) -> 'e -> 'd) -> 'a -> 'f) -> 'f
//│       = [Function: c_add_]

// let c_mul n (m:Int) = m (c_add n) c_i0

def c_mul m (n: Fint) = m (c_add n) c_i0
//│ c_mul: ((Fint -> (forall 'a 'b. (('a | 'b) -> 'a) -> 'b -> 'a | Fint)) -> (forall 'c. anything -> 'c -> 'c) -> 'd) -> Fint -> 'd
//│      = [Function: c_mul]

def c_mul_ m n = m (c_add_ n) c_i0
//│ c_mul_: ((forall 'a. ((forall 'b 'c 'd 'e. ('b -> 'c -> 'd) -> ('e -> 'c & 'b) -> 'e -> 'd) -> 'f -> 'a) -> 'a) -> (forall 'g. anything -> 'g -> 'g) -> 'h) -> 'f -> 'h
//│       = [Function: c_mul_]

// let c_pow n (m:Int) = m (c_mul n) c_i1

def c_pow m (n: Fint) = m (c_mul n) c_i1
//│ c_pow: ((Fint -> (forall 'a 'b. (('a | 'b) -> 'a) -> 'b -> ('b | 'a) | Fint)) -> (forall 'c 'd. ('c -> 'd) -> 'c -> 'd) -> 'e) -> Fint -> 'e
//│      = [Function: c_pow]

def c_pow_ m n = m (c_mul_ n) c_i1
//│ c_pow_: (('a -> 'b) -> (forall 'c 'd. ('c -> 'd) -> 'c -> 'd) -> 'e) -> ((forall 'f. ((forall 'g 'h 'i 'j. ('g -> 'h -> 'i) -> ('j -> 'h & 'g) -> 'j -> 'i) -> 'a -> 'f) -> 'f) -> (forall 'k. anything -> 'k -> 'k) -> 'b) -> 'e
//│       = [Function: c_pow_]


// let c_pred (n:Int) =
//    let s p = c_pair (c_2_2 p) (c_succ (c_2_2 p))
//   and z = c_pair c_i0 c_i0 in
//   c_1_2 (n s z)

def c_pred (n: Fint) =
  let s = fun p -> c_pair (c_2_2 p) (c_succ (c_2_2 p)) in
  let z = c_pair c_i0 c_i0 in
  c_1_2 (n s z)
//│ c_pred: Fint -> Fint
//│       = [Function: c_pred]

def c_pred_ n =
  let s = fun p -> c_pair (c_2_2_ p) (c_succ_ (c_2_2_ p)) in
  let z = c_pair c_i0 c_i0 in
  c_1_2_ (n s z)
//│ c_pred_: ((forall 'a 'b 'c 'd 'e 'f. ((forall 'g. anything -> 'g -> 'g) -> ('a -> 'b -> 'c & 'd)) -> ('d -> (('e -> 'b & 'a) -> 'e -> 'c) -> 'f) -> 'f) -> (forall 'h. ((forall 'i. anything -> 'i -> 'i) -> (forall 'i. anything -> 'i -> 'i) -> 'h) -> 'h) -> (forall 'j. 'j -> anything -> 'j) -> 'k) -> 'k
//│        = [Function: c_pred_]


// let c_printint (n:Int) = print_int (n (fun x -> x+1) 0); print " "
def c_printint (n: Fint) =
  let _ = print_int (n (fun x -> x + 1) 0) in
  print_string " "
def c_printint_ n =
  let _ = print_int (n (fun x -> x + 1) 0) in
  print_string " "
//│ c_printint: Fint -> unit
//│           = [Function: c_printint]
//│ c_printint_: ((int -> int) -> 0 -> int) -> unit
//│            = [Function: c_printint_]

def c_printint2 (n: Fint) = toString (n (fun x -> x + 1) 0)
def c_printint2_ n = toString (n (fun x -> x + 1) 0)
//│ c_printint2: Fint -> string
//│            = [Function: c_printint2]
//│ c_printint2_: ((int -> int) -> 0 -> anything) -> string
//│             = [Function: c_printint2_]

// let c_i2 = c_succ c_i1
def c_i2 = c_succ c_i1
def c_i2_ = c_succ_ c_i1
//│ c_i2: (('a | 'b) -> 'a) -> 'b -> 'a
//│     = [Function: c_i21]
//│ c_i2_: ('a -> 'b & 'b -> 'c) -> 'a -> 'c
//│      = [Function: c_i2_]

// let c_i3 = c_succ c_i2
def c_i3 = c_succ c_i2
def c_i3_ = c_succ_ c_i2
//│ c_i3: (('a | 'b) -> 'a) -> 'b -> 'a
//│     = [Function: c_i3]
//│ c_i3_: ('b -> 'c & ('a | 'c) -> 'a) -> 'b -> 'a
//│      = [Function: c_i3_]

// let c_i4 = c_succ c_i3
def c_i4 = c_succ c_i3
def c_i4_ = c_succ_ c_i3
//│ c_i4: (('a | 'b) -> 'a) -> 'b -> 'a
//│     = [Function: c_i4]
//│ c_i4_: ('b -> 'c & ('a | 'c) -> 'a) -> 'b -> 'a
//│      = [Function: c_i4_]



// (* Fails with value restriction. *)
// (* Passes with relaxed value restriction. *)
// let rec (to_church:int -> Int) n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)

def to_church: int -> Fint
//│ to_church: int -> Fint
//│          = <missing implementation>

// * See to_church_3 in `ex_casparticuliers.mls`
rec def to_church n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church (n - 1) : Fint) f x)
//│ int -> ('a -> ('a & 'b)) -> ('a & 'b) -> 'b
//│   <:  to_church:
//│ int -> Fint
//│          = [Function: to_church]


// let rec to_church n =
//   if n = 0 then fun f x -> x
//   else fun f x -> f ((to_church (n-1)) f x)

rec def to_church_ n =
  if n == 0 then fun f -> fun x -> x
  else fun f -> fun x -> f ((to_church_ (n - 1)) f x)
//│ to_church_: int -> ('a -> 'b & 'a -> 'a) -> ('a & 'b) -> 'b
//│           = [Function: to_church_]


// let rec c_fact (n:Int) =
//   c_if (c_iszero n) (fun (u:Unit) -> c_i1)
//     (fun (u:Unit) -> c_mul n (c_fact (c_pred n)))

rec def c_fact (n: Fint) =
  c_if (c_iszero n) (fun (u: Funit) -> c_i1)
    (fun (u: Funit) -> c_mul n (c_fact (c_pred n)))
//│ c_fact: Fint -> ((('a | 'b) -> 'a & 'b -> 'c) -> 'b -> ('a | 'b | 'c) | Fint)
//│       = [Function: c_fact]

// def c_fact: Fint -> (forall 'a 'b. ('a & 'b) -> (forall 'c 'd 'e 'f 'g 'h. (('c & 'h) -> ('d | 'g | 'c))))
def c_fact_A: Fint -> Fint
//│ c_fact_A: Fint -> Fint
//│         = <missing implementation>

def c_fact_A n =
  c_if (c_iszero n) (fun u -> c_i1)
    (fun u -> c_mul n (c_fact_A (c_pred n)))
//│ (Fint & (Fint -> (forall 'a 'b. (('a | 'b) -> 'a) -> 'b -> 'a | Fint)) -> (forall 'c. anything -> 'c -> 'c) -> 'd) -> (('e -> 'f) -> 'e -> 'f | 'd)
//│   <:  c_fact_A:
//│ Fint -> Fint
//│         = <no result>
//│           c_fact_A is not implemented

// * This one MLF probably can't type
// * TODO: better type simplif...?
:e
rec def c_fact_ n =
  c_if_ (c_iszero_ n) (fun _ -> c_i1)
    (fun _ -> c_mul_ n (c_fact_ (c_pred_ n)))
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: (forall 'b. ((forall 'c. ? -> 'c -> 'c) -> (forall 'c. ? -> 'c -> 'c) -> 'b) -> 'b) -> (forall 'd. 'd -> ? -> 'd) -> ((forall 'e. ? -> ? -> ((forall 'f. 'f -> 'f) -> 'e) -> 'e) -> (forall 'g. ((forall 'f. 'f -> 'f) -> 'g) -> ? -> 'g) -> (forall 'h 'i. ? -> ('h -> 'i) -> 'h -> 'i) -> (? -> 'j) -> 'k & (forall 'l. ((forall 'm 'n 'o 'p. ('m -> 'n -> 'o) -> ('p -> 'n & 'm) -> 'p -> 'o) -> 'k -> 'l) -> 'l) -> (forall 'c. ? -> 'c -> 'c) -> 'j & (forall 'q 'r 's 't 'u 'v. ((forall 'w. ? -> 'w -> 'w) -> ('q -> 'r -> 's & 't)) -> ('t -> (('u -> 'r & 'q) -> 'u -> 's) -> 'v) -> 'v) -> 'a)
//│ ║  l.963: 	  c_1_2_ (n s z)
//│ ╙──       	          ^^^
//│ c_fact_: 'a -> 'b
//│   where
//│     'a <: (forall 'c. anything -> anything -> ((forall 'd. 'd -> 'd) -> 'c) -> 'c) -> (forall 'e. ((forall 'd. 'd -> 'd) -> 'e) -> anything -> 'e) -> (forall 'f 'g. anything -> ('f -> 'g) -> 'f -> 'g) -> (anything -> 'h) -> 'b & (forall 'i. ((forall 'j 'k 'l 'm. ('j -> 'k -> 'l) -> ('m -> 'k & 'j) -> 'm -> 'l) -> 'b -> 'i) -> 'i) -> (forall 'n. anything -> 'n -> 'n) -> 'h & (forall 'o 'p 'q 'r 's 't. ((forall 'u. anything -> 'u -> 'u) -> ('o -> 'p -> 'q & 'r)) -> ('r -> (('s -> 'p & 'o) -> 's -> 'q) -> 't) -> 't) -> (forall 'v. ((forall 'n. anything -> 'n -> 'n) -> (forall 'n. anything -> 'n -> 'n) -> 'v) -> 'v) -> (forall 'w. 'w -> anything -> 'w) -> 'a
//│        = [Function: c_fact_]

:e // * The type we infer without any annotations can't be checked against the desired signature
c_fact_A = c_fact_
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: (forall 'b. ((forall 'c. ? -> 'c -> 'c) -> (forall 'c. ? -> 'c -> 'c) -> 'b) -> 'b) -> (forall 'd. 'd -> ? -> 'd) -> ((forall 'e. ? -> ? -> ((forall 'f. 'f -> 'f) -> 'e) -> 'e) -> (forall 'g. ((forall 'f. 'f -> 'f) -> 'g) -> ? -> 'g) -> (forall 'h 'i. ? -> ('h -> 'i) -> 'h -> 'i) -> (forall 'j. ? -> (? -> 'j -> 'j | 'k)) -> 'l & (forall 'm. ((forall 'n 'o 'p 'q. ('n -> 'o -> 'p) -> ('q -> 'o & 'n) -> 'q -> 'p) -> (forall 'r 's. ('r -> 's) -> 'r -> 's | 'l) -> 'm) -> 'm) -> (forall 'c. ? -> 'c -> 'c) -> 'k & (forall 't 'u 'v 'w 'x 'y. ((forall 'z. ? -> 'z -> 'z) -> ('t -> 'u -> 'v & 'w)) -> ('w -> (('x -> 'u & 't) -> 'x -> 'v) -> 'y) -> 'y) -> 'a)
//│ ║  l.963: 	  c_1_2_ (n s z)
//│ ╙──       	          ^^^
//│ 'a -> 'b
//│   where
//│     'a <: (forall 'c. anything -> anything -> ((forall 'd. 'd -> 'd) -> 'c) -> 'c) -> (forall 'e. ((forall 'd. 'd -> 'd) -> 'e) -> anything -> 'e) -> (forall 'f 'g. anything -> ('f -> 'g) -> 'f -> 'g) -> (anything -> 'h) -> 'b & (forall 'i. ((forall 'j 'k 'l 'm. ('j -> 'k -> 'l) -> ('m -> 'k & 'j) -> 'm -> 'l) -> 'b -> 'i) -> 'i) -> (forall 'n. anything -> 'n -> 'n) -> 'h & (forall 'o 'p 'q 'r 's 't. ((forall 'u. anything -> 'u -> 'u) -> ('o -> 'p -> 'q & 'r)) -> ('r -> (('s -> 'p & 'o) -> 's -> 'q) -> 't) -> 't) -> (forall 'v. ((forall 'n. anything -> 'n -> 'n) -> (forall 'n. anything -> 'n -> 'n) -> 'v) -> 'v) -> (forall 'w. 'w -> anything -> 'w) -> 'a
//│   <:  c_fact_A:
//│ Fint -> Fint
//│ ╔══[ERROR] Cyclic-looking constraint while typing def definition; a type annotation may be required
//│ ║  l.1085: 	c_fact_A = c_fact_
//│ ║          	^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│         = [Function: c_fact_]


// let print_fact n =
//   print_string "Factorial " ;
//   print_int n ;
//   print_string " = " ;
//   c_printint (c_fact (to_church n)) ;
//   print_string "\n" ;
//   ()
def print_fact n =
  let _ = print_string "Factorial " in
  let _ = print_int n in
  let _ = print_string " = " in
  let _ = c_printint (c_fact (to_church n)) in
          print_string "\n"
//│ print_fact: int -> unit
//│           = [Function: print_fact]

:e // * We get a cycle error because recursive `c_fact_` has NO annotations whatsoever
def print_fact_ n =
  let _ = print_string "Factorial " in
  let _ = print_int n in
  let _ = print_string " = " in
  let _ = c_printint_ (c_fact_ (to_church_ n)) in
          print_string "\n"
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: (forall 'b. ((forall 'c. ? -> 'c -> 'c) -> (forall 'c. ? -> 'c -> 'c) -> 'b) -> 'b) -> (forall 'd. 'd -> ? -> 'd) -> ((forall 'e. ? -> ? -> ((forall 'f. 'f -> 'f) -> 'e) -> 'e) -> (forall 'g. ((forall 'f. 'f -> 'f) -> 'g) -> ? -> 'g) -> (forall 'h 'i. ? -> ('h -> 'i) -> 'h -> 'i) -> (forall 'j. ? -> (? -> 'j -> 'j | 'k)) -> 'l & (forall 'm. ((forall 'n 'o 'p 'q. ('n -> 'o -> 'p) -> ('q -> 'o & 'n) -> 'q -> 'p) -> (forall 'r 's. ('r -> 's) -> 'r -> 's | 'l) -> 'm) -> 'm) -> (forall 'c. ? -> 'c -> 'c) -> 'k & (forall 't 'u 'v 'w 'x 'y. ((forall 'z. ? -> 'z -> 'z) -> ('t -> 'u -> 'v & 'w)) -> ('w -> (('x -> 'u & 't) -> 'x -> 'v) -> 'y) -> 'y) -> 'a)
//│ ║  l.963: 	  c_1_2_ (n s z)
//│ ╙──       	          ^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1124: 	  let _ = c_printint_ (c_fact_ (to_church_ n)) in
//│ ║          	                       ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ print_fact_: int -> unit
//│            = [Function: print_fact_]
// * Works when using the annotated `c_fact`:
def print_fact_ n =
  let _ = print_string "Factorial " in
  let _ = print_int n in
  let _ = print_string " = " in
  let _ = c_printint_ (c_fact (to_church_ n)) in
          print_string "\n"
//│ print_fact_: int -> unit
//│            = [Function: print_fact_1]

def print_fact2 n =
  concat "Factorial " (
  concat (toString n) (
  concat " = "
         (c_printint2 (c_fact (to_church n))) ))
//│ print_fact2: int -> string
//│            = [Function: print_fact2]

:e // * Similar as above (bad `c_fact_`)
def print_fact2_ n =
  concat "Factorial_ " (
  concat (toString n) (
  concat " = "
         (c_printint2_ (c_fact_ (to_church_ n))) ))
//│ ╔══[ERROR] Inferred recursive type: 'a
//│   where
//│     'a <: (forall 'b. ((forall 'c. ? -> 'c -> 'c) -> (forall 'c. ? -> 'c -> 'c) -> 'b) -> 'b) -> (forall 'd. 'd -> ? -> 'd) -> ((forall 'e. ? -> ? -> ((forall 'f. 'f -> 'f) -> 'e) -> 'e) -> (forall 'g. ((forall 'f. 'f -> 'f) -> 'g) -> ? -> 'g) -> (forall 'h 'i. ? -> ('h -> 'i) -> 'h -> 'i) -> (forall 'j. ? -> (? -> 'j -> 'j | 'k)) -> 'l & (forall 'm. ((forall 'n 'o 'p 'q. ('n -> 'o -> 'p) -> ('q -> 'o & 'n) -> 'q -> 'p) -> (forall 'r 's. ('r -> 's) -> 'r -> 's | 'l) -> 'm) -> 'm) -> (forall 'c. ? -> 'c -> 'c) -> 'k & (forall 't 'u 'v 'w 'x 'y. ((forall 'z. ? -> 'z -> 'z) -> ('t -> 'u -> 'v & 'w)) -> ('w -> (('x -> 'u & 't) -> 'x -> 'v) -> 'y) -> 'y) -> 'a)
//│ ║  l.963: 	  c_1_2_ (n s z)
//│ ╙──       	          ^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1160: 	         (c_printint2_ (c_fact_ (to_church_ n))) ))
//│ ║          	                        ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ print_fact2_: int -> string
//│             = [Function: print_fact2_]
// * Works when using the annotated `c_fact`:
def print_fact2_ n =
  concat "Factorial_ " (
  concat (toString n) (
  concat " = "
         (c_printint2_ (c_fact (to_church_ n))) ))
//│ print_fact2_: int -> string
//│             = [Function: print_fact2_1]

// let essai =
//   print_string "Church integers :\n";
//   let c_i5 = c_add c_i3 c_i2 in
//   let c_i10 = c_mul c_i5 c_i2 in
//   let c_i9 = c_pred c_i10 in
//   let c_99 = c_add (c_mul c_i9 c_i10) c_i9 in
//   let c_98 = c_pred c_99 in
//   print_string "This should be 98 : " ;
//   c_printint c_98;
//   print_string "\n\n" ;

this_should_be_98 =
  let c_i5 = c_add c_i3 c_i2 in
  let c_i10 = c_mul c_i5 c_i2 in
  let c_i9 = c_pred c_i10 in
  let c_99 = c_add (c_mul c_i9 c_i10) c_i9 in
  let c_98 = c_pred c_99 in
  c_printint2 c_98
//│ this_should_be_98: string
//│                  = '98'

// * [FCP:patho] This version without any type annotations doesn't work (probably also doesn't in MLF)
:stats // * Note: subtyping takes too many steps when replacing both `c_mul_` by `c_mul`
:e // * Not sure what's a minimal change to make this one work
this_should_be_98_ =
  let c_i5_ = c_add_ c_i3_ c_i2_ in
  let c_i10_ = c_mul_ c_i5_ c_i2_ in
  let c_i9_ = c_pred_ c_i10_ in
  let c_99_ = c_add_ (c_mul_ c_i9_ c_i10_) c_i9_ in
  let c_98_ = c_pred_ c_99_ in
  c_printint2_ c_98_
//│ ╔══[ERROR] Inferred recursive type: nothing
//│ ║  l.731: 	type Fint  = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                    ^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1207: 	  let c_i10_ = c_mul_ c_i5_ c_i2_ in
//│ ║          	               ^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1208: 	  let c_i9_ = c_pred_ c_i10_ in
//│ ║          	              ^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ this_should_be_98_: string
//│                   = '98'
//│ constrain calls  : 11252
//│ annoying  calls  : 0
//│ subtyping calls  : 38847

// * Decomposing...

:stats
c_i5_ = c_add_ c_i3_ c_i2_
//│ c_i5_: ('b -> 'c & 'c -> 'd & 'd -> 'e & ('a | 'e) -> 'a) -> 'b -> 'a
//│      = [Function (anonymous)]
//│ constrain calls  : 118
//│ annoying  calls  : 0
//│ subtyping calls  : 493

:stats
:e
c_i10_ = c_mul_ c_i5_ c_i2_
//│ ╔══[ERROR] Inferred recursive type: nothing
//│ ║  l.731: 	type Fint  = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                    ^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1241: 	c_i10_ = c_mul_ c_i5_ c_i2_
//│ ║          	         ^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ c_i10_: error | ((forall 'a 'b 'c. ('a -> 'b & 'b -> 'c) -> 'a -> 'c | 'd) -> ('e -> 'f -> ('g & 'h & 'i & 'j & 'k & 'l & 'm) & 'n) & (('o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 's) -> 'o -> 'r | 'n) -> ('t -> 'u -> ('h & 'i & 'j & 'k & 'l & 'm) & 'v) & (('w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's) -> 'w -> 'g | 'v) -> ('x -> 'y -> ('i & 'j & 'k & 'l & 'm) & 'z) & (('a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't) -> 'a1 -> 'h | 'z) -> ('b1 -> 'c1 -> ('j & 'k & 'l & 'm) & 'd1) & (('e1 -> ('y & 'a1) & 'a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't & 'x) -> 'e1 -> 'i | 'd1) -> ('f1 -> 'g1 -> ('k & 'l & 'm) & 'h1) & (('i1 -> ('c1 & 'e1) & 'e1 -> ('y & 'a1) & 'a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't & 'x & 'b1) -> 'i1 -> 'j | 'h1) -> ('j1 -> 'k1 -> ('l & 'm) & 'l1) & (('m1 -> ('g1 & 'i1) & 'i1 -> ('c1 & 'e1) & 'e1 -> ('y & 'a1) & 'a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't & 'x & 'b1 & 'f1) -> 'm1 -> 'k | 'l1) -> ('n1 -> 'o1 -> 'm & 'p1) & (('q1 -> ('k1 & 'm1) & 'm1 -> ('g1 & 'i1) & 'i1 -> ('c1 & 'e1) & 'e1 -> ('y & 'a1) & 'a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't & 'x & 'b1 & 'f1 & 'j1) -> 'q1 -> 'l | 'p1) -> ('r1 & 's1)) -> ('s -> 'p -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'd) -> (('t1 -> ('o1 & 'q1) & 'q1 -> ('k1 & 'm1) & 'm1 -> ('g1 & 'i1) & 'i1 -> ('c1 & 'e1) & 'e1 -> ('y & 'a1) & 'a1 -> ('u & 'w) & 'w -> ('f & 'o) & 'o -> 'p & 'p -> 'q & 'q -> ('g & 'h & 'i & 'j & 'k & 'l & 'm & 'r) & 'e & 's & 't & 'x & 'b1 & 'f1 & 'j1 & 'n1) -> 't1 -> 'm | 'r1) | 's1
//│   where
//│     's1 <: (forall 'u1 'v1 'w1 'x1. ('u1 -> 'v1 -> 'w1) -> ('x1 -> 'v1 & 'u1) -> 'x1 -> 'w1) -> (forall 'y1 'z1 'a2. ('y1 -> 'z1 & 'z1 -> 'a2) -> 'y1 -> 'a2) -> 's1
//│       = [Function (anonymous)]
//│ constrain calls  : 983
//│ annoying  calls  : 0
//│ subtyping calls  : 32252
:stats
// * This one works:
c_i10_ = c_mul c_i5_ c_i2_
//│ c_i10_: (('a | 'b) -> 'a & ('a0 | 'b) -> 'a0) -> 'b -> ('a | 'a0) | Fint
//│       = [Function (anonymous)]
//│ constrain calls  : 624
//│ annoying  calls  : 0
//│ subtyping calls  : 2474

// * Ouchie (cf stats)
:stats
c_i9_ = c_pred_ c_i10_
//│ c_i9_: ('a -> ('a & 'b) & 'c -> 'b & 'c -> 'c & 'd -> ('d & 'b) & 'e -> 'b & 'e -> 'e) -> ('a & 'b & 'c & 'd & 'e) -> 'b
//│      = [Function (anonymous)]
//│ constrain calls  : 2552
//│ annoying  calls  : 0
//│ subtyping calls  : 11102

:stats
:e
c_99_ = c_add_ (c_mul_ c_i9_ c_i10_) c_i9_
//│ ╔══[ERROR] Inferred recursive type: 'b
//│   where
//│     'b <: (forall 'c 'd 'e 'f. ('c -> 'd -> 'e) -> ('f -> 'd & 'c) -> 'f -> 'e) -> ((forall 'a 'g 'a0 'a1 'a2. (('a | 'g) -> 'a & ('a0 | 'g) -> 'a0 & ('a1 | 'g) -> 'a1 & ('a2 | 'g) -> 'a2) -> 'g -> ('a | 'a0 | 'a1 | 'a2) | Fint) -> ? & (forall 'a3 'h 'a4. (('a3 | 'h) -> 'a3 & ('a4 | 'h) -> 'a4) -> 'h -> ('a3 | 'a4) | Fint) -> anything)
//│ ║  l.903: 	def c_succ_ n = fun f -> fun x -> n f (f x)
//│ ╙──       	                                       ^^^
//│ ╔══[ERROR] Cyclic-looking constraint while typing application; a type annotation may be required
//│ ║  l.1276: 	c_99_ = c_add_ (c_mul_ c_i9_ c_i10_) c_i9_
//│ ║          	                ^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ c_99_: error | ('a -> 'a & 'b -> 'b & 'c -> 'c & 'd -> 'd) -> ('a & 'b & 'c & 'd) -> error
//│      = [Function (anonymous)]
//│ constrain calls  : 3117
//│ annoying  calls  : 0
//│ subtyping calls  : 14864
:stats
// * Note: works with `c_mul` AND recursive types...
:RecursiveTypes
c_99_ = c_add_ (c_mul c_i9_ c_i10_) c_i9_
//│ c_99_: ('b -> ('b & 'c & 'a & 'a0) & 'a -> ('c & 'a) & 'a0 -> ('c & 'a0) & 'd -> ('e & 'c & 'a1 & 'a2) & 'e -> ('e & 'c & 'a3 & 'a4) & 'a3 -> ('c & 'a3) & 'a4 -> ('c & 'a4) & 'a1 -> ('c & 'a1) & 'a2 -> ('c & 'a2) & 'f -> ('f & 'c & 'a5 & 'a6) & 'a5 -> ('c & 'a5) & 'a6 -> ('c & 'a6) & ('a7 | 'd) -> 'a7 & 'd -> ('g & 'c & 'a8 & 'a9) & 'g -> ('g & 'c & 'a10 & 'a11) & 'a10 -> ('c & 'a10) & 'a11 -> ('c & 'a11) & 'a8 -> ('c & 'a8) & 'a9 -> ('c & 'a9)) -> ('b & 'd & 'f & 'c) -> ('c | 'a7) | Fint
//│      = [Function (anonymous)]
//│ constrain calls  : 2217
//│ annoying  calls  : 0
//│ subtyping calls  : 22997
:NoRecursiveTypes

// * Ouchie++
:stats
:Fuel 20000
c_98_ = c_pred_ c_99_
//│ c_98_: ('a -> ('a & 'b) & 'c -> 'a & 'c -> 'c & 'd -> ('a & 'd) & 'e -> 'b & 'f -> 'e & 'f -> 'f & 'g -> ('e & 'g) & 'h -> ('e & 'h) & 'i -> 'h & 'i -> 'i & 'j -> ('h & 'j) & 'k -> ('k & 'b) & 'l -> 'k & 'l -> 'l & 'm -> ('k & 'm) & 'n -> ('n & 'b) & 'o -> 'b & 'o -> 'o & 'p -> 'b & 'q -> 'p & 'q -> 'q & 'r -> ('p & 'r) & 's -> ('p & 's) & 't -> 's & 't -> 't & 'u -> ('s & 'u)) -> ('a & 'c & 'd & 'b & 'e & 'f & 'g & 'h & 'i & 'j & 'k & 'l & 'm & 'n & 'o & 'p & 'q & 'r & 's & 't & 'u) -> 'b
//│      = [Function (anonymous)]
//│ constrain calls  : 11598
//│ annoying  calls  : 0
//│ subtyping calls  : 74107
:ResetFuel


//   print_fact 0 ;
//   print_fact 1 ;
//   print_fact 2 ;
//   print_fact 3 ;
//   print_fact 4 ;
//   print_fact 5 ;
//   print_fact 6 ;
//   ()
print_fact2 0
print_fact2 1
print_fact2 2
print_fact2 3
print_fact2 4
print_fact2 5
print_fact2 6
//│ res: string
//│    = 'Factorial 0 = 1'
//│ res: string
//│    = 'Factorial 1 = 1'
//│ res: string
//│    = 'Factorial 2 = 2'
//│ res: string
//│    = 'Factorial 3 = 6'
//│ res: string
//│    = 'Factorial 4 = 24'
//│ res: string
//│    = 'Factorial 5 = 120'
//│ res: string
//│    = 'Factorial 6 = 720'

print_fact2_ 0
print_fact2_ 1
print_fact2_ 2
print_fact2_ 3
print_fact2_ 4
print_fact2_ 5
print_fact2_ 6
//│ res: string
//│    = 'Factorial_ 0 = 1'
//│ res: string
//│    = 'Factorial_ 1 = 1'
//│ res: string
//│    = 'Factorial_ 2 = 2'
//│ res: string
//│    = 'Factorial_ 3 = 6'
//│ res: string
//│    = 'Factorial_ 4 = 24'
//│ res: string
//│    = 'Factorial_ 5 = 120'
//│ res: string
//│    = 'Factorial_ 6 = 720'





// * === Variation: With Constrained Types ===


:DontDistributeForalls
:ConstrainedTypes


def c_succ (n: Fint) = fun f -> fun x -> n f (f x)
def c_succ_ n = fun f -> fun x -> n f (f x)
//│ c_succ: Fint -> (forall 'b. 'b -> (forall 'a 'c. 'c -> 'a
//│   where
//│     'b <: 'a -> 'a & 'c -> 'a))
//│       = [Function: c_succ1]
//│ c_succ_: 'a -> (forall 'b. 'b -> (forall 'c 'd 'e. 'e -> 'd
//│   where
//│     'a <: 'b -> 'c -> 'd
//│     'b <: 'e -> 'c))
//│        = [Function: c_succ_1]

def c_add_ n m = m c_succ_ n
//│ c_add_: 'a -> (forall 'b. ((forall 'c. 'c -> (forall 'd. 'd -> (forall 'e 'f 'g. 'g -> 'f
//│   where
//│     'c <: 'd -> 'e -> 'f
//│     'd <: 'g -> 'e))) -> 'a -> 'b) -> 'b)
//│       = [Function: c_add_1]

// let c_i1 = fun f x -> f x
def c_i1 = fun f -> fun x -> f x
//│ c_i1: 'a -> (forall 'b 'c. 'b -> 'c
//│   where
//│     'a <: 'b -> 'c)
//│     = [Function: c_i11]

// let c_i2 = c_succ c_i1
def c_i2 = c_succ c_i1
def c_i2_ = c_succ_ c_i1
//│ c_i2: 'b -> (forall 'a 'c. 'c -> 'a
//│   where
//│     'b <: 'a -> 'a & 'c -> 'a)
//│     = [Function: c_i22]
//│ c_i2_: 'a -> (forall 'b 'c 'd. 'd -> 'c
//│   where
//│     forall 'e. 'e -> (forall 'f 'g. 'f -> 'g
//│       where
//│         'e <: 'f -> 'g) <: 'a -> 'b -> 'c
//│     'a <: 'd -> 'b)
//│      = [Function: c_i2_1]

// let c_i3 = c_succ c_i2
def c_i3 = c_succ c_i2
def c_i3_ = c_succ_ c_i2
//│ c_i3: 'b -> (forall 'a 'c. 'c -> 'a
//│   where
//│     'b <: 'a -> 'a & 'c -> 'a)
//│     = [Function: c_i31]
//│ c_i3_: 'b -> (forall 'c 'd 'e. 'e -> 'd
//│   where
//│     forall 'f. 'f -> (forall 'a 'g. 'g -> 'a
//│       where
//│         'f <: 'a -> 'a & 'g -> 'a) <: 'b -> 'c -> 'd
//│     'b <: 'e -> 'c)
//│      = [Function: c_i3_1]

:e
:stats
c_i5_ = c_add_ c_i3_ c_i2
//│ ╔══[ERROR] Inferred recursive type: 'b
//│   where
//│     'b :> forall 'c. 'c -> (forall 'd 'e 'f 'g. 'f -> 'e
//│       where
//│         'c <: 'f -> 'd & 'f -> 'g
//│         'b <: 'c -> 'd -> 'e
//│         forall 'h. 'h -> (forall 'i 'j 'k. 'k -> 'j
//│           where
//│             forall 'l. 'l -> (forall 'a 'm. 'm -> 'a
//│               where
//│                 'l <: 'a -> 'a & 'm -> 'a) <: 'h -> 'i -> 'j
//│             'h <: 'k -> 'i) <: 'c -> 'g -> 'e)
//│ ╙──
//│ c_i5_: 'b
//│   where
//│     'b :> forall 'c. 'c -> (forall 'd 'e 'f 'g. 'f -> 'e
//│       where
//│         'c <: 'f -> 'd & 'f -> 'g
//│         'b <: 'c -> 'd -> 'e
//│         forall 'h. 'h -> (forall 'i 'j 'k. 'k -> 'j
//│           where
//│             forall 'l. 'l -> (forall 'a 'm. 'm -> 'a
//│               where
//│                 'l <: 'a -> 'a & 'm -> 'a) <: 'h -> 'i -> 'j
//│             'h <: 'k -> 'i) <: 'c -> 'g -> 'e)
//│      = [Function (anonymous)]
//│ constrain calls  : 107
//│ annoying  calls  : 0
//│ subtyping calls  : 378

:stats
:e
c_i10_ = c_mul_ c_i5_ c_i2_
//│ ╔══[ERROR] Inferred recursive type: nothing
//│ ║  l.731: 	type Fint  = forall 'a. ('a -> 'a) -> ('a -> 'a)
//│ ╙──       	                    ^^
//│ ╔══[ERROR] Subtyping constraint of the form `forall ?a ?b ?c. ?b -> ?c -> ?a <: (forall ?d. ?d) -> ?e` exceeded recursion depth limit (250)
//│ ║  l.1468: 	c_i10_ = c_mul_ c_i5_ c_i2_
//│ ║          	         ^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ c_i10_: error
//│       = [Function (anonymous)]
//│ constrain calls  : 3360
//│ annoying  calls  : 0
//│ subtyping calls  : 23503


