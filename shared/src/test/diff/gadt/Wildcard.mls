:NewDefs

class Foo[type T](val x: T)
//│ class Foo[T](x: T)

fun foo(f: Foo[?]) = f
//│ fun foo: (f: Foo[anything]) -> Foo[anything]

foo(Foo(0))
//│ Foo[anything]
//│ res
//│     = Foo {}

fun foo(f: Foo[?]) = 0
//│ fun foo: (f: Foo[anything]) -> 0

let f: Foo[?] = Foo(1)
//│ let f: Foo[anything]
//│ f
//│   = Foo {}

foo(f)
foo(Foo(1))
//│ 0
//│ res
//│     = 0
//│ res
//│     = 0

fun y: Foo[Foo[Int]]
//│ fun y: Foo[Foo[Int]]

// * Foo is invariant so this doesn't work
:e
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.35: 	let f: Foo[Foo[?]] = y
//│ ║        	                     ^
//│ ╙── expression of type `Int` does not match type `nothing`
//│ let f: Foo[Foo[anything]]
//│ f
//│   = <no result>
//│     y is not implemented


fun foo(f: Foo[?]) = f.x
//│ fun foo: (f: Foo[anything]) -> anything

foo(Foo(Foo(1)))
foo(Foo(1))
//│ anything
//│ res
//│     = Foo {}
//│ res
//│     = 1

:e // * To allow this, we'd need to either introduce more levels even outside pattern matching branches
   // * or support proper path-dependent types internally.
fun foo(f: Foo[?]) = f.x as f.T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.59: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ║        	                     ^^^
//│ ╟── field selection of type `anything` does not match type `nothing`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.59: 	fun foo(f: Foo[?]) = f.x as f.T
//│ ╙──      	                             ^^
//│ fun foo: (f: Foo[anything]) -> anything

fun foo(f: Foo[?]) = if f is Foo(x) then x as f.T
//│ fun foo: (f: Foo[anything]) -> ??T

foo(Foo(1))
//│ ??T
//│ res
//│     = 1

class Foo[out T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[anything]
//│ f
//│   = Foo {}

let f: Foo[Foo[?]] = Foo(Foo(1))
//│ let f: Foo[Foo[anything]]
//│ f
//│   = Foo {}

class Foo[in T](val x: T)
//│ class Foo[T](x: T)

let f: Foo[?] = Foo(1)
//│ let f: Foo[nothing]
//│ f
//│   = Foo {}

let y: Foo[Foo[Int]] = Foo(Foo(0))
//│ let y: Foo[Foo[Int]]
//│ y
//│   = Foo {}

// * Correct error: Foo[Int] <: Foo[?] so Foo[Foo[?]] <: Foo[Foo[Int]] and not the other way around
:e
let f: Foo[Foo[?]] = y
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.105: 	let f: Foo[Foo[?]] = y
//│ ║         	                     ^
//│ ╟── type `anything` is not an instance of type `Int`
//│ ║  l.105: 	let f: Foo[Foo[?]] = y
//│ ║         	               ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.98: 	let y: Foo[Foo[Int]] = Foo(Foo(0))
//│ ╙──      	               ^^^
//│ let f: Foo[Foo[nothing]]
//│ f
//│   = Foo {}

(x: Foo[Foo[?]]) => x as Foo[Foo[Int]]
//│ (x: Foo[Foo[nothing]]) -> Foo[Foo[Int]]
//│ res
//│     = [Function: res]

abstract class Bar[type A]: MkBarInt | MkBarBool | MkBarFoo[?]
class MkBarInt() extends Bar[Int]
class MkBarBool() extends Bar[Bool]
class MkBarFoo[A](ev: A) extends Bar[Foo[A]]
//│ abstract class Bar[A]: MkBarBool | MkBarFoo[anything] | MkBarInt
//│ class MkBarInt() extends Bar
//│ class MkBarBool() extends Bar
//│ class MkBarFoo[A](ev: A) extends Bar

fun bar(b: Bar[?]) = if b is
    MkBarInt then 1
    MkBarBool then 2
    MkBarFoo then 3
//│ fun bar: (b: Bar[?]) -> (1 | 2 | 3)

bar(MkBarInt())
bar(MkBarBool() as Bar[?])
bar(MkBarFoo("hello"))
bar(MkBarFoo(Foo(1)))
//│ 1 | 2 | 3
//│ res
//│     = 1
//│ res
//│     = 2
//│ res
//│     = 3
//│ res
//│     = 3

let x: Bar[?] = MkBarInt()
//│ let x: Bar[?]
//│ x
//│   = MkBarInt {}

:e
x as Bar[Bool]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.159: 	x as Bar[Bool]
//│ ║         	^
//│ ╟── type `Bool` does not match type `nothing`
//│ ║  l.159: 	x as Bar[Bool]
//│ ║         	         ^^^^
//│ ╟── Note: constraint arises from wildcard:
//│ ║  l.153: 	let x: Bar[?] = MkBarInt()
//│ ╙──       	           ^
//│ Bar[Bool]
//│ res
//│     = MkBarInt {}

MkBarFoo(Foo(1)) as Bar[Foo[Foo[Int]]]
//│ Bar[Foo[Foo[Int]]]
//│ res
//│     = MkBarFoo {}

MkBarFoo(Foo(1)) as Bar[?]
//│ Bar[?]
//│ res
//│     = MkBarFoo {}

MkBarFoo(Foo(1)) as Bar[Foo[?]]
//│ Bar[Foo[nothing]]
//│ res
//│     = MkBarFoo {}

let x: Bar[Foo[?]] = MkBarFoo(1)
//│ let x: Bar[Foo[nothing]]
//│ x
//│   = MkBarFoo {}

let x: Bar[Foo[?]] = MkBarFoo(1)
//│ let x: Bar[Foo[nothing]]
//│ x
//│   = MkBarFoo {}

:e
x as Bar[Foo[Int]]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.199: 	x as Bar[Foo[Int]]
//│ ║         	^
//│ ╟── type `anything` is not an instance of type `Int`
//│ ║  l.193: 	let x: Bar[Foo[?]] = MkBarFoo(1)
//│ ║         	               ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.199: 	x as Bar[Foo[Int]]
//│ ╙──       	             ^^^
//│ Bar[Foo[Int]]
//│ res
//│     = MkBarFoo {}

abstract class C[type A]: MkC
class MkC() extends C[Int]
//│ abstract class C[A]: MkC
//│ class MkC() extends C

fun fc(c: C[?]) = if c is MkC then 1 as c.A
//│ fun fc: (c: C[?]) -> Int

fc(MkC())
//│ Int
//│ res
//│     = 1

abstract class Baz[type A]: BI | BB
class BI() extends Baz[Int]
class BB() extends Baz[Bool]
//│ abstract class Baz[A]: BB | BI
//│ class BI() extends Baz
//│ class BB() extends Baz

fun baz[T](b: Baz[T]): T = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'T. (b: Baz['T]) -> 'T

fun baz(b: Baz['a]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: forall 'a. (b: Baz['a]) -> ('a & (Int | false | true))

fun baz(b: Baz[?]) = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: (b: Baz[?]) -> (Int | false | true)

// * Note: this didn't work before we pushed ascriptions in,
// * as we don't yet have proper path-dependent type forms like b.A, which is basically ? here.
fun baz(b: Baz[?]): b.A = if b is
    BI then 1 as b.A
    BB then true as b.A
//│ fun baz: (b: Baz[?]) -> (Int | false | true)

class Foo[T](val x: T)
//│ class Foo[T](x: T)

fun e: Foo[?]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[anything]
//│ fun f: Foo[anything] -> Foo[anything]

f(e)
//│ Foo[anything]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[Int]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[Int]
//│ fun f: Foo[anything] -> Foo[anything]

f(e)
//│ Foo[anything]
//│ res
//│     = <no result>
//│       f is not implemented

fun e: Foo[?]
fun f: Foo[Int] -> Foo[?]
//│ fun e: Foo[anything]
//│ fun f: Foo[Int] -> Foo[anything]

:e
e as Foo[Int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.286: 	e as Foo[Int]
//│ ║         	^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[Int]
//│ res
//│     = <no result>
//│       e is not implemented

:e
f(e)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.297: 	f(e)
//│ ║         	^^^^
//│ ╙── expression of type `anything` is not an instance of type `Int`
//│ Foo[anything] | error
//│ res
//│     = <no result>
//│       f is not implemented

class Foo[T](val x: T => T)
//│ class Foo[T](x: T -> T)

fun e: Foo[?]
fun f: Foo[?] -> Foo[?]
//│ fun e: Foo[?]
//│ fun f: Foo[?] -> Foo[?]

:e
fun f(x: ?) = x
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.316: 	fun f(x: ?) = x
//│ ╙──       	         ^
//│ fun f: (x: error) -> error

:e
fun f(x): ? = x
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.323: 	fun f(x): ? = x
//│ ╙──       	          ^
//│ fun f: error -> error

:e
fun f(x: Int): ? = x
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.330: 	fun f(x: Int): ? = x
//│ ╙──       	               ^
//│ fun f: (x: Int) -> error

:e
fun f(x: ?): ? = x
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.337: 	fun f(x: ?): ? = x
//│ ╙──       	         ^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.337: 	fun f(x: ?): ? = x
//│ ╙──       	             ^
//│ fun f: (x: error) -> error

:e
let x: ? = 1
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.347: 	let x: ? = 1
//│ ╙──       	       ^
//│ let x: error
//│ x
//│   = 1

:e
1 as ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.356: 	1 as ?
//│ ╙──       	     ^
//│ error
//│ res
//│     = 1

:e
fun f: (? -> ?) -> ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.365: 	fun f: (? -> ?) -> ?
//│ ╙──       	        ^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.365: 	fun f: (? -> ?) -> ?
//│ ╙──       	             ^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.365: 	fun f: (? -> ?) -> ?
//│ ╙──       	                   ^
//│ fun f: (error -> error) -> error

:e
fun f: ? -> ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.378: 	fun f: ? -> ?
//│ ╙──       	       ^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.378: 	fun f: ? -> ?
//│ ╙──       	            ^
//│ fun f: error -> error

:e
fun f: ? -> Int
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.388: 	fun f: ? -> Int
//│ ╙──       	       ^
//│ fun f: error -> Int

:e
fun f: Int -> ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.395: 	fun f: Int -> ?
//│ ╙──       	              ^
//│ fun f: Int -> error

:e
let x: ? -> ?
//│ ╔══[ERROR] `let` bindings must have a right-hand side
//│ ║  l.402: 	let x: ? -> ?
//│ ╙──       	^^^^^^^^^^^^^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.402: 	let x: ? -> ?
//│ ╙──       	       ^
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.402: 	let x: ? -> ?
//│ ╙──       	            ^
//│ let x: error -> error
//│ x
//│   = <missing implementation>

:e
let x = ?
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.417: 	let x = ?
//│ ╙──       	        ^
//│ let x: error
//│ Code generation encountered an error:
//│   unresolved symbol ?

:e
if ? is 1 then 1
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.426: 	if ? is 1 then 1
//│ ╙──       	   ^
//│ 1
//│ Code generation encountered an error:
//│   unresolved symbol ?

:e
if x is ? then 1
//│ ╔══[ERROR] Cannot match on wildcard ?
//│ ║  l.435: 	if x is ? then 1
//│ ╙──       	        ^
//│ error
//│ Code generation encountered an error:
//│   if expression was not desugared

:e
let x: ?[?]
//│ ╔══[ERROR] `let` bindings must have a right-hand side
//│ ║  l.444: 	let x: ?[?]
//│ ╙──       	^^^^^^^^^^^
//│ ╔══[ERROR] type identifier not found: ?
//│ ║  l.444: 	let x: ?[?]
//│ ╙──       	       ^^^^
//│ let x: error
//│ x
//│   = <missing implementation>

:e
class Bar extends ?
//│ ╔══[ERROR] Could not find definition `?`
//│ ║  l.456: 	class Bar extends ?
//│ ╙──       	                  ^
//│ class Bar {
//│   constructor()
//│ }
//│ Code generation encountered an error:
//│   unresolved parent ?.

:e
abstract class Bar: ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.467: 	abstract class Bar: ?
//│ ╙──       	                    ^
//│ abstract class Bar: error

:e
class ?
//│ ╔══[ERROR] Type name '?' is reserved
//│ ║  l.474: 	class ?
//│ ╙──       	^^^^^^^
//│ class ? {
//│   constructor()
//│ }
//│ Syntax error:
//│   Invalid or unexpected token

:e
type ? = Int
//│ ╔══[ERROR] Type name '?' is reserved
//│ ║  l.485: 	type ? = Int
//│ ╙──       	^^^^^^
//│ type ? = Int

:e
type W = ?
//│ ╔══[ERROR] Invalid use of wildcard type `?` here
//│ ║  l.492: 	type W = ?
//│ ╙──       	         ^
//│ type W = error

// TODO reject
fun (?) wc: (Int, Int) -> Bool
fun (?) wc(x, y) = x == y
//│ fun (?) wc: (Num, Num) -> Bool
//│ fun (?) wc: (Int, Int) -> Bool

:e
1 ? 1
//│ ╔══[ERROR] Cannot use ? as expression
//│ ║  l.505: 	1 ? 1
//│ ╙──       	  ^
//│ error
//│ res
//│     = true

class Foo[T](val a: T)
let f: Foo[?] = Foo(1)
//│ class Foo[T](a: T)
//│ let f: Foo[anything]
//│ f
//│   = Foo {}

:e
f.a : Int
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.521: 	f.a : Int
//│ ║         	^^^
//│ ╟── field selection of type `anything` is not an instance of type `Int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.521: 	f.a : Int
//│ ╙──       	      ^^^
//│ Int
//│ res
//│     = 1

// * FIXME strange error!
:e
42 : f.a
//│ ╔══[ERROR] Type mismatch in type selection:
//│ ║  l.535: 	42 : f.a
//│ ║         	      ^^
//│ ╙── type `anything` cannot be reassigned
//│ anything
//│ res
//│     = 42

