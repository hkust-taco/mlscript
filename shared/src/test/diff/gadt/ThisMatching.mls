:NewDefs


:e
:re
module Dummy {
  log(if this is Dummy then "duh!" else "huh?")
}
//│ ╔══[ERROR] Cannot access `this` during object initialization
//│ ║  l.7: 	  log(if this is Dummy then "duh!" else "huh?")
//│ ╙──     	         ^^^^
//│ module Dummy
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

module Dummy {
  fun introspect =
    if this is Dummy then "duh!" else "huh?"
}
//│ module Dummy {
//│   fun introspect: "duh!" | "huh?"
//│ }

Dummy.introspect
//│ "duh!" | "huh?"
//│ res
//│     = 'duh!'


<<<<<<<
class Funny: Int { fun test = this + 1 }
//│ class Funny: Int {
//│   constructor()
//│   fun test: Int
||||||| b14bd8d83
// * TODO: simplify `forall 'a. Int | 'a` – seems it's not because it shares a var...
class Funny: Int { fun test = this + 1 }
//│ class Funny: Int | 'a {
//│   constructor()
//│   fun test: forall 'a. Int | 'a
=======
// * TODO: simplify `forall 'a. Int | 'a` – seems it's not because it shares a var...
abstract class Funny: Int { fun test = this + 1 }
//│ abstract class Funny: Int | 'a {
//│   fun test: forall 'a. Int | 'a
>>>>>>>

:e
class Unfunny { fun test = this + 1 }
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.49: 	class Unfunny { fun test = this + 1 }
//│ ║        	                           ^^^^^^^^
//│ ╟── reference of type `#Unfunny` is not an instance of type `Int`
//│ ║  l.49: 	class Unfunny { fun test = this + 1 }
//│ ╙──      	                           ^^^^
//│ class Unfunny {
//│   constructor()
//│   fun test: Int | error
//│ }


<<<<<<<
class Exp: (Pair | Lit) {
||||||| b14bd8d83
class Exp: Pair | Lit {
=======
abstract class Exp: Pair | Lit {
>>>>>>>
  fun test = if this is
    Lit then 0
    Pair then 1
}
class Lit(n: Int) extends Exp
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╔══[PARSE ERROR] Unexpected closing curly brace
//│ ║  l.72: 	}
//│ ╙──      	^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.69: 	  fun test = if this is
//│ ╙──      	                ^^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Could not find definition `Exp`
//│ ║  l.73: 	class Lit(n: Int) extends Exp
//│ ╙──      	                          ^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Could not find definition `Exp`
//│ ║  l.74: 	class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╙──      	                                       ^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] type identifier not found: Exp
//│ ║  l.74: 	class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╙──      	                ^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] type identifier not found: Exp
//│ ║  l.74: 	class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╙──      	                          ^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun test: 0 | 1
//│ class Lit(n: Int)
//│ class Pair(lhs: error, rhs: error)
//│ Code generation encountered an error:
//│   unresolved parent Exp.


<<<<<<<
class Exp: (() | Lit) {
||||||| b14bd8d83
class Exp: Pair | Lit {
=======
abstract class Exp: Pair | Lit {
>>>>>>>
  fun test = if this is
    Lit then 0
    () then 1
}
class Lit(n: Int) extends Exp
//│ ╔══[PARSE ERROR] Unexpected closing curly brace
//│ ║  l.116: 	}
//│ ╙──       	^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.113: 	  fun test = if this is
//│ ╙──       	                ^^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ ╔══[ERROR] Could not find definition `Exp`
//│ ║  l.117: 	class Lit(n: Int) extends Exp
//│ ╙──       	                          ^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ fun test: 0 | 1
//│ class Lit(n: Int)
//│ Code generation encountered an error:
//│   unresolved parent Exp.
<<<<<<<
//│ class Exp: Lit | () {
//│   constructor()
||||||| b14bd8d83
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ class Exp: Lit | Pair {
//│   constructor()
=======
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ abstract class Exp: Lit | Pair {
>>>>>>>

// * TODO fix this by requiring a type annotation on `test` and delaying its body's type checking until all the involed classes are completed
// * Currently we try to complete Exp ->{type checking defn body} complete test ->{type checking pattern} find Wrap's typed fields ->{get Wrap's typed parents} complete Exp
:e
class Exp: (() | Wrap) {
  fun test = if this is
    Wrap(a) then 0
    () then 1
}
class Wrap(n: Exp) extends Exp
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.149: 	class Exp: (() | Wrap) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.150: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.151: 	    Wrap(a) then 0
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.152: 	    () then 1
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.153: 	}
//│ ║         	^
//│ ╟── expression of type `#Exp` does not match type `Wrap | ()`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.149: 	class Exp: (() | Wrap) {
//│ ╙──       	           ^^^^^^^^^^^
//│ ╔══[ERROR] Unhandled cyclic definition
//│ ║  l.149: 	class Exp: (() | Wrap) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.150: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.151: 	    Wrap(a) then 0
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.152: 	    () then 1
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.153: 	}
//│ ╙──       	^
//│ class Exp: Wrap | () {
//│   constructor()
//│   fun test: 0 | 1
//│ }
//│ class Wrap(n: Exp) extends Exp

// * TODO (same as above)
:e
class Exp: (Pair | Lit) {
  fun test: Int
  fun test = if this is
    Lit then 0
    Pair(l, r) then 1
}
class Lit(n: Int) extends Exp
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.189: 	class Exp: (Pair | Lit) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.190: 	  fun test: Int
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.191: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.192: 	    Lit then 0
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.193: 	    Pair(l, r) then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.194: 	}
//│ ║         	^
//│ ╟── expression of type `#Exp` does not match type `Lit | Pair`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.189: 	class Exp: (Pair | Lit) {
//│ ╙──       	           ^^^^^^^^^^^^
//│ ╔══[ERROR] Unhandled cyclic definition
//│ ║  l.189: 	class Exp: (Pair | Lit) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.190: 	  fun test: Int
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.191: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.192: 	    Lit then 0
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.193: 	    Pair(l, r) then 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.194: 	}
//│ ╙──       	^
//│ class Exp: Lit | Pair {
//│   constructor()
//│   fun test: Int
//│ }
//│ class Lit(n: Int) extends Exp {
//│   fun test: Int
//│ }
//│ class Pair(lhs: Exp, rhs: Exp) extends Exp

:e // TODO
Pair(Lit(1), Lit(2)).test
//│ ╔══[ERROR] Type `Pair` does not contain member `test`
//│ ║  l.237: 	Pair(Lit(1), Lit(2)).test
//│ ╙──       	                    ^^^^^
//│ error
//│ res
//│     = 1


:e // TODO can we support this?
class Exp: (Pair | Lit) {
  fun test = if this is
    Lit then 0
    Pair(l, r) then l.test + r.test
}
class Lit(n: Int) extends Exp
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.247: 	class Exp: (Pair | Lit) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.248: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.249: 	    Lit then 0
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.250: 	    Pair(l, r) then l.test + r.test
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.251: 	}
//│ ║         	^
//│ ╟── expression of type `#Exp` does not match type `Lit | Pair`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.247: 	class Exp: (Pair | Lit) {
//│ ╙──       	           ^^^^^^^^^^^^
//│ ╔══[ERROR] Unhandled cyclic definition
//│ ║  l.247: 	class Exp: (Pair | Lit) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.248: 	  fun test = if this is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.249: 	    Lit then 0
//│ ║         	^^^^^^^^^^^^^^
//│ ║  l.250: 	    Pair(l, r) then l.test + r.test
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.251: 	}
//│ ╙──       	^
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.250: 	    Pair(l, r) then l.test + r.test
//│ ╙──       	                     ^^^^^
//│ class Exp: Lit | Pair {
//│   constructor()
//│   fun test: Int | error
//│ }
//│ class Lit(n: Int) extends Exp {
//│   fun test: Int | error
//│ }
//│ class Pair(lhs: Exp, rhs: Exp) extends Exp


<<<<<<<
:e // TODO
class Exp: (Pair | Lit) {
||||||| b14bd8d83
class Exp: Pair | Lit {
=======
abstract class Exp: Pair | Lit {
>>>>>>>
  fun test : Int
  fun test = if this is
    Lit then 0
    Pair(l, r) then l.test + r.test
}
class Lit(n: Int) extends Exp
class Pair(lhs: Exp, rhs: Exp) extends Exp
//│ ╔══[PARSE ERROR] Unexpected closing curly brace
//│ ║  l.305: 	}
//│ ╙──       	^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[PARSE ERROR] Unexpected 'fun' keyword in expression position
//│ ║  l.302: 	  fun test = if this is
//│ ╙──       	  ^^^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[PARSE ERROR] Unexpected '=' here
//│ ║  l.302: 	  fun test = if this is
//│ ╙──       	           ^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.301: 	  fun test : Int
//│ ║         	             ^^^
//│ ║  l.302: 	  fun test = if this is
//│ ╙──       	^^^^^^^^^^
//│ TEST CASE FAILURE: There was an unexpected warning
//│ ╔══[ERROR] Wrong number of type arguments – expected 0, found 1
//│ ║  l.301: 	  fun test : Int
//│ ║         	             ^^^
//│ ║  l.302: 	  fun test = if this is
//│ ╙──       	^^^^^^^^^^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ class Lit(n: Int) extends Exp {
//│   fun test: Int | error
//│ }
//│ class Pair(lhs: Exp, rhs: Exp) extends Exp {
//│   fun test: Int | error
//│ }
//│ fun test: Int


:e // TODO support – this requires implementing type member lookup without forced completion (we get constraints like Pair<Exp> <: Pair#L)
<<<<<<<
class Exp[A]: (Pair | Lit) {
||||||| b14bd8d83
class Exp[A]: Pair | Lit {
=======
abstract class Exp[A]: Pair | Lit {
>>>>>>>
  fun test = if this is
    Lit then 0
    Pair then 1
}
class Lit(n: Int) extends Exp[Int]
class Pair[L, R](lhs: L, rhs: R) extends Exp[[L, R]]
//│ ╔══[PARSE ERROR] Unexpected closing curly brace
//│ ║  l.352: 	}
//│ ╙──       	^
//│ TEST CASE FAILURE: There was an unexpected parse error
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.349: 	  fun test = if this is
//│ ╙──       	                ^^^^
//│ ╔══[ERROR] class Exp expects 0 type parameter(s); got 1
//│ ║  l.353: 	class Lit(n: Int) extends Exp[Int]
//│ ╙──       	                          ^^^^^^^
//│ /!!!\ Uncaught error: java.lang.AssertionError: assertion failed
//│ 	at: scala.Predef$.assert(Predef.scala:264)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$expandWith$1(TyperHelpers.scala:1131)
//│ 	at: scala.Option.map(Option.scala:242)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandWith(TyperHelpers.scala:1090)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandWith$(TyperHelpers.scala:1089)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandWith(TyperDatatypes.scala:378)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandOrCrash(TyperHelpers.scala:1087)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandOrCrash$(TyperHelpers.scala:1085)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandOrCrash(TyperDatatypes.scala:378)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:763)

Lit(0).test
//│ /!!!\ Uncaught error: java.lang.AssertionError: assertion failed
//│ 	at: scala.Predef$.assert(Predef.scala:264)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$expandWith$1(TyperHelpers.scala:1131)
//│ 	at: scala.Option.map(Option.scala:242)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandWith(TyperHelpers.scala:1090)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandWith$(TyperHelpers.scala:1089)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandWith(TyperDatatypes.scala:378)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandOrCrash(TyperHelpers.scala:1087)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.expandOrCrash$(TyperHelpers.scala:1085)
//│ 	at: mlscript.TyperDatatypes$TypeRef.expandOrCrash(TyperDatatypes.scala:378)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:763)


