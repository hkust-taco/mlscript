:NewDefs

abstract class Option[type out T]: None | Some[T]
class None extends Option[nothing]
class Some[A](val get: A) extends Option[A]
//│ abstract class Option[T]: None | Some[T]
//│ class None extends Option {
//│   constructor()
//│ }
//│ class Some[A](get: A) extends Option

class Box[type A](val get: A)
//│ class Box[A](get: A)

abstract class F[type A]: MkF[?]
class MkF[T](t: T) extends F[Box[T]]
//│ abstract class F[A]: MkF[anything]
//│ class MkF[T](t: T) extends F

fun f[T](x: F[T]): T = if x is MkF(t) then Box(t) as x.A
//│ fun f: forall 'T. (x: F['T]) -> 'T

abstract class H[type A]: HI | HB | HG[?]
module HI extends H[Option[Int]]
module HB extends H[Box[Bool]]
class HG[T](t: T) extends H[Option[Box[T]]]
//│ abstract class H[A]: HB | HG[anything] | HI
//│ module HI extends H
//│ module HB extends H
//│ class HG[T](t: T) extends H

fun h[A](x: H[A]): A = if x is
    HI then Some(1) as x.A
    HB then Box(false) as x.A
    HG(t) then Some(Box(t)) as x.A
//│ fun h: forall 'A. (x: H['A]) -> 'A

h(HG(1))
//│ Option[Box['T]]
//│   where
//│     'T :> 1
//│ res
//│     = Some {}

abstract class F[type A, type B]: MkF[A]
class MkF[X](x: X) extends F[X, Some[Box[Int]]]
//│ abstract class F[A, B]: MkF[A]
//│ class MkF[X](x: X) extends F

fun f[T](x: F[T, T]): Int = if x is
    MkF(m) then ((m as x.A) as x.B).get.get
//│ fun f: forall 'T. (x: F['T, 'T]) -> Int

f(MkF(Some(Box(1))))
//│ Int
//│ res
//│     = 1

MkF(1)
//│ MkF['X]
//│   where
//│     'X :> 1
//│ res
//│     = MkF {}

:e
MkF(1) : F['a, 'a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.67: 	MkF(1) : F['a, 'a]
//│ ║        	^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Some`
//│ ║  l.67: 	MkF(1) : F['a, 'a]
//│ ║        	    ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.46: 	class MkF[X](x: X) extends F[X, Some[Box[Int]]]
//│ ║        	                                ^^^^^^^^^^^^^^
//│ ╟── Note: type parameter B is defined at:
//│ ║  l.45: 	abstract class F[type A, type B]: MkF[A]
//│ ╙──      	                              ^
//│ F[in Some[Box[Int]] out Some[Box[Int]] | 1, in Some[Box[Int]] out Some[Box[Int]] | 1]
//│ res
//│     = MkF {}

abstract class F[type A, type B]: MkF[?]
class MkF[type X](x: X) extends F[Some[X], Some[Box[Int]]]
//│ abstract class F[A, B]: MkF[anything]
//│ class MkF[X](x: X) extends F

fun f[R](x: F['t, R]): R = if x is
    MkF(m) then Some(Box(1)) : x.B
//│ fun f: forall 't 'R. (x: F['t, 'R]) -> 'R

:e
fun f[R](x: F['t, R]): R = if x is
    MkF(m) then Some(Box(false)) : x.B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.95: 	    MkF(m) then Some(Box(false)) : x.B
//│ ║        	                ^^^^^^^^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `Int`
//│ ║  l.95: 	    MkF(m) then Some(Box(false)) : x.B
//│ ╙──      	                         ^^^^^
//│ fun f: forall 't 'R. (x: F['t, 'R]) -> 'R

fun g[T](x: F[T, T], y: F[T, T]): Int = if x is MkF(n) and y is MkF(m) then 
    ((Some(n) as x.A) as x.B).get.get + ((Some(m) as y.A) as y.B).get.get
//│ fun g: forall 'T. (x: F['T, 'T], y: F['T, 'T]) -> Int

fun f[T](x: F[T, T]): Int = if x is
    MkF(m) then ((Some(m) as x.A) as x.B).get.get
//│ fun f: forall 'T. (x: F['T, 'T]) -> Int

f(MkF(Box(1)))
//│ Int
//│ res
//│     = 1

:e
f(MkF(1))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.118: 	f(MkF(1))
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Box`
//│ ║  l.118: 	f(MkF(1))
//│ ║         	      ^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.85: 	class MkF[type X](x: X) extends F[Some[X], Some[Box[Int]]]
//│ ╙──      	                                                ^^^^^^^^
//│ Int | error
//│ res
//│     = undefined

abstract class U[type A, type B, type C]: MkU[A, B]
class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ abstract class U[A, B, C]: MkU[A, B]
//│ class MkU[S, T](s: S, t: T) extends U

fun u[A](x: U[A, A, A]): A = if x is
    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ fun u: forall 'A. (x: U['A, 'A, 'A]) -> 'A

u(MkU(1, 2))
//│ Int
//│ res
//│     = 3

:e
u(MkU(1, true))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.147: 	u(MkU(1, true))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of `Int`
//│ ║  l.147: 	u(MkU(1, true))
//│ ║         	         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ ║         	                                            ^^^
//│ ╟── Note: type parameter C is defined at:
//│ ║  l.132: 	abstract class U[type A, type B, type C]: MkU[A, B]
//│ ╙──       	                                      ^
//│ Int | error | true
//│ res
//│     = 2

:e
fun u2[A, B](x: U[A, B, A]): A = if x is
    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.165: 	fun u2[A, B](x: U[A, B, A]): A = if x is
//│ ║         	                                    ^^^^
//│ ║  l.166: 	    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `B` does not match type `Int | A | ~(B & ??T)`
//│ ║  l.165: 	fun u2[A, B](x: U[A, B, A]): A = if x is
//│ ║         	          ^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.166: 	    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ ║         	                                                          ^^
//│ ╟── from type selection:
//│ ║  l.166: 	    MkU(s, t) then (((s as x.A) as x.C) + ((t as x.B) as x.C)) as x.C
//│ ║         	                                                  ^^
//│ ╟── Note: type parameter T is defined at:
//│ ║  l.133: 	class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ ╙──       	             ^
//│ fun u2: forall 'A 'B. (x: U['A, 'B, 'A]) -> (error | 'A)

u2(MkU(1, false))
//│ Int | error
//│ res
//│     = 1

fun eu[A, B](x: U[A,B,A], y: U[A,B,A]): Bool =
    if x is MkU(s1, t1) and y is MkU(s2, t2) then 
        ((s1 as x.A) as x.C) == ((s2 as y.A) as y.C)
    else false
//│ fun eu: forall 'A 'B. (x: U['A, 'B, 'A], y: U['A, 'B, 'A]) -> Bool

eu(MkU(1, 2), MkU(1, 3))
//│ Bool
//│ res
//│     = true

eu(MkU(1, true), MkU(2, false))
//│ Bool
//│ res
//│     = false

eu(MkU(1, 2), MkU(1, "ha"))
//│ Bool
//│ res
//│     = true

fun su[A, B](x: U[A,B,A], y: U[B,A,B]): Int =
    if x is MkU(s1, t1) and y is MkU(s2, t2) then 
        (t1 as y.A) as y.C
    else 0
//│ fun su: forall 'A 'B. (x: U['A, 'B, 'A], y: U['B, 'A, 'B]) -> Int

fun su[A, B](x: U[A,B,A], y: U[B,A,B]): Int =
    if x is MkU(s1, t1) and y is MkU(s2, t2) then 
        ((s1 as x.A) as x.C) + ((t1 as y.A) as y.C) + ((s2 as y.A) as y.C) + ((t2 as x.A) as x.C)
    else 0
//│ fun su: forall 'A 'B. (x: U['A, 'B, 'A], y: U['B, 'A, 'B]) -> Int

su(MkU(1,2), MkU(3,4))
//│ Int
//│ res
//│     = 10

:e
su(MkU(1,true), MkU(3,4))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.230: 	su(MkU(1,true), MkU(3,4))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of `Int`
//│ ║  l.230: 	su(MkU(1,true), MkU(3,4))
//│ ║         	         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	class MkU[S, T](s: S, t: T) extends U[S, T, Int]
//│ ║         	                                            ^^^
//│ ╟── Note: type parameter C is defined at:
//│ ║  l.132: 	abstract class U[type A, type B, type C]: MkU[A, B]
//│ ╙──       	                                      ^
//│ Int | error
//│ res
//│     = 9
