:NewDefs

fun fff(x, y, z) = (x - y) * z
//│ fun fff: (Int, Int, Int,) -> Int

:d
fff(1, 2, 3)
//│ 0. Typing TypingUnit(List(fff (1, 2, 3,)))
//│ | Typing unit statements
//│ | | 0. Typing term fff (1, 2, 3,)
//│ | | | applying-to-function => fff<class mlscript.Var>1, 2, 3,<class mlscript.Tup>
//│ | | | now we should desugar in case of named args!
//│ | | | !!unnamed args case!!
//│ | | | 0. Typing term fff
//│ | | | 0. : ‹∀ 0. ((α43', α44', α45',) -> α49')›
//│ | | | 0. Typing term 1
//│ | | | 0. : #1<Int,Num,Object>
//│ | | | 0. Typing term 2
//│ | | | 0. : #2<Int,Num,Object>
//│ | | | 0. Typing term 3
//│ | | | 0. : #3<Int,Num,Object>
//│ | | | f and f_ty => Var(fff) ‹∀ 0. ((α43', α44', α45',) -> α49')›
//│ | | | a and a_ty => Tup(_: IntLit(1), _: IntLit(2), _: IntLit(3)) (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,)
//│ | | | CONSTRAIN ‹∀ 0. ((α43', α44', α45',) -> α49')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α55)
//│ | | |   where 
//│ 		α43' <: Int
//│ 		α44' <: Int
//│ 		α45' <: Int
//│ 		α49' :> Int
//│ | | | 0. C ‹∀ 0. ((α43', α44', α45',) -> α49')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α55)    (0)
//│ | | | | could be distribbed: Set(α49')
//│ | | | | cannot be distribbed: Set(α43', α44', α45')
//│ | | | | inner: ‹∀ 0. α49'›
//│ | | | | raised: ((α43', α44', α45',) -> ‹∀ 1. α49_56''›)
//│ | | | |   where: 
//│ 		α43' <: Int
//│ 		α44' <: Int
//│ 		α45' <: Int
//│ 		α49_56'' :> Int
//│ | | | | DISTRIB-L'  ~>  ‹∀ 0. ((α43', α44', α45',) -> ‹∀ 1. α49_56''›)›
//│ | | | | 0. C ‹∀ 0. ((α43', α44', α45',) -> ‹∀ 1. α49_56''›)› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α55)    (2)
//│ | | | | | could be distribbed: Set()
//│ | | | | | INST [0]   ‹∀ 0. ((α43', α44', α45',) -> ‹∀ 1. α49_56''›)›
//│ | | | | |   where  
//│ 		α43' <: Int
//│ 		α44' <: Int
//│ 		α45' <: Int
//│ 		α49_56'' :> Int
//│ | | | | | TO [0] ~>  ((α43_57, α44_58, α45_59,) -> ‹∀ 1. α49_56''›)
//│ | | | | |   where  
//│ 		α49_56'' :> Int
//│ 		α43_57 <: Int
//│ 		α44_58 <: Int
//│ 		α45_59 <: Int
//│ | | | | | 0. C ((α43_57, α44_58, α45_59,) -> ‹∀ 1. α49_56''›) <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α55)    (5)
//│ | | | | | | 0. C (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) <! (α43_57, α44_58, α45_59,)    (3)
//│ | | | | | | | 0. C #1<Int,Num,Object> <! α43_57    (4)
//│ | | | | | | | | NEW α43_57 LB (0)
//│ | | | | | | | | 0. C #1<Int,Num,Object> <! Int    (7)
//│ | | | | | | | 0. C #2<Int,Num,Object> <! α44_58    (4)
//│ | | | | | | | | NEW α44_58 LB (0)
//│ | | | | | | | | 0. C #2<Int,Num,Object> <! Int    (7)
//│ | | | | | | | 0. C #3<Int,Num,Object> <! α45_59    (4)
//│ | | | | | | | | NEW α45_59 LB (0)
//│ | | | | | | | | 0. C #3<Int,Num,Object> <! Int    (7)
//│ | | | | | | 0. C ‹∀ 1. α49_56''› <! α55    (3)
//│ | | | | | | | NEW α55 LB (0)
//│ | | 0. : α55
//│ | : Some(α55)
//│ ======== TYPED ========
//│ res: Some(α55) where 
//│ 		α55 :> ‹∀ 1. α49_56''›
//│ 		α49_56'' :> Int
//│ Int
//│ res
//│     = -3

:d
fff(y: 2, z: 3, x: 1)
//│ 0. Typing TypingUnit(List(fff (y: 2, z: 3, x: 1,)))
//│ | Typing unit statements
//│ | | 0. Typing term fff (y: 2, z: 3, x: 1,)
//│ | | | applying-to-function => fff<class mlscript.Var>y: 2, z: 3, x: 1,<class mlscript.Tup>
//│ | | | now we should desugar in case of named args!
//│ | | | !!named args case!!
//│ | | | value => CompletedTypeInfo(TypedNuFun(0,fun fff = (x::0, y::1, z::2,) => * ('(' - (x,) (y,) ')',) (z,),((α43', α44', α45',) -> α49'))) class mlscript.TyperDatatypes$CompletedTypeInfo
//│ | | | TypedNuFun matched! fd => fun fff = (x::0, y::1, z::2,) => * ('(' - (x,) (y,) ')',) (z,)
//│ | | | v and f => y Fld(false,false,2)
//│ | | | v and f => z Fld(false,false,3)
//│ | | | v and f => x Fld(false,false,1)
//│ | | | lhs is => class mlscript.Tup x::0, y::1, z::2,
//│ | | | funSignatureArgs => x::0, y::1, z::2, class mlscript.Tup Tup(_: Var(x), _: Var(y), _: Var(z))
//│ | | | (None,Fld(false,false,x::0)) Var(x) x::0 head!
//│ | | | y is here => List()
//│ | | | Desugared is here => let y = 2 in let z = 3 in let x = 1 in fff (x, y, z,)
//│ | | | 0. Typing term fff
//│ | | | 0. : ‹∀ 0. ((α43', α44', α45',) -> α49')›
//│ | | 0. : ‹∀ 0. ((α43', α44', α45',) -> α49')›
//│ | : Some(‹∀ 0. ((α43', α44', α45',) -> α49')›)
//│ ======== TYPED ========
//│ res: Some(‹∀ 0. ((α43', α44', α45',) -> α49')›) where 
//│ 		α43' <: Int
//│ 		α44' <: Int
//│ 		α45' <: Int
//│ 		α49' :> Int
//│ (Int, Int, Int,) -> Int
//│ res
//│     = -3


:p
let x1 = 1
let y1 = 2
let z1 = 3
//│ |#let| |x1| |#=| |1|↵|#let| |y1| |#=| |2|↵|#let| |z1| |#=| |3|
//│ AST: TypingUnit(NuFunDef(Some(false), x1, [], IntLit(1)), NuFunDef(Some(false), y1, [], IntLit(2)), NuFunDef(Some(false), z1, [], IntLit(3)))
//│ Parsed: let x1 = 1; let y1 = 2; let z1 = 3;
//│ let x1: 1
//│ let y1: 2
//│ let z1: 3
//│ x1
//│    = 1
//│ y1
//│    = 2
//│ z1
//│    = 3

:p
fff(x1, y1, z1)
//│ |fff|(|x1|,| |y1|,| |z1|)|
//│ AST: TypingUnit(App(Var(fff), Tup(_: Var(x1), _: Var(y1), _: Var(z1))))
//│ Parsed: fff (x1, y1, z1,);
//│ Int
//│ res
//│     = -3
