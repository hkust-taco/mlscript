// * Seeking Stability by Being Lazy and Shallow
// * Lazy and Shallow Instantiation Is User Friendly
// * https://dl.acm.org/doi/10.1145/3471874.3472985

// * A lot of these examples are transcribed lossily because we currently
// * do not have anything like explicit type applications and Haskell-style type classes.
// * It turns out most of the examples are very Haskell-specific and thus not insightful for us.


:NoRecursiveTypes



// Preliminary definitions


// id :: âˆ€ a. a â†’ a
def id: forall 'a. 'a -> 'a
//â”‚ id: 'a -> 'a
//â”‚   = <missing implementation>

// pair :: âˆ€ a. a â†’ âˆ€ b. b â†’ (a, b)
def pair: forall 'a. 'a -> (forall 'b. 'b -> ('a, 'b,))
pair x y = (x, y)
//â”‚ pair: 'a -> 'b -> ('a, 'b,)
//â”‚     = <missing implementation>
//â”‚ 'a -> 'b -> ('a, 'b,)
//â”‚   <:  pair:
//â”‚ 'a -> 'b -> ('a, 'b,)
//â”‚     = [Function: pair]

// myPairX x = pair x
myPairX x = pair x
//â”‚ myPairX: 'a -> 'b -> ('a, 'b,)
//â”‚        = [Function: myPairX]



// 3.1 Similarity 1: Let-Inlining and Extraction


// Example 1: myId

// myId = id
myId = id
//â”‚ myId: 'a -> 'a
//â”‚     = <no result>
//â”‚       id is not implemented


// Example 2: myPair

// myPair = pair
myPair = pair
//â”‚ myPair: 'a -> 'b -> ('a, 'b,)
//â”‚       = [Function: pair]


// Example 3: myPairX

// myPairX x = pair x
myPairX x = pair x
//â”‚ myPairX: 'a -> 'b -> ('a, 'b,)
//â”‚        = [Function: myPairX1]



// 3.2 Similarity 2: Signature Property
// (The second similarity annotates a let binding with the inferred type ðœŽ of the bound expression e1.)


// Example 4: infer

// infer = ðœ† @a (x :: a) â†’ x
infer = forall 'a. fun (x: 'a) -> x
//â”‚ infer: 'a -> 'a
//â”‚      = [Function: infer]

def infer: 'a -> 'a
infer = forall 'a. fun (x: 'a) -> x
//â”‚ infer: 'a -> 'a
//â”‚      = <missing implementation>
//â”‚ 'a -> 'a
//â”‚   <:  infer:
//â”‚ 'a -> 'a
//â”‚      = [Function: infer1]



// 3.3 Similarity 3: Type Signatures
// (Changing a type signature should not affect runtime semantics.)


// Example 5: swizzle

// undef :: âˆ€ a. Int â†’ a â†’ a
// undef = undefined
:re
def undef: forall 'a. int -> 'a -> 'a
undef = error
//â”‚ undef: int -> 'a -> 'a
//â”‚      = <missing implementation>
//â”‚ nothing
//â”‚   <:  undef:
//â”‚ int -> 'a -> 'a
//â”‚ Runtime error:
//â”‚   Error: unexpected runtime error

// swizzle :: Int â†’ âˆ€ a. a â†’ a
// swizzle = undef
:re
def swizzle: int -> (forall 'a. 'a -> 'a)
swizzle = undef
//â”‚ swizzle: int -> (forall 'a. 'a -> 'a)
//â”‚        = <missing implementation>
//â”‚ int -> 'a -> 'a
//â”‚   <:  swizzle:
//â”‚ int -> (forall 'a. 'a -> 'a)
//â”‚ Runtime error:
//â”‚   ReferenceError: undef is not defined

// In Haskell, "deeply skolemization" would eta expand swizzle as:
swizzle = fun x -> undef x
//â”‚ int -> 'a -> 'a
//â”‚   <:  swizzle:
//â”‚ int -> (forall 'a. 'a -> 'a)
//â”‚        = [Function: swizzle1]



// 3.4 Similarity 4: Pattern-Inlining and Extraction
// (changing variable patterns into ðœ†-binders)


// Example 6: infer2, again

// infer2 @a (x :: a) = x
infer2 = forall 'a. fun (x: 'a) -> x
//â”‚ infer2: 'a -> 'a
//â”‚       = [Function: infer2]



// 3.5 Similarity 5: Single vs. Multiple Equations


// Example 7: unitId1 and unitId2

unitId1 () = id
//â”‚ unitId1: () -> (forall 'a. 'a -> 'a)
//â”‚        = <no result>
//â”‚          id is not implemented

// Unlike in Haskell, here multiple equations simply shadow one another
unitId2 () = id
unitId2 () = id
//â”‚ unitId2: () -> (forall 'a. 'a -> 'a)
//â”‚        = <no result>
//â”‚          id is not implemented
//â”‚ unitId2: () -> (forall 'a. 'a -> 'a)
//â”‚        = <no result>
//â”‚          id is not implemented



// 3.6 Similarity 6: ðœ‚-Expansion


// Example 8: eta

// noEta = id
noEta = id
//â”‚ noEta: 'a -> 'a
//â”‚      = <no result>
//â”‚        id is not implemented

// eta = ðœ†x â†’ id x
eta = fun x -> id x
//â”‚ eta: 'a -> 'a
//â”‚    = <no result>
//â”‚      id is not implemented



