:NewParser

:d
:ne
:NoJS
let qq_int = code"10"
//│ 1. Typing term Quoted' 10 '
//│ | 1. Typing term 10
//│ | 1. : 10<int,number>
//│ 1. : Code[10<int,number>]
//│ ⬤ Typed as: Code[10<int,number>]
//│  where: 
//│ qq_int: code & {Code#T <: 10}

:d 
:ne
:NoJS
let qq_bool : Code<int> = code"10+2"
//│ 1. Typing term Quoted' + (10,) (2,) ' : AppliedType(TypeName(Code),List(TypeName(int)))
//│ | 1. Typing term Quoted' + (10,) (2,) '
//│ | | 1. Typing term + (10,) (2,)
//│ | | | 1. Typing term + (10,)
//│ | | | | 1. Typing term +
//│ | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 1. Typing term 10,
//│ | | | | | 1. Typing term 10
//│ | | | | | 1. : 10<int,number>
//│ | | | | 1. : (10<int,number>,)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (10<int,number> -> α24')
//│ | | | |   where 
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (10<int,number> -> α24')    (0)
//│ | | | | | C (10<int,number>,) <! (int<number>,)    (1)
//│ | | | | | C (int<number> -> int<number>) <! α24'    (1)
//│ | | | 1. : α24'
//│ | | | 1. Typing term 2,
//│ | | | | 1. Typing term 2
//│ | | | | 1. : 2<int,number>
//│ | | | 1. : (2<int,number>,)
//│ | | | CONSTRAIN α24' <! (2<int,number> -> α25')
//│ | | |   where 
//│ 		α24' :> (int<number> -> int<number>)
//│ | | | C α24' <! (2<int,number> -> α25')    (0)
//│ | | | | C (int<number> -> int<number>) <! (2<int,number> -> α25')    (1)
//│ | | | | | C (2<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α25'    (2)
//│ | | 1. : α25'
//│ | 1. : Code[α25']
//│ | 1. Typing type AppliedType(TypeName(Code),List(TypeName(int)))
//│ | | vars=Map() newDefsInfo=Map()
//│ | => Code[Int] | 
//│ | CONSTRAIN Code[α25'] <! Code[Int]
//│ |   where 
//│ 		α25' :> int<number>
//│ | C Code[α25'] <! Code[Int]    (0)
//│ | | C α25' <! Int    (1)
//│ | | | C int<number> <! Int    (2)
//│ 1. : Code[Int]
//│ ⬤ Typed as: Code[Int]
//│  where: 
//│ qq_bool: code & {Code#T <: int}
