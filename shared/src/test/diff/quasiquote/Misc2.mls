:NewParser

:e // Should be an error
code"let x = 1 in ${ 1 }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: 1<int,number>
//│ ║  l.4: 	code"let x = 1 in ${ 1 }"
//│ ╙──     	                     ^
//│ res: code & {Code#C = anything, Code#T <: error}
//│    = [ 'Let', 'x', Symbol(x), [ '_', 1 ], [ 'Unquoted', 1 ] ]

:e // Should be two errors
code"let x = 1 in ${ x }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: [x.type27]
//│ ║  l.12: 	code"let x = 1 in ${ x }"
//│ ╙──      	                     ^
//│ res: code & {Code#C = anything, Code#T <: error}
//│ Code generation encountered an error:
//│   unresolved symbol x

// The type is wrong
code"let x = 1 in ${ code"x + 1" }"
//│ res: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Unquoted', [ 'App', '+', [Array], [Array] ] ]
//│      ]

:e
1 + code"2"
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.32: 	1 + code"2"
//│ ║        	^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C = anything, Code#T <: 2}` is not an instance of type `int`
//│ res: error | int
//│    = '1_,2'

:e // Should be an error
code"let x = 1 in ${ code"x + ${ x }" }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: [x.type41]
//│ ║  l.41: 	code"let x = 1 in ${ code"x + ${ x }" }"
//│ ╙──      	                                 ^
//│ res: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
//│ Code generation encountered an error:
//│   unresolved symbol x


fun x: Code‹int›
//│ ╔══[ERROR] Wrong number of type arguments – expected 2, found 1
//│ ║  l.50: 	fun x: Code‹int›
//│ ╙──      	       ^^^^^^^^
//│ x: code & {Code#C = anything, Code#T <: int}
//│  = <missing implementation>

code"1 + ${x}"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: [Code[Int,α51]]
//│ ║  l.57: 	code"1 + ${x}"
//│ ╙──      	           ^
//│ res: code & {Code#C = anything, Code#T <: int}
//│    = <no result>
//│      x is not implemented

:NewParser
:d
:ne
:NoJS
code"let a = 1; ${a + code"b + ${a + b}" }"
//│ 0. Typing term Quoted' let a = 1 in Unquote' + (a,) (Quoted' + (b,) (Unquote' + (a,) (b,) ',) ',) ' '
//│ | 0. Typing term let a = 1 in Unquote' + (a,) (Quoted' + (b,) (Unquote' + (a,) (b,) ',) ',) '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term Unquote' + (a,) (Quoted' + (b,) (Unquote' + (a,) (b,) ',) ',) '
//│ | | | 0. Typing term + (a,) (Quoted' + (b,) (Unquote' + (a,) (b,) ',) ',)
//│ | | | | 0. Typing term + (a,)
//│ | | | | | 0. Typing term +
//│ | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | 0. Typing term a,
//│ | | | | | | 0. Typing term a
//│ | | | | | | | free: a
//│ | | | | | | 0. : a.type54
//│ | | | | | 0. : (a.type54,)
//│ | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (a.type54 -> α55)
//│ | | | | |   where 
//│ | | | | | C (int<number> -> (int<number> -> int<number>)) <! (a.type54 -> α55)    (0)
//│ | | | | | | C (a.type54,) <! (int<number>,)    (1)
//│ | | | | | | | C a.type54 <! int<number>    (2)
//│ | | | | | | C (int<number> -> int<number>) <! α55    (3)
//│ | | | | 0. : α55
//│ | | | | 0. Typing term Quoted' + (b,) (Unquote' + (a,) (b,) ',) ',
//│ | | | | | 0. Typing term Quoted' + (b,) (Unquote' + (a,) (b,) ',) '
//│ | | | | | | 0. Typing term + (b,) (Unquote' + (a,) (b,) ',)
//│ | | | | | | | 0. Typing term + (b,)
//│ | | | | | | | | 0. Typing term +
//│ | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | 0. Typing term b,
//│ | | | | | | | | | 0. Typing term b
//│ | | | | | | | | | | free: b
//│ | | | | | | | | | 0. : b.type56
//│ | | | | | | | | 0. : (b.type56,)
//│ | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (b.type56 -> α57)
//│ | | | | | | | |   where 
//│ | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (b.type56 -> α57)    (0)
//│ | | | | | | | | | C (b.type56,) <! (int<number>,)    (1)
//│ | | | | | | | | | | C b.type56 <! int<number>    (2)
//│ | | | | | | | | | C (int<number> -> int<number>) <! α57    (3)
//│ | | | | | | | 0. : α57
//│ | | | | | | | 0. Typing term Unquote' + (a,) (b,) ',
//│ | | | | | | | | 0. Typing term Unquote' + (a,) (b,) '
//│ | | | | | | | | | 0. Typing term + (a,) (b,)
//│ | | | | | | | | | | 0. Typing term + (a,)
//│ | | | | | | | | | | | 0. Typing term +
//│ | | | | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | 0. Typing term a,
//│ | | | | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | | | | 0. : a.type54
//│ | | | | | | | | | | | 0. : (a.type54,)
//│ | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (a.type54 -> α58)
//│ | | | | | | | | | | |   where 
//│ 		a.type54 <: int<number>
//│ | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (a.type54 -> α58)    (0)
//│ | | | | | | | | | | | | C (a.type54,) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! α58    (1)
//│ | | | | | | | | | | 0. : α58
//│ | | | | | | | | | | 0. Typing term b,
//│ | | | | | | | | | | | 0. Typing term b
//│ | | | | | | | | | | | | free: b
//│ | | | | | | | | | | | 0. : b.type59
//│ | | | | | | | | | | 0. : (b.type59,)
//│ | | | | | | | | | | CONSTRAIN α58 <! (b.type59 -> α60)
//│ | | | | | | | | | |   where 
//│ 		α58 :> (int<number> -> int<number>)
//│ | | | | | | | | | | C α58 <! (b.type59 -> α60)    (0)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! (b.type59 -> α60)    (1)
//│ | | | | | | | | | | | | C (b.type59,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C b.type59 <! int<number>    (3)
//│ | | | | | | | | | | | | C int<number> <! α60    (4)
//│ | | | | | | | | | 0. : α60
//│ | | | | | | | | 0. : error<>
//│ | | | | | | | 0. : (error<>,)
//│ | | | | | | | CONSTRAIN α57 <! (error<> -> α61)
//│ | | | | | | |   where 
//│ 		α57 :> (int<number> -> int<number>)
//│ | | | | | | | C α57 <! (error<> -> α61)    (0)
//│ | | | | | | | | C (int<number> -> int<number>) <! (error<> -> α61)    (1)
//│ | | | | | | | | | C (error<>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | C error<> <! int<number>    (3)
//│ | | | | | | | | | C int<number> <! α61    (4)
//│ | | | | | | 0. : α61
//│ | | | | | 0. : Code[α61,b.type5662]
//│ | | | | 0. : (Code[α61,b.type5662],)
//│ | | | | CONSTRAIN α55 <! (Code[α61,b.type5662] -> α63)
//│ | | | |   where 
//│ 		α55 :> (int<number> -> int<number>)
//│ 		α61 :> int<number>
//│ | | | | C α55 <! (Code[α61,b.type5662] -> α63)    (0)
//│ | | | | | C (int<number> -> int<number>) <! (Code[α61,b.type5662] -> α63)    (1)
//│ | | | | | | C (Code[α61,b.type5662],) <! (int<number>,)    (2)
//│ | | | | | | | C Code[α61,b.type5662] <! int<number>    (3)
//│ | | | | | | | | C (code<> & {Code#T: mut ..α61, Code#C: mut b.type5662..⊤}) <! int<number>    (4)
//│ | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α61, Code#C: mut b.type5662..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | Consider code<>{Code#T: mut ..α61, Code#C: mut b.type5662..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | A  code<>{Code#T: mut ..α61, Code#C: mut b.type5662..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..α61, Code#C: mut b.type5662..⊤}) <: int<number>
//│ | | | | | | | | | | | allVarPols: -b.type5662, +α64
//│ | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..α64, Code#C: mut b.type5662..⊤})
//│ | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..α64, Code#C: mut b.type5662..⊤})
//│ | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | norm[+] α64
//│ | | | | | | | | | | | | | DNF: DNF(α64)
//│ | | | | | | | | | | | | | norm[+] int<number>
//│ | | | | | | | | | | | | | | DNF: DNF(int<number>{})
//│ | | | | | | | | | | | | | ~> int<number>
//│ | | | | | | | | | | | | ~> α64
//│ | | | | | | | | | | | | norm[-] b.type5662
//│ | | | | | | | | | | | | | DNF: DNF(b.type5662)
//│ | | | | | | | | | | | | ~> b.type5662
//│ | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | ~> (code<> & {Code#C: mut b.type5662..⊤, Code#T: mut ..α64})
//│ | | | | | | | | | | | CONSTRAIN error<> <! α63
//│ | | | | | | | | | | |   where 
//│ | | | | | | | | | | | C error<> <! α63    (0)
//│ | | | | | | C int<number> <! α63    (5)
//│ | | | 0. : α63
//│ | | 0. : error<>
//│ | 0. : error<>
//│ 0. : Code[error<>,a.type54&b.type5965]
//│ ⬤ Typed as: Code[error<>,a.type54&b.type5965]
//│  where: 
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α60
//│ ║  l.69: 	code"let a = 1; ${a + code"b + ${a + b}" }"
//│ ╙──      	                                 ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.69: 	code"let a = 1; ${a + code"b + ${a + b}" }"
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?b.type56, Code#T <: ?a}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α63
//│ ║  l.69: 	code"let a = 1; ${a + code"b + ${a + b}" }"
//│ ╙──      	                  ^^^^^^^^^^^^^^^^^^^^^^
//│ res: code & {Code#C = anything, Code#T <: error}


code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α72
//│ ║  l.209: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──       	                                            ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.209: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?b.type68, Code#T <: ?a}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α75
//│ ║  l.209: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──       	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ res: code & {Code#C = anything, Code#T <: error}

:NewParser
:d
:ne
:NoJS
code"let a = 1; ${code"let b = 1; ${code"a + b"}"}"
//│ 0. Typing term Quoted' let a = 1 in Unquote' Quoted' let b = 1 in Unquote' Quoted' + (a,) (b,) ' ' ' ' '
//│ | 0. Typing term let a = 1 in Unquote' Quoted' let b = 1 in Unquote' Quoted' + (a,) (b,) ' ' ' '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term Unquote' Quoted' let b = 1 in Unquote' Quoted' + (a,) (b,) ' ' ' '
//│ | | | 0. Typing term Quoted' let b = 1 in Unquote' Quoted' + (a,) (b,) ' ' '
//│ | | | | 0. Typing term let b = 1 in Unquote' Quoted' + (a,) (b,) ' '
//│ | | | | | 1. Typing term 1
//│ | | | | | 1. : 1<int,number>
//│ | | | | | 0. Typing term Unquote' Quoted' + (a,) (b,) ' '
//│ | | | | | | 0. Typing term Quoted' + (a,) (b,) '
//│ | | | | | | | 0. Typing term + (a,) (b,)
//│ | | | | | | | | 0. Typing term + (a,)
//│ | | | | | | | | | 0. Typing term +
//│ | | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | 0. Typing term a,
//│ | | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | | | free: a
//│ | | | | | | | | | | 0. : a.type79
//│ | | | | | | | | | 0. : (a.type79,)
//│ | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (a.type79 -> α80)
//│ | | | | | | | | |   where 
//│ | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (a.type79 -> α80)    (0)
//│ | | | | | | | | | | C (a.type79,) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C a.type79 <! int<number>    (2)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! α80    (3)
//│ | | | | | | | | 0. : α80
//│ | | | | | | | | 0. Typing term b,
//│ | | | | | | | | | 0. Typing term b
//│ | | | | | | | | | | free: b
//│ | | | | | | | | | 0. : b.type81
//│ | | | | | | | | 0. : (b.type81,)
//│ | | | | | | | | CONSTRAIN α80 <! (b.type81 -> α82)
//│ | | | | | | | |   where 
//│ 		α80 :> (int<number> -> int<number>)
//│ | | | | | | | | C α80 <! (b.type81 -> α82)    (0)
//│ | | | | | | | | | C (int<number> -> int<number>) <! (b.type81 -> α82)    (1)
//│ | | | | | | | | | | C (b.type81,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C b.type81 <! int<number>    (3)
//│ | | | | | | | | | | C int<number> <! α82    (4)
//│ | | | | | | | 0. : α82
//│ | | | | | | 0. : Code[α82,b.type81&a.type7983]
//│ | | | | | 0. : Code[α82,b.type81&a.type7983]
//│ | | | | 0. : Code[α82,b.type81&a.type7983]
//│ | | | 0. : Code[Code[α82,b.type81&a.type7983],Anything]
//│ | | 0. : Code[α82,b.type81&a.type7983]
//│ | 0. : Code[α82,b.type81&a.type7983]
//│ 0. : Code[Code[α82,b.type81&a.type7983],Anything]
//│ ⬤ Typed as: Code[Code[α82,b.type81&a.type7983],Anything]
//│  where: 
//│ 		α82 :> int<number>
//│ res: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
