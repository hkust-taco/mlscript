:NewParser
:d
:ne
:NoJS
code"a + b"
//│ 0. Typing term Quoted' + (a,) (b,) '
//│ | 0. Typing term + (a,) (b,)
//│ | | 0. Typing term + (a,)
//│ | | | 0. Typing term +
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term a,
//│ | | | | 0. Typing term a
//│ | | | | | free: a
//│ | | | | 0. : a.type27
//│ | | | 0. : (a.type27,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (a.type27 -> α28)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (a.type27 -> α28)    (0)
//│ | | | | C (a.type27,) <! (int<number>,)    (1)
//│ | | | | | C a.type27 <! int<number>    (2)
//│ | | | | C (int<number> -> int<number>) <! α28    (3)
//│ | | 0. : α28
//│ | | 0. Typing term b,
//│ | | | 0. Typing term b
//│ | | | | free: b
//│ | | | 0. : b.type29
//│ | | 0. : (b.type29,)
//│ | | CONSTRAIN α28 <! (b.type29 -> α30)
//│ | |   where 
//│ 		α28 :> (int<number> -> int<number>)
//│ | | C α28 <! (b.type29 -> α30)    (0)
//│ | | | C (int<number> -> int<number>) <! (b.type29 -> α30)    (1)
//│ | | | | C (b.type29,) <! (int<number>,)    (2)
//│ | | | | | C b.type29 <! int<number>    (3)
//│ | | | | C int<number> <! α30    (4)
//│ | 0. : α30
//│ 0. : Code[α30,a.type27&b.type2931]
//│ ⬤ Typed as: Code[α30,a.type27&b.type2931]
//│  where: 
//│ 		α30 :> int<number>
//│ res: code & {Code#C = anything, Code#T <: int}

:NewParser
:d
:ne
:NoJS
code"let a = 1; ${code"b + ${code"1"}"} + 1"
//│ 0. Typing term Quoted' let a = 1 in + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,) '
//│ | 0. Typing term let a = 1 in + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,)
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,)
//│ | | | 0. Typing term + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',)
//│ | | | | 0. Typing term +
//│ | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 0. Typing term Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',
//│ | | | | | 0. Typing term Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' '
//│ | | | | | | 0. Typing term Quoted' + (b,) (Unquote' Quoted' 1 ' ',) '
//│ | | | | | | | 0. Typing term + (b,) (Unquote' Quoted' 1 ' ',)
//│ | | | | | | | | 0. Typing term + (b,)
//│ | | | | | | | | | 0. Typing term +
//│ | | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | 0. Typing term b,
//│ | | | | | | | | | | 0. Typing term b
//│ | | | | | | | | | | | free: b
//│ | | | | | | | | | | 0. : b.type34
//│ | | | | | | | | | 0. : (b.type34,)
//│ | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (b.type34 -> α35)
//│ | | | | | | | | |   where 
//│ | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (b.type34 -> α35)    (0)
//│ | | | | | | | | | | C (b.type34,) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C b.type34 <! int<number>    (2)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! α35    (3)
//│ | | | | | | | | 0. : α35
//│ | | | | | | | | 0. Typing term Unquote' Quoted' 1 ' ',
//│ | | | | | | | | | 0. Typing term Unquote' Quoted' 1 ' '
//│ | | | | | | | | | | 0. Typing term Quoted' 1 '
//│ | | | | | | | | | | | 0. Typing term 1
//│ | | | | | | | | | | | 0. : 1<int,number>
//│ | | | | | | | | | | 0. : Code[1<int,number>,Anything]
//│ | | | | | | | | | 0. : 1<int,number>
//│ | | | | | | | | 0. : (1<int,number>,)
//│ | | | | | | | | CONSTRAIN α35 <! (1<int,number> -> α36)
//│ | | | | | | | |   where 
//│ 		α35 :> (int<number> -> int<number>)
//│ | | | | | | | | C α35 <! (1<int,number> -> α36)    (0)
//│ | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α36)    (1)
//│ | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | C int<number> <! α36    (2)
//│ | | | | | | | 0. : α36
//│ | | | | | | 0. : Code[α36,b.type3437]
//│ | | | | | 0. : Code[α36,b.type3437]
//│ | | | | 0. : (Code[α36,b.type3437],)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (Code[α36,b.type3437] -> α38)
//│ | | | |   where 
//│ 		α36 :> int<number>
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (Code[α36,b.type3437] -> α38)    (0)
//│ | | | | | C (Code[α36,b.type3437],) <! (int<number>,)    (1)
//│ | | | | | | C Code[α36,b.type3437] <! int<number>    (2)
//│ | | | | | | | C (code<> & {Code#T: mut ..α36, Code#C: mut b.type3437..⊤}) <! int<number>    (3)
//│ | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α36, Code#C: mut b.type3437..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | Consider code<>{Code#T: mut ..α36, Code#C: mut b.type3437..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | Possible: List()
//│ | | | | | | | | | A  code<>{Code#T: mut ..α36, Code#C: mut b.type3437..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..α36, Code#C: mut b.type3437..⊤}) <: int<number>
//│ | | | | | | | | | | allVarPols: -b.type3437, +α39
//│ | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..α39, Code#C: mut b.type3437..⊤})
//│ | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..α39, Code#C: mut b.type3437..⊤})
//│ | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | norm[+] α39
//│ | | | | | | | | | | | | DNF: DNF(α39)
//│ | | | | | | | | | | | | norm[+] int<number>
//│ | | | | | | | | | | | | | DNF: DNF(int<number>{})
//│ | | | | | | | | | | | | ~> int<number>
//│ | | | | | | | | | | | ~> α39
//│ | | | | | | | | | | | norm[-] b.type3437
//│ | | | | | | | | | | | | DNF: DNF(b.type3437)
//│ | | | | | | | | | | | ~> b.type3437
//│ | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | ~> (code<> & {Code#C: mut b.type3437..⊤, Code#T: mut ..α39})
//│ | | | | | | | | | | CONSTRAIN error<> <! α38
//│ | | | | | | | | | |   where 
//│ | | | | | | | | | | C error<> <! α38    (0)
//│ | | | | | C (int<number> -> int<number>) <! α38    (4)
//│ | | | 0. : α38
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN α38 <! (1<int,number> -> α40)
//│ | | |   where 
//│ 		α38 :> (int<number> -> int<number>) | error<>
//│ | | | C α38 <! (1<int,number> -> α40)    (0)
//│ | | | | C (int<number> -> int<number>) <! (1<int,number> -> α40)    (1)
//│ | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α40    (2)
//│ | | | | C error<> <! (1<int,number> -> α40)    (3)
//│ | | | | | C (1<int,number>,) <! error<>    (4)
//│ | | | | | C error<> <! α40    (5)
//│ | | 0. : α40
//│ | 0. : α40
//│ 0. : Code[α40,Anything]
//│ ⬤ Typed as: Code[α40,Anything]
//│  where: 
//│ 		α40 :> error<> | int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.47: 	code"let a = 1; ${code"b + ${code"1"}"} + 1"
//│ ║        	                ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?b.type34, Code#T <: ?a}` is not an instance of type `int`
//│ res: code & {Code#C = anything, Code#T <: error | int}


:NewParser
:d
:ne
:NoJS
code"let a = 10000; a + ${code"a"} + 10"
//│ 0. Typing term Quoted' let a = 10000 in + (+ (a,) (Unquote' Quoted' a ' ',),) (10,) '
//│ | 0. Typing term let a = 10000 in + (+ (a,) (Unquote' Quoted' a ' ',),) (10,)
//│ | | 1. Typing term 10000
//│ | | 1. : 10000<int,number>
//│ | | 0. Typing term + (+ (a,) (Unquote' Quoted' a ' ',),) (10,)
//│ | | | 0. Typing term + (+ (a,) (Unquote' Quoted' a ' ',),)
//│ | | | | 0. Typing term +
//│ | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 0. Typing term + (a,) (Unquote' Quoted' a ' ',),
//│ | | | | | 0. Typing term + (a,) (Unquote' Quoted' a ' ',)
//│ | | | | | | 0. Typing term + (a,)
//│ | | | | | | | 0. Typing term +
//│ | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | 0. Typing term a,
//│ | | | | | | | | 0. Typing term a
//│ | | | | | | | | 0. : 10000<int,number>
//│ | | | | | | | 0. : (10000<int,number>,)
//│ | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (10000<int,number> -> α42)
//│ | | | | | | |   where 
//│ | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (10000<int,number> -> α42)    (0)
//│ | | | | | | | | C (10000<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | | C (int<number> -> int<number>) <! α42    (1)
//│ | | | | | | 0. : α42
//│ | | | | | | 0. Typing term Unquote' Quoted' a ' ',
//│ | | | | | | | 0. Typing term Unquote' Quoted' a ' '
//│ | | | | | | | | 0. Typing term Quoted' a '
//│ | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | | free: a
//│ | | | | | | | | | 0. : a.type43
//│ | | | | | | | | 0. : Code[a.type43,a.type4344]
//│ | | | | | | | 0. : Code[a.type43,a.type4344]
//│ | | | | | | 0. : (Code[a.type43,a.type4344],)
//│ | | | | | | CONSTRAIN α42 <! (Code[a.type43,a.type4344] -> α45)
//│ | | | | | |   where 
//│ 		α42 :> (int<number> -> int<number>)
//│ | | | | | | C α42 <! (Code[a.type43,a.type4344] -> α45)    (0)
//│ | | | | | | | C (int<number> -> int<number>) <! (Code[a.type43,a.type4344] -> α45)    (1)
//│ | | | | | | | | C (Code[a.type43,a.type4344],) <! (int<number>,)    (2)
//│ | | | | | | | | | C Code[a.type43,a.type4344] <! int<number>    (3)
//│ | | | | | | | | | | C (code<> & {Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | Consider code<>{Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | A  code<>{Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤}) <: int<number>
//│ | | | | | | | | | | | | | allVarPols: +a.type43, -a.type4344
//│ | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤})
//│ | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..a.type43, Code#C: mut a.type4344..⊤})
//│ | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | norm[+] a.type43
//│ | | | | | | | | | | | | | | | DNF: DNF(a.type43)
//│ | | | | | | | | | | | | | | ~> a.type43
//│ | | | | | | | | | | | | | | norm[-] a.type4344
//│ | | | | | | | | | | | | | | | DNF: DNF(a.type4344)
//│ | | | | | | | | | | | | | | ~> a.type4344
//│ | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | ~> (code<> & {Code#C: mut a.type4344..⊤, Code#T: mut ..a.type43})
//│ | | | | | | | | | | | | | CONSTRAIN error<> <! α45
//│ | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | C error<> <! α45    (0)
//│ | | | | | | | | C int<number> <! α45    (5)
//│ | | | | | 0. : α45
//│ | | | | 0. : (α45,)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α45 -> α46)
//│ | | | |   where 
//│ 		α45 :> int<number> | error<>
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (α45 -> α46)    (0)
//│ | | | | | C (α45,) <! (int<number>,)    (1)
//│ | | | | | | C α45 <! int<number>    (2)
//│ | | | | | | | C int<number> <! int<number>    (3)
//│ | | | | | | | C error<> <! int<number>    (3)
//│ | | | | | C (int<number> -> int<number>) <! α46    (4)
//│ | | | 0. : α46
//│ | | | 0. Typing term 10,
//│ | | | | 0. Typing term 10
//│ | | | | 0. : 10<int,number>
//│ | | | 0. : (10<int,number>,)
//│ | | | CONSTRAIN α46 <! (10<int,number> -> α47)
//│ | | |   where 
//│ 		α46 :> (int<number> -> int<number>)
//│ | | | C α46 <! (10<int,number> -> α47)    (0)
//│ | | | | C (int<number> -> int<number>) <! (10<int,number> -> α47)    (1)
//│ | | | | | C (10<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α47    (2)
//│ | | 0. : α47
//│ | 0. : α47
//│ 0. : Code[α47,Anything]
//│ ⬤ Typed as: Code[α47,Anything]
//│  where: 
//│ 		α47 :> int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.161: 	code"let a = 10000; a + ${code"a"} + 10"
//│ ║         	                    ^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?a.type43, Code#T <: ?a.type}` is not an instance of type `int`
//│ res: code & {Code#C = anything, Code#T <: int}
