:NewParser
:d
:ne
:NoJS
fun Const(n) = code"${code"n"}"
code"a + b"
//│ 1. Typing term n, => Quoted' Unquote' Quoted' n ' ' '
//│ | 1. Typing pattern n,
//│ | | 1. Typing pattern n
//│ | | 1. : α25'
//│ | 1. : (α25',)
//│ | 1. Typing term Quoted' Unquote' Quoted' n ' ' '
//│ | | 1. Typing term Unquote' Quoted' n ' '
//│ | | | 1. Typing term Quoted' n '
//│ | | | | 1. Typing term n
//│ | | | | 1. : α25'
//│ | | | 1. : Code[α25',Anything]
//│ | | | check subtypeCode[α25',Anything]
//│ | | | true
//│ | | | true
//│ | | 1. : Code[α25',Anything]
//│ | 1. : Code[Code[α25',Anything],Anything]
//│ 1. : (α25' -> Code[Code[α25',Anything],Anything])
//│ CONSTRAIN (α25' -> Code[Code[α25',Anything],Anything]) <! Const24'
//│   where 
//│ C (α25' -> Code[Code[α25',Anything],Anything]) <! Const24'    (0)
//│ ⬤ Typed as: Const24'
//│  where: 
//│ 		Const24' :> (α25' -> Code[Code[α25',Anything],Anything])
//│ 0. Typing term Quoted' + (a,) (b,) '
//│ | 0. Typing term + (a,) (b,)
//│ | | 0. Typing term + (a,)
//│ | | | 0. Typing term +
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term a,
//│ | | | | 0. Typing term a
//│ | | | | 0. : a.type28
//│ | | | 0. : (a.type28,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (a.type28 -> α29)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (a.type28 -> α29)    (0)
//│ | | | | C (a.type28,) <! (int<number>,)    (1)
//│ | | | | | C a.type28 <! int<number>    (2)
//│ | | | | C (int<number> -> int<number>) <! α29    (3)
//│ | | 0. : α29
//│ | | 0. Typing term b,
//│ | | | 0. Typing term b
//│ | | | 0. : b.type30
//│ | | 0. : (b.type30,)
//│ | | CONSTRAIN α29 <! (b.type30 -> α31)
//│ | |   where 
//│ 		α29 :> (int<number> -> int<number>)
//│ | | C α29 <! (b.type30 -> α31)    (0)
//│ | | | C (int<number> -> int<number>) <! (b.type30 -> α31)    (1)
//│ | | | | C (b.type30,) <! (int<number>,)    (2)
//│ | | | | | C b.type30 <! int<number>    (3)
//│ | | | | C int<number> <! α31    (4)
//│ | 0. : α31
//│ 0. : Code[α31,a.type28&b.type3032]
//│ ⬤ Typed as: Code[α31,a.type28&b.type3032]
//│  where: 
//│ 		α31 :> int<number>
//│ Const: anything -> code
//│ res: code

:NewParser
:d
:ne
:NoJS
code"let a = 1; ${code"b + ${code"1"}"} + 1"
//│ 0. Typing term Quoted' let a = 1 in + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,) '
//│ | 0. Typing term let a = 1 in + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,)
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',) (1,)
//│ | | | 0. Typing term + (Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',)
//│ | | | | 0. Typing term +
//│ | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 0. Typing term Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' ',
//│ | | | | | 0. Typing term Unquote' Quoted' + (b,) (Unquote' Quoted' 1 ' ',) ' '
//│ | | | | | | 0. Typing term Quoted' + (b,) (Unquote' Quoted' 1 ' ',) '
//│ | | | | | | | 0. Typing term + (b,) (Unquote' Quoted' 1 ' ',)
//│ | | | | | | | | 0. Typing term + (b,)
//│ | | | | | | | | | 0. Typing term +
//│ | | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | 0. Typing term b,
//│ | | | | | | | | | | 0. Typing term b
//│ | | | | | | | | | | 0. : b.type33
//│ | | | | | | | | | 0. : (b.type33,)
//│ | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (b.type33 -> α34)
//│ | | | | | | | | |   where 
//│ | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (b.type33 -> α34)    (0)
//│ | | | | | | | | | | C (b.type33,) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C b.type33 <! int<number>    (2)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! α34    (3)
//│ | | | | | | | | 0. : α34
//│ | | | | | | | | 0. Typing term Unquote' Quoted' 1 ' ',
//│ | | | | | | | | | 0. Typing term Unquote' Quoted' 1 ' '
//│ | | | | | | | | | | 0. Typing term Quoted' 1 '
//│ | | | | | | | | | | | 0. Typing term 1
//│ | | | | | | | | | | | 0. : 1<int,number>
//│ | | | | | | | | | | 0. : Code[1<int,number>,Anything]
//│ | | | | | | | | | | check subtypeCode[1<int,number>,Anything]
//│ | | | | | | | | | | true
//│ | | | | | | | | | | true
//│ | | | | | | | | | 0. : Code[1<int,number>,Anything]
//│ | | | | | | | | 0. : (Code[1<int,number>,Anything],)
//│ | | | | | | | | CONSTRAIN α34 <! (Code[1<int,number>,Anything] -> α35)
//│ | | | | | | | |   where 
//│ 		α34 :> (int<number> -> int<number>)
//│ | | | | | | | | C α34 <! (Code[1<int,number>,Anything] -> α35)    (0)
//│ | | | | | | | | | C (int<number> -> int<number>) <! (Code[1<int,number>,Anything] -> α35)    (1)
//│ | | | | | | | | | | C (Code[1<int,number>,Anything],) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C Code[1<int,number>,Anything] <! int<number>    (3)
//│ | | | | | | | | | | | | C (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | | | Consider code<>{Code#T: mut ..⊤, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | | | A  code<>{Code#T: mut ..⊤, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <: int<number>
//│ | | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..⊤})
//│ | | | | | | | | | | | | | | | CONSTRAIN error<> <! α35
//│ | | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | | C error<> <! α35    (0)
//│ | | | | | | | | | | C int<number> <! α35    (5)
//│ | | | | | | | 0. : α35
//│ | | | | | | 0. : Code[α35,b.type3336]
//│ | | | | | | check subtypeCode[α35,b.type3336]
//│ | | | | | | true
//│ | | | | | | true
//│ | | | | | 0. : Code[α35,b.type3336]
//│ | | | | 0. : (Code[α35,b.type3336],)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (Code[α35,b.type3336] -> α37)
//│ | | | |   where 
//│ 		α35 :> int<number> | error<>
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (Code[α35,b.type3336] -> α37)    (0)
//│ | | | | | C (Code[α35,b.type3336],) <! (int<number>,)    (1)
//│ | | | | | | C Code[α35,b.type3336] <! int<number>    (2)
//│ | | | | | | | C (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <! int<number>    (3)
//│ | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | Consider code<>{Code#T: mut ..⊤, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | Possible: List()
//│ | | | | | | | | | A  code<>{Code#T: mut ..⊤, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <: int<number>
//│ | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..⊤})
//│ | | | | | | | | | | CONSTRAIN error<> <! α37
//│ | | | | | | | | | |   where 
//│ | | | | | | | | | | C error<> <! α37    (0)
//│ | | | | | C (int<number> -> int<number>) <! α37    (4)
//│ | | | 0. : α37
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN α37 <! (1<int,number> -> α38)
//│ | | |   where 
//│ 		α37 :> (int<number> -> int<number>) | error<>
//│ | | | C α37 <! (1<int,number> -> α38)    (0)
//│ | | | | C (int<number> -> int<number>) <! (1<int,number> -> α38)    (1)
//│ | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α38    (2)
//│ | | | | C error<> <! (1<int,number> -> α38)    (3)
//│ | | | | | C (1<int,number>,) <! error<>    (4)
//│ | | | | | C error<> <! α38    (5)
//│ | | 0. : α38
//│ | 0. : α38
//│ 0. : Code[α38,Anything]
//│ ⬤ Typed as: Code[α38,Anything]
//│  where: 
//│ 		α38 :> error<> | int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.70: 	code"let a = 1; ${code"b + ${code"1"}"} + 1"
//│ ║        	                       ^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.70: 	code"let a = 1; ${code"b + ${code"1"}"} + 1"
//│ ║        	                ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T}` is not an instance of type `int`
//│ res: code


:NewParser
:d
:ne
:NoJS
code"let a = 10000; a + ${code"a"} + 10"
//│ 0. Typing term Quoted' let a = 10000 in + (+ (a,) (Unquote' Quoted' a ' ',),) (10,) '
//│ | 0. Typing term let a = 10000 in + (+ (a,) (Unquote' Quoted' a ' ',),) (10,)
//│ | | 1. Typing term 10000
//│ | | 1. : 10000<int,number>
//│ | | 0. Typing term + (+ (a,) (Unquote' Quoted' a ' ',),) (10,)
//│ | | | 0. Typing term + (+ (a,) (Unquote' Quoted' a ' ',),)
//│ | | | | 0. Typing term +
//│ | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 0. Typing term + (a,) (Unquote' Quoted' a ' ',),
//│ | | | | | 0. Typing term + (a,) (Unquote' Quoted' a ' ',)
//│ | | | | | | 0. Typing term + (a,)
//│ | | | | | | | 0. Typing term +
//│ | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | 0. Typing term a,
//│ | | | | | | | | 0. Typing term a
//│ | | | | | | | | 0. : 10000<int,number>
//│ | | | | | | | 0. : (10000<int,number>,)
//│ | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (10000<int,number> -> α39)
//│ | | | | | | |   where 
//│ | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (10000<int,number> -> α39)    (0)
//│ | | | | | | | | C (10000<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | | C (int<number> -> int<number>) <! α39    (1)
//│ | | | | | | 0. : α39
//│ | | | | | | 0. Typing term Unquote' Quoted' a ' ',
//│ | | | | | | | 0. Typing term Unquote' Quoted' a ' '
//│ | | | | | | | | 0. Typing term Quoted' a '
//│ | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | 0. : a.type40
//│ | | | | | | | | 0. : Code[a.type40,a.type4041]
//│ | | | | | | | | check subtypeCode[a.type40,a.type4041]
//│ | | | | | | | | true
//│ | | | | | | | | true
//│ | | | | | | | 0. : Code[a.type40,a.type4041]
//│ | | | | | | 0. : (Code[a.type40,a.type4041],)
//│ | | | | | | CONSTRAIN α39 <! (Code[a.type40,a.type4041] -> α42)
//│ | | | | | |   where 
//│ 		α39 :> (int<number> -> int<number>)
//│ | | | | | | C α39 <! (Code[a.type40,a.type4041] -> α42)    (0)
//│ | | | | | | | C (int<number> -> int<number>) <! (Code[a.type40,a.type4041] -> α42)    (1)
//│ | | | | | | | | C (Code[a.type40,a.type4041],) <! (int<number>,)    (2)
//│ | | | | | | | | | C Code[a.type40,a.type4041] <! int<number>    (3)
//│ | | | | | | | | | | C (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | Consider code<>{Code#T: mut ..⊤, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | A  code<>{Code#T: mut ..⊤, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <: int<number>
//│ | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..⊤})
//│ | | | | | | | | | | | | | CONSTRAIN error<> <! α42
//│ | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | C error<> <! α42    (0)
//│ | | | | | | | | C int<number> <! α42    (5)
//│ | | | | | 0. : α42
//│ | | | | 0. : (α42,)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)
//│ | | | |   where 
//│ 		α42 :> int<number> | error<>
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)    (0)
//│ | | | | | C (α42,) <! (int<number>,)    (1)
//│ | | | | | | C α42 <! int<number>    (2)
//│ | | | | | | | C int<number> <! int<number>    (3)
//│ | | | | | | | C error<> <! int<number>    (3)
//│ | | | | | C (int<number> -> int<number>) <! α43    (4)
//│ | | | 0. : α43
//│ | | | 0. Typing term 10,
//│ | | | | 0. Typing term 10
//│ | | | | 0. : 10<int,number>
//│ | | | 0. : (10<int,number>,)
//│ | | | CONSTRAIN α43 <! (10<int,number> -> α44)
//│ | | |   where 
//│ 		α43 :> (int<number> -> int<number>)
//│ | | | C α43 <! (10<int,number> -> α44)    (0)
//│ | | | | C (int<number> -> int<number>) <! (10<int,number> -> α44)    (1)
//│ | | | | | C (10<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α44    (2)
//│ | | 0. : α44
//│ | 0. : α44
//│ 0. : Code[α44,Anything]
//│ ⬤ Typed as: Code[α44,Anything]
//│  where: 
//│ 		α44 :> int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.216: 	code"let a = 10000; a + ${code"a"} + 10"
//│ ║         	                    ^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T}` is not an instance of type `int`
//│ res: code

let z = code"3"
//│ z: code

fun Const(n) = code"n"
//│ Const: anything -> code

:d
:ne
Const(42)
//│ 0. Typing term Const (42,)
//│ | 0. Typing term Const
//│ | 0. : Const49
//│ | 0. Typing term 42,
//│ | | 0. Typing term 42
//│ | | 0. : 42<int,number>
//│ | 0. : (42<int,number>,)
//│ | CONSTRAIN Const49 <! (42<int,number> -> α51)
//│ |   where 
//│ 		Const49 :> [(α50 -> Code[[α50],Anything])]
//│ | C Const49 <! (42<int,number> -> α51)    (0)
//│ | | C [(α50 -> Code[[α50],Anything])] <! (42<int,number> -> α51)    (1)
//│ | | | C (α50 -> Code[[α50],Anything]) <! (42<int,number> -> α51)    (1)
//│ | | | | C (42<int,number>,) <! (α50,)    (2)
//│ | | | | | C 42<int,number> <! α50    (3)
//│ | | | | C Code[[α50],Anything] <! α51    (4)
//│ 0. : α51
//│ ⬤ Typed as: α51
//│  where: 
//│ 		α50 :> 42<int,number>
//│ 		α51 :> Code[[α50],Anything]
//│ res: code

:d
:ne
code"let a = code"2"; code"(${a} + ${a}) * 2""
//│ 0. Typing term Quoted' let a = Quoted' 2 ' in Quoted' * (+ (Unquote' a ',) (Unquote' a ',),) (2,) ' '
//│ | 0. Typing term let a = Quoted' 2 ' in Quoted' * (+ (Unquote' a ',) (Unquote' a ',),) (2,) '
//│ | | 1. Typing term Quoted' 2 '
//│ | | | 1. Typing term 2
//│ | | | 1. : 2<int,number>
//│ | | 1. : Code[2<int,number>,Anything]
//│ | | 0. Typing term Quoted' * (+ (Unquote' a ',) (Unquote' a ',),) (2,) '
//│ | | | 0. Typing term * (+ (Unquote' a ',) (Unquote' a ',),) (2,)
//│ | | | | 0. Typing term * (+ (Unquote' a ',) (Unquote' a ',),)
//│ | | | | | 0. Typing term *
//│ | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | 0. Typing term + (Unquote' a ',) (Unquote' a ',),
//│ | | | | | | 0. Typing term + (Unquote' a ',) (Unquote' a ',)
//│ | | | | | | | 0. Typing term + (Unquote' a ',)
//│ | | | | | | | | 0. Typing term +
//│ | | | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | 0. Typing term Unquote' a ',
//│ | | | | | | | | | 0. Typing term Unquote' a '
//│ | | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | | 0. : Code[2<int,number>,Anything]
//│ | | | | | | | | | | check subtypeCode[2<int,number>,Anything]
//│ | | | | | | | | | | true
//│ | | | | | | | | | | true
//│ | | | | | | | | | 0. : Code[2<int,number>,Anything]
//│ | | | | | | | | 0. : (Code[2<int,number>,Anything],)
//│ | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (Code[2<int,number>,Anything] -> α53)
//│ | | | | | | | |   where 
//│ | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (Code[2<int,number>,Anything] -> α53)    (0)
//│ | | | | | | | | | C (Code[2<int,number>,Anything],) <! (int<number>,)    (1)
//│ | | | | | | | | | | C Code[2<int,number>,Anything] <! int<number>    (2)
//│ | | | | | | | | | | | C (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <! int<number>    (3)
//│ | | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | | Consider code<>{Code#T: mut ..⊤, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | | A  code<>{Code#T: mut ..⊤, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <: int<number>
//│ | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..⊤})
//│ | | | | | | | | | | | | | | CONSTRAIN error<> <! α53
//│ | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | C error<> <! α53    (0)
//│ | | | | | | | | | C (int<number> -> int<number>) <! α53    (4)
//│ | | | | | | | 0. : α53
//│ | | | | | | | 0. Typing term Unquote' a ',
//│ | | | | | | | | 0. Typing term Unquote' a '
//│ | | | | | | | | | 0. Typing term a
//│ | | | | | | | | | 0. : Code[2<int,number>,Anything]
//│ | | | | | | | | | check subtypeCode[2<int,number>,Anything]
//│ | | | | | | | | | true
//│ | | | | | | | | | true
//│ | | | | | | | | 0. : Code[2<int,number>,Anything]
//│ | | | | | | | 0. : (Code[2<int,number>,Anything],)
//│ | | | | | | | CONSTRAIN α53 <! (Code[2<int,number>,Anything] -> α54)
//│ | | | | | | |   where 
//│ 		α53 :> (int<number> -> int<number>) | error<>
//│ | | | | | | | C α53 <! (Code[2<int,number>,Anything] -> α54)    (0)
//│ | | | | | | | | C (int<number> -> int<number>) <! (Code[2<int,number>,Anything] -> α54)    (1)
//│ | | | | | | | | | C (Code[2<int,number>,Anything],) <! (int<number>,)    (2)
//│ | | | | | | | | | | C Code[2<int,number>,Anything] <! int<number>    (3)
//│ | | | | | | | | | | | C (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | | Consider code<>{Code#T: mut ..⊤, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | | A  code<>{Code#T: mut ..⊤, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤}) <: int<number>
//│ | | | | | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..⊤, Code#C: mut ..⊤})
//│ | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..⊤})
//│ | | | | | | | | | | | | | | CONSTRAIN error<> <! α54
//│ | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | C error<> <! α54    (0)
//│ | | | | | | | | | C int<number> <! α54    (5)
//│ | | | | | | | | C error<> <! (Code[2<int,number>,Anything] -> α54)    (6)
//│ | | | | | | | | | C (Code[2<int,number>,Anything],) <! error<>    (7)
//│ | | | | | | | | | C error<> <! α54    (8)
//│ | | | | | | 0. : α54
//│ | | | | | 0. : (α54,)
//│ | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α54 -> α55)
//│ | | | | |   where 
//│ 		α54 :> error<> | int<number> | error<>
//│ | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α54 -> α55)    (0)
//│ | | | | | | C (α54,) <! (int<number>,)    (1)
//│ | | | | | | | C α54 <! int<number>    (2)
//│ | | | | | | | | C error<> <! int<number>    (3)
//│ | | | | | | | | C int<number> <! int<number>    (4)
//│ | | | | | | | | C error<> <! int<number>    (4)
//│ | | | | | | | | | Cached!
//│ | | | | | | C (int<number> -> int<number>) <! α55    (4)
//│ | | | | 0. : α55
//│ | | | | 0. Typing term 2,
//│ | | | | | 0. Typing term 2
//│ | | | | | 0. : 2<int,number>
//│ | | | | 0. : (2<int,number>,)
//│ | | | | CONSTRAIN α55 <! (2<int,number> -> α56)
//│ | | | |   where 
//│ 		α55 :> (int<number> -> int<number>)
//│ | | | | C α55 <! (2<int,number> -> α56)    (0)
//│ | | | | | C (int<number> -> int<number>) <! (2<int,number> -> α56)    (1)
//│ | | | | | | C (2<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | C int<number> <! α56    (2)
//│ | | | 0. : α56
//│ | | 0. : Code[α56,Anything]
//│ | 0. : Code[α56,Anything]
//│ 0. : Code[Code[α56,Anything],Anything]
//│ ⬤ Typed as: Code[Code[α56,Anything],Anything]
//│  where: 
//│ 		α56 :> int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.353: 	code"let a = code"2"; code"(${a} + ${a}) * 2""
//│ ║         	                            ^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.353: 	code"let a = code"2"; code"(${a} + ${a}) * 2""
//│ ║         	                            ^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T}` is not an instance of type `int`
//│ res: code


:d
:ne
:NoJS
fun pow(n, cde) = if (n > 0) then code"${pow(n - 1, cde)} * ${cde}" else code"1"
//│ 1. Typing term n, cde, => if ('(' > (n,) (0,), ')') then Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) ' else Quoted' 1 '
//│ | 1. Typing pattern n, cde,
//│ | | 1. Typing pattern n
//│ | | 1. : α58'
//│ | | 1. Typing pattern cde
//│ | | 1. : α59'
//│ | 1. : (α58', α59',)
//│ | 1. Typing term if ('(' > (n,) (0,), ')') then Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) ' else Quoted' 1 '
//│ | | The mutable CaseOf tree
//│ | | if «'(' > (n,) (0,), ')'»
//│ | |   «Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) '»
//│ | | else
//│ | |   «Quoted' 1 '»
//│ | | Desugared term: case '(' > (n,) (0,), ')' of { true => Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) '; _ => Quoted' 1 ' }
//│ | | 1. Typing term case '(' > (n,) (0,), ')' of { true => Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) '; _ => Quoted' 1 ' }
//│ | | | 1. Typing term '(' > (n,) (0,), ')'
//│ | | | | 1. Typing term > (n,) (0,),
//│ | | | | | 1. Typing term > (n,) (0,)
//│ | | | | | | 1. Typing term > (n,)
//│ | | | | | | | 1. Typing term >
//│ | | | | | | | 1. : (number<> -> (number<> -> bool<>))
//│ | | | | | | | 1. Typing term n,
//│ | | | | | | | | 1. Typing term n
//│ | | | | | | | | 1. : α58'
//│ | | | | | | | 1. : (α58',)
//│ | | | | | | | CONSTRAIN (number<> -> (number<> -> bool<>)) <! (α58' -> α60')
//│ | | | | | | |   where 
//│ | | | | | | | C (number<> -> (number<> -> bool<>)) <! (α58' -> α60')    (0)
//│ | | | | | | | | C (α58',) <! (number<>,)    (1)
//│ | | | | | | | | | C α58' <! number<>    (2)
//│ | | | | | | | | C (number<> -> bool<>) <! α60'    (3)
//│ | | | | | | 1. : α60'
//│ | | | | | | 1. Typing term 0,
//│ | | | | | | | 1. Typing term 0
//│ | | | | | | | 1. : 0<int,number>
//│ | | | | | | 1. : (0<int,number>,)
//│ | | | | | | CONSTRAIN α60' <! (0<int,number> -> α61')
//│ | | | | | |   where 
//│ 		α60' :> (number<> -> bool<>)
//│ | | | | | | C α60' <! (0<int,number> -> α61')    (0)
//│ | | | | | | | C (number<> -> bool<>) <! (0<int,number> -> α61')    (1)
//│ | | | | | | | | C (0<int,number>,) <! (number<>,)    (2)
//│ | | | | | | | | C bool<> <! α61'    (2)
//│ | | | | | 1. : α61'
//│ | | | | 1. : (α61',)
//│ | | | 1. : (α61',)
//│ | | | 1. Typing term Quoted' * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',) '
//│ | | | | 1. Typing term * (Unquote' pow (- (n,) (1,), cde,) ',) (Unquote' cde ',)
//│ | | | | | 1. Typing term * (Unquote' pow (- (n,) (1,), cde,) ',)
//│ | | | | | | 1. Typing term *
//│ | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | 1. Typing term Unquote' pow (- (n,) (1,), cde,) ',
//│ | | | | | | | 1. Typing term Unquote' pow (- (n,) (1,), cde,) '
//│ | | | | | | | | 1. Typing term pow (- (n,) (1,), cde,)
//│ | | | | | | | | | 1. Typing term pow
//│ | | | | | | | | | 1. : pow57'
//│ | | | | | | | | | 1. Typing term - (n,) (1,), cde,
//│ | | | | | | | | | | 1. Typing term - (n,) (1,)
//│ | | | | | | | | | | | 1. Typing term - (n,)
//│ | | | | | | | | | | | | 1. Typing term -
//│ | | | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | | 1. Typing term n,
//│ | | | | | | | | | | | | | 1. Typing term n
//│ | | | | | | | | | | | | | 1. : α58'
//│ | | | | | | | | | | | | 1. : (α58',)
//│ | | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α58' -> α62')
//│ | | | | | | | | | | | |   where 
//│ 		α58' <: number<>
//│ | | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α58' -> α62')    (0)
//│ | | | | | | | | | | | | | C (α58',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | | | C α58' <! int<number>    (2)
//│ | | | | | | | | | | | | | C (int<number> -> int<number>) <! α62'    (3)
//│ | | | | | | | | | | | 1. : α62'
//│ | | | | | | | | | | | 1. Typing term 1,
//│ | | | | | | | | | | | | 1. Typing term 1
//│ | | | | | | | | | | | | 1. : 1<int,number>
//│ | | | | | | | | | | | 1. : (1<int,number>,)
//│ | | | | | | | | | | | CONSTRAIN α62' <! (1<int,number> -> α63')
//│ | | | | | | | | | | |   where 
//│ 		α62' :> (int<number> -> int<number>)
//│ | | | | | | | | | | | C α62' <! (1<int,number> -> α63')    (0)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α63')    (1)
//│ | | | | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C int<number> <! α63'    (2)
//│ | | | | | | | | | | 1. : α63'
//│ | | | | | | | | | | 1. Typing term cde
//│ | | | | | | | | | | 1. : α59'
//│ | | | | | | | | | 1. : (α63', α59',)
//│ | | | | | | | | | CONSTRAIN pow57' <! ((α63', α59',) -> α64')
//│ | | | | | | | | |   where 
//│ 		α63' :> int<number>
//│ | | | | | | | | | C pow57' <! ((α63', α59',) -> α64')    (0)
//│ | | | | | | | | 1. : α64'
//│ | | | | | | | | check subtypeα64'
//│ | | | | | | | | false
//│ | | | | | | | | false
//│ | | | | | | | 1. : error<>
//│ | | | | | | 1. : (error<>,)
//│ | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (error<> -> α65')
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (error<> -> α65')    (0)
//│ | | | | | | | C (error<>,) <! (int<number>,)    (1)
//│ | | | | | | | | C error<> <! int<number>    (2)
//│ | | | | | | | C (int<number> -> int<number>) <! α65'    (3)
//│ | | | | | 1. : α65'
//│ | | | | | 1. Typing term Unquote' cde ',
//│ | | | | | | 1. Typing term Unquote' cde '
//│ | | | | | | | 1. Typing term cde
//│ | | | | | | | 1. : α59'
//│ | | | | | | | check subtypeα59'
//│ | | | | | | | false
//│ | | | | | | | false
//│ | | | | | | 1. : error<>
//│ | | | | | 1. : (error<>,)
//│ | | | | | CONSTRAIN α65' <! (error<> -> α66')
//│ | | | | |   where 
//│ 		α65' :> (int<number> -> int<number>)
//│ | | | | | C α65' <! (error<> -> α66')    (0)
//│ | | | | | | C (int<number> -> int<number>) <! (error<> -> α66')    (1)
//│ | | | | | | | C (error<>,) <! (int<number>,)    (2)
//│ | | | | | | | | C error<> <! int<number>    (3)
//│ | | | | | | | C int<number> <! α66'    (4)
//│ | | | | 1. : α66'
//│ | | | 1. : Code[α66',Anything]
//│ | | | 1. Typing term Quoted' 1 '
//│ | | | | 1. Typing term 1
//│ | | | | 1. : 1<int,number>
//│ | | | 1. : Code[1<int,number>,Anything]
//│ | | | CONSTRAIN (α61',) <! (true<bool> | (α67' & ~(true<bool>)))
//│ | | |   where 
//│ 		α61' :> bool<>
//│ | | | C (α61',) <! (true<bool> | (α67' & ~(true<bool>)))    (0)
//│ | | | | ARGH  DNF((α61',){_1: α61'})  <!  DNF(true<bool>{} | α67'∧~(true<bool>))
//│ | | | | | Consider (α61',){_1: α61'} <: DNF(true<bool>{} | α67'∧~(true<bool>))
//│ | | | | | Possible: List(α67'∧~(true<bool>))
//│ | | | | | A  (α61',){_1: α61'}  %  List()  <!  List((α67' & ~(true<bool>)))  %  ⊥
//│ | | | | | | Case.1
//│ | | | | | | A  (α61',){_1: α61'}  %  List()  <!  List(α67')  %  ⊥
//│ | | | | | | | C ((α61',) & {_1: α61'}) <! α67'    (1)
//│ | | | | | | Case.2
//│ | | | | | | A  (α61',){_1: α61'}  %  List()  <!  List(~(true<bool>))  %  ⊥
//│ | | | | | | | A  (α61',){_1: α61'}  %  List(true<bool>)  <!  List()  %  ⊥
//│ | | | | | | | | OK  (α61',){_1: α61'} & true<bool>  =:=  ⊥
//│ | | 1. : (Code[α66',Anything] | Code[1<int,number>,Anything])
//│ | 1. : (Code[α66',Anything] | Code[1<int,number>,Anything])
//│ 1. : ((α58', α59',) -> (Code[α66',Anything] | Code[1<int,number>,Anything]))
//│ CONSTRAIN ((α58', α59',) -> (Code[α66',Anything] | Code[1<int,number>,Anything])) <! pow57'
//│   where 
//│ 		pow57' <: ((α63', α59',) -> α64')
//│ 		α58' <: int<number> & number<>
//│ 		α63' :> int<number>
//│ 		α66' :> int<number>
//│ C ((α58', α59',) -> (Code[α66',Anything] | Code[1<int,number>,Anything])) <! pow57'    (0)
//│ | C ((α58', α59',) -> (Code[α66',Anything] | Code[1<int,number>,Anything])) <! ((α63', α59',) -> α64')    (1)
//│ | | C (α63', α59',) <! (α58', α59',)    (2)
//│ | | | C α63' <! α58'    (3)
//│ | | | | C int<number> <! α58'    (4)
//│ | | | | | C int<number> <! int<number>    (5)
//│ | | | | | C int<number> <! number<>    (5)
//│ | | | C α59' <! α59'    (5)
//│ | | C (Code[α66',Anything] | Code[1<int,number>,Anything]) <! α64'    (5)
//│ ⬤ Typed as: pow57'
//│  where: 
//│ 		pow57' :> ((α58', α59',) -> (Code[α66',Anything] | Code[1<int,number>,Anything])) <: ((α63', α59',) -> α64')
//│ 		α58' :> int<number> <: int<number> & number<>
//│ 		α63' :> int<number> <: α58'
//│ 		α64' :> (Code[α66',Anything] | Code[1<int,number>,Anything])
//│ 		α66' :> int<number>
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α64'
//│ ║  l.502: 	fun pow(n, cde) = if (n > 0) then code"${pow(n - 1, cde)} * ${cde}" else code"1"
//│ ╙──       	                                         ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α59'
//│ ║  l.502: 	fun pow(n, cde) = if (n > 0) then code"${pow(n - 1, cde)} * ${cde}" else code"1"
//│ ╙──       	                                                              ^^^
//│ pow: (int, anything,) -> code

:d
:ne
:NoJS
fun test(n, cde) = if n > 0 then code"let x = n - 1; ${test(n - 1, code"${cde} + x")}" else cde
//│ 1. Typing term n, cde, => if (> (n,) (0,)) then Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | 1. Typing pattern n, cde,
//│ | | 1. Typing pattern n
//│ | | 1. : α72'
//│ | | 1. Typing pattern cde
//│ | | 1. : α73'
//│ | 1. : (α72', α73',)
//│ | 1. Typing term if (> (n,) (0,)) then Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | | The mutable CaseOf tree
//│ | | if «> (n,) (0,)»
//│ | |   «Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '»
//│ | | else
//│ | |   «cde»
//│ | | Desugared term: case > (n,) (0,) of { true => Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | 1. Typing term case > (n,) (0,) of { true => Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | | 1. Typing term > (n,) (0,)
//│ | | | | 1. Typing term > (n,)
//│ | | | | | 1. Typing term >
//│ | | | | | 1. : (number<> -> (number<> -> bool<>))
//│ | | | | | 1. Typing term n,
//│ | | | | | | 1. Typing term n
//│ | | | | | | 1. : α72'
//│ | | | | | 1. : (α72',)
//│ | | | | | CONSTRAIN (number<> -> (number<> -> bool<>)) <! (α72' -> α74')
//│ | | | | |   where 
//│ | | | | | C (number<> -> (number<> -> bool<>)) <! (α72' -> α74')    (0)
//│ | | | | | | C (α72',) <! (number<>,)    (1)
//│ | | | | | | | C α72' <! number<>    (2)
//│ | | | | | | C (number<> -> bool<>) <! α74'    (3)
//│ | | | | 1. : α74'
//│ | | | | 1. Typing term 0,
//│ | | | | | 1. Typing term 0
//│ | | | | | 1. : 0<int,number>
//│ | | | | 1. : (0<int,number>,)
//│ | | | | CONSTRAIN α74' <! (0<int,number> -> α75')
//│ | | | |   where 
//│ 		α74' :> (number<> -> bool<>)
//│ | | | | C α74' <! (0<int,number> -> α75')    (0)
//│ | | | | | C (number<> -> bool<>) <! (0<int,number> -> α75')    (1)
//│ | | | | | | C (0<int,number>,) <! (number<>,)    (2)
//│ | | | | | | C bool<> <! α75'    (2)
//│ | | | 1. : α75'
//│ | | | 1. Typing term Quoted' let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '
//│ | | | | 1. Typing term let x = - (n,) (1,) in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | 2. Typing term - (n,) (1,)
//│ | | | | | | 2. Typing term - (n,)
//│ | | | | | | | 2. Typing term -
//│ | | | | | | | 2. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | 2. Typing term n,
//│ | | | | | | | | 2. Typing term n
//│ | | | | | | | | 2. : α72'
//│ | | | | | | | 2. : (α72',)
//│ | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α72' -> α76'')
//│ | | | | | | |   where 
//│ 		α72' <: number<>
//│ | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α72' -> α76'')    (0)
//│ | | | | | | | | C (α72',) <! (int<number>,)    (1)
//│ | | | | | | | | | C α72' <! int<number>    (2)
//│ | | | | | | | | C (int<number> -> int<number>) <! α76''    (3)
//│ | | | | | | 2. : α76''
//│ | | | | | | 2. Typing term 1,
//│ | | | | | | | 2. Typing term 1
//│ | | | | | | | 2. : 1<int,number>
//│ | | | | | | 2. : (1<int,number>,)
//│ | | | | | | CONSTRAIN α76'' <! (1<int,number> -> α77'')
//│ | | | | | |   where 
//│ 		α76'' :> (int<number> -> int<number>)
//│ | | | | | | C α76'' <! (1<int,number> -> α77'')    (0)
//│ | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α77'')    (1)
//│ | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | C int<number> <! α77''    (2)
//│ | | | | | 2. : α77''
//│ | | | | | 1. Typing term Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | | 1. Typing term test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',)
//│ | | | | | | | 1. Typing term test
//│ | | | | | | | 1. : test71'
//│ | | | | | | | 1. Typing term - (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',
//│ | | | | | | | | 1. Typing term - (n,) (1,)
//│ | | | | | | | | | 1. Typing term - (n,)
//│ | | | | | | | | | | 1. Typing term -
//│ | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | 1. Typing term n,
//│ | | | | | | | | | | | 1. Typing term n
//│ | | | | | | | | | | | 1. : α72'
//│ | | | | | | | | | | 1. : (α72',)
//│ | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α72' -> α78')
//│ | | | | | | | | | |   where 
//│ 		α72' <: int<number> & number<>
//│ | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α72' -> α78')    (0)
//│ | | | | | | | | | | | C (α72',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! α78'    (1)
//│ | | | | | | | | | 1. : α78'
//│ | | | | | | | | | 1. Typing term 1,
//│ | | | | | | | | | | 1. Typing term 1
//│ | | | | | | | | | | 1. : 1<int,number>
//│ | | | | | | | | | 1. : (1<int,number>,)
//│ | | | | | | | | | CONSTRAIN α78' <! (1<int,number> -> α79')
//│ | | | | | | | | |   where 
//│ 		α78' :> (int<number> -> int<number>)
//│ | | | | | | | | | C α78' <! (1<int,number> -> α79')    (0)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α79')    (1)
//│ | | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C int<number> <! α79'    (2)
//│ | | | | | | | | 1. : α79'
//│ | | | | | | | | 1. Typing term Quoted' + (Unquote' cde ',) (x,) '
//│ | | | | | | | | | 1. Typing term + (Unquote' cde ',) (x,)
//│ | | | | | | | | | | 1. Typing term + (Unquote' cde ',)
//│ | | | | | | | | | | | 1. Typing term +
//│ | | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | 1. Typing term Unquote' cde ',
//│ | | | | | | | | | | | | 1. Typing term Unquote' cde '
//│ | | | | | | | | | | | | | 1. Typing term cde
//│ | | | | | | | | | | | | | 1. : α73'
//│ | | | | | | | | | | | | | check subtypeα73'
//│ | | | | | | | | | | | | | false
//│ | | | | | | | | | | | | | false
//│ | | | | | | | | | | | | 1. : error<>
//│ | | | | | | | | | | | 1. : (error<>,)
//│ | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (error<> -> α80')
//│ | | | | | | | | | | |   where 
//│ | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (error<> -> α80')    (0)
//│ | | | | | | | | | | | | C (error<>,) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | | C error<> <! int<number>    (2)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! α80'    (3)
//│ | | | | | | | | | | 1. : α80'
//│ | | | | | | | | | | 1. Typing term x,
//│ | | | | | | | | | | | 1. Typing term x
//│ | | | | | | | | | | | 1. : x.type81'
//│ | | | | | | | | | | 1. : (x.type81',)
//│ | | | | | | | | | | CONSTRAIN α80' <! (x.type81' -> α82')
//│ | | | | | | | | | |   where 
//│ 		α80' :> (int<number> -> int<number>)
//│ | | | | | | | | | | C α80' <! (x.type81' -> α82')    (0)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! (x.type81' -> α82')    (1)
//│ | | | | | | | | | | | | C (x.type81',) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C x.type81' <! int<number>    (3)
//│ | | | | | | | | | | | | C int<number> <! α82'    (4)
//│ | | | | | | | | | 1. : α82'
//│ | | | | | | | | 1. : Code[α82',x.type81'83']
//│ | | | | | | | 1. : (α79', Code[α82',x.type81'83'],)
//│ | | | | | | | CONSTRAIN test71' <! ((α79', Code[α82',x.type81'83'],) -> α84')
//│ | | | | | | |   where 
//│ 		α79' :> int<number>
//│ 		α82' :> int<number>
//│ | | | | | | | C test71' <! ((α79', Code[α82',x.type81'83'],) -> α84')    (0)
//│ | | | | | | 1. : α84'
//│ | | | | | | check subtypeα84'
//│ | | | | | | false
//│ | | | | | | false
//│ | | | | | 1. : error<>
//│ | | | | 1. : error<>
//│ | | | 1. : Code[error<>,Anything]
//│ | | | 1. Typing term cde
//│ | | | 1. : α73'
//│ | | | CONSTRAIN α75' <! (true<bool> | (α85' & ~(true<bool>)))
//│ | | |   where 
//│ 		α75' :> bool<>
//│ | | | C α75' <! (true<bool> | (α85' & ~(true<bool>)))    (0)
//│ | | | | C bool<> <! (true<bool> | (α85' & ~(true<bool>)))    (1)
//│ | | | | | ARGH  DNF(bool<>{})  <!  DNF(true<bool>{} | α85'∧~(true<bool>))
//│ | | | | | | Consider bool<>{} <: DNF(true<bool>{} | α85'∧~(true<bool>))
//│ | | | | | | Possible: List(true<bool>{}, α85'∧~(true<bool>))
//│ | | | | | | A  bool<>{}  %  List()  <!  List(true<bool>, (α85' & ~(true<bool>)))  %  ⊥
//│ | | | | | | | A  bool<>{}  %  List()  <!  List((α85' & ~(true<bool>)))  %  true<bool>
//│ | | | | | | | | Case.1
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(α85')  %  true<bool>
//│ | | | | | | | | | C (bool<> & ~(true<bool>)) <! α85'    (2)
//│ | | | | | | | | Case.2
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(~(true<bool>))  %  true<bool>
//│ | | | | | | | | | A  bool<>{}  %  List(true<bool>)  <!  List()  %  true<bool>
//│ | | | | | | | | | | A  true<bool>{}  %  List()  <!  List()  %  true<bool>
//│ | | | | | | | | | | | OK  true<bool>  <:  true<bool>
//│ | | 1. : (Code[error<>,Anything] | α73')
//│ | 1. : (Code[error<>,Anything] | α73')
//│ 1. : ((α72', α73',) -> (Code[error<>,Anything] | α73'))
//│ CONSTRAIN ((α72', α73',) -> (Code[error<>,Anything] | α73')) <! test71'
//│   where 
//│ 		test71' <: ((α79', Code[α82',x.type81'83'],) -> α84')
//│ 		α72' <: int<number> & number<>
//│ 		α79' :> int<number>
//│ 		α82' :> int<number>
//│ C ((α72', α73',) -> (Code[error<>,Anything] | α73')) <! test71'    (0)
//│ | C ((α72', α73',) -> (Code[error<>,Anything] | α73')) <! ((α79', Code[α82',x.type81'83'],) -> α84')    (1)
//│ | | C (α79', Code[α82',x.type81'83'],) <! (α72', α73',)    (2)
//│ | | | C α79' <! α72'    (3)
//│ | | | | C int<number> <! α72'    (4)
//│ | | | | | C int<number> <! int<number>    (5)
//│ | | | | | C int<number> <! number<>    (5)
//│ | | | C Code[α82',x.type81'83'] <! α73'    (5)
//│ | | C (Code[error<>,Anything] | α73') <! α84'    (6)
//│ ⬤ Typed as: test71'
//│  where: 
//│ 		test71' :> ((α72', α73',) -> (Code[error<>,Anything] | α73')) <: ((α79', Code[α82',x.type81'83'],) -> α84')
//│ 		α72' :> int<number> <: int<number> & number<>
//│ 		α73' :> Code[α82',x.type81'83']
//│ 		α79' :> int<number> <: α72'
//│ 		α82' :> int<number>
//│ 		α84' :> (Code[error<>,Anything] | α73')
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α73'
//│ ║  l.682: 	fun test(n, cde) = if n > 0 then code"let x = n - 1; ${test(n - 1, code"${cde} + x")}" else cde
//│ ╙──       	                                                                          ^^^
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α84'
//│ ║  l.682: 	fun test(n, cde) = if n > 0 then code"let x = n - 1; ${test(n - 1, code"${cde} + x")}" else cde
//│ ╙──       	                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ test: (int, 'a,) -> (code | 'a)

