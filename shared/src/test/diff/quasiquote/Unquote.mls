:NewParser

let a = code"x"
let b = code"y"
//│ a: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ b: Code['a, {y: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'y' ] ]

code"x + (let x = 2; x * x)"
//│ res: Code[int, {x: int}]
//│    = [
//│        'App',
//│        '+',
//│        [ 'Var', [ 'FreeVar', 'x' ] ],
//│        [
//│          'Let',
//│          'x',
//│          Symbol(x),
//│          [ '_', 2 ],
//│          [ 'App', '*', [Array], [Array] ]
//│        ]
//│      ]

let a = code"x"
let b = code"y"
let x = 1
code"let x = 1
let b = 1
${a} + (let y = 1; ${b})
"
//│ a: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ b: Code['a, {y: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'y' ] ]
//│ x: 1
//│  = 1
//│ res: Code[int, {x: int}\b\x & {y: int}\b\x\y]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [
//│          'Let',
//│          'b',
//│          Symbol(b),
//│          [ '_', 1 ],
//│          [ 'App', '+', [Array], [Array] ]
//│        ]
//│      ]

:d
let cde = code"a"
//│ 1. Typing term Quoted' a '
//│ | class: class mlscript.Var (a)
//│ | 1. Typing term a
//│ | 1. : α68'
//│ 1. : Code[α68',{a: α68'}]
//│ ⬤ Typed as: Code[α68',{a: α68'}]
//│  where: 
//│ cde: Code['a, {a: 'a}]
//│    = [ 'Var', [ 'FreeVar', 'a' ] ]

let cde_w_free_vars = code"let x = 1; x + y"
//│ cde_w_free_vars: Code[int, {y: int}]
//│                = [
//│                    'Let',
//│                    'x',
//│                    Symbol(x),
//│                    [ '_', 1 ],
//│                    [ 'App', '+', [ 'Var', Symbol(x) ], [ 'Var', [Array] ] ]
//│                  ]


let cde_w_unquote = code"${cde}"
//│ cde_w_unquote: Code['a, {a: 'a}]
//│              = [ 'Unquoted', [ 'Var', [ 'FreeVar', 'a' ] ] ]

let cde_w_unquote_w_free_vars = code"${cde_w_free_vars}"
//│ cde_w_unquote_w_free_vars: Code[int, {y: int}]
//│                          = [
//│                              'Unquoted',
//│                              [
//│                                'Let',
//│                                'x',
//│                                Symbol(x),
//│                                [ '_', 1 ],
//│                                [ 'App', '+', [Array], [Array] ]
//│                              ]
//│                            ]


let cde_w_unquote_w_local_free_vars = code"[z, ${cde_w_unquote_w_free_vars}]"
//│ cde_w_unquote_w_local_free_vars: Code[('a, int,), {y: int, z: 'a}]
//│                                = [ 'Bra', [ 'Tup', [ [Array], [Array] ] ] ]

let free_var1 = code"let x = 1; x + y"
let free_var2 = code"let i = 1; i + x"
let cde_w_mutli_unquote = code"${free_var2} + ${free_var1}"
//│ free_var1: Code[int, {y: int}]
//│          = [
//│              'Let',
//│              'x',
//│              Symbol(x),
//│              [ '_', 1 ],
//│              [ 'App', '+', [ 'Var', Symbol(x) ], [ 'Var', [Array] ] ]
//│            ]
//│ free_var2: Code[int, {x: int}]
//│          = [
//│              'Let',
//│              'i',
//│              Symbol(i),
//│              [ '_', 1 ],
//│              [ 'App', '+', [ 'Var', Symbol(i) ], [ 'Var', [Array] ] ]
//│            ]
//│ cde_w_mutli_unquote: Code[int, {x: int, y: int}]
//│                    = [
//│                        'App',
//│                        '+',
//│                        [ 'Unquoted', [ 'Let', 'i', Symbol(i), [Array], [Array] ] ],
//│                        [ 'Unquoted', [ 'Let', 'x', Symbol(x), [Array], [Array] ] ]
//│                      ]

// FIXME
c: Code<int, {}>
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.126: 	c: Code<int, {}>
//│ ╙──       	^
//│ res: Code[int, anything]
//│ Code generation encountered an error:
//│   unresolved symbol c


fun f(x, y) = code"[${x}, ${y}]"
//│ f: (Code['a, 'b], Code['c, 'b],) -> Code[('a, 'c,), 'b]
//│  = [Function: f]

let x = code"y"
//│ x: Code['a, {y: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'y' ] ]

let c = f(x, x)
//│ c: Code[('a, 'a,), {y: 'a}]
//│  = [ 'Bra', [ 'Tup', [ [Array], [Array] ] ] ]

let cde_arr = code"[${code"y"}, ${code"y"}]"
//│ cde_arr: Code[('a, 'a,), {y: 'a}]
//│        = [ 'Bra', [ 'Tup', [ [Array], [Array] ] ] ]

code"let y = 1; ${cde_arr}"
//│ res: Code[('a, 'a,), {y: 'a}\y]
//│    = [
//│        'Let',
//│        'y',
//│        Symbol(y),
//│        [ '_', 1 ],
//│        [ 'Unquoted', [ 'Bra', [Array] ] ]
//│      ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'y'
//│ res: (nothing, nothing,) | error
//│    = [ 1, 1 ]

// CHECK THIS
y => code"[${code"y"}, ${code"y"}]"
//│ res: anything -> Code[('a, 'a,), {y: 'a}]
//│    = [Function: res]

code"y => ${c}"
//│ res: Code[anything -> ('a, 'a,), {y: 'a}\y]
//│    = [ '_', [Function (anonymous)] ]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, 'b] & 'c, Code['d, 'b] & 'e,) -> (Code[('a, 'd,), 'b], 'c, 'e,)
//│  = [Function: f1]

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]
//│  = <missing implementation>


fun f(x) = x
//│ f: 'a -> 'a
//│  = [Function: f2]

let built_in_binding_test = code"let f = x => x + 1; f(if true then 1 else 2)"
//│ built_in_binding_test: Code[int, anything]
//│                      = [
//│                          'Let',
//│                          'f',
//│                          Symbol(f),
//│                          [ '_', [Function (anonymous)] ],
//│                          [ 'App_Fun', [ 'Var', Symbol(f) ], [ 'Tup', [Array] ] ]
//│                        ]


code"f(0)"
//│ res: Code[0, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'f' ] ], [ 'Tup', [ [Array] ] ] ]

:e
:ge
code"${code"${code"${z}"}"}"
//│ ╔══[ERROR] identifier not found: z
//│ ║  l.210: 	code"${code"${code"${z}"}"}"
//│ ╙──       	                     ^
//│ res: Code[error, anything]
//│ Code generation encountered an error:
//│   unresolved symbol z

let z = code"1"
code"${code"${z}"}"
//│ z: Code[1, anything]
//│  = [ '_', 1 ]
//│ res: Code[1, anything]
//│    = [ 'Unquoted', [ 'Unquoted', [ '_', 1 ] ] ]

code"let x = 1; let z = 1; code"x + y""
//│ res: Code[Code[int, {x: int, y: int}], anything]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'z', Symbol(z), [ '_', 1 ], [ '_', [Array] ] ]
//│      ]
code"let z = 0;${code"z"}"
//│ res: Code['a, {z: 'a}\z]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ '_', 0 ],
//│        [ 'Unquoted', [ 'Var', [Array] ] ]
//│      ]
code"let x = 1;${code"x + y"}"
//│ res: Code[int, {x: int, y: int}\x]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Unquoted', [ 'App', '+', [Array], [Array] ] ]
//│      ]


code"1 + ${code"b"}"
//│ res: Code[int, {b: int}]
//│    = [ 'App', '+', [ '_', 1 ], [ 'Unquoted', [ 'Var', [Array] ] ] ]

let n = 1
code"${Const(n)} + 1"
//│ n: 1
//│  = 1
//│ res: Code[int, anything]
//│    = [ 'App', '+', [ 'Unquoted', [ '_', 1 ] ], [ '_', 1 ] ]
fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ test: (int, Code[int | 'a, 'b & 'c] & 'd,) -> (Code[int | 'a, 'b\x & {x: int} & 'c] | 'd)
//│   where
//│     'b <: 'b\x & {x: int} & 'c
//│     = [Function: test]
