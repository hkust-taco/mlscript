:NewParser
:ne
:NoJS
let cde = code"a"
code"let a = 10; let b = 10;${cde}"
//│ cde: Code['a, {a: 'a}]
//│ res: Code['a, {a: 'a}\a\b]

code"1"
//│ res: Code[1, anything]

:ne
:NoJS
fun f(x, y) = code"[${x}, ${y}]"
//│ f: (Code['a, 'b], Code['c, 'b],) -> Code[('a, 'c,), 'b]

let x = code"y"
//│ x: Code['a, {y: 'a}]

:d
let c = f(x, x)
//│ 1. Typing term f (x, x,)
//│ | 1. Typing term f
//│ | 1. : f68'
//│ | 1. Typing term x, x,
//│ | | 1. Typing term x
//│ | | 1. : Code[[α73'],{y: α73'}]
//│ | | 1. Typing term x
//│ | | 1. : Code[[α74'],{y: α74'}]
//│ | 1. : (Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],)
//│ | CONSTRAIN f68' <! ((Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],) -> α75')
//│ |   where 
//│ 		f68' :> [((α69', α70',) -> Code[(α71', α72',),(α44 & α47)])]
//│ 		α69' <: [[Code[α43,α44]]]
//│ 		α70' <: [[Code[α46,α47]]]
//│ 		α71' :> [α43]
//│ 		α72' :> [α46]
//│ | C f68' <! ((Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],) -> α75')    (0)
//│ | | C [((α69', α70',) -> Code[(α71', α72',),(α44 & α47)])] <! ((Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],) -> α75')    (1)
//│ | | | C ((α69', α70',) -> Code[(α71', α72',),(α44 & α47)]) <! ((Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],) -> α75')    (1)
//│ | | | | C (Code[[α73'],{y: α73'}], Code[[α74'],{y: α74'}],) <! (α69', α70',)    (2)
//│ | | | | | C Code[[α73'],{y: α73'}] <! α69'    (3)
//│ | | | | | | C Code[[α73'],{y: α73'}] <! [[Code[α43,α44]]]    (4)
//│ | | | | | | | C Code[[α73'],{y: α73'}] <! [Code[α43,α44]]    (4)
//│ | | | | | | | | C Code[[α73'],{y: α73'}] <! Code[α43,α44]    (4)
//│ | | | | | | | | | C [α73'] <! α43    (5)
//│ | | | | | | | | | | C α73' <! α43    (5)
//│ | | | | | | | | | C α44 <! {y: α73'}    (6)
//│ | | | | | | | | | | EXTR RHS  {y: α73'}  ~>  {y: α76}  to 0
//│ | | | | | | | | | |  where 
//│ 		α76 <: α43
//│ | | | | | | | | | |    and 
//│ 		α73' :> α76 <: α43
//│ 		α76 <: α43
//│ | | | | | | | | | | C α44 <! {y: α76}    (7)
//│ | | | | | C Code[[α74'],{y: α74'}] <! α70'    (8)
//│ | | | | | | C Code[[α74'],{y: α74'}] <! [[Code[α46,α47]]]    (9)
//│ | | | | | | | C Code[[α74'],{y: α74'}] <! [Code[α46,α47]]    (9)
//│ | | | | | | | | C Code[[α74'],{y: α74'}] <! Code[α46,α47]    (9)
//│ | | | | | | | | | C [α74'] <! α46    (10)
//│ | | | | | | | | | | C α74' <! α46    (10)
//│ | | | | | | | | | C α47 <! {y: α74'}    (11)
//│ | | | | | | | | | | EXTR RHS  {y: α74'}  ~>  {y: α77}  to 0
//│ | | | | | | | | | |  where 
//│ 		α77 <: α46
//│ | | | | | | | | | |    and 
//│ 		α74' :> α77 <: α46
//│ 		α77 <: α46
//│ | | | | | | | | | | C α47 <! {y: α77}    (12)
//│ | | | | C Code[(α71', α72',),(α44 & α47)] <! α75'    (13)
//│ 1. : α75'
//│ ⬤ Typed as: α75'
//│  where: 
//│ 		α44 <: {y: α76}
//│ 		α47 <: {y: α77}
//│ 		α71' :> [α43]
//│ 		α72' :> [α46]
//│ 		α75' :> Code[(α71', α72',),(α44 & α47)]
//│ 		α76 <: α43
//│ 		α77 <: α46
//│ c: Code[('a, 'a,), {y: 'a}]

code"[${code"y"}, ${code"y"}]"
//│ res: Code[('a, 'a,), {y: 'a}]

y => code"[${code"y"}, ${code"y"}]"
//│ res: anything -> Code[('a, 'a,), {y: 'a}]

code"y => ${c}"
//│ res: Code[anything -> ('a, 'a,), {y: 'a}\y]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, 'b] & 'c, Code['d, 'b] & 'e,) -> (Code[('a, 'd,), 'b], 'c, 'e,)

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]


fun f(x) = x
//│ f: 'a -> 'a


:d
code"f(0)"
//│ 0. Typing term Quoted' f (0,) '
//│ | 0. Typing term f (0,)
//│ | | 0. Typing term f
//│ | | 0. : f187
//│ | | 0. Typing term 0,
//│ | | | 0. Typing term 0
//│ | | | 0. : 0<int,number>
//│ | | 0. : (0<int,number>,)
//│ | | CONSTRAIN f187 <! (0<int,number> -> α189)
//│ | |   where 
//│ 		f187 :> [(α188 -> [α188])]
//│ | | C f187 <! (0<int,number> -> α189)    (0)
//│ | | | C [(α188 -> [α188])] <! (0<int,number> -> α189)    (1)
//│ | | | | C (α188 -> [α188]) <! (0<int,number> -> α189)    (1)
//│ | | | | | C (0<int,number>,) <! (α188,)    (2)
//│ | | | | | | C 0<int,number> <! α188    (3)
//│ | | | | | C [α188] <! α189    (4)
//│ | | | | | | C α188 <! α189    (4)
//│ | | | | | | | C 0<int,number> <! α189    (5)
//│ | 0. : α189
//│ 0. : Code[α189,{}]
//│ ⬤ Typed as: Code[α189,{}]
//│  where: 
//│ 		α189 :> 0<int,number>
//│ res: Code[0, anything]

:NewParser
:d
:ne
:NoJS
code"${code"${code"${z}"}"}"
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' ' '
//│ | 0. Typing term Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' '
//│ | | 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | | | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | | | 0. Typing term Unquote' z '
//│ | | | | | | 0. Typing term z
//│ | | | | | | 0. : α197
//│ | | | | | | CONSTRAIN (Code[α195,α196] -> α195) <! (α197 -> α198)
//│ | | | | | |   where 
//│ | | | | | | C (Code[α195,α196] -> α195) <! (α197 -> α198)    (0)
//│ | | | | | | | C α197 <! Code[α195,α196]    (1)
//│ | | | | | | | C α195 <! α198    (2)
//│ | | | | | 0. : α198
//│ | | | | 0. : Code[α198,α196]
//│ | | | | CONSTRAIN (Code[α193,α194] -> α193) <! (Code[α198,α196] -> α199)
//│ | | | |   where 
//│ | | | | C (Code[α193,α194] -> α193) <! (Code[α198,α196] -> α199)    (0)
//│ | | | | | C Code[α198,α196] <! Code[α193,α194]    (1)
//│ | | | | | | C α198 <! α193    (2)
//│ | | | | | | C α194 <! α196    (3)
//│ | | | | | C α193 <! α199    (4)
//│ | | | 0. : α199
//│ | | 0. : Code[α199,α194]
//│ | | CONSTRAIN (Code[α191,α192] -> α191) <! (Code[α199,α194] -> α200)
//│ | |   where 
//│ 		α194 <: α196
//│ | | C (Code[α191,α192] -> α191) <! (Code[α199,α194] -> α200)    (0)
//│ | | | C Code[α199,α194] <! Code[α191,α192]    (1)
//│ | | | | C α199 <! α191    (2)
//│ | | | | C α192 <! α194    (3)
//│ | | | C α191 <! α200    (4)
//│ | 0. : α200
//│ 0. : Code[α200,α192]
//│ ⬤ Typed as: Code[α200,α192]
//│  where: 
//│ 		α192 <: α194
//│ 		α194 <: α196
//│ ╔══[ERROR] identifier not found: z
//│ ║  l.138: 	code"${code"${code"${z}"}"}"
//│ ╙──       	                     ^
//│ res: Code[nothing, anything]


:NewParser
:d
:ne
:NoJS
let z = code"1"
code"${code"${z}"}"
//│ 1. Typing term Quoted' 1 '
//│ | 1. Typing term 1
//│ | 1. : 1<int,number>
//│ 1. : Code[1<int,number>,{}]
//│ ⬤ Typed as: Code[1<int,number>,{}]
//│  where: 
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | 0. Typing term Unquote' z '
//│ | | | | 0. Typing term z
//│ | | | | 0. : Code[1<int,number>,{}]
//│ | | | | CONSTRAIN (Code[α207,α208] -> α207) <! (Code[1<int,number>,{}] -> α209)
//│ | | | |   where 
//│ | | | | C (Code[α207,α208] -> α207) <! (Code[1<int,number>,{}] -> α209)    (0)
//│ | | | | | C Code[1<int,number>,{}] <! Code[α207,α208]    (1)
//│ | | | | | | C 1<int,number> <! α207    (2)
//│ | | | | | | C α208 <! {}    (3)
//│ | | | | | C α207 <! α209    (4)
//│ | | | | | | C 1<int,number> <! α209    (5)
//│ | | | 0. : α209
//│ | | 0. : Code[α209,α208]
//│ | | CONSTRAIN (Code[α205,α206] -> α205) <! (Code[α209,α208] -> α210)
//│ | |   where 
//│ 		α209 :> 1<int,number>
//│ | | C (Code[α205,α206] -> α205) <! (Code[α209,α208] -> α210)    (0)
//│ | | | C Code[α209,α208] <! Code[α205,α206]    (1)
//│ | | | | C α209 <! α205    (2)
//│ | | | | | C 1<int,number> <! α205    (3)
//│ | | | | C α206 <! α208    (4)
//│ | | | C α205 <! α210    (5)
//│ | | | | C 1<int,number> <! α210    (6)
//│ | 0. : α210
//│ 0. : Code[α210,α206]
//│ ⬤ Typed as: Code[α210,α206]
//│  where: 
//│ 		α206 <: α208
//│ 		α210 :> 1<int,number>
//│ z: Code[1, anything]
//│ res: Code[1, anything]

:NewParser
:d
:ne
:NoJS
code"let x = 1; let z = 1; code"x + y""
//│ 0. Typing term Quoted' let x = 1 in let z = 1 in Quoted' + (x,) (y,) ' '
//│ | 0. Typing term let x = 1 in let z = 1 in Quoted' + (x,) (y,) '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | Let: x
//│ | | 0. Typing term let z = 1 in Quoted' + (x,) (y,) '
//│ | | | 1. Typing term 1
//│ | | | 1. : 1<int,number>
//│ | | | Let: z
//│ | | | 0. Typing term Quoted' + (x,) (y,) '
//│ | | | | 0. Typing term + (x,) (y,)
//│ | | | | | 0. Typing term + (x,)
//│ | | | | | | 0. Typing term +
//│ | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | 0. Typing term x,
//│ | | | | | | | 0. Typing term x
//│ | | | | | | | 0. : α214
//│ | | | | | | 0. : (α214,)
//│ | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α214 -> α215)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α214 -> α215)    (0)
//│ | | | | | | | C (α214,) <! (int<number>,)    (1)
//│ | | | | | | | | C α214 <! int<number>    (2)
//│ | | | | | | | C (int<number> -> int<number>) <! α215    (3)
//│ | | | | | 0. : α215
//│ | | | | | 0. Typing term y,
//│ | | | | | | 0. Typing term y
//│ | | | | | | 0. : α216
//│ | | | | | 0. : (α216,)
//│ | | | | | CONSTRAIN α215 <! (α216 -> α217)
//│ | | | | |   where 
//│ 		α215 :> (int<number> -> int<number>)
//│ | | | | | C α215 <! (α216 -> α217)    (0)
//│ | | | | | | C (int<number> -> int<number>) <! (α216 -> α217)    (1)
//│ | | | | | | | C (α216,) <! (int<number>,)    (2)
//│ | | | | | | | | C α216 <! int<number>    (3)
//│ | | | | | | | C int<number> <! α217    (4)
//│ | | | | 0. : α217
//│ | | | 0. : Code[α217,{y: α216, x: α214}]
//│ | | 0. : Code[α217,{y: α216, x: α214}]
//│ | 0. : Code[α217,{y: α216, x: α214}]
//│ 0. : Code[Code[α217,{y: α216, x: α214}],{}\x-z]
//│ ⬤ Typed as: Code[Code[α217,{y: α216, x: α214}],{}\x-z]
//│  where: 
//│ 		α214 <: int<number>
//│ 		α216 <: int<number>
//│ 		α217 :> int<number>
//│ res: Code[Code[int, {x: int, y: int}], anything\x\z]

:NewParser
:d
:ne
:NoJS
code"let z = 0;${code"z"}"
//│ 0. Typing term Quoted' let z = 0 in Unquote' Quoted' z ' ' '
//│ | 0. Typing term let z = 0 in Unquote' Quoted' z ' '
//│ | | 1. Typing term 0
//│ | | 1. : 0<int,number>
//│ | | Let: z
//│ | | 0. Typing term Unquote' Quoted' z ' '
//│ | | | 0. Typing term Quoted' z '
//│ | | | | 0. Typing term z
//│ | | | | 0. : α223
//│ | | | 0. : Code[α223,{z: α223}]
//│ | | | CONSTRAIN (Code[α221,α222] -> α221) <! (Code[α223,{z: α223}] -> α224)
//│ | | |   where 
//│ | | | C (Code[α221,α222] -> α221) <! (Code[α223,{z: α223}] -> α224)    (0)
//│ | | | | C Code[α223,{z: α223}] <! Code[α221,α222]    (1)
//│ | | | | | C α223 <! α221    (2)
//│ | | | | | C α222 <! {z: α223}    (3)
//│ | | | | C α221 <! α224    (4)
//│ | | 0. : α224
//│ | 0. : α224
//│ 0. : Code[α224,α222\z]
//│ ⬤ Typed as: Code[α224,α222\z]
//│  where: 
//│ 		α221 <: α224
//│ 		α222 <: {z: α223}
//│ 		α223 <: α221
//│ res: Code['a, {z: 'a}\z]

:NewParser
:d
:ne
:NoJS
code"let x = 1;${code"x + y"}"
//│ 0. Typing term Quoted' let x = 1 in Unquote' Quoted' + (x,) (y,) ' ' '
//│ | 0. Typing term let x = 1 in Unquote' Quoted' + (x,) (y,) ' '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | Let: x
//│ | | 0. Typing term Unquote' Quoted' + (x,) (y,) ' '
//│ | | | 0. Typing term Quoted' + (x,) (y,) '
//│ | | | | 0. Typing term + (x,) (y,)
//│ | | | | | 0. Typing term + (x,)
//│ | | | | | | 0. Typing term +
//│ | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | 0. Typing term x,
//│ | | | | | | | 0. Typing term x
//│ | | | | | | | 0. : α233
//│ | | | | | | 0. : (α233,)
//│ | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α233 -> α234)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α233 -> α234)    (0)
//│ | | | | | | | C (α233,) <! (int<number>,)    (1)
//│ | | | | | | | | C α233 <! int<number>    (2)
//│ | | | | | | | C (int<number> -> int<number>) <! α234    (3)
//│ | | | | | 0. : α234
//│ | | | | | 0. Typing term y,
//│ | | | | | | 0. Typing term y
//│ | | | | | | 0. : α235
//│ | | | | | 0. : (α235,)
//│ | | | | | CONSTRAIN α234 <! (α235 -> α236)
//│ | | | | |   where 
//│ 		α234 :> (int<number> -> int<number>)
//│ | | | | | C α234 <! (α235 -> α236)    (0)
//│ | | | | | | C (int<number> -> int<number>) <! (α235 -> α236)    (1)
//│ | | | | | | | C (α235,) <! (int<number>,)    (2)
//│ | | | | | | | | C α235 <! int<number>    (3)
//│ | | | | | | | C int<number> <! α236    (4)
//│ | | | | 0. : α236
//│ | | | 0. : Code[α236,{y: α235, x: α233}]
//│ | | | CONSTRAIN (Code[α231,α232] -> α231) <! (Code[α236,{y: α235, x: α233}] -> α237)
//│ | | |   where 
//│ 		α233 <: int<number>
//│ 		α235 <: int<number>
//│ 		α236 :> int<number>
//│ | | | C (Code[α231,α232] -> α231) <! (Code[α236,{y: α235, x: α233}] -> α237)    (0)
//│ | | | | C Code[α236,{y: α235, x: α233}] <! Code[α231,α232]    (1)
//│ | | | | | C α236 <! α231    (2)
//│ | | | | | | C int<number> <! α231    (3)
//│ | | | | | C α232 <! {y: α235, x: α233}    (4)
//│ | | | | C α231 <! α237    (5)
//│ | | | | | C int<number> <! α237    (6)
//│ | | 0. : α237
//│ | 0. : α237
//│ 0. : Code[α237,α232\x]
//│ ⬤ Typed as: Code[α237,α232\x]
//│  where: 
//│ 		α232 <: {y: α235, x: α233}
//│ 		α233 <: int<number>
//│ 		α235 <: int<number>
//│ 		α237 :> int<number>
//│ res: Code[int, {x: int, y: int}\x]


:NewParser
:d
:ne
:NoJS
code"1 + ${code"b"}"
//│ 0. Typing term Quoted' + (1,) (Unquote' Quoted' b ' ',) '
//│ | 0. Typing term + (1,) (Unquote' Quoted' b ' ',)
//│ | | 0. Typing term + (1,)
//│ | | | 0. Typing term +
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α242)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α242)    (0)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | C (int<number> -> int<number>) <! α242    (1)
//│ | | 0. : α242
//│ | | 0. Typing term Unquote' Quoted' b ' ',
//│ | | | 0. Typing term Unquote' Quoted' b ' '
//│ | | | | 0. Typing term Quoted' b '
//│ | | | | | 0. Typing term b
//│ | | | | | 0. : α245
//│ | | | | 0. : Code[α245,{b: α245}]
//│ | | | | CONSTRAIN (Code[α243,α244] -> α243) <! (Code[α245,{b: α245}] -> α246)
//│ | | | |   where 
//│ | | | | C (Code[α243,α244] -> α243) <! (Code[α245,{b: α245}] -> α246)    (0)
//│ | | | | | C Code[α245,{b: α245}] <! Code[α243,α244]    (1)
//│ | | | | | | C α245 <! α243    (2)
//│ | | | | | | C α244 <! {b: α245}    (3)
//│ | | | | | C α243 <! α246    (4)
//│ | | | 0. : α246
//│ | | 0. : (α246,)
//│ | | CONSTRAIN α242 <! (α246 -> α247)
//│ | |   where 
//│ 		α242 :> (int<number> -> int<number>)
//│ | | C α242 <! (α246 -> α247)    (0)
//│ | | | C (int<number> -> int<number>) <! (α246 -> α247)    (1)
//│ | | | | C (α246,) <! (int<number>,)    (2)
//│ | | | | | C α246 <! int<number>    (3)
//│ | | | | C int<number> <! α247    (4)
//│ | 0. : α247
//│ 0. : Code[α247,α244]
//│ ⬤ Typed as: Code[α247,α244]
//│  where: 
//│ 		α243 <: α246
//│ 		α244 <: {b: α245}
//│ 		α245 <: α243
//│ 		α246 <: int<number>
//│ 		α247 :> int<number>
//│ res: Code[int, {b: int}]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α255)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α255)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α255    (1)
//│ | | | | | 0. : α255
//│ | | | | | CONSTRAIN (Code[α253,α254] -> α253) <! (α255 -> α256)
//│ | | | | |   where 
//│ 		α255 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α253,α254] -> α253) <! (α255 -> α256)    (0)
//│ | | | | | | C α255 <! Code[α253,α254]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α253,α254]    (2)
//│ | | | | | | | | C int<number> <! α253    (3)
//│ | | | | | | | | C α254 <! ⊥    (4)
//│ | | | | | | C α253 <! α256    (5)
//│ | | | | | | | C int<number> <! α256    (6)
//│ | | | | 0. : α256
//│ | | | 0. : (α256,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α256 -> α257)
//│ | | |   where 
//│ 		α256 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α256 -> α257)    (0)
//│ | | | | C (α256,) <! (int<number>,)    (1)
//│ | | | | | C α256 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α257    (3)
//│ | | 0. : α257
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α257 <! (1<int,number> -> α258)
//│ | |   where 
//│ 		α257 :> (int<number> -> int<number>)
//│ | | C α257 <! (1<int,number> -> α258)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α258)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α258    (2)
//│ | 0. : α258
//│ 0. : Code[α258,α254]
//│ ⬤ Typed as: Code[α258,α254]
//│  where: 
//│ 		α254 <: ⊥
//│ 		α258 :> int<number>
//│ n: 1
//│ res: Code[int, ?]

:NewParser
:d
:ne
:NoJS
fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ 1. Typing term n, cde, => if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | 1. Typing pattern n, cde,
//│ | | 1. Typing pattern n
//│ | | | n
//│ | | 1. : α262'
//│ | | 1. Typing pattern cde
//│ | | | cde
//│ | | 1. : α264'
//│ | 1. : (α262', α264',)
//│ | 1. Typing term if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | | The mutable CaseOf tree
//│ | | if «> (n,) (0,)»
//│ | |   «Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '»
//│ | | else
//│ | |   «cde»
//│ | | Desugared term: case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | 1. Typing term case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | | 1. Typing term > (n,) (0,)
//│ | | | | 1. Typing term > (n,)
//│ | | | | | 1. Typing term >
//│ | | | | | 1. : (number<> -> (number<> -> bool<>))
//│ | | | | | 1. Typing term n,
//│ | | | | | | 1. Typing term n
//│ | | | | | | 1. : α262'
//│ | | | | | 1. : (α262',)
//│ | | | | | CONSTRAIN (number<> -> (number<> -> bool<>)) <! (α262' -> α265')
//│ | | | | |   where 
//│ | | | | | C (number<> -> (number<> -> bool<>)) <! (α262' -> α265')    (0)
//│ | | | | | | C (α262',) <! (number<>,)    (1)
//│ | | | | | | | C α262' <! number<>    (2)
//│ | | | | | | C (number<> -> bool<>) <! α265'    (3)
//│ | | | | 1. : α265'
//│ | | | | 1. Typing term 0,
//│ | | | | | 1. Typing term 0
//│ | | | | | 1. : 0<int,number>
//│ | | | | 1. : (0<int,number>,)
//│ | | | | CONSTRAIN α265' <! (0<int,number> -> α266')
//│ | | | |   where 
//│ 		α265' :> (number<> -> bool<>)
//│ | | | | C α265' <! (0<int,number> -> α266')    (0)
//│ | | | | | C (number<> -> bool<>) <! (0<int,number> -> α266')    (1)
//│ | | | | | | C (0<int,number>,) <! (number<>,)    (2)
//│ | | | | | | C bool<> <! α266'    (2)
//│ | | | 1. : α266'
//│ | | | 1. Typing term Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '
//│ | | | | 1. Typing term let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | 2. Typing term Unquote' Const (n,) '
//│ | | | | | | 1. Typing term Const (n,)
//│ | | | | | | | 1. Typing term Const
//│ | | | | | | | 1. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | | 1. Typing term n,
//│ | | | | | | | | 1. Typing term n
//│ | | | | | | | | 1. : α262'
//│ | | | | | | | 1. : (α262',)
//│ | | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (α262' -> α269')
//│ | | | | | | |   where 
//│ 		α262' <: number<>
//│ | | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (α262' -> α269')    (0)
//│ | | | | | | | | C (α262',) <! (int<number>,)    (1)
//│ | | | | | | | | | C α262' <! int<number>    (2)
//│ | | | | | | | | C Code[int<number>,⊥] <! α269'    (3)
//│ | | | | | | 1. : α269'
//│ | | | | | | CONSTRAIN (Code[α267,α268] -> α267) <! (α269' -> α270'')
//│ | | | | | |   where 
//│ 		α269' :> Code[int<number>,⊥]
//│ | | | | | | C (Code[α267,α268] -> α267) <! (α269' -> α270'')    (0)
//│ | | | | | | | C α269' <! Code[α267,α268]    (1)
//│ | | | | | | | | C Code[int<number>,⊥] <! Code[α267,α268]    (2)
//│ | | | | | | | | | C int<number> <! α267    (3)
//│ | | | | | | | | | C α268 <! ⊥    (4)
//│ | | | | | | | C α267 <! α270''    (5)
//│ | | | | | 2. : α270''
//│ | | | | | Let: x
//│ | | | | | 1. Typing term Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | | 1. Typing term test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',)
//│ | | | | | | | 1. Typing term test
//│ | | | | | | | 1. : test261'
//│ | | | | | | | 1. Typing term - (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',
//│ | | | | | | | | 1. Typing term - (n,) (1,)
//│ | | | | | | | | | 1. Typing term - (n,)
//│ | | | | | | | | | | 1. Typing term -
//│ | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | 1. Typing term n,
//│ | | | | | | | | | | | 1. Typing term n
//│ | | | | | | | | | | | 1. : α262'
//│ | | | | | | | | | | 1. : (α262',)
//│ | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α262' -> α273')
//│ | | | | | | | | | |   where 
//│ 		α262' <: int<number> & number<>
//│ | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α262' -> α273')    (0)
//│ | | | | | | | | | | | C (α262',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! α273'    (1)
//│ | | | | | | | | | 1. : α273'
//│ | | | | | | | | | 1. Typing term 1,
//│ | | | | | | | | | | 1. Typing term 1
//│ | | | | | | | | | | 1. : 1<int,number>
//│ | | | | | | | | | 1. : (1<int,number>,)
//│ | | | | | | | | | CONSTRAIN α273' <! (1<int,number> -> α274')
//│ | | | | | | | | |   where 
//│ 		α273' :> (int<number> -> int<number>)
//│ | | | | | | | | | C α273' <! (1<int,number> -> α274')    (0)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α274')    (1)
//│ | | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C int<number> <! α274'    (2)
//│ | | | | | | | | 1. : α274'
//│ | | | | | | | | 1. Typing term Quoted' + (Unquote' cde ',) (x,) '
//│ | | | | | | | | | 1. Typing term + (Unquote' cde ',) (x,)
//│ | | | | | | | | | | 1. Typing term + (Unquote' cde ',)
//│ | | | | | | | | | | | 1. Typing term +
//│ | | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | 1. Typing term Unquote' cde ',
//│ | | | | | | | | | | | | 1. Typing term Unquote' cde '
//│ | | | | | | | | | | | | | 1. Typing term cde
//│ | | | | | | | | | | | | | 1. : α264'
//│ | | | | | | | | | | | | | CONSTRAIN (Code[α275,α276] -> α275) <! (α264' -> α277')
//│ | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | C (Code[α275,α276] -> α275) <! (α264' -> α277')    (0)
//│ | | | | | | | | | | | | | | C α264' <! Code[α275,α276]    (1)
//│ | | | | | | | | | | | | | | C α275 <! α277'    (2)
//│ | | | | | | | | | | | | 1. : α277'
//│ | | | | | | | | | | | 1. : (α277',)
//│ | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α277' -> α278')
//│ | | | | | | | | | | |   where 
//│ 		α277' :> α275
//│ | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α277' -> α278')    (0)
//│ | | | | | | | | | | | | C (α277',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | | C α277' <! int<number>    (2)
//│ | | | | | | | | | | | | | | C α275 <! int<number>    (3)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! α278'    (4)
//│ | | | | | | | | | | 1. : α278'
//│ | | | | | | | | | | 1. Typing term x,
//│ | | | | | | | | | | | 1. Typing term x
//│ | | | | | | | | | | | 1. : α279'
//│ | | | | | | | | | | 1. : (α279',)
//│ | | | | | | | | | | CONSTRAIN α278' <! (α279' -> α280')
//│ | | | | | | | | | |   where 
//│ 		α278' :> (int<number> -> int<number>)
//│ | | | | | | | | | | C α278' <! (α279' -> α280')    (0)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! (α279' -> α280')    (1)
//│ | | | | | | | | | | | | C (α279',) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C α279' <! int<number>    (3)
//│ | | | | | | | | | | | | C int<number> <! α280'    (4)
//│ | | | | | | | | | 1. : α280'
//│ | | | | | | | | 1. : Code[α280',(α276 & {x: α279'})]
//│ | | | | | | | 1. : (α274', Code[α280',(α276 & {x: α279'})],)
//│ | | | | | | | CONSTRAIN test261' <! ((α274', Code[α280',(α276 & {x: α279'})],) -> α281')
//│ | | | | | | |   where 
//│ 		α274' :> int<number>
//│ 		α279' <: int<number>
//│ 		α280' :> int<number>
//│ | | | | | | | C test261' <! ((α274', Code[α280',(α276 & {x: α279'})],) -> α281')    (0)
//│ | | | | | | 1. : α281'
//│ | | | | | | CONSTRAIN (Code[α271,α272] -> α271) <! (α281' -> α282')
//│ | | | | | |   where 
//│ | | | | | | C (Code[α271,α272] -> α271) <! (α281' -> α282')    (0)
//│ | | | | | | | C α281' <! Code[α271,α272]    (1)
//│ | | | | | | | C α271 <! α282'    (2)
//│ | | | | | 1. : α282'
//│ | | | | 1. : α282'
//│ | | | 1. : Code[α282',(α268 & α272)\x]
//│ | | | 1. Typing term cde
//│ | | | 1. : α264'
//│ | | | CONSTRAIN α266' <! (true<bool> | (α283' & ~(true<bool>)))
//│ | | |   where 
//│ 		α266' :> bool<>
//│ | | | C α266' <! (true<bool> | (α283' & ~(true<bool>)))    (0)
//│ | | | | C bool<> <! (true<bool> | (α283' & ~(true<bool>)))    (1)
//│ | | | | | ARGH  DNF(bool<>{})  <!  DNF(true<bool>{} | α283'∧~(true<bool>))
//│ | | | | | | Consider bool<>{} <: DNF(true<bool>{} | α283'∧~(true<bool>))
//│ | | | | | | Possible: List(true<bool>{}, α283'∧~(true<bool>))
//│ | | | | | | A  bool<>{}  %  List()  <!  List(true<bool>, (α283' & ~(true<bool>)))  %  ⊥
//│ | | | | | | | A  bool<>{}  %  List()  <!  List((α283' & ~(true<bool>)))  %  true<bool>
//│ | | | | | | | | Case.1
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(α283')  %  true<bool>
//│ | | | | | | | | | C (bool<> & ~(true<bool>)) <! α283'    (2)
//│ | | | | | | | | Case.2
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(~(true<bool>))  %  true<bool>
//│ | | | | | | | | | A  bool<>{}  %  List(true<bool>)  <!  List()  %  true<bool>
//│ | | | | | | | | | | A  true<bool>{}  %  List()  <!  List()  %  true<bool>
//│ | | | | | | | | | | | OK  true<bool>  <:  true<bool>
//│ | | 1. : (Code[α282',(α268 & α272)\x] | α264')
//│ | 1. : (Code[α282',(α268 & α272)\x] | α264')
//│ 1. : ((α262', α264',) -> (Code[α282',(α268 & α272)\x] | α264'))
//│ CONSTRAIN ((α262', α264',) -> (Code[α282',(α268 & α272)\x] | α264')) <! test261'
//│   where 
//│ 		test261' <: ((α274', Code[α280',(α276 & {x: α279'})],) -> α281')
//│ 		α262' <: int<number> & number<>
//│ 		α264' <: Code[α275,α276]
//│ 		α268 <: ⊥
//│ 		α274' :> int<number>
//│ 		α275 <: int<number>
//│ 		α279' <: int<number>
//│ 		α280' :> int<number>
//│ 		α281' <: Code[α271,α272]
//│ 		α282' :> α271
//│ C ((α262', α264',) -> (Code[α282',(α268 & α272)\x] | α264')) <! test261'    (0)
//│ | C ((α262', α264',) -> (Code[α282',(α268 & α272)\x] | α264')) <! ((α274', Code[α280',(α276 & {x: α279'})],) -> α281')    (1)
//│ | | C (α274', Code[α280',(α276 & {x: α279'})],) <! (α262', α264',)    (2)
//│ | | | C α274' <! α262'    (3)
//│ | | | | C int<number> <! α262'    (4)
//│ | | | | | C int<number> <! int<number>    (5)
//│ | | | | | C int<number> <! number<>    (5)
//│ | | | C Code[α280',(α276 & {x: α279'})] <! α264'    (5)
//│ | | | | C Code[α280',(α276 & {x: α279'})] <! Code[α275,α276]    (6)
//│ | | | | | C α280' <! α275    (7)
//│ | | | | | | C int<number> <! α275    (8)
//│ | | | | | | | C int<number> <! int<number>    (9)
//│ | | | | | C α276 <! (α276 & {x: α279'})    (9)
//│ | | | | | | EXTR RHS  (α276 & {x: α279'})  ~>  (α276 & {x: α284})  to 0
//│ | | | | | |  where 
//│ 		α284 <: int<number>
//│ | | | | | |    and 
//│ 		α279' :> α284 <: int<number>
//│ 		α284 <: int<number>
//│ | | | | | | C α276 <! (α276 & {x: α284})    (10)
//│ | | C (Code[α282',(α268 & α272)\x] | α264') <! α281'    (11)
//│ | | | C (Code[α282',(α268 & α272)\x] | α264') <! Code[α271,α272]    (12)
//│ | | | | C Code[α282',(α268 & α272)\x] <! Code[α271,α272]    (13)
//│ | | | | | C α282' <! α271    (14)
//│ | | | | | | C α271 <! α271    (15)
//│ | | | | | C α272 <! (α268 & α272)\x    (15)
//│ | | | | C α264' <! Code[α271,α272]    (16)
//│ | | | | | C Code[α280',(α276 & {x: α279'})] <! Code[α271,α272]    (17)
//│ | | | | | | C α280' <! α271    (18)
//│ | | | | | | | C int<number> <! α271    (19)
//│ | | | | | | C α272 <! (α276 & {x: α279'})    (20)
//│ | | | | | | | EXTR RHS  (α276 & {x: α279'})  ~>  (α276 & {x: α285})  to 0
//│ | | | | | | |  where 
//│ 		α276 <: (α276 & {x: α284})
//│ 		α284 <: int<number>
//│ 		α285 <: int<number>
//│ | | | | | | |    and 
//│ 		α276 <: (α276 & {x: α284})
//│ 		α279' :> α285 | α284 <: int<number>
//│ 		α284 <: int<number>
//│ 		α285 <: int<number>
//│ | | | | | | | C α272 <! (α276 & {x: α285})    (21)
//│ ⬤ Typed as: test261'
//│  where: 
//│ 		test261' :> ((α262', α264',) -> (Code[α282',(α268 & α272)\x] | α264')) <: ((α274', Code[α280',(α276 & {x: α279'})],) -> α281')
//│ 		α262' :> int<number> <: int<number> & number<>
//│ 		α264' :> Code[α280',(α276 & {x: α279'})] <: Code[α271,α272] & Code[α275,α276]
//│ 		α268 <: ⊥
//│ 		α271 :> int<number>
//│ 		α272 <: (α276 & {x: α285}) & (α268 & α272)\x
//│ 		α274' :> int<number> <: α262'
//│ 		α275 :> int<number> <: int<number>
//│ 		α276 <: (α276 & {x: α284})
//│ 		α279' :> α285 | α284 <: int<number>
//│ 		α280' :> int<number> <: α271 & α275
//│ 		α281' :> (Code[α282',(α268 & α272)\x] | α264') <: Code[α271,α272]
//│ 		α282' :> α271 <: α271
//│ 		α284 <: int<number>
//│ 		α285 <: int<number>
//│ test: (int, Code[int | 'a, ?] & 'b,) -> (Code[int | 'a, nothing\x & {x: int} & 'c] | 'b)
