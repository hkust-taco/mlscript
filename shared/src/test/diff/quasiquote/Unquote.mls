// :NewParser
:NewParser
:d
code"z + 1"
//│ 0. Typing term Quoted' + (z,) (1,) '
//│ | typing for 507
//│ | 0. Typing term + (z,) (1,)
//│ | | 0. Typing term + (z,)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term z,
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | | insert z into the free vars
//│ | | | | 0. : α26
//│ | | | 0. : (α26,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α26 -> α27)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α26 -> α27)    (0)
//│ | | | | C (α26,) <! (int<number>,)    (1)
//│ | | | | | C α26 <! int<number>    (2)
//│ | | | | C (int<number> -> int<number>) <! α27    (3)
//│ | | 0. : α27
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α27 <! (1<int,number> -> α28)
//│ | |   where 
//│ 		α27 :> (int<number> -> int<number>)
//│ | | C α27 <! (1<int,number> -> α28)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α28)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α28    (2)
//│ | 0. : α28
//│ | chaining for 507
//│ | local unquoted context:
//│ | List()
//│ | {z: α26}
//│ 0. : Code[α28,({test1: α29, test2: α29} & ~({test1: α29}))]
//│ ⬤ Typed as: Code[α28,({test1: α29, test2: α29} & ~({test1: α29}))]
//│  where: 
//│ 		α28 :> int<number>
//│ res: Code[int, ?]
//│    = [ 'App', '+', [ 'Var', [ 'FreeVar', 'z' ] ], [ '_', 1 ] ]

:NewParser
:d
code"z +
1"
//│ ╔══[PARSE ERROR] Unexpected newline in expression position
//│ ║  l.8: 	code"z +
//│ ║       	        ^
//│ ║  l.9: 	1"
//│ ╙──     	
//│ 0. Typing term Quoted' + (z,) (1,) '
//│ | typing for 519
//│ | 0. Typing term + (z,) (1,)
//│ | | 0. Typing term + (z,)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term z,
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | | insert z into the free vars
//│ | | | | 0. : α33
//│ | | | 0. : (α33,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α33 -> α34)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α33 -> α34)    (0)
//│ | | | | C (α33,) <! (int<number>,)    (1)
//│ | | | | | C α33 <! int<number>    (2)
//│ | | | | C (int<number> -> int<number>) <! α34    (3)
//│ | | 0. : α34
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α34 <! (1<int,number> -> α35)
//│ | |   where 
//│ 		α34 :> (int<number> -> int<number>)
//│ | | C α34 <! (1<int,number> -> α35)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α35)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α35    (2)
//│ | 0. : α35
//│ | chaining for 519
//│ | local unquoted context:
//│ | List()
//│ | {z: α33}
//│ 0. : Code[α35,({test1: α36, test2: α36} & ~({test1: α36}))]
//│ ⬤ Typed as: Code[α35,({test1: α36, test2: α36} & ~({test1: α36}))]
//│  where: 
//│ 		α35 :> int<number>
//│ res: Code[int, ?]
//│    = [ 'App', '+', [ 'Var', [ 'FreeVar', 'z' ] ], [ '_', 1 ] ]

:d
:ne
:NoJS
fun f(x, y) = code"[${x}, ${y}]"
//│ 1. Typing term x, y, => Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | 1. Typing pattern x, y,
//│ | | 1. Typing pattern x
//│ | | 1. : α41'
//│ | | 1. Typing pattern y
//│ | | 1. : α42'
//│ | 1. : (α41', α42',)
//│ | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | | typing for 852
//│ | | 1. Typing term '(' Unquote' x ', Unquote' y ', ')'
//│ | | | 1. Typing term Unquote' x ', Unquote' y ',
//│ | | | | 1. Typing term Unquote' x '
//│ | | | | | 1. Typing term x
//│ | | | | | | inspect x by ctx.get
//│ | | | | | 1. : α41'
//│ | | | | | CONSTRAIN (Code[α43,α44] -> α43) <! (α41' -> α45')
//│ | | | | |   where 
//│ | | | | | C (Code[α43,α44] -> α43) <! (α41' -> α45')    (0)
//│ | | | | | | C α41' <! Code[α43,α44]    (1)
//│ | | | | | | C α43 <! α45'    (2)
//│ | | | | 1. : α45'
//│ | | | | 1. Typing term Unquote' y '
//│ | | | | | 1. Typing term y
//│ | | | | | | inspect y by ctx.get
//│ | | | | | 1. : α42'
//│ | | | | | CONSTRAIN (Code[α46,α47] -> α46) <! (α42' -> α48')
//│ | | | | |   where 
//│ | | | | | C (Code[α46,α47] -> α46) <! (α42' -> α48')    (0)
//│ | | | | | | C α42' <! Code[α46,α47]    (1)
//│ | | | | | | C α46 <! α48'    (2)
//│ | | | | 1. : α48'
//│ | | | 1. : (α45', α48',)
//│ | | 1. : (α45', α48',)
//│ | | chaining for 852
//│ | | local unquoted context:
//│ | | List(α44, α47)
//│ | | {}
//│ | 1. : Code[(α45', α48',),({test1: α49', test2: α49'} & ~({test1: α49'}))]
//│ 1. : ((α41', α42',) -> Code[(α45', α48',),({test1: α49', test2: α49'} & ~({test1: α49'}))])
//│ CONSTRAIN ((α41', α42',) -> Code[(α45', α48',),({test1: α49', test2: α49'} & ~({test1: α49'}))]) <! f40'
//│   where 
//│ 		α41' <: Code[α43,α44]
//│ 		α42' <: Code[α46,α47]
//│ 		α45' :> α43
//│ 		α48' :> α46
//│ C ((α41', α42',) -> Code[(α45', α48',),({test1: α49', test2: α49'} & ~({test1: α49'}))]) <! f40'    (0)
//│ ⬤ Typed as: f40'
//│  where: 
//│ 		f40' :> ((α41', α42',) -> Code[(α45', α48',),({test1: α49', test2: α49'} & ~({test1: α49'}))])
//│ 		α41' <: Code[α43,α44]
//│ 		α42' <: Code[α46,α47]
//│ 		α45' :> α43
//│ 		α48' :> α46
//│ f: (Code['a, ?], Code['b, ?],) -> Code[('a, 'b,), ?]

let x = code"y"
//│ x: Code[nothing, ?]

let c = f(x, x)
//│ c: Code[(nothing, nothing,), ?]

code"y"
y => code"[${code"y"}, ${code"y"}]"
//│ res: Code[nothing, ?]
//│ res: 'a -> Code[('a, 'a,), ?]

code"y => ${c}"
//│ res: Code[anything -> (nothing, nothing,), ?]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, ?] & 'b, Code['c, ?] & 'd,) -> (Code[('a, 'c,), ?], 'b, 'd,)

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]


fun f(x) = x
//│ f: 'a -> 'a

code"f(0)"
//│ res: Code[0, ?]
code"${a + b} + 10"
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.143: 	code"${a + b} + 10"
//│ ║         	       ^^^
//│ ╟── type `code & {Code#C :> {z: int}, Code#T <: int}` is not an instance of type `int`
//│ ║  l.134: 	let a: Code<int, {z: int}>
//│ ║         	       ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.143: 	code"${a + b} + 10"
//│ ╙──       	       ^
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.143: 	code"${a + b} + 10"
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in unquote:
//│ ║  l.143: 	code"${a + b} + 10"
//│ ║         	     ^^^^^^^^
//│ ╟── operator application of type `int` is not an instance of type `code`
//│ ║  l.143: 	code"${a + b} + 10"
//│ ╙──       	       ^^^^^
//│ res: Code[int, ?]

:NewParser
code"let a = 1; let b = 3; ${code"b + ${code"1"}"} + 1"
//│ res: Code[int, ?]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | typing for 927
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | | inspect Const by ctx.get
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | | inspect n by ctx.get
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α208)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α208)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α208    (1)
//│ | | | | | 0. : α208
//│ | | | | | CONSTRAIN (Code[α206,α207] -> α206) <! (α208 -> α209)
//│ | | | | |   where 
//│ 		α208 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α206,α207] -> α206) <! (α208 -> α209)    (0)
//│ | | | | | | C α208 <! Code[α206,α207]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α206,α207]    (2)
//│ | | | | | | | | C int<number> <! α206    (3)
//│ | | | | | | | | C α207 <! ⊥    (4)
//│ | | | | | | C α206 <! α209    (5)
//│ | | | | | | | C int<number> <! α209    (6)
//│ | | | | 0. : α209
//│ | | | 0. : (α209,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α209 -> α210)
//│ | | |   where 
//│ 		α209 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α209 -> α210)    (0)
//│ | | | | C (α209,) <! (int<number>,)    (1)
//│ | | | | | C α209 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α210    (3)
//│ | | 0. : α210
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α210 <! (1<int,number> -> α211)
//│ | |   where 
//│ 		α210 :> (int<number> -> int<number>)
//│ | | C α210 <! (1<int,number> -> α211)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α211)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α211    (2)
//│ | 0. : α211
//│ | chaining for 927
//│ | local unquoted context:
//│ | List(α207)
//│ | {}
//│ 0. : Code[α211,({test1: α212, test2: α212} & ~({test1: α212}))]
//│ ⬤ Typed as: Code[α211,({test1: α212, test2: α212} & ~({test1: α212}))]
//│  where: 
//│ 		α211 :> int<number>
//│ n: 1
//│ res: Code[int, ?]

:NewParser
code"let a = 1; let b = 3"
//│ res: Code[undefined, ?]

:NewParser
code"let a = 1; 
let b = 3"
//│ ╔══[PARSE ERROR] Unexpected newline in expression position
//│ ║  l.252: 	code"let a = 1; 
//│ ║         	                ^
//│ ║  l.253: 	let b = 3"
//│ ╙──       	
//│ res: Code[undefined, ?]



:NewParser
:d
code"let x = 1; ${y
}
"
//│ 0. Typing term Quoted' let x = 1 in Unquote' y ' '
//│ | typing for 233
//│ | 0. Typing term let x = 1 in Unquote' y '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term Unquote' y '
//│ | | | 0. Typing term y
//│ | | | | inspect y by ctx.get
//│ | | | | insert y into the free vars
//│ | | | 0. : α224
//│ | | | CONSTRAIN (Code[α222,α223] -> α222) <! (α224 -> α225)
//│ | | |   where 
//│ | | | C (Code[α222,α223] -> α222) <! (α224 -> α225)    (0)
//│ | | | | C α224 <! Code[α222,α223]    (1)
//│ | | | | C α222 <! α225    (2)
//│ | | 0. : α225
//│ | 0. : α225
//│ | chaining for 233
//│ | local unquoted context:
//│ | List(α223)
//│ | {y: α224}
//│ 0. : Code[α225,({test1: α226, test2: α226} & ~({test1: α226}))]
//│ ⬤ Typed as: Code[α225,({test1: α226, test2: α226} & ~({test1: α226}))]
//│  where: 
//│ res: Code[nothing, ?]

:NewParser
:d
:ge
class Foo(
x
) 
let f = new Foo(
5)
//│ ╔══[PARSE ERROR] Unexpected identifier here
//│ ║  l.298: 	x
//│ ╙──       	^
//│ ╔══[PARSE ERROR] Unexpected literal here
//│ ║  l.301: 	5)
//│ ╙──       	^
//│ 0. Typing type Record(List())
//│ | vars=Map() newDefsInfo=Map(Foo -> (Cls,0))
//│ => ⊤ | 
//│ Defined class Foo
//│ 1. Typing term  => Foo ({},)
//│ | 1. Typing pattern 
//│ | 1. : ()
//│ | 1. Typing term Foo ({},)
//│ | | 1. Typing term Foo
//│ | | | inspect Foo by ctx.get
//│ | | 1. : (⊤ -> foo<>)
//│ | | 1. Typing term {},
//│ | | | 1. Typing term {}
//│ | | | 1. : ⊤
//│ | | 1. : (⊤,)
//│ | | CONSTRAIN (⊤ -> foo<>) <! (⊤ -> α231')
//│ | |   where 
//│ | | C (⊤ -> foo<>) <! (⊤ -> α231')    (0)
//│ | | | C (⊤,) <! (⊤,)    (1)
//│ | | | C foo<> <! α231'    (1)
//│ | 1. : α231'
//│ 1. : (() -> α231')
//│ ⬤ Typed as: (() -> α231')
//│  where: 
//│ 		α231' :> foo<>
//│ 1. Typing term new Foo() {}
//│ | 1. Typing term Foo ()
//│ | | 1. Typing term Foo
//│ | | | inspect Foo by ctx.get
//│ | | 1. : (() -> α233')
//│ | | 1. Typing term 
//│ | | 1. : ()
//│ | | CONSTRAIN (() -> α233') <! (() -> α234')
//│ | |   where 
//│ 		α233' :> foo<>
//│ | | C (() -> α233') <! (() -> α234')    (0)
//│ | | | C () <! ()    (1)
//│ | | | C α233' <! α234'    (1)
//│ | | | | C foo<> <! α234'    (2)
//│ | 1. : α234'
//│ 1. : α234'
//│ ⬤ Typed as: α234'
//│  where: 
//│ 		α234' :> foo<>
//│ Foo: () -> Foo
//│ f: Foo
