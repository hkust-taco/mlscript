:NewParser
:d 
:ne
:NoJS
code"${a}"
//│ 0. Typing term Quoted' a '
//│ | 0. Typing term a
//│ | 0. : error<>
//│ 0. : Code[error<>]
//│ ⬤ Typed as: Code[error<>]
//│  where: 
//│ ╔══[ERROR] identifier not found: a
//│ ║  l.5: 	code"${a}"
//│ ╙──     	     ^^^^
//│ res: code & {Code#T <: error}


// Test case: unquoted syntax
// 
// Description: parsing unquoted syntax


// Test case: track function free variable
// 
// Description: track free variable x



:d 
:ne
:NoJS
code"(x) => x + 1"
//│ 0. Typing term Quoted' x, => + (x,) (1,) '
//│ | 0. Typing term x, => + (x,) (1,)
//│ | | 0. Typing pattern x,
//│ | | | 0. Typing pattern x
//│ | | | 0. : α24
//│ | | 0. : (α24,)
//│ | | 0. Typing term + (x,) (1,)
//│ | | | 0. Typing term + (x,)
//│ | | | | 0. Typing term +
//│ | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | 0. Typing term x,
//│ | | | | | 0. Typing term x
//│ | | | | | 0. : α24
//│ | | | | 0. : (α24,)
//│ | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α24 -> α25)
//│ | | | |   where 
//│ | | | | C (int<number> -> (int<number> -> int<number>)) <! (α24 -> α25)    (0)
//│ | | | | | C (α24,) <! (int<number>,)    (1)
//│ | | | | | | C α24 <! int<number>    (2)
//│ | | | | | C (int<number> -> int<number>) <! α25    (3)
//│ | | | 0. : α25
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN α25 <! (1<int,number> -> α26)
//│ | | |   where 
//│ 		α25 :> (int<number> -> int<number>)
//│ | | | C α25 <! (1<int,number> -> α26)    (0)
//│ | | | | C (int<number> -> int<number>) <! (1<int,number> -> α26)    (1)
//│ | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | C int<number> <! α26    (2)
//│ | | 0. : α26
//│ | 0. : (α24 -> α26)
//│ 0. : Code[(α24 -> α26)]
//│ ⬤ Typed as: Code[(α24 -> α26)]
//│  where: 
//│ 		α24 <: int<number>
//│ 		α26 :> int<number>
//│ res: code & {Code#T <: int -> int}
