:NewParser
:d
:ne
:NoJS
code"z"
code"z + y"
//│ 0. Typing term Quoted' z '
//│ | typing for 883
//│ | 0. Typing term z
//│ | | inspect z by ctx.get
//│ | | insert z into the free vars
//│ | 0. : α26
//│ | chaining for 883
//│ | local unquoted context:
//│ | List()
//│ | {z: α26}
//│ 0. : Code[α26,{z: α26}]
//│ ⬤ Typed as: Code[α26,{z: α26}]
//│  where: 
//│ 0. Typing term Quoted' + (z,) (y,) '
//│ | typing for 375
//│ | 0. Typing term + (z,) (y,)
//│ | | 0. Typing term + (z,)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term z,
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | | insert z into the free vars
//│ | | | | 0. : α30
//│ | | | 0. : (α30,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α30 -> α31)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α30 -> α31)    (0)
//│ | | | | C (α30,) <! (int<number>,)    (1)
//│ | | | | | C α30 <! int<number>    (2)
//│ | | | | C (int<number> -> int<number>) <! α31    (3)
//│ | | 0. : α31
//│ | | 0. Typing term y,
//│ | | | 0. Typing term y
//│ | | | | inspect y by ctx.get
//│ | | | | insert y into the free vars
//│ | | | 0. : α32
//│ | | 0. : (α32,)
//│ | | CONSTRAIN α31 <! (α32 -> α33)
//│ | |   where 
//│ 		α31 :> (int<number> -> int<number>)
//│ | | C α31 <! (α32 -> α33)    (0)
//│ | | | C (int<number> -> int<number>) <! (α32 -> α33)    (1)
//│ | | | | C (α32,) <! (int<number>,)    (2)
//│ | | | | | C α32 <! int<number>    (3)
//│ | | | | C int<number> <! α33    (4)
//│ | 0. : α33
//│ | chaining for 375
//│ | local unquoted context:
//│ | List()
//│ | {y: α32, z: α30}
//│ 0. : Code[α33,{y: α32, z: α30}]
//│ ⬤ Typed as: Code[α33,{y: α32, z: α30}]
//│  where: 
//│ 		α30 <: int<number>
//│ 		α32 <: int<number>
//│ 		α33 :> int<number>
//│ res: Code['a, {z: 'a}]
//│ res: Code[int, {y: int, z: int}]

:d
:ne
:NoJS
fun f(x, y) = [code"[${x}, ${y}]", code"${x}"]
fun f(x, y) = code"[${x}, ${y}]"
//│ 1. Typing term x, y, => '(' Quoted' '(' Unquote' x ', Unquote' y ', ')' ', Quoted' Unquote' x ' ', ')'
//│ | 1. Typing pattern x, y,
//│ | | 1. Typing pattern x
//│ | | 1. : α38'
//│ | | 1. Typing pattern y
//│ | | 1. : α39'
//│ | 1. : (α38', α39',)
//│ | 1. Typing term '(' Quoted' '(' Unquote' x ', Unquote' y ', ')' ', Quoted' Unquote' x ' ', ')'
//│ | | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' ', Quoted' Unquote' x ' ',
//│ | | | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | | | | typing for 989
//│ | | | | 1. Typing term '(' Unquote' x ', Unquote' y ', ')'
//│ | | | | | 1. Typing term Unquote' x ', Unquote' y ',
//│ | | | | | | 1. Typing term Unquote' x '
//│ | | | | | | | 1. Typing term x
//│ | | | | | | | | inspect x by ctx.get
//│ | | | | | | | 1. : α38'
//│ | | | | | | | CONSTRAIN (Code[α40,α41] -> α40) <! (α38' -> α42')
//│ | | | | | | |   where 
//│ | | | | | | | C (Code[α40,α41] -> α40) <! (α38' -> α42')    (0)
//│ | | | | | | | | C α38' <! Code[α40,α41]    (1)
//│ | | | | | | | | C α40 <! α42'    (2)
//│ | | | | | | 1. : α42'
//│ | | | | | | 1. Typing term Unquote' y '
//│ | | | | | | | 1. Typing term y
//│ | | | | | | | | inspect y by ctx.get
//│ | | | | | | | 1. : α39'
//│ | | | | | | | CONSTRAIN (Code[α43,α44] -> α43) <! (α39' -> α45')
//│ | | | | | | |   where 
//│ | | | | | | | C (Code[α43,α44] -> α43) <! (α39' -> α45')    (0)
//│ | | | | | | | | C α39' <! Code[α43,α44]    (1)
//│ | | | | | | | | C α43 <! α45'    (2)
//│ | | | | | | 1. : α45'
//│ | | | | | 1. : (α42', α45',)
//│ | | | | 1. : (α42', α45',)
//│ | | | | chaining for 989
//│ | | | | local unquoted context:
//│ | | | | List(α41, α44)
//│ | | | | {}
//│ | | | 1. : Code[(α42', α45',),(α41 & α44)]
//│ | | | 1. Typing term Quoted' Unquote' x ' '
//│ | | | | typing for 804
//│ | | | | 1. Typing term Unquote' x '
//│ | | | | | 1. Typing term x
//│ | | | | | | inspect x by ctx.get
//│ | | | | | 1. : α38'
//│ | | | | | CONSTRAIN (Code[α46,α47] -> α46) <! (α38' -> α48')
//│ | | | | |   where 
//│ 		α38' <: Code[α40,α41]
//│ | | | | | C (Code[α46,α47] -> α46) <! (α38' -> α48')    (0)
//│ | | | | | | C α38' <! Code[α46,α47]    (1)
//│ | | | | | | C α46 <! α48'    (2)
//│ | | | | 1. : α48'
//│ | | | | chaining for 804
//│ | | | | local unquoted context:
//│ | | | | List(α47)
//│ | | | | {}
//│ | | | 1. : Code[α48',α47]
//│ | | 1. : (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],)
//│ | 1. : (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],)
//│ 1. : ((α38', α39',) -> (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],))
//│ CONSTRAIN ((α38', α39',) -> (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],)) <! f37'
//│   where 
//│ 		α38' <: Code[α46,α47] & Code[α40,α41]
//│ 		α39' <: Code[α43,α44]
//│ 		α42' :> α40
//│ 		α45' :> α43
//│ 		α48' :> α46
//│ C ((α38', α39',) -> (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],)) <! f37'    (0)
//│ ⬤ Typed as: f37'
//│  where: 
//│ 		f37' :> ((α38', α39',) -> (Code[(α42', α45',),(α41 & α44)], Code[α48',α47],))
//│ 		α38' <: Code[α46,α47] & Code[α40,α41]
//│ 		α39' <: Code[α43,α44]
//│ 		α42' :> α40
//│ 		α45' :> α43
//│ 		α48' :> α46
//│ 1. Typing term x, y, => Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | 1. Typing pattern x, y,
//│ | | 1. Typing pattern x
//│ | | 1. : α72'
//│ | | 1. Typing pattern y
//│ | | 1. : α73'
//│ | 1. : (α72', α73',)
//│ | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | | typing for 117
//│ | | 1. Typing term '(' Unquote' x ', Unquote' y ', ')'
//│ | | | 1. Typing term Unquote' x ', Unquote' y ',
//│ | | | | 1. Typing term Unquote' x '
//│ | | | | | 1. Typing term x
//│ | | | | | | inspect x by ctx.get
//│ | | | | | 1. : α72'
//│ | | | | | CONSTRAIN (Code[α74,α75] -> α74) <! (α72' -> α76')
//│ | | | | |   where 
//│ | | | | | C (Code[α74,α75] -> α74) <! (α72' -> α76')    (0)
//│ | | | | | | C α72' <! Code[α74,α75]    (1)
//│ | | | | | | C α74 <! α76'    (2)
//│ | | | | 1. : α76'
//│ | | | | 1. Typing term Unquote' y '
//│ | | | | | 1. Typing term y
//│ | | | | | | inspect y by ctx.get
//│ | | | | | 1. : α73'
//│ | | | | | CONSTRAIN (Code[α77,α78] -> α77) <! (α73' -> α79')
//│ | | | | |   where 
//│ | | | | | C (Code[α77,α78] -> α77) <! (α73' -> α79')    (0)
//│ | | | | | | C α73' <! Code[α77,α78]    (1)
//│ | | | | | | C α77 <! α79'    (2)
//│ | | | | 1. : α79'
//│ | | | 1. : (α76', α79',)
//│ | | 1. : (α76', α79',)
//│ | | chaining for 117
//│ | | local unquoted context:
//│ | | List(α75, α78)
//│ | | {}
//│ | 1. : Code[(α76', α79',),(α75 & α78)]
//│ 1. : ((α72', α73',) -> Code[(α76', α79',),(α75 & α78)])
//│ CONSTRAIN ((α72', α73',) -> Code[(α76', α79',),(α75 & α78)]) <! f71'
//│   where 
//│ 		α72' <: Code[α74,α75]
//│ 		α73' <: Code[α77,α78]
//│ 		α76' :> α74
//│ 		α79' :> α77
//│ C ((α72', α73',) -> Code[(α76', α79',),(α75 & α78)]) <! f71'    (0)
//│ ⬤ Typed as: f71'
//│  where: 
//│ 		f71' :> ((α72', α73',) -> Code[(α76', α79',),(α75 & α78)])
//│ 		α72' <: Code[α74,α75]
//│ 		α73' <: Code[α77,α78]
//│ 		α76' :> α74
//│ 		α79' :> α77
//│ f: (Code['a | 'b, 'c & 'd], Code['e, 'd],) -> (Code[('b, 'e,), 'd], Code['a, 'c],)
//│ f: (Code['a, 'b], Code['c, 'b],) -> Code[('a, 'c,), 'b]

let x = code"y"
//│ x: Code['a, {y: 'a}]

let c = f(x, x)
//│ c: Code[('a, 'a,), {y: 'a}]

code"y => ${c}"
//│ res: Code[anything -> ('a, 'a,), {y: 'a}]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, 'b] & 'c, Code['d, 'b] & 'e,) -> (Code[('a, 'd,), 'b], 'c, 'e,)

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]


fun f(x) = x
//│ f: 'a -> 'a

code"f(0)"
//│ res: Code[0, anything]

:NewParser
:d
:ne
:NoJS
code"${code"${code"${z}"}"}"
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' ' '
//│ | typing for 425
//│ | 0. Typing term Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' '
//│ | | 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | | | typing for 624
//│ | | | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | | | typing for 451
//│ | | | | | 0. Typing term Unquote' z '
//│ | | | | | | 0. Typing term z
//│ | | | | | | | inspect z by ctx.get
//│ | | | | | | | insert z into the free vars
//│ | | | | | | 0. : α188
//│ | | | | | | CONSTRAIN (Code[α186,α187] -> α186) <! (α188 -> α189)
//│ | | | | | |   where 
//│ | | | | | | C (Code[α186,α187] -> α186) <! (α188 -> α189)    (0)
//│ | | | | | | | C α188 <! Code[α186,α187]    (1)
//│ | | | | | | | C α186 <! α189    (2)
//│ | | | | | 0. : α189
//│ | | | | | chaining for 451
//│ | | | | | local unquoted context:
//│ | | | | | List(α187)
//│ | | | | | {}
//│ | | | | 0. : Code[α189,α187]
//│ | | | | CONSTRAIN (Code[α184,α185] -> α184) <! (Code[α189,α187] -> α190)
//│ | | | |   where 
//│ | | | | C (Code[α184,α185] -> α184) <! (Code[α189,α187] -> α190)    (0)
//│ | | | | | C Code[α189,α187] <! Code[α184,α185]    (1)
//│ | | | | | | C α189 <! α184    (2)
//│ | | | | | | C α185 <! α187    (3)
//│ | | | | | C α184 <! α190    (4)
//│ | | | 0. : α190
//│ | | | chaining for 624
//│ | | | local unquoted context:
//│ | | | List(α185)
//│ | | | {}
//│ | | 0. : Code[α190,α185]
//│ | | CONSTRAIN (Code[α182,α183] -> α182) <! (Code[α190,α185] -> α191)
//│ | |   where 
//│ 		α185 <: α187
//│ | | C (Code[α182,α183] -> α182) <! (Code[α190,α185] -> α191)    (0)
//│ | | | C Code[α190,α185] <! Code[α182,α183]    (1)
//│ | | | | C α190 <! α182    (2)
//│ | | | | C α183 <! α185    (3)
//│ | | | C α182 <! α191    (4)
//│ | 0. : α191
//│ | chaining for 425
//│ | local unquoted context:
//│ | List(α183)
//│ | {}
//│ 0. : Code[α191,α183]
//│ ⬤ Typed as: Code[α191,α183]
//│  where: 
//│ 		α183 <: α185
//│ 		α185 <: α187
//│ ╔══[ERROR] identifier not found: z
//│ ║  l.216: 	code"${code"${code"${z}"}"}"
//│ ╙──       	                     ^
//│ res: Code[nothing, anything]


:NewParser
:d
:ne
:NoJS
let z = code"1"
code"${code"${z}"}"
//│ 1. Typing term Quoted' 1 '
//│ | typing for 675
//│ | 1. Typing term 1
//│ | 1. : 1<int,number>
//│ | chaining for 675
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 1. : Code[1<int,number>,{}]
//│ ⬤ Typed as: Code[1<int,number>,{}]
//│  where: 
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | typing for 270
//│ | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | typing for 560
//│ | | | 0. Typing term Unquote' z '
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | 0. : Code[1<int,number>,{}]
//│ | | | | CONSTRAIN (Code[α198,α199] -> α198) <! (Code[1<int,number>,{}] -> α200)
//│ | | | |   where 
//│ | | | | C (Code[α198,α199] -> α198) <! (Code[1<int,number>,{}] -> α200)    (0)
//│ | | | | | C Code[1<int,number>,{}] <! Code[α198,α199]    (1)
//│ | | | | | | C 1<int,number> <! α198    (2)
//│ | | | | | | C α199 <! {}    (3)
//│ | | | | | C α198 <! α200    (4)
//│ | | | | | | C 1<int,number> <! α200    (5)
//│ | | | 0. : α200
//│ | | | chaining for 560
//│ | | | local unquoted context:
//│ | | | List(α199)
//│ | | | {}
//│ | | 0. : Code[α200,α199]
//│ | | CONSTRAIN (Code[α196,α197] -> α196) <! (Code[α200,α199] -> α201)
//│ | |   where 
//│ 		α200 :> 1<int,number>
//│ | | C (Code[α196,α197] -> α196) <! (Code[α200,α199] -> α201)    (0)
//│ | | | C Code[α200,α199] <! Code[α196,α197]    (1)
//│ | | | | C α200 <! α196    (2)
//│ | | | | | C 1<int,number> <! α196    (3)
//│ | | | | C α197 <! α199    (4)
//│ | | | C α196 <! α201    (5)
//│ | | | | C 1<int,number> <! α201    (6)
//│ | 0. : α201
//│ | chaining for 270
//│ | local unquoted context:
//│ | List(α197)
//│ | {}
//│ 0. : Code[α201,α197]
//│ ⬤ Typed as: Code[α201,α197]
//│  where: 
//│ 		α197 <: α199
//│ 		α201 :> 1<int,number>
//│ z: Code[1, anything]
//│ res: Code[1, anything]

:NewParser
:d
:ne
:NoJS
code"let x = 1; let z = 1; code"x""
//│ 0. Typing term Quoted' let x = 1 in let z = 1 in Quoted' x ' '
//│ | typing for 860
//│ | 0. Typing term let x = 1 in let z = 1 in Quoted' x '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term let z = 1 in Quoted' x '
//│ | | | 1. Typing term 1
//│ | | | 1. : 1<int,number>
//│ | | | 0. Typing term Quoted' x '
//│ | | | | typing for 68
//│ | | | | 0. Typing term x
//│ | | | | | inspect x by ctx.get
//│ | | | | 0. : 1<int,number>
//│ | | | | chaining for 68
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {}
//│ | | | 0. : Code[1<int,number>,{}]
//│ | | 0. : Code[1<int,number>,{}]
//│ | 0. : Code[1<int,number>,{}]
//│ | chaining for 860
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 0. : Code[Code[1<int,number>,{}],{}]
//│ ⬤ Typed as: Code[Code[1<int,number>,{}],{}]
//│  where: 
//│ res: Code[Code[1, anything], anything]

:NewParser
:d
:ne
:NoJS
code"x; code"x""
//│ ╔══[PARSE ERROR] Unexpected ';' keyword here
//│ ║  l.379: 	code"x; code"x""
//│ ╙──       	      ^
//│ 0. Typing term Quoted' x '
//│ | typing for 13
//│ | 0. Typing term x
//│ | | inspect x by ctx.get
//│ | 0. : Code[[α205],{y: α205}]
//│ | chaining for 13
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 0. : Code[Code[[α205],{y: α205}],{}]
//│ ⬤ Typed as: Code[Code[[α205],{y: α205}],{}]
//│  where: 
//│ res: Code[Code['a, {y: 'a}], anything]

:NewParser
:d
:ne
:NoJS
code"let z = 0;${code"z"}"
//│ 0. Typing term Quoted' let z = 0 in Unquote' Quoted' z ' ' '
//│ | typing for 76
//│ | 0. Typing term let z = 0 in Unquote' Quoted' z ' '
//│ | | 1. Typing term 0
//│ | | 1. : 0<int,number>
//│ | | 0. Typing term Unquote' Quoted' z ' '
//│ | | | 0. Typing term Quoted' z '
//│ | | | | typing for 941
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | 0. : Code[1<int,number>,{}]
//│ | | | | chaining for 941
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {}
//│ | | | 0. : Code[Code[1<int,number>,{}],{}]
//│ | | | CONSTRAIN (Code[α209,α210] -> α209) <! (Code[Code[1<int,number>,{}],{}] -> α211)
//│ | | |   where 
//│ | | | C (Code[α209,α210] -> α209) <! (Code[Code[1<int,number>,{}],{}] -> α211)    (0)
//│ | | | | C Code[Code[1<int,number>,{}],{}] <! Code[α209,α210]    (1)
//│ | | | | | C Code[1<int,number>,{}] <! α209    (2)
//│ | | | | | C α210 <! {}    (3)
//│ | | | | C α209 <! α211    (4)
//│ | | | | | C Code[1<int,number>,{}] <! α211    (5)
//│ | | 0. : α211
//│ | 0. : α211
//│ | chaining for 76
//│ | local unquoted context:
//│ | List(α210)
//│ | {}
//│ 0. : Code[α211,α210]
//│ ⬤ Typed as: Code[α211,α210]
//│  where: 
//│ 		α211 :> Code[1<int,number>,{}]
//│ res: Code[Code[1, anything], anything]

:NewParser
:d
:ne
:NoJS
code"let x = 1;${code"x + y"}"
//│ 0. Typing term Quoted' let x = 1 in Unquote' Quoted' + (x,) (y,) ' ' '
//│ | typing for 999
//│ | 0. Typing term let x = 1 in Unquote' Quoted' + (x,) (y,) ' '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term Unquote' Quoted' + (x,) (y,) ' '
//│ | | | 0. Typing term Quoted' + (x,) (y,) '
//│ | | | | typing for 174
//│ | | | | 0. Typing term + (x,) (y,)
//│ | | | | | 0. Typing term + (x,)
//│ | | | | | | 0. Typing term +
//│ | | | | | | | inspect + by ctx.get
//│ | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | 0. Typing term x,
//│ | | | | | | | 0. Typing term x
//│ | | | | | | | | inspect x by ctx.get
//│ | | | | | | | 0. : Code[[α216],{y: α216}]
//│ | | | | | | 0. : (Code[[α216],{y: α216}],)
//│ | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (Code[[α216],{y: α216}] -> α217)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (Code[[α216],{y: α216}] -> α217)    (0)
//│ | | | | | | | C (Code[[α216],{y: α216}],) <! (int<number>,)    (1)
//│ | | | | | | | | C Code[[α216],{y: α216}] <! int<number>    (2)
//│ | | | | | | | | | C (code<> & {Code#T: mut ..[α216], Code#C: mut {y: α216}..⊤}) <! int<number>    (3)
//│ | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α216, Code#C: mut {y: α216}..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | Consider code<>{Code#T: mut ..α216, Code#C: mut {y: α216}..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | A  code<>{Code#T: mut ..α216, Code#C: mut {y: α216}..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..[α216], Code#C: mut {y: α216}..⊤}) <: int<number>
//│ | | | | | | | | | | | | allVarPols: =α216
//│ | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..[α216], Code#C: mut {y: α216}..⊤})
//│ | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..[α216], Code#C: mut {y: α216}..⊤})
//│ | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | norm[+] [α216]
//│ | | | | | | | | | | | | | | DNF: DNF(α216)
//│ | | | | | | | | | | | | | ~> α216
//│ | | | | | | | | | | | | | norm[-] {y: α216}
//│ | | | | | | | | | | | | | | DNF: DNF({y: α216})
//│ | | | | | | | | | | | | | | norm[-] α216
//│ | | | | | | | | | | | | | | | DNF: DNF(α216)
//│ | | | | | | | | | | | | | | ~> α216
//│ | | | | | | | | | | | | | ~> {y: α216}
//│ | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | ~> (code<> & {Code#C: mut {y: α216}..⊤, Code#T: mut ..α216})
//│ | | | | | | | | | | | | CONSTRAIN error<> <! α217
//│ | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | C error<> <! α217    (0)
//│ | | | | | | | C (int<number> -> int<number>) <! α217    (4)
//│ | | | | | 0. : α217
//│ | | | | | 0. Typing term y,
//│ | | | | | | 0. Typing term y
//│ | | | | | | | inspect y by ctx.get
//│ | | | | | | | insert y into the free vars
//│ | | | | | | 0. : α218
//│ | | | | | 0. : (α218,)
//│ | | | | | CONSTRAIN α217 <! (α218 -> α219)
//│ | | | | |   where 
//│ 		α217 :> (int<number> -> int<number>) | error<>
//│ | | | | | C α217 <! (α218 -> α219)    (0)
//│ | | | | | | C (int<number> -> int<number>) <! (α218 -> α219)    (1)
//│ | | | | | | | C (α218,) <! (int<number>,)    (2)
//│ | | | | | | | | C α218 <! int<number>    (3)
//│ | | | | | | | C int<number> <! α219    (4)
//│ | | | | | | C error<> <! (α218 -> α219)    (5)
//│ | | | | | | | C (α218,) <! error<>    (6)
//│ | | | | | | | C error<> <! α219    (7)
//│ | | | | 0. : α219
//│ | | | | chaining for 174
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {y: α218}
//│ | | | 0. : Code[α219,{y: α218}]
//│ | | | CONSTRAIN (Code[α214,α215] -> α214) <! (Code[α219,{y: α218}] -> α220)
//│ | | |   where 
//│ 		α218 <: int<number>
//│ 		α219 :> error<> | int<number>
//│ | | | C (Code[α214,α215] -> α214) <! (Code[α219,{y: α218}] -> α220)    (0)
//│ | | | | C Code[α219,{y: α218}] <! Code[α214,α215]    (1)
//│ | | | | | C α219 <! α214    (2)
//│ | | | | | | C error<> <! α214    (3)
//│ | | | | | | C int<number> <! α214    (4)
//│ | | | | | C α215 <! {y: α218}    (5)
//│ | | | | C α214 <! α220    (6)
//│ | | | | | C int<number> <! α220    (7)
//│ | | | | | C error<> <! α220    (8)
//│ | | 0. : α220
//│ | 0. : α220
//│ | chaining for 999
//│ | local unquoted context:
//│ | List(α215)
//│ | {}
//│ 0. : Code[α220,α215]
//│ ⬤ Typed as: Code[α220,α215]
//│  where: 
//│ 		α215 <: {y: α218}
//│ 		α218 <: int<number>
//│ 		α220 :> error<> | int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.442: 	code"let x = 1;${code"x + y"}"
//│ ║         	                      ^^^
//│ ╙── expression of type `code & {Code#C :> {y: ?a}, Code#T <: ?a}` is not an instance of type `int`
//│ res: Code[error | int, {y: int}]


:NewParser
:d
:ne
:NoJS
code"1 + ${code"b"}"
//│ 0. Typing term Quoted' + (1,) (Unquote' Quoted' b ' ',) '
//│ | typing for 984
//│ | 0. Typing term + (1,) (Unquote' Quoted' b ' ',)
//│ | | 0. Typing term + (1,)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α224)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α224)    (0)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | C (int<number> -> int<number>) <! α224    (1)
//│ | | 0. : α224
//│ | | 0. Typing term Unquote' Quoted' b ' ',
//│ | | | 0. Typing term Unquote' Quoted' b ' '
//│ | | | | 0. Typing term Quoted' b '
//│ | | | | | typing for 773
//│ | | | | | 0. Typing term b
//│ | | | | | | inspect b by ctx.get
//│ | | | | | | insert b into the free vars
//│ | | | | | 0. : α227
//│ | | | | | chaining for 773
//│ | | | | | local unquoted context:
//│ | | | | | List()
//│ | | | | | {b: α227}
//│ | | | | 0. : Code[α227,{b: α227}]
//│ | | | | CONSTRAIN (Code[α225,α226] -> α225) <! (Code[α227,{b: α227}] -> α228)
//│ | | | |   where 
//│ | | | | C (Code[α225,α226] -> α225) <! (Code[α227,{b: α227}] -> α228)    (0)
//│ | | | | | C Code[α227,{b: α227}] <! Code[α225,α226]    (1)
//│ | | | | | | C α227 <! α225    (2)
//│ | | | | | | C α226 <! {b: α227}    (3)
//│ | | | | | C α225 <! α228    (4)
//│ | | | 0. : α228
//│ | | 0. : (α228,)
//│ | | CONSTRAIN α224 <! (α228 -> α229)
//│ | |   where 
//│ 		α224 :> (int<number> -> int<number>)
//│ | | C α224 <! (α228 -> α229)    (0)
//│ | | | C (int<number> -> int<number>) <! (α228 -> α229)    (1)
//│ | | | | C (α228,) <! (int<number>,)    (2)
//│ | | | | | C α228 <! int<number>    (3)
//│ | | | | C int<number> <! α229    (4)
//│ | 0. : α229
//│ | chaining for 984
//│ | local unquoted context:
//│ | List(α226)
//│ | {}
//│ 0. : Code[α229,α226]
//│ ⬤ Typed as: Code[α229,α226]
//│  where: 
//│ 		α225 <: α228
//│ 		α226 <: {b: α227}
//│ 		α227 <: α225
//│ 		α228 <: int<number>
//│ 		α229 :> int<number>
//│ res: Code[int, {b: int}]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | typing for 96
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | | inspect Const by ctx.get
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | | inspect n by ctx.get
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α237)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α237)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α237    (1)
//│ | | | | | 0. : α237
//│ | | | | | CONSTRAIN (Code[α235,α236] -> α235) <! (α237 -> α238)
//│ | | | | |   where 
//│ 		α237 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α235,α236] -> α235) <! (α237 -> α238)    (0)
//│ | | | | | | C α237 <! Code[α235,α236]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α235,α236]    (2)
//│ | | | | | | | | C int<number> <! α235    (3)
//│ | | | | | | | | C α236 <! ⊥    (4)
//│ | | | | | | C α235 <! α238    (5)
//│ | | | | | | | C int<number> <! α238    (6)
//│ | | | | 0. : α238
//│ | | | 0. : (α238,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α238 -> α239)
//│ | | |   where 
//│ 		α238 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α238 -> α239)    (0)
//│ | | | | C (α238,) <! (int<number>,)    (1)
//│ | | | | | C α238 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α239    (3)
//│ | | 0. : α239
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α239 <! (1<int,number> -> α240)
//│ | |   where 
//│ 		α239 :> (int<number> -> int<number>)
//│ | | C α239 <! (1<int,number> -> α240)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α240)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α240    (2)
//│ | 0. : α240
//│ | chaining for 96
//│ | local unquoted context:
//│ | List(α236)
//│ | {}
//│ 0. : Code[α240,α236]
//│ ⬤ Typed as: Code[α240,α236]
//│  where: 
//│ 		α236 <: ⊥
//│ 		α240 :> int<number>
//│ n: 1
//│ res: Code[int, ?]

:NewParser
:d
:ne
:NoJS
fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ 1. Typing term n, cde, => if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | 1. Typing pattern n, cde,
//│ | | 1. Typing pattern n
//│ | | 1. : α244'
//│ | | 1. Typing pattern cde
//│ | | 1. : α245'
//│ | 1. : (α244', α245',)
//│ | 1. Typing term if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | | The mutable CaseOf tree
//│ | | if «> (n,) (0,)»
//│ | |   «Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '»
//│ | | else
//│ | |   «cde»
//│ | | Desugared term: case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | 1. Typing term case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | | 1. Typing term > (n,) (0,)
//│ | | | | 1. Typing term > (n,)
//│ | | | | | 1. Typing term >
//│ | | | | | | inspect > by ctx.get
//│ | | | | | 1. : (number<> -> (number<> -> bool<>))
//│ | | | | | 1. Typing term n,
//│ | | | | | | 1. Typing term n
//│ | | | | | | | inspect n by ctx.get
//│ | | | | | | 1. : α244'
//│ | | | | | 1. : (α244',)
//│ | | | | | CONSTRAIN (number<> -> (number<> -> bool<>)) <! (α244' -> α246')
//│ | | | | |   where 
//│ | | | | | C (number<> -> (number<> -> bool<>)) <! (α244' -> α246')    (0)
//│ | | | | | | C (α244',) <! (number<>,)    (1)
//│ | | | | | | | C α244' <! number<>    (2)
//│ | | | | | | C (number<> -> bool<>) <! α246'    (3)
//│ | | | | 1. : α246'
//│ | | | | 1. Typing term 0,
//│ | | | | | 1. Typing term 0
//│ | | | | | 1. : 0<int,number>
//│ | | | | 1. : (0<int,number>,)
//│ | | | | CONSTRAIN α246' <! (0<int,number> -> α247')
//│ | | | |   where 
//│ 		α246' :> (number<> -> bool<>)
//│ | | | | C α246' <! (0<int,number> -> α247')    (0)
//│ | | | | | C (number<> -> bool<>) <! (0<int,number> -> α247')    (1)
//│ | | | | | | C (0<int,number>,) <! (number<>,)    (2)
//│ | | | | | | C bool<> <! α247'    (2)
//│ | | | 1. : α247'
//│ | | | 1. Typing term Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '
//│ | | | | typing for 530
//│ | | | | 1. Typing term let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | 2. Typing term Unquote' Const (n,) '
//│ | | | | | | 1. Typing term Const (n,)
//│ | | | | | | | 1. Typing term Const
//│ | | | | | | | | inspect Const by ctx.get
//│ | | | | | | | 1. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | | 1. Typing term n,
//│ | | | | | | | | 1. Typing term n
//│ | | | | | | | | | inspect n by ctx.get
//│ | | | | | | | | 1. : α244'
//│ | | | | | | | 1. : (α244',)
//│ | | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (α244' -> α250')
//│ | | | | | | |   where 
//│ 		α244' <: number<>
//│ | | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (α244' -> α250')    (0)
//│ | | | | | | | | C (α244',) <! (int<number>,)    (1)
//│ | | | | | | | | | C α244' <! int<number>    (2)
//│ | | | | | | | | C Code[int<number>,⊥] <! α250'    (3)
//│ | | | | | | 1. : α250'
//│ | | | | | | CONSTRAIN (Code[α248,α249] -> α248) <! (α250' -> α251'')
//│ | | | | | |   where 
//│ 		α250' :> Code[int<number>,⊥]
//│ | | | | | | C (Code[α248,α249] -> α248) <! (α250' -> α251'')    (0)
//│ | | | | | | | C α250' <! Code[α248,α249]    (1)
//│ | | | | | | | | C Code[int<number>,⊥] <! Code[α248,α249]    (2)
//│ | | | | | | | | | C int<number> <! α248    (3)
//│ | | | | | | | | | C α249 <! ⊥    (4)
//│ | | | | | | | C α248 <! α251''    (5)
//│ | | | | | 2. : α251''
//│ | | | | | 1. Typing term Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | | 1. Typing term test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',)
//│ | | | | | | | 1. Typing term test
//│ | | | | | | | | inspect test by ctx.get
//│ | | | | | | | 1. : test243'
//│ | | | | | | | 1. Typing term - (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',
//│ | | | | | | | | 1. Typing term - (n,) (1,)
//│ | | | | | | | | | 1. Typing term - (n,)
//│ | | | | | | | | | | 1. Typing term -
//│ | | | | | | | | | | | inspect - by ctx.get
//│ | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | 1. Typing term n,
//│ | | | | | | | | | | | 1. Typing term n
//│ | | | | | | | | | | | | inspect n by ctx.get
//│ | | | | | | | | | | | 1. : α244'
//│ | | | | | | | | | | 1. : (α244',)
//│ | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α244' -> α254')
//│ | | | | | | | | | |   where 
//│ 		α244' <: int<number> & number<>
//│ | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α244' -> α254')    (0)
//│ | | | | | | | | | | | C (α244',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! α254'    (1)
//│ | | | | | | | | | 1. : α254'
//│ | | | | | | | | | 1. Typing term 1,
//│ | | | | | | | | | | 1. Typing term 1
//│ | | | | | | | | | | 1. : 1<int,number>
//│ | | | | | | | | | 1. : (1<int,number>,)
//│ | | | | | | | | | CONSTRAIN α254' <! (1<int,number> -> α255')
//│ | | | | | | | | |   where 
//│ 		α254' :> (int<number> -> int<number>)
//│ | | | | | | | | | C α254' <! (1<int,number> -> α255')    (0)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α255')    (1)
//│ | | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C int<number> <! α255'    (2)
//│ | | | | | | | | 1. : α255'
//│ | | | | | | | | 1. Typing term Quoted' + (Unquote' cde ',) (x,) '
//│ | | | | | | | | | typing for 513
//│ | | | | | | | | | 1. Typing term + (Unquote' cde ',) (x,)
//│ | | | | | | | | | | 1. Typing term + (Unquote' cde ',)
//│ | | | | | | | | | | | 1. Typing term +
//│ | | | | | | | | | | | | inspect + by ctx.get
//│ | | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | 1. Typing term Unquote' cde ',
//│ | | | | | | | | | | | | 1. Typing term Unquote' cde '
//│ | | | | | | | | | | | | | 1. Typing term cde
//│ | | | | | | | | | | | | | | inspect cde by ctx.get
//│ | | | | | | | | | | | | | 1. : α245'
//│ | | | | | | | | | | | | | CONSTRAIN (Code[α256,α257] -> α256) <! (α245' -> α258')
//│ | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | C (Code[α256,α257] -> α256) <! (α245' -> α258')    (0)
//│ | | | | | | | | | | | | | | C α245' <! Code[α256,α257]    (1)
//│ | | | | | | | | | | | | | | C α256 <! α258'    (2)
//│ | | | | | | | | | | | | 1. : α258'
//│ | | | | | | | | | | | 1. : (α258',)
//│ | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α258' -> α259')
//│ | | | | | | | | | | |   where 
//│ 		α258' :> α256
//│ | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α258' -> α259')    (0)
//│ | | | | | | | | | | | | C (α258',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | | C α258' <! int<number>    (2)
//│ | | | | | | | | | | | | | | C α256 <! int<number>    (3)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! α259'    (4)
//│ | | | | | | | | | | 1. : α259'
//│ | | | | | | | | | | 1. Typing term x,
//│ | | | | | | | | | | | 1. Typing term x
//│ | | | | | | | | | | | | inspect x by ctx.get
//│ | | | | | | | | | | | 1. : Code[[α260'],{y: α260'}]
//│ | | | | | | | | | | 1. : (Code[[α260'],{y: α260'}],)
//│ | | | | | | | | | | CONSTRAIN α259' <! (Code[[α260'],{y: α260'}] -> α261')
//│ | | | | | | | | | |   where 
//│ 		α259' :> (int<number> -> int<number>)
//│ | | | | | | | | | | C α259' <! (Code[[α260'],{y: α260'}] -> α261')    (0)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! (Code[[α260'],{y: α260'}] -> α261')    (1)
//│ | | | | | | | | | | | | C (Code[[α260'],{y: α260'}],) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C Code[[α260'],{y: α260'}] <! int<number>    (3)
//│ | | | | | | | | | | | | | | C (code<> & {Code#T: mut ..[α260'], Code#C: mut {y: α260'}..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α260', Code#C: mut {y: α260'}..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | | | | | Consider code<>{Code#T: mut ..α260', Code#C: mut {y: α260'}..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | | | | | A  code<>{Code#T: mut ..α260', Code#C: mut {y: α260'}..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..[α260'], Code#C: mut {y: α260'}..⊤}) <: int<number>
//│ | | | | | | | | | | | | | | | | | allVarPols: =α260'
//│ | | | | | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..[α260'], Code#C: mut {y: α260'}..⊤})
//│ | | | | | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..[α260'], Code#C: mut {y: α260'}..⊤})
//│ | | | | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | | | norm[+] [α260']
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF(α260')
//│ | | | | | | | | | | | | | | | | | | ~> α260'
//│ | | | | | | | | | | | | | | | | | | norm[-] {y: α260'}
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF({y: α260'})
//│ | | | | | | | | | | | | | | | | | | | norm[-] α260'
//│ | | | | | | | | | | | | | | | | | | | | DNF: DNF(α260')
//│ | | | | | | | | | | | | | | | | | | | ~> α260'
//│ | | | | | | | | | | | | | | | | | | ~> {y: α260'}
//│ | | | | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | | | ~> (code<> & {Code#C: mut {y: α260'}..⊤, Code#T: mut ..α260'})
//│ | | | | | | | | | | | | | | | | | CONSTRAIN error<> <! α261'
//│ | | | | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | | | | C error<> <! α261'    (0)
//│ | | | | | | | | | | | | C int<number> <! α261'    (5)
//│ | | | | | | | | | 1. : α261'
//│ | | | | | | | | | chaining for 513
//│ | | | | | | | | | local unquoted context:
//│ | | | | | | | | | List(α257)
//│ | | | | | | | | | {}
//│ | | | | | | | | 1. : Code[α261',α257]
//│ | | | | | | | 1. : (α255', Code[α261',α257],)
//│ | | | | | | | CONSTRAIN test243' <! ((α255', Code[α261',α257],) -> α262')
//│ | | | | | | |   where 
//│ 		α255' :> int<number>
//│ 		α261' :> int<number> | error<>
//│ | | | | | | | C test243' <! ((α255', Code[α261',α257],) -> α262')    (0)
//│ | | | | | | 1. : α262'
//│ | | | | | | CONSTRAIN (Code[α252,α253] -> α252) <! (α262' -> α263')
//│ | | | | | |   where 
//│ | | | | | | C (Code[α252,α253] -> α252) <! (α262' -> α263')    (0)
//│ | | | | | | | C α262' <! Code[α252,α253]    (1)
//│ | | | | | | | C α252 <! α263'    (2)
//│ | | | | | 1. : α263'
//│ | | | | 1. : α263'
//│ | | | | chaining for 530
//│ | | | | local unquoted context:
//│ | | | | List(α249, α253)
//│ | | | | {}
//│ | | | 1. : Code[α263',(α249 & α253)]
//│ | | | 1. Typing term cde
//│ | | | | inspect cde by ctx.get
//│ | | | 1. : α245'
//│ | | | CONSTRAIN α247' <! (true<bool> | (α264' & ~(true<bool>)))
//│ | | |   where 
//│ 		α247' :> bool<>
//│ | | | C α247' <! (true<bool> | (α264' & ~(true<bool>)))    (0)
//│ | | | | C bool<> <! (true<bool> | (α264' & ~(true<bool>)))    (1)
//│ | | | | | ARGH  DNF(bool<>{})  <!  DNF(true<bool>{} | α264'∧~(true<bool>))
//│ | | | | | | Consider bool<>{} <: DNF(true<bool>{} | α264'∧~(true<bool>))
//│ | | | | | | Possible: List(true<bool>{}, α264'∧~(true<bool>))
//│ | | | | | | A  bool<>{}  %  List()  <!  List(true<bool>, (α264' & ~(true<bool>)))  %  ⊥
//│ | | | | | | | A  bool<>{}  %  List()  <!  List((α264' & ~(true<bool>)))  %  true<bool>
//│ | | | | | | | | Case.1
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(α264')  %  true<bool>
//│ | | | | | | | | | C (bool<> & ~(true<bool>)) <! α264'    (2)
//│ | | | | | | | | Case.2
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(~(true<bool>))  %  true<bool>
//│ | | | | | | | | | A  bool<>{}  %  List(true<bool>)  <!  List()  %  true<bool>
//│ | | | | | | | | | | A  true<bool>{}  %  List()  <!  List()  %  true<bool>
//│ | | | | | | | | | | | OK  true<bool>  <:  true<bool>
//│ | | 1. : (Code[α263',(α249 & α253)] | α245')
//│ | 1. : (Code[α263',(α249 & α253)] | α245')
//│ 1. : ((α244', α245',) -> (Code[α263',(α249 & α253)] | α245'))
//│ CONSTRAIN ((α244', α245',) -> (Code[α263',(α249 & α253)] | α245')) <! test243'
//│   where 
//│ 		test243' <: ((α255', Code[α261',α257],) -> α262')
//│ 		α244' <: int<number> & number<>
//│ 		α245' <: Code[α256,α257]
//│ 		α249 <: ⊥
//│ 		α255' :> int<number>
//│ 		α256 <: int<number>
//│ 		α261' :> int<number> | error<>
//│ 		α262' <: Code[α252,α253]
//│ 		α263' :> α252
//│ C ((α244', α245',) -> (Code[α263',(α249 & α253)] | α245')) <! test243'    (0)
//│ | C ((α244', α245',) -> (Code[α263',(α249 & α253)] | α245')) <! ((α255', Code[α261',α257],) -> α262')    (1)
//│ | | C (α255', Code[α261',α257],) <! (α244', α245',)    (2)
//│ | | | C α255' <! α244'    (3)
//│ | | | | C int<number> <! α244'    (4)
//│ | | | | | C int<number> <! int<number>    (5)
//│ | | | | | C int<number> <! number<>    (5)
//│ | | | C Code[α261',α257] <! α245'    (5)
//│ | | | | C Code[α261',α257] <! Code[α256,α257]    (6)
//│ | | | | | C α261' <! α256    (7)
//│ | | | | | | C int<number> <! α256    (8)
//│ | | | | | | | C int<number> <! int<number>    (9)
//│ | | | | | | C error<> <! α256    (9)
//│ | | | | | | | C error<> <! int<number>    (10)
//│ | | | | | C α257 <! α257    (11)
//│ | | C (Code[α263',(α249 & α253)] | α245') <! α262'    (11)
//│ | | | C (Code[α263',(α249 & α253)] | α245') <! Code[α252,α253]    (12)
//│ | | | | C Code[α263',(α249 & α253)] <! Code[α252,α253]    (13)
//│ | | | | | C α263' <! α252    (14)
//│ | | | | | | C α252 <! α252    (15)
//│ | | | | | C α253 <! (α249 & α253)    (15)
//│ | | | | C α245' <! Code[α252,α253]    (16)
//│ | | | | | C Code[α261',α257] <! Code[α252,α253]    (17)
//│ | | | | | | C α261' <! α252    (18)
//│ | | | | | | | C int<number> <! α252    (19)
//│ | | | | | | | C error<> <! α252    (20)
//│ | | | | | | C α253 <! α257    (21)
//│ ⬤ Typed as: test243'
//│  where: 
//│ 		test243' :> ((α244', α245',) -> (Code[α263',(α249 & α253)] | α245')) <: ((α255', Code[α261',α257],) -> α262')
//│ 		α244' :> int<number> <: int<number> & number<>
//│ 		α245' :> Code[α261',α257] <: Code[α252,α253] & Code[α256,α257]
//│ 		α249 <: ⊥
//│ 		α252 :> error<> | int<number>
//│ 		α253 <: α257 & (α249 & α253)
//│ 		α255' :> int<number> <: α244'
//│ 		α256 :> error<> | int<number> <: int<number>
//│ 		α261' :> int<number> | error<> <: α252 & α256
//│ 		α262' :> (Code[α263',(α249 & α253)] | α245') <: Code[α252,α253]
//│ 		α263' :> α252 <: α252
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.702: 	fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ ║         	                                                                              ^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> {y: ?a}, Code#T <: ?a}` is not an instance of type `int`
//│ test: (int, Code[int | 'a, ?] & 'b,) -> (Code[error | int | 'a, ?] | 'b)
