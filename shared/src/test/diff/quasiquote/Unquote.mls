:NewParser
:d
:ne
:NoJS
code"z
+ 1"
//│ ╔══[PARSE ERROR] Unexpected operator here
//│ ║  l.6: 	+ 1"
//│ ╙──     	^
//│ 0. Typing term Quoted' z '
//│ | typing for 87
//│ | 0. Typing term z
//│ | | inspect z by ctx.get
//│ | | insert z into the free vars
//│ | 0. : α26
//│ | chaining for 87
//│ | local unquoted context:
//│ | List()
//│ | {z: α26}
//│ 0. : Code[α26,({test1: α27, test2: α27} & ~({test1: α27}))]
//│ ⬤ Typed as: Code[α26,({test1: α27, test2: α27} & ~({test1: α27}))]
//│  where: 
//│ res: Code[nothing, ?]

:d
:ne
:NoJS
fun f(x, y) = code"[${x}, ${y}]"
//│ 1. Typing term x, y, => Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | 1. Typing pattern x, y,
//│ | | 1. Typing pattern x
//│ | | 1. : α32'
//│ | | 1. Typing pattern y
//│ | | 1. : α33'
//│ | 1. : (α32', α33',)
//│ | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | | typing for 291
//│ | | 1. Typing term '(' Unquote' x ', Unquote' y ', ')'
//│ | | | 1. Typing term Unquote' x ', Unquote' y ',
//│ | | | | 1. Typing term Unquote' x '
//│ | | | | | 1. Typing term x
//│ | | | | | | inspect x by ctx.get
//│ | | | | | 1. : α32'
//│ | | | | | CONSTRAIN (Code[α34,α35] -> α34) <! (α32' -> α36')
//│ | | | | |   where 
//│ | | | | | C (Code[α34,α35] -> α34) <! (α32' -> α36')    (0)
//│ | | | | | | C α32' <! Code[α34,α35]    (1)
//│ | | | | | | C α34 <! α36'    (2)
//│ | | | | 1. : α36'
//│ | | | | 1. Typing term Unquote' y '
//│ | | | | | 1. Typing term y
//│ | | | | | | inspect y by ctx.get
//│ | | | | | 1. : α33'
//│ | | | | | CONSTRAIN (Code[α37,α38] -> α37) <! (α33' -> α39')
//│ | | | | |   where 
//│ | | | | | C (Code[α37,α38] -> α37) <! (α33' -> α39')    (0)
//│ | | | | | | C α33' <! Code[α37,α38]    (1)
//│ | | | | | | C α37 <! α39'    (2)
//│ | | | | 1. : α39'
//│ | | | 1. : (α36', α39',)
//│ | | 1. : (α36', α39',)
//│ | | chaining for 291
//│ | | local unquoted context:
//│ | | List(α35, α38)
//│ | | {}
//│ | 1. : Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]
//│ 1. : ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))])
//│ CONSTRAIN ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]) <! f31'
//│   where 
//│ 		α32' <: Code[α34,α35]
//│ 		α33' <: Code[α37,α38]
//│ 		α36' :> α34
//│ 		α39' :> α37
//│ C ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]) <! f31'    (0)
//│ ⬤ Typed as: f31'
//│  where: 
//│ 		f31' :> ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))])
//│ 		α32' <: Code[α34,α35]
//│ 		α33' <: Code[α37,α38]
//│ 		α36' :> α34
//│ 		α39' :> α37
//│ f: (Code['a, ?], Code['b, ?],) -> Code[('a, 'b,), ?]

let x = code"y"
//│ x: Code[nothing, ?]

let c = f(x, x)
//│ c: Code[(nothing, nothing,), ?]

code"y"
y => code"[${code"y"}, ${code"y"}]"
//│ res: Code[nothing, ?]
//│ res: 'a -> Code[('a, 'a,), ?]

code"y => ${c}"
//│ res: Code[anything -> (nothing, nothing,), ?]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, ?] & 'b, Code['c, ?] & 'd,) -> (Code[('a, 'c,), ?], 'b, 'd,)

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]


fun f(x) = x
//│ f: 'a -> 'a

code"f(0)"
//│ res: Code[0, ?]

:NewParser
:d
:ne
:NoJS
code"${code"${code"${z}"}"}"
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' ' '
//│ | typing for 706
//│ | 0. Typing term Unquote' Quoted' Unquote' Quoted' Unquote' z ' ' ' ' '
//│ | | 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | | | typing for 164
//│ | | | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | | | typing for 838
//│ | | | | | 0. Typing term Unquote' z '
//│ | | | | | | 0. Typing term z
//│ | | | | | | | inspect z by ctx.get
//│ | | | | | | | insert z into the free vars
//│ | | | | | | 0. : α174
//│ | | | | | | CONSTRAIN (Code[α172,α173] -> α172) <! (α174 -> α175)
//│ | | | | | |   where 
//│ | | | | | | C (Code[α172,α173] -> α172) <! (α174 -> α175)    (0)
//│ | | | | | | | C α174 <! Code[α172,α173]    (1)
//│ | | | | | | | C α172 <! α175    (2)
//│ | | | | | 0. : α175
//│ | | | | | chaining for 838
//│ | | | | | local unquoted context:
//│ | | | | | List(α173)
//│ | | | | | {}
//│ | | | | 0. : Code[α175,({test1: α176, test2: α176} & ~({test1: α176}))]
//│ | | | | CONSTRAIN (Code[α170,α171] -> α170) <! (Code[α175,({test1: α176, test2: α176} & ~({test1: α176}))] -> α177)
//│ | | | |   where 
//│ | | | | C (Code[α170,α171] -> α170) <! (Code[α175,({test1: α176, test2: α176} & ~({test1: α176}))] -> α177)    (0)
//│ | | | | | C Code[α175,({test1: α176, test2: α176} & ~({test1: α176}))] <! Code[α170,α171]    (1)
//│ | | | | | | C α175 <! α170    (2)
//│ | | | | | | C α171 <! ({test1: α176, test2: α176} & ~({test1: α176}))    (3)
//│ | | | | | C α170 <! α177    (4)
//│ | | | 0. : α177
//│ | | | chaining for 164
//│ | | | local unquoted context:
//│ | | | List(α171)
//│ | | | {}
//│ | | 0. : Code[α177,({test1: α178, test2: α178} & ~({test1: α178}))]
//│ | | CONSTRAIN (Code[α168,α169] -> α168) <! (Code[α177,({test1: α178, test2: α178} & ~({test1: α178}))] -> α179)
//│ | |   where 
//│ | | C (Code[α168,α169] -> α168) <! (Code[α177,({test1: α178, test2: α178} & ~({test1: α178}))] -> α179)    (0)
//│ | | | C Code[α177,({test1: α178, test2: α178} & ~({test1: α178}))] <! Code[α168,α169]    (1)
//│ | | | | C α177 <! α168    (2)
//│ | | | | C α169 <! ({test1: α178, test2: α178} & ~({test1: α178}))    (3)
//│ | | | C α168 <! α179    (4)
//│ | 0. : α179
//│ | chaining for 706
//│ | local unquoted context:
//│ | List(α169)
//│ | {}
//│ 0. : Code[α179,({test1: α180, test2: α180} & ~({test1: α180}))]
//│ ⬤ Typed as: Code[α179,({test1: α180, test2: α180} & ~({test1: α180}))]
//│  where: 
//│ ╔══[ERROR] identifier not found: z
//│ ║  l.116: 	code"${code"${code"${z}"}"}"
//│ ╙──       	                     ^
//│ res: Code[nothing, ?]


:NewParser
:d
:ne
:NoJS
let z = code"1"
code"${code"${z}"}"
//│ 1. Typing term Quoted' 1 '
//│ | typing for 379
//│ | 1. Typing term 1
//│ | 1. : 1<int,number>
//│ | chaining for 379
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 1. : Code[1<int,number>,({test1: α184', test2: α184'} & ~({test1: α184'}))]
//│ ⬤ Typed as: Code[1<int,number>,({test1: α184', test2: α184'} & ~({test1: α184'}))]
//│  where: 
//│ 0. Typing term Quoted' Unquote' Quoted' Unquote' z ' ' ' '
//│ | typing for 530
//│ | 0. Typing term Unquote' Quoted' Unquote' z ' ' '
//│ | | 0. Typing term Quoted' Unquote' z ' '
//│ | | | typing for 812
//│ | | | 0. Typing term Unquote' z '
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | 0. : Code[1<int,number>,({test1: α191, test2: α191} & ~({test1: α191}))]
//│ | | | | CONSTRAIN (Code[α189,α190] -> α189) <! (Code[1<int,number>,({test1: α191, test2: α191} & ~({test1: α191}))] -> α192)
//│ | | | |   where 
//│ | | | | C (Code[α189,α190] -> α189) <! (Code[1<int,number>,({test1: α191, test2: α191} & ~({test1: α191}))] -> α192)    (0)
//│ | | | | | C Code[1<int,number>,({test1: α191, test2: α191} & ~({test1: α191}))] <! Code[α189,α190]    (1)
//│ | | | | | | C 1<int,number> <! α189    (2)
//│ | | | | | | C α190 <! ({test1: α191, test2: α191} & ~({test1: α191}))    (3)
//│ | | | | | C α189 <! α192    (4)
//│ | | | | | | C 1<int,number> <! α192    (5)
//│ | | | 0. : α192
//│ | | | chaining for 812
//│ | | | local unquoted context:
//│ | | | List(α190)
//│ | | | {}
//│ | | 0. : Code[α192,({test1: α193, test2: α193} & ~({test1: α193}))]
//│ | | CONSTRAIN (Code[α187,α188] -> α187) <! (Code[α192,({test1: α193, test2: α193} & ~({test1: α193}))] -> α194)
//│ | |   where 
//│ 		α192 :> 1<int,number>
//│ | | C (Code[α187,α188] -> α187) <! (Code[α192,({test1: α193, test2: α193} & ~({test1: α193}))] -> α194)    (0)
//│ | | | C Code[α192,({test1: α193, test2: α193} & ~({test1: α193}))] <! Code[α187,α188]    (1)
//│ | | | | C α192 <! α187    (2)
//│ | | | | | C 1<int,number> <! α187    (3)
//│ | | | | C α188 <! ({test1: α193, test2: α193} & ~({test1: α193}))    (4)
//│ | | | C α187 <! α194    (5)
//│ | | | | C 1<int,number> <! α194    (6)
//│ | 0. : α194
//│ | chaining for 530
//│ | local unquoted context:
//│ | List(α188)
//│ | {}
//│ 0. : Code[α194,({test1: α195, test2: α195} & ~({test1: α195}))]
//│ ⬤ Typed as: Code[α194,({test1: α195, test2: α195} & ~({test1: α195}))]
//│  where: 
//│ 		α194 :> 1<int,number>
//│ z: Code[1, ?]
//│ res: Code[1, ?]

:NewParser
:d
:ne
:NoJS
code"let x = 1; let z = 1; code"x""
//│ 0. Typing term Quoted' let x = 1 in let z = 1 in Quoted' x ' '
//│ | typing for 708
//│ | 0. Typing term let x = 1 in let z = 1 in Quoted' x '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term let z = 1 in Quoted' x '
//│ | | | 1. Typing term 1
//│ | | | 1. : 1<int,number>
//│ | | | 0. Typing term Quoted' x '
//│ | | | | typing for 803
//│ | | | | 0. Typing term x
//│ | | | | | inspect x by ctx.get
//│ | | | | 0. : 1<int,number>
//│ | | | | chaining for 803
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {}
//│ | | | 0. : Code[1<int,number>,({test1: α199, test2: α199} & ~({test1: α199}))]
//│ | | 0. : Code[1<int,number>,({test1: α199, test2: α199} & ~({test1: α199}))]
//│ | 0. : Code[1<int,number>,({test1: α199, test2: α199} & ~({test1: α199}))]
//│ | chaining for 708
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 0. : Code[Code[1<int,number>,({test1: α199, test2: α199} & ~({test1: α199}))],({test1: α200, test2: α200} & ~({test1: α200}))]
//│ ⬤ Typed as: Code[Code[1<int,number>,({test1: α199, test2: α199} & ~({test1: α199}))],({test1: α200, test2: α200} & ~({test1: α200}))]
//│  where: 
//│ res: Code[Code[1, ?], ?]

:NewParser
:d
:ne
:NoJS
code"x; code"x""
//│ ╔══[PARSE ERROR] Unexpected ';' keyword here
//│ ║  l.275: 	code"x; code"x""
//│ ╙──       	      ^
//│ 0. Typing term Quoted' x '
//│ | typing for 817
//│ | 0. Typing term x
//│ | | inspect x by ctx.get
//│ | 0. : Code[[α205],({test1: α206, test2: α206} & ~({test1: α206}))]
//│ | chaining for 817
//│ | local unquoted context:
//│ | List()
//│ | {}
//│ 0. : Code[Code[[α205],({test1: α206, test2: α206} & ~({test1: α206}))],({test1: α207, test2: α207} & ~({test1: α207}))]
//│ ⬤ Typed as: Code[Code[[α205],({test1: α206, test2: α206} & ~({test1: α206}))],({test1: α207, test2: α207} & ~({test1: α207}))]
//│  where: 
//│ res: Code[Code[nothing, ?], ?]

:NewParser
:d
:ne
:NoJS
code"let z = 0;${code"z"}"
//│ 0. Typing term Quoted' let z = 0 in Unquote' Quoted' z ' ' '
//│ | typing for 230
//│ | 0. Typing term let z = 0 in Unquote' Quoted' z ' '
//│ | | 1. Typing term 0
//│ | | 1. : 0<int,number>
//│ | | 0. Typing term Unquote' Quoted' z ' '
//│ | | | 0. Typing term Quoted' z '
//│ | | | | typing for 697
//│ | | | | 0. Typing term z
//│ | | | | | inspect z by ctx.get
//│ | | | | 0. : Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))]
//│ | | | | chaining for 697
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {}
//│ | | | 0. : Code[Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))],({test1: α216, test2: α216} & ~({test1: α216}))]
//│ | | | CONSTRAIN (Code[α213,α214] -> α213) <! (Code[Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))],({test1: α216, test2: α216} & ~({test1: α216}))] -> α217)
//│ | | |   where 
//│ | | | C (Code[α213,α214] -> α213) <! (Code[Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))],({test1: α216, test2: α216} & ~({test1: α216}))] -> α217)    (0)
//│ | | | | C Code[Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))],({test1: α216, test2: α216} & ~({test1: α216}))] <! Code[α213,α214]    (1)
//│ | | | | | C Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))] <! α213    (2)
//│ | | | | | C α214 <! ({test1: α216, test2: α216} & ~({test1: α216}))    (3)
//│ | | | | C α213 <! α217    (4)
//│ | | | | | C Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))] <! α217    (5)
//│ | | 0. : α217
//│ | 0. : α217
//│ | chaining for 230
//│ | local unquoted context:
//│ | List(α214)
//│ | {}
//│ 0. : Code[α217,({test1: α218, test2: α218} & ~({test1: α218}))]
//│ ⬤ Typed as: Code[α217,({test1: α218, test2: α218} & ~({test1: α218}))]
//│  where: 
//│ 		α217 :> Code[1<int,number>,({test1: α215, test2: α215} & ~({test1: α215}))]
//│ res: Code[Code[1, ?], ?]

:NewParser
:d
:ne
:NoJS
code"let x = 1;${code"x + y"}"
//│ 0. Typing term Quoted' let x = 1 in Unquote' Quoted' + (x,) (y,) ' ' '
//│ | typing for 791
//│ | 0. Typing term let x = 1 in Unquote' Quoted' + (x,) (y,) ' '
//│ | | 1. Typing term 1
//│ | | 1. : 1<int,number>
//│ | | 0. Typing term Unquote' Quoted' + (x,) (y,) ' '
//│ | | | 0. Typing term Quoted' + (x,) (y,) '
//│ | | | | typing for 453
//│ | | | | 0. Typing term + (x,) (y,)
//│ | | | | | 0. Typing term + (x,)
//│ | | | | | | 0. Typing term +
//│ | | | | | | | inspect + by ctx.get
//│ | | | | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | 0. Typing term x,
//│ | | | | | | | 0. Typing term x
//│ | | | | | | | | inspect x by ctx.get
//│ | | | | | | | 0. : Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))]
//│ | | | | | | 0. : (Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))],)
//│ | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))] -> α228)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))] -> α228)    (0)
//│ | | | | | | | C (Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))],) <! (int<number>,)    (1)
//│ | | | | | | | | C Code[[α226],({test1: α227, test2: α227} & ~({test1: α227}))] <! int<number>    (2)
//│ | | | | | | | | | C (code<> & {Code#T: mut ..[α226], Code#C: mut ({test1: α227, test2: α227} & ~({test1: α227}))..⊤}) <! int<number>    (3)
//│ | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α226, Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | Consider code<>{Code#T: mut ..α226, Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | A  code<>{Code#T: mut ..α226, Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..[α226], Code#C: mut ({test1: α227, test2: α227} & ~({test1: α227}))..⊤}) <: int<number>
//│ | | | | | | | | | | | | allVarPols: +α226, =α227
//│ | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..[α226], Code#C: mut ({test1: α227, test2: α227} & ~({test1: α227}))..⊤})
//│ | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..[α226], Code#C: mut ({test1: α227, test2: α227} & ~({test1: α227}))..⊤})
//│ | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | norm[+] [α226]
//│ | | | | | | | | | | | | | | DNF: DNF(α226)
//│ | | | | | | | | | | | | | ~> α226
//│ | | | | | | | | | | | | | norm[-] ({test1: α227, test2: α227} & ~({test1: α227}))
//│ | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..α226})
//│ | | | | | | | | | | | | CONSTRAIN error<> <! α228
//│ | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | C error<> <! α228    (0)
//│ | | | | | | | C (int<number> -> int<number>) <! α228    (4)
//│ | | | | | 0. : α228
//│ | | | | | 0. Typing term y,
//│ | | | | | | 0. Typing term y
//│ | | | | | | | inspect y by ctx.get
//│ | | | | | | | insert y into the free vars
//│ | | | | | | 0. : α229
//│ | | | | | 0. : (α229,)
//│ | | | | | CONSTRAIN α228 <! (α229 -> α230)
//│ | | | | |   where 
//│ 		α228 :> (int<number> -> int<number>) | error<>
//│ | | | | | C α228 <! (α229 -> α230)    (0)
//│ | | | | | | C (int<number> -> int<number>) <! (α229 -> α230)    (1)
//│ | | | | | | | C (α229,) <! (int<number>,)    (2)
//│ | | | | | | | | C α229 <! int<number>    (3)
//│ | | | | | | | C int<number> <! α230    (4)
//│ | | | | | | C error<> <! (α229 -> α230)    (5)
//│ | | | | | | | C (α229,) <! error<>    (6)
//│ | | | | | | | C error<> <! α230    (7)
//│ | | | | 0. : α230
//│ | | | | chaining for 453
//│ | | | | local unquoted context:
//│ | | | | List()
//│ | | | | {y: α229}
//│ | | | 0. : Code[α230,({test1: α231, test2: α231} & ~({test1: α231}))]
//│ | | | CONSTRAIN (Code[α224,α225] -> α224) <! (Code[α230,({test1: α231, test2: α231} & ~({test1: α231}))] -> α232)
//│ | | |   where 
//│ 		α230 :> error<> | int<number>
//│ | | | C (Code[α224,α225] -> α224) <! (Code[α230,({test1: α231, test2: α231} & ~({test1: α231}))] -> α232)    (0)
//│ | | | | C Code[α230,({test1: α231, test2: α231} & ~({test1: α231}))] <! Code[α224,α225]    (1)
//│ | | | | | C α230 <! α224    (2)
//│ | | | | | | C error<> <! α224    (3)
//│ | | | | | | C int<number> <! α224    (4)
//│ | | | | | C α225 <! ({test1: α231, test2: α231} & ~({test1: α231}))    (5)
//│ | | | | C α224 <! α232    (6)
//│ | | | | | C int<number> <! α232    (7)
//│ | | | | | C error<> <! α232    (8)
//│ | | 0. : α232
//│ | 0. : α232
//│ | chaining for 791
//│ | local unquoted context:
//│ | List(α225)
//│ | {}
//│ 0. : Code[α232,({test1: α233, test2: α233} & ~({test1: α233}))]
//│ ⬤ Typed as: Code[α232,({test1: α233, test2: α233} & ~({test1: α233}))]
//│  where: 
//│ 		α232 :> error<> | int<number>
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.338: 	code"let x = 1;${code"x + y"}"
//│ ║         	                      ^^^
//│ ╙── expression of type `code & {Code#C, Code#T <: ?a}` is not an instance of type `int`
//│ res: Code[error | int, ?]


:NewParser
:d
:ne
:NoJS
code"1 + ${code"b"}"
//│ 0. Typing term Quoted' + (1,) (Unquote' Quoted' b ' ',) '
//│ | typing for 163
//│ | 0. Typing term + (1,) (Unquote' Quoted' b ' ',)
//│ | | 0. Typing term + (1,)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term 1,
//│ | | | | 0. Typing term 1
//│ | | | | 0. : 1<int,number>
//│ | | | 0. : (1<int,number>,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α237)
//│ | | |   where 
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (1<int,number> -> α237)    (0)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | C (int<number> -> int<number>) <! α237    (1)
//│ | | 0. : α237
//│ | | 0. Typing term Unquote' Quoted' b ' ',
//│ | | | 0. Typing term Unquote' Quoted' b ' '
//│ | | | | 0. Typing term Quoted' b '
//│ | | | | | typing for 798
//│ | | | | | 0. Typing term b
//│ | | | | | | inspect b by ctx.get
//│ | | | | | | insert b into the free vars
//│ | | | | | 0. : α240
//│ | | | | | chaining for 798
//│ | | | | | local unquoted context:
//│ | | | | | List()
//│ | | | | | {b: α240}
//│ | | | | 0. : Code[α240,({test1: α241, test2: α241} & ~({test1: α241}))]
//│ | | | | CONSTRAIN (Code[α238,α239] -> α238) <! (Code[α240,({test1: α241, test2: α241} & ~({test1: α241}))] -> α242)
//│ | | | |   where 
//│ | | | | C (Code[α238,α239] -> α238) <! (Code[α240,({test1: α241, test2: α241} & ~({test1: α241}))] -> α242)    (0)
//│ | | | | | C Code[α240,({test1: α241, test2: α241} & ~({test1: α241}))] <! Code[α238,α239]    (1)
//│ | | | | | | C α240 <! α238    (2)
//│ | | | | | | C α239 <! ({test1: α241, test2: α241} & ~({test1: α241}))    (3)
//│ | | | | | C α238 <! α242    (4)
//│ | | | 0. : α242
//│ | | 0. : (α242,)
//│ | | CONSTRAIN α237 <! (α242 -> α243)
//│ | |   where 
//│ 		α237 :> (int<number> -> int<number>)
//│ | | C α237 <! (α242 -> α243)    (0)
//│ | | | C (int<number> -> int<number>) <! (α242 -> α243)    (1)
//│ | | | | C (α242,) <! (int<number>,)    (2)
//│ | | | | | C α242 <! int<number>    (3)
//│ | | | | C int<number> <! α243    (4)
//│ | 0. : α243
//│ | chaining for 163
//│ | local unquoted context:
//│ | List(α239)
//│ | {}
//│ 0. : Code[α243,({test1: α244, test2: α244} & ~({test1: α244}))]
//│ ⬤ Typed as: Code[α243,({test1: α244, test2: α244} & ~({test1: α244}))]
//│  where: 
//│ 		α243 :> int<number>
//│ res: Code[int, ?]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | typing for 45
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | | inspect Const by ctx.get
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | | inspect n by ctx.get
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α250)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α250)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α250    (1)
//│ | | | | | 0. : α250
//│ | | | | | CONSTRAIN (Code[α248,α249] -> α248) <! (α250 -> α251)
//│ | | | | |   where 
//│ 		α250 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α248,α249] -> α248) <! (α250 -> α251)    (0)
//│ | | | | | | C α250 <! Code[α248,α249]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α248,α249]    (2)
//│ | | | | | | | | C int<number> <! α248    (3)
//│ | | | | | | | | C α249 <! ⊥    (4)
//│ | | | | | | C α248 <! α251    (5)
//│ | | | | | | | C int<number> <! α251    (6)
//│ | | | | 0. : α251
//│ | | | 0. : (α251,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α251 -> α252)
//│ | | |   where 
//│ 		α251 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α251 -> α252)    (0)
//│ | | | | C (α251,) <! (int<number>,)    (1)
//│ | | | | | C α251 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α252    (3)
//│ | | 0. : α252
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α252 <! (1<int,number> -> α253)
//│ | |   where 
//│ 		α252 :> (int<number> -> int<number>)
//│ | | C α252 <! (1<int,number> -> α253)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α253)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α253    (2)
//│ | 0. : α253
//│ | chaining for 45
//│ | local unquoted context:
//│ | List(α249)
//│ | {}
//│ 0. : Code[α253,({test1: α254, test2: α254} & ~({test1: α254}))]
//│ ⬤ Typed as: Code[α253,({test1: α254, test2: α254} & ~({test1: α254}))]
//│  where: 
//│ 		α253 :> int<number>
//│ n: 1
//│ res: Code[int, ?]

:NewParser
:d
:ne
:NoJS
fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ 1. Typing term n, cde, => if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | 1. Typing pattern n, cde,
//│ | | 1. Typing pattern n
//│ | | 1. : α259'
//│ | | 1. Typing pattern cde
//│ | | 1. : α260'
//│ | 1. : (α259', α260',)
//│ | 1. Typing term if (> (n,) (0,)) then Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' ' else cde
//│ | | The mutable CaseOf tree
//│ | | if «> (n,) (0,)»
//│ | |   «Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '»
//│ | | else
//│ | |   «cde»
//│ | | Desugared term: case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | 1. Typing term case > (n,) (0,) of { true => Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '; _ => cde }
//│ | | | 1. Typing term > (n,) (0,)
//│ | | | | 1. Typing term > (n,)
//│ | | | | | 1. Typing term >
//│ | | | | | | inspect > by ctx.get
//│ | | | | | 1. : (number<> -> (number<> -> bool<>))
//│ | | | | | 1. Typing term n,
//│ | | | | | | 1. Typing term n
//│ | | | | | | | inspect n by ctx.get
//│ | | | | | | 1. : α259'
//│ | | | | | 1. : (α259',)
//│ | | | | | CONSTRAIN (number<> -> (number<> -> bool<>)) <! (α259' -> α261')
//│ | | | | |   where 
//│ | | | | | C (number<> -> (number<> -> bool<>)) <! (α259' -> α261')    (0)
//│ | | | | | | C (α259',) <! (number<>,)    (1)
//│ | | | | | | | C α259' <! number<>    (2)
//│ | | | | | | C (number<> -> bool<>) <! α261'    (3)
//│ | | | | 1. : α261'
//│ | | | | 1. Typing term 0,
//│ | | | | | 1. Typing term 0
//│ | | | | | 1. : 0<int,number>
//│ | | | | 1. : (0<int,number>,)
//│ | | | | CONSTRAIN α261' <! (0<int,number> -> α262')
//│ | | | |   where 
//│ 		α261' :> (number<> -> bool<>)
//│ | | | | C α261' <! (0<int,number> -> α262')    (0)
//│ | | | | | C (number<> -> bool<>) <! (0<int,number> -> α262')    (1)
//│ | | | | | | C (0<int,number>,) <! (number<>,)    (2)
//│ | | | | | | C bool<> <! α262'    (2)
//│ | | | 1. : α262'
//│ | | | 1. Typing term Quoted' let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) ' '
//│ | | | | typing for 796
//│ | | | | 1. Typing term let x = Unquote' Const (n,) ' in Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | 2. Typing term Unquote' Const (n,) '
//│ | | | | | | 1. Typing term Const (n,)
//│ | | | | | | | 1. Typing term Const
//│ | | | | | | | | inspect Const by ctx.get
//│ | | | | | | | 1. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | | 1. Typing term n,
//│ | | | | | | | | 1. Typing term n
//│ | | | | | | | | | inspect n by ctx.get
//│ | | | | | | | | 1. : α259'
//│ | | | | | | | 1. : (α259',)
//│ | | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (α259' -> α265')
//│ | | | | | | |   where 
//│ 		α259' <: number<>
//│ | | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (α259' -> α265')    (0)
//│ | | | | | | | | C (α259',) <! (int<number>,)    (1)
//│ | | | | | | | | | C α259' <! int<number>    (2)
//│ | | | | | | | | C Code[int<number>,⊥] <! α265'    (3)
//│ | | | | | | 1. : α265'
//│ | | | | | | CONSTRAIN (Code[α263,α264] -> α263) <! (α265' -> α266'')
//│ | | | | | |   where 
//│ 		α265' :> Code[int<number>,⊥]
//│ | | | | | | C (Code[α263,α264] -> α263) <! (α265' -> α266'')    (0)
//│ | | | | | | | C α265' <! Code[α263,α264]    (1)
//│ | | | | | | | | C Code[int<number>,⊥] <! Code[α263,α264]    (2)
//│ | | | | | | | | | C int<number> <! α263    (3)
//│ | | | | | | | | | C α264 <! ⊥    (4)
//│ | | | | | | | C α263 <! α266''    (5)
//│ | | | | | 2. : α266''
//│ | | | | | 1. Typing term Unquote' test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',) '
//│ | | | | | | 1. Typing term test (- (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',)
//│ | | | | | | | 1. Typing term test
//│ | | | | | | | | inspect test by ctx.get
//│ | | | | | | | 1. : test258'
//│ | | | | | | | 1. Typing term - (n,) (1,), Quoted' + (Unquote' cde ',) (x,) ',
//│ | | | | | | | | 1. Typing term - (n,) (1,)
//│ | | | | | | | | | 1. Typing term - (n,)
//│ | | | | | | | | | | 1. Typing term -
//│ | | | | | | | | | | | inspect - by ctx.get
//│ | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | 1. Typing term n,
//│ | | | | | | | | | | | 1. Typing term n
//│ | | | | | | | | | | | | inspect n by ctx.get
//│ | | | | | | | | | | | 1. : α259'
//│ | | | | | | | | | | 1. : (α259',)
//│ | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α259' -> α269')
//│ | | | | | | | | | |   where 
//│ 		α259' <: int<number> & number<>
//│ | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α259' -> α269')    (0)
//│ | | | | | | | | | | | C (α259',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! α269'    (1)
//│ | | | | | | | | | 1. : α269'
//│ | | | | | | | | | 1. Typing term 1,
//│ | | | | | | | | | | 1. Typing term 1
//│ | | | | | | | | | | 1. : 1<int,number>
//│ | | | | | | | | | 1. : (1<int,number>,)
//│ | | | | | | | | | CONSTRAIN α269' <! (1<int,number> -> α270')
//│ | | | | | | | | |   where 
//│ 		α269' :> (int<number> -> int<number>)
//│ | | | | | | | | | C α269' <! (1<int,number> -> α270')    (0)
//│ | | | | | | | | | | C (int<number> -> int<number>) <! (1<int,number> -> α270')    (1)
//│ | | | | | | | | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | | | | | | | | C int<number> <! α270'    (2)
//│ | | | | | | | | 1. : α270'
//│ | | | | | | | | 1. Typing term Quoted' + (Unquote' cde ',) (x,) '
//│ | | | | | | | | | typing for 553
//│ | | | | | | | | | 1. Typing term + (Unquote' cde ',) (x,)
//│ | | | | | | | | | | 1. Typing term + (Unquote' cde ',)
//│ | | | | | | | | | | | 1. Typing term +
//│ | | | | | | | | | | | | inspect + by ctx.get
//│ | | | | | | | | | | | 1. : (int<number> -> (int<number> -> int<number>))
//│ | | | | | | | | | | | 1. Typing term Unquote' cde ',
//│ | | | | | | | | | | | | 1. Typing term Unquote' cde '
//│ | | | | | | | | | | | | | 1. Typing term cde
//│ | | | | | | | | | | | | | | inspect cde by ctx.get
//│ | | | | | | | | | | | | | 1. : α260'
//│ | | | | | | | | | | | | | CONSTRAIN (Code[α271,α272] -> α271) <! (α260' -> α273')
//│ | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | C (Code[α271,α272] -> α271) <! (α260' -> α273')    (0)
//│ | | | | | | | | | | | | | | C α260' <! Code[α271,α272]    (1)
//│ | | | | | | | | | | | | | | C α271 <! α273'    (2)
//│ | | | | | | | | | | | | 1. : α273'
//│ | | | | | | | | | | | 1. : (α273',)
//│ | | | | | | | | | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α273' -> α274')
//│ | | | | | | | | | | |   where 
//│ 		α273' :> α271
//│ | | | | | | | | | | | C (int<number> -> (int<number> -> int<number>)) <! (α273' -> α274')    (0)
//│ | | | | | | | | | | | | C (α273',) <! (int<number>,)    (1)
//│ | | | | | | | | | | | | | C α273' <! int<number>    (2)
//│ | | | | | | | | | | | | | | C α271 <! int<number>    (3)
//│ | | | | | | | | | | | | C (int<number> -> int<number>) <! α274'    (4)
//│ | | | | | | | | | | 1. : α274'
//│ | | | | | | | | | | 1. Typing term x,
//│ | | | | | | | | | | | 1. Typing term x
//│ | | | | | | | | | | | | inspect x by ctx.get
//│ | | | | | | | | | | | 1. : Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))]
//│ | | | | | | | | | | 1. : (Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))],)
//│ | | | | | | | | | | CONSTRAIN α274' <! (Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))] -> α277')
//│ | | | | | | | | | |   where 
//│ 		α274' :> (int<number> -> int<number>)
//│ | | | | | | | | | | C α274' <! (Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))] -> α277')    (0)
//│ | | | | | | | | | | | C (int<number> -> int<number>) <! (Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))] -> α277')    (1)
//│ | | | | | | | | | | | | C (Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))],) <! (int<number>,)    (2)
//│ | | | | | | | | | | | | | C Code[[α275'],({test1: α276', test2: α276'} & ~({test1: α276'}))] <! int<number>    (3)
//│ | | | | | | | | | | | | | | C (code<> & {Code#T: mut ..[α275'], Code#C: mut ({test1: α276', test2: α276'} & ~({test1: α276'}))..⊤}) <! int<number>    (4)
//│ | | | | | | | | | | | | | | | ARGH  DNF(code<>{Code#T: mut ..α275', Code#C: mut ..⊤})  <!  DNF(int<number>{})
//│ | | | | | | | | | | | | | | | | Consider code<>{Code#T: mut ..α275', Code#C: mut ..⊤} <: DNF(int<number>{})
//│ | | | | | | | | | | | | | | | | Possible: List()
//│ | | | | | | | | | | | | | | | | A  code<>{Code#T: mut ..α275', Code#C: mut ..⊤}  %  List()  <!  List()  %  ⊥
//│ | | | | | | | | | | | | | | | | | CONSTRAINT FAILURE: (code<> & {Code#T: mut ..[α275'], Code#C: mut ({test1: α276', test2: α276'} & ~({test1: α276'}))..⊤}) <: int<number>
//│ | | | | | | | | | | | | | | | | | allVarPols: +α275', =α276'
//│ | | | | | | | | | | | | | | | | | norm[+] (code<> & {Code#T: mut ..[α275'], Code#C: mut ({test1: α276', test2: α276'} & ~({test1: α276'}))..⊤})
//│ | | | | | | | | | | | | | | | | | | DNF: DNF(code<>{Code#T: mut ..[α275'], Code#C: mut ({test1: α276', test2: α276'} & ~({test1: α276'}))..⊤})
//│ | | | | | | | | | | | | | | | | | | norm[-] ⊥
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | | | norm[+] [α275']
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF(α275')
//│ | | | | | | | | | | | | | | | | | | ~> α275'
//│ | | | | | | | | | | | | | | | | | | norm[-] ({test1: α276', test2: α276'} & ~({test1: α276'}))
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | | | ~> ⊥
//│ | | | | | | | | | | | | | | | | | | norm[+] ⊤
//│ | | | | | | | | | | | | | | | | | | | DNF: DNF()
//│ | | | | | | | | | | | | | | | | | | ~> ⊤
//│ | | | | | | | | | | | | | | | | | ~> (code<> & {Code#C: mut ..⊤, Code#T: mut ..α275'})
//│ | | | | | | | | | | | | | | | | | CONSTRAIN error<> <! α277'
//│ | | | | | | | | | | | | | | | | |   where 
//│ | | | | | | | | | | | | | | | | | C error<> <! α277'    (0)
//│ | | | | | | | | | | | | C int<number> <! α277'    (5)
//│ | | | | | | | | | 1. : α277'
//│ | | | | | | | | | chaining for 553
//│ | | | | | | | | | local unquoted context:
//│ | | | | | | | | | List(α272)
//│ | | | | | | | | | {}
//│ | | | | | | | | 1. : Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))]
//│ | | | | | | | 1. : (α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],)
//│ | | | | | | | CONSTRAIN test258' <! ((α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) -> α279')
//│ | | | | | | |   where 
//│ 		α270' :> int<number>
//│ 		α277' :> int<number> | error<>
//│ | | | | | | | C test258' <! ((α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) -> α279')    (0)
//│ | | | | | | 1. : α279'
//│ | | | | | | CONSTRAIN (Code[α267,α268] -> α267) <! (α279' -> α280')
//│ | | | | | |   where 
//│ | | | | | | C (Code[α267,α268] -> α267) <! (α279' -> α280')    (0)
//│ | | | | | | | C α279' <! Code[α267,α268]    (1)
//│ | | | | | | | C α267 <! α280'    (2)
//│ | | | | | 1. : α280'
//│ | | | | 1. : α280'
//│ | | | | chaining for 796
//│ | | | | local unquoted context:
//│ | | | | List(α264, α268)
//│ | | | | {}
//│ | | | 1. : Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))]
//│ | | | 1. Typing term cde
//│ | | | | inspect cde by ctx.get
//│ | | | 1. : α260'
//│ | | | CONSTRAIN α262' <! (true<bool> | (α282' & ~(true<bool>)))
//│ | | |   where 
//│ 		α262' :> bool<>
//│ | | | C α262' <! (true<bool> | (α282' & ~(true<bool>)))    (0)
//│ | | | | C bool<> <! (true<bool> | (α282' & ~(true<bool>)))    (1)
//│ | | | | | ARGH  DNF(bool<>{})  <!  DNF(true<bool>{} | α282'∧~(true<bool>))
//│ | | | | | | Consider bool<>{} <: DNF(true<bool>{} | α282'∧~(true<bool>))
//│ | | | | | | Possible: List(true<bool>{}, α282'∧~(true<bool>))
//│ | | | | | | A  bool<>{}  %  List()  <!  List(true<bool>, (α282' & ~(true<bool>)))  %  ⊥
//│ | | | | | | | A  bool<>{}  %  List()  <!  List((α282' & ~(true<bool>)))  %  true<bool>
//│ | | | | | | | | Case.1
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(α282')  %  true<bool>
//│ | | | | | | | | | C (bool<> & ~(true<bool>)) <! α282'    (2)
//│ | | | | | | | | Case.2
//│ | | | | | | | | A  bool<>{}  %  List()  <!  List(~(true<bool>))  %  true<bool>
//│ | | | | | | | | | A  bool<>{}  %  List(true<bool>)  <!  List()  %  true<bool>
//│ | | | | | | | | | | A  true<bool>{}  %  List()  <!  List()  %  true<bool>
//│ | | | | | | | | | | | OK  true<bool>  <:  true<bool>
//│ | | 1. : (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')
//│ | 1. : (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')
//│ 1. : ((α259', α260',) -> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260'))
//│ CONSTRAIN ((α259', α260',) -> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')) <! test258'
//│   where 
//│ 		test258' <: ((α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) -> α279')
//│ 		α259' <: int<number> & number<>
//│ 		α260' <: Code[α271,α272]
//│ 		α270' :> int<number>
//│ 		α271 <: int<number>
//│ 		α277' :> int<number> | error<>
//│ 		α279' <: Code[α267,α268]
//│ 		α280' :> α267
//│ C ((α259', α260',) -> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')) <! test258'    (0)
//│ | C ((α259', α260',) -> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')) <! ((α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) -> α279')    (1)
//│ | | C (α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) <! (α259', α260',)    (2)
//│ | | | C α270' <! α259'    (3)
//│ | | | | C int<number> <! α259'    (4)
//│ | | | | | C int<number> <! int<number>    (5)
//│ | | | | | C int<number> <! number<>    (5)
//│ | | | C Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))] <! α260'    (5)
//│ | | | | C Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))] <! Code[α271,α272]    (6)
//│ | | | | | C α277' <! α271    (7)
//│ | | | | | | C int<number> <! α271    (8)
//│ | | | | | | | C int<number> <! int<number>    (9)
//│ | | | | | | C error<> <! α271    (9)
//│ | | | | | | | C error<> <! int<number>    (10)
//│ | | | | | C α272 <! ({test1: α278', test2: α278'} & ~({test1: α278'}))    (11)
//│ | | | | | | EXTR RHS  ({test1: α278', test2: α278'} & ~({test1: α278'}))  ~>  ({test1: α283, test2: α283} & ~({test1: α283}))  to 0
//│ | | | | | |  where 
//│ | | | | | |    and 
//│ 		α278' :> α283
//│ | | | | | | C α272 <! ({test1: α283, test2: α283} & ~({test1: α283}))    (12)
//│ | | C (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260') <! α279'    (13)
//│ | | | C (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260') <! Code[α267,α268]    (14)
//│ | | | | C Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] <! Code[α267,α268]    (15)
//│ | | | | | C α280' <! α267    (16)
//│ | | | | | | C α267 <! α267    (17)
//│ | | | | | C α268 <! ({test1: α281', test2: α281'} & ~({test1: α281'}))    (17)
//│ | | | | | | EXTR RHS  ({test1: α281', test2: α281'} & ~({test1: α281'}))  ~>  ({test1: α284, test2: α284} & ~({test1: α284}))  to 0
//│ | | | | | |  where 
//│ | | | | | |    and 
//│ 		α281' :> α284
//│ | | | | | | C α268 <! ({test1: α284, test2: α284} & ~({test1: α284}))    (18)
//│ | | | | C α260' <! Code[α267,α268]    (19)
//│ | | | | | C Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))] <! Code[α267,α268]    (20)
//│ | | | | | | C α277' <! α267    (21)
//│ | | | | | | | C int<number> <! α267    (22)
//│ | | | | | | | C error<> <! α267    (23)
//│ | | | | | | C α268 <! ({test1: α278', test2: α278'} & ~({test1: α278'}))    (24)
//│ | | | | | | | EXTR RHS  ({test1: α278', test2: α278'} & ~({test1: α278'}))  ~>  ({test1: α285, test2: α285} & ~({test1: α285}))  to 0
//│ | | | | | | |  where 
//│ | | | | | | |    and 
//│ 		α278' :> α285 | α283
//│ | | | | | | | C α268 <! ({test1: α285, test2: α285} & ~({test1: α285}))    (25)
//│ ⬤ Typed as: test258'
//│  where: 
//│ 		test258' :> ((α259', α260',) -> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260')) <: ((α270', Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))],) -> α279')
//│ 		α259' :> int<number> <: int<number> & number<>
//│ 		α260' :> Code[α277',({test1: α278', test2: α278'} & ~({test1: α278'}))] <: Code[α267,α268] & Code[α271,α272]
//│ 		α267 :> error<> | int<number>
//│ 		α268 <: ({test1: α285, test2: α285} & ~({test1: α285})) & ({test1: α284, test2: α284} & ~({test1: α284}))
//│ 		α270' :> int<number> <: α259'
//│ 		α271 :> error<> | int<number> <: int<number>
//│ 		α272 <: ({test1: α283, test2: α283} & ~({test1: α283}))
//│ 		α277' :> int<number> | error<> <: α267 & α271
//│ 		α278' :> α285 | α283
//│ 		α279' :> (Code[α280',({test1: α281', test2: α281'} & ~({test1: α281'}))] | α260') <: Code[α267,α268]
//│ 		α280' :> α267 <: α267
//│ 		α281' :> α284
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.587: 	fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ ║         	                                                                              ^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C, Code#T <: ?a}` is not an instance of type `int`
//│ test: (int, Code[int | 'a, ?] & 'b,) -> (Code[error | int | 'a, ?] | 'b)
