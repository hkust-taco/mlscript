// :NewParser

code"${a + b} + 10"
//│ res: "${a + b} + 10"
//│    = '${a + b} + 10'

:NewParser
code"let a = 1; let b = 3; ${code"b + ${code"1"}"} + 1"
//│ res: Code[int, ?]
//│    = [
//│        'Let',
//│        Symbol(a),
//│        [ 1 ],
//│        [ 'Let', Symbol(b), [ 3 ], [ 'App', '+', [Array], [Array] ] ]
//│      ]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | typing for 373
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | | search inside QQ
//│ | | | | try env
//│ | | | | try free env
//│ | | | | try parent
//│ | | | | search inside QQ
//│ | | | | Reach limit
//│ | | | 0. : α159
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α41)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α41)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α41    (1)
//│ | | | | | 0. : α41
//│ | | | | | CONSTRAIN (Code[α39,α40] -> α39) <! (α41 -> α42)
//│ | | | | |   where 
//│ 		α41 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α39,α40] -> α39) <! (α41 -> α42)    (0)
//│ | | | | | | C α41 <! Code[α39,α40]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α39,α40]    (2)
//│ | | | | | | | | C int<number> <! α39    (3)
//│ | | | | | | | | C ⊥ <! α40    (4)
//│ | | | | | | C α39 <! α42    (5)
//│ | | | | | | | C int<number> <! α42    (6)
//│ | | | | 0. : α42
//│ | | | 0. : (α42,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)
//│ | | |   where 
//│ 		α42 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)    (0)
//│ | | | | C (α42,) <! (int<number>,)    (1)
//│ | | | | | C α42 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α43    (3)
//│ | | 0. : α43
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α164 <! (1<int,number> -> α165)
//│ | |   where 
//│ | | C α164 <! (1<int,number> -> α165)    (0)
//│ | 0. : α165
//│ | chaining for 373
//│ | local unquoted context:
//│ | List(α161)
//│ 0. : Code[α165,(α161 | "+"<>)]
//│ ⬤ Typed as: Code[α165,(α161 | "+"<>)]
//│  where: 
//│ n: 1
//│ res: Code[int, ?]

:NewParser
code"let a = 1; 
let b = 3"
//│ ╔══[LEXICAL ERROR] unclosed quotation mark
//│ ║  l.90: 	let b = 3"
//│ ╙──      	         ^
//│ ╔══[PARSE ERROR] Unmatched opening quasiquote
//│ ║  l.89: 	code"let a = 1; 
//│ ╙──      	^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found ';' keyword instead
//│ ║  l.89: 	code"let a = 1; 
//│ ╙──      	              ^
//│ a: 1



:NewParser
:d
:ne
:NoJS
code"let x = 1; ${y
}
"
//│ ╔══[LEXICAL ERROR] unclosed quotation mark
//│ ║  l.110: 	"
//│ ╙──       	^
//│ ╔══[PARSE ERROR] Unmatched opening quasiquote
//│ ║  l.108: 	code"let x = 1; ${y
//│ ╙──       	^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found ';' keyword instead
//│ ║  l.108: 	code"let x = 1; ${y
//│ ╙──       	              ^
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ x: 1

:NewParser
:d
:ge
class Foo(
x
) 
let f = new Foo(
5)
//│ ╔══[PARSE ERROR] Unexpected identifier here
//│ ║  l.136: 	x
//│ ╙──       	^
//│ ╔══[PARSE ERROR] Unexpected literal here
//│ ║  l.139: 	5)
//│ ╙──       	^
//│ 0. Typing type Record(List())
//│ | vars=Map() newDefsInfo=Map(Foo -> (Cls,0))
//│ => ⊤ | 
//│ Defined class Foo
//│ 1. Typing term  => Foo ({},)
//│ | 1. Typing pattern 
//│ | 1. : ()
//│ | 1. Typing term Foo ({},)
//│ | | 1. Typing term Foo
//│ | | 1. : (⊤ -> foo<>)
//│ | | 1. Typing term {},
//│ | | | 1. Typing term {}
//│ | | | 1. : ⊤
//│ | | 1. : (⊤,)
//│ | | CONSTRAIN (⊤ -> foo<>) <! (⊤ -> α47')
//│ | |   where 
//│ | | C (⊤ -> foo<>) <! (⊤ -> α47')    (0)
//│ | | | C (⊤,) <! (⊤,)    (1)
//│ | | | C foo<> <! α47'    (1)
//│ | 1. : α47'
//│ 1. : (() -> α47')
//│ ⬤ Typed as: (() -> α47')
//│  where: 
//│ 		α47' :> foo<>
//│ 1. Typing term new Foo() {}
//│ | 1. Typing term Foo ()
//│ | | 1. Typing term Foo
//│ | | 1. : (() -> α49')
//│ | | 1. Typing term 
//│ | | 1. : ()
//│ | | CONSTRAIN (() -> α49') <! (() -> α50')
//│ | |   where 
//│ 		α49' :> foo<>
//│ | | C (() -> α49') <! (() -> α50')    (0)
//│ | | | C () <! ()    (1)
//│ | | | C α49' <! α50'    (1)
//│ | | | | C foo<> <! α50'    (2)
//│ | 1. : α50'
//│ 1. : α50'
//│ ⬤ Typed as: α50'
//│  where: 
//│ 		α50' :> foo<>
//│ Foo: () -> Foo
//│ f: Foo
