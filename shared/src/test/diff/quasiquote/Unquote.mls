:NewParser

let cde = code"a"
//│ cde: Code['a, {a: 'a}]
//│    = [ 'Var', [ 'FreeVar', 'a' ] ]

let c = code"let a = 10; let b = 10;${cde}"
//│ c: Code['a, {a: 'a}\a\b]
//│  = [
//│      'Let',
//│      'a',
//│      Symbol(a),
//│      [ '_', 10 ],
//│      [ 'Let', 'b', Symbol(b), [ '_', 10 ], [ 'Unquoted', [Array] ] ]
//│    ]

// FIXME
c: Code<int, {}>
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.18: 	c: Code<int, {}>
//│ ║        	^
//│ ╟── type `anything` does not have field 'a'
//│ ║  l.18: 	c: Code<int, {}>
//│ ╙──      	             ^^
//│ res: Code[int, anything]
//│    = [
//│        'Let',
//│        'a',
//│        Symbol(a),
//│        [ '_', 10 ],
//│        [ 'Let', 'b', Symbol(b), [ '_', 10 ], [ 'Unquoted', [Array] ] ]
//│      ]

code"1"
//│ res: Code[1, anything]
//│    = [ '_', 1 ]

// :d
fun f(x, y) = code"[${x}, ${y}]"
//│ f: (Code['a, 'b], Code['c, 'b],) -> Code[('a, 'c,), 'b]
//│  = [Function: f]

let x = code"y"
//│ x: Code['a, {y: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'y' ] ]

// :d
let c = f(x, x)
//│ c: Code[('a, 'a,), {y: 'a}]
//│  = [ 'Bra', [ 'Tup', [ [Array], [Array] ] ] ]

code"[${code"y"}, ${code"y"}]"
//│ res: Code[('a, 'a,), {y: 'a}]
//│ Runtime error:
//│   ReferenceError: y is not defined

y => code"[${code"y"}, ${code"y"}]"
//│ res: anything -> Code[('a, 'a,), {y: 'a}]
//│    = [Function: res]

code"y => ${c}"
//│ res: Code[anything -> ('a, 'a,), {y: 'a}\y]
//│    = [ '_', [Function (anonymous)] ]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, 'b] & 'c, Code['d, 'b] & 'e,) -> (Code[('a, 'd,), 'b], 'c, 'e,)
//│  = [Function: f1]

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]
//│  = <missing implementation>


fun f(x) = x
//│ f: 'a -> 'a
//│  = [Function: f2]

// :d
let built_in_binding_test = code"let f = x => x + 1; f(if true then 1 else 2)"
//│ built_in_binding_test: Code[int, anything\f\x]
//│                      = [
//│                          'Let',
//│                          'f',
//│                          Symbol(f),
//│                          [ '_', [Function (anonymous)] ],
//│                          [ 'App_Fun', [ 'Var', Symbol(f) ], [ 'Tup', [Array] ] ]
//│                        ]


// :d
code"f(0)"
//│ res: Code[0, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'f' ] ], [ 'Tup', [ [Array] ] ] ]

:e
code"${code"${code"${z}"}"}"
//│ ╔══[ERROR] identifier not found: z
//│ ║  l.97: 	code"${code"${code"${z}"}"}"
//│ ╙──      	                     ^
//│ res: Code[nothing, anything]
//│ Code generation encountered an error:
//│   unresolved symbol z

// :d
let z = code"1"
code"${code"${z}"}"
//│ z: Code[1, anything]
//│  = [ '_', 1 ]
//│ res: Code[1, anything]
//│    = [ 'Unquoted', [ 'Unquoted', [ '_', 1 ] ] ]
// :d
code"let x = 1; let z = 1; code"x + y""
//│ res: Code[Code[int, {x: int, y: int}], anything\x\z]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'z', Symbol(z), [ '_', 1 ], [ '_', [Array] ] ]
//│      ]
// :d
code"let z = 0;${code"z"}"
//│ res: Code['a, {z: 'a}\z]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ '_', 0 ],
//│        [ 'Unquoted', [ 'Var', Symbol(z) ] ]
//│      ]
// :d
code"let x = 1;${code"x + y"}"
//│ res: Code[int, {x: int, y: int}\x]
//│ Runtime error:
//│   ReferenceError: y is not defined

// :d
code"1 + ${code"b"}"
//│ res: Code[int, {b: int}]
//│ Runtime error:
//│   ReferenceError: b is not defined

// :d
let n = 1
code"${Const(n)} + 1"
//│ n: 1
//│  = 1
//│ res: Code[int, ?]
//│    = [ 'App', '+', [ 'Unquoted', [ '_', 1 ] ], [ '_', 1 ] ]
// :d
fun test(n, cde) = if n > 0 then code"let x = ${Const(n)}; ${test(n - 1, code"${cde} + x")}" else cde
//│ test: (int, Code[int | 'a, ?] & 'b,) -> (Code[int | 'a, nothing\x & {x: int} & 'c] | 'b)
//│     = [Function: test]
