// :NewParser
:NewParser
:d
:ne
:NoJS
code"z
+ 1"
//│ ╔══[PARSE ERROR] Unexpected operator here
//│ ║  l.6: 	+ 1"
//│ ╙──     	^
//│ 0. Typing term Quoted' z '
//│ | typing for 87
//│ | 0. Typing term z
//│ | | inspect z by ctx.get
//│ | | insert z into the free vars
//│ | 0. : α26
//│ | chaining for 87
//│ | local unquoted context:
//│ | List()
//│ | {z: α26}
//│ 0. : Code[α26,({test1: α27, test2: α27} & ~({test1: α27}))]
//│ ⬤ Typed as: Code[α26,({test1: α27, test2: α27} & ~({test1: α27}))]
//│  where: 
//│ res: Code[nothing, ?]

:d
:ne
:NoJS
fun f(x, y) = code"[${x}, ${y}]"
//│ 1. Typing term x, y, => Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | 1. Typing pattern x, y,
//│ | | 1. Typing pattern x
//│ | | 1. : α32'
//│ | | 1. Typing pattern y
//│ | | 1. : α33'
//│ | 1. : (α32', α33',)
//│ | 1. Typing term Quoted' '(' Unquote' x ', Unquote' y ', ')' '
//│ | | typing for 291
//│ | | 1. Typing term '(' Unquote' x ', Unquote' y ', ')'
//│ | | | 1. Typing term Unquote' x ', Unquote' y ',
//│ | | | | 1. Typing term Unquote' x '
//│ | | | | | 1. Typing term x
//│ | | | | | | inspect x by ctx.get
//│ | | | | | 1. : α32'
//│ | | | | | CONSTRAIN (Code[α34,α35] -> α34) <! (α32' -> α36')
//│ | | | | |   where 
//│ | | | | | C (Code[α34,α35] -> α34) <! (α32' -> α36')    (0)
//│ | | | | | | C α32' <! Code[α34,α35]    (1)
//│ | | | | | | C α34 <! α36'    (2)
//│ | | | | 1. : α36'
//│ | | | | 1. Typing term Unquote' y '
//│ | | | | | 1. Typing term y
//│ | | | | | | inspect y by ctx.get
//│ | | | | | 1. : α33'
//│ | | | | | CONSTRAIN (Code[α37,α38] -> α37) <! (α33' -> α39')
//│ | | | | |   where 
//│ | | | | | C (Code[α37,α38] -> α37) <! (α33' -> α39')    (0)
//│ | | | | | | C α33' <! Code[α37,α38]    (1)
//│ | | | | | | C α37 <! α39'    (2)
//│ | | | | 1. : α39'
//│ | | | 1. : (α36', α39',)
//│ | | 1. : (α36', α39',)
//│ | | chaining for 291
//│ | | local unquoted context:
//│ | | List(α35, α38)
//│ | | {}
//│ | 1. : Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]
//│ 1. : ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))])
//│ CONSTRAIN ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]) <! f31'
//│   where 
//│ 		α32' <: Code[α34,α35]
//│ 		α33' <: Code[α37,α38]
//│ 		α36' :> α34
//│ 		α39' :> α37
//│ C ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))]) <! f31'    (0)
//│ ⬤ Typed as: f31'
//│  where: 
//│ 		f31' :> ((α32', α33',) -> Code[(α36', α39',),({test1: α40', test2: α40'} & ~({test1: α40'}))])
//│ 		α32' <: Code[α34,α35]
//│ 		α33' <: Code[α37,α38]
//│ 		α36' :> α34
//│ 		α39' :> α37
//│ f: (Code['a, ?], Code['b, ?],) -> Code[('a, 'b,), ?]

let x = code"y"
//│ x: Code[nothing, ?]

let c = f(x, x)
//│ c: Code[(nothing, nothing,), ?]

code"y"
y => code"[${code"y"}, ${code"y"}]"
//│ res: Code[nothing, ?]
//│ res: 'a -> Code[('a, 'a,), ?]

code"y => ${c}"
//│ res: Code[anything -> (nothing, nothing,), ?]


fun f(x, y) = [code"[${x}, ${y}]", x, y]
//│ f: (Code['a, ?] & 'b, Code['c, ?] & 'd,) -> (Code[('a, 'c,), ?], 'b, 'd,)

let a: Code<int, {z: int}>
//│ a: Code[int, {z: int}]


fun f(x) = x
//│ f: 'a -> 'a

code"f(0)"
//│ res: Code[0, anything]
code"${a + b} + 10"
//│ res: "${a + b} + 10"
//│    = '${a + b} + 10'

:NewParser
code"let a = 1; let b = 3; ${code"b + ${code"1"}"} + 1"
//│ res: Code[int, ?]
//│    = [
//│        'Let',
//│        Symbol(a),
//│        [ 1 ],
//│        [ 'Let', Symbol(b), [ 3 ], [ 'App', '+', [Array], [Array] ] ]
//│      ]


:NewParser
:d
:ne
:NoJS
let n = 1
code"${Const(n)} + 1"
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ 0. Typing term Quoted' + (Unquote' Const (n,) ',) (1,) '
//│ | typing for 45
//│ | 0. Typing term + (Unquote' Const (n,) ',) (1,)
//│ | | 0. Typing term + (Unquote' Const (n,) ',)
//│ | | | 0. Typing term +
//│ | | | | inspect + by ctx.get
//│ | | | 0. : (int<number> -> (int<number> -> int<number>))
//│ | | | 0. Typing term Unquote' Const (n,) ',
//│ | | | | 0. Typing term Unquote' Const (n,) '
//│ | | | | | 0. Typing term Const (n,)
//│ | | | | | | 0. Typing term Const
//│ | | | | | | | inspect Const by ctx.get
//│ | | | | | | 0. : (int<number> -> Code[int<number>,⊥])
//│ | | | | | | 0. Typing term n,
//│ | | | | | | | 0. Typing term n
//│ | | | | | | | | inspect n by ctx.get
//│ | | | | | | | 0. : 1<int,number>
//│ | | | | | | 0. : (1<int,number>,)
//│ | | | | | | CONSTRAIN (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α41)
//│ | | | | | |   where 
//│ | | | | | | C (int<number> -> Code[int<number>,⊥]) <! (1<int,number> -> α41)    (0)
//│ | | | | | | | C (1<int,number>,) <! (int<number>,)    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! α41    (1)
//│ | | | | | 0. : α41
//│ | | | | | CONSTRAIN (Code[α39,α40] -> α39) <! (α41 -> α42)
//│ | | | | |   where 
//│ 		α41 :> Code[int<number>,⊥]
//│ | | | | | C (Code[α39,α40] -> α39) <! (α41 -> α42)    (0)
//│ | | | | | | C α41 <! Code[α39,α40]    (1)
//│ | | | | | | | C Code[int<number>,⊥] <! Code[α39,α40]    (2)
//│ | | | | | | | | C int<number> <! α39    (3)
//│ | | | | | | | | C ⊥ <! α40    (4)
//│ | | | | | | C α39 <! α42    (5)
//│ | | | | | | | C int<number> <! α42    (6)
//│ | | | | 0. : α42
//│ | | | 0. : (α42,)
//│ | | | CONSTRAIN (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)
//│ | | |   where 
//│ 		α42 :> int<number>
//│ | | | C (int<number> -> (int<number> -> int<number>)) <! (α42 -> α43)    (0)
//│ | | | | C (α42,) <! (int<number>,)    (1)
//│ | | | | | C α42 <! int<number>    (2)
//│ | | | | | | C int<number> <! int<number>    (3)
//│ | | | | C (int<number> -> int<number>) <! α43    (3)
//│ | | 0. : α43
//│ | | 0. Typing term 1,
//│ | | | 0. Typing term 1
//│ | | | 0. : 1<int,number>
//│ | | 0. : (1<int,number>,)
//│ | | CONSTRAIN α252 <! (1<int,number> -> α253)
//│ | |   where 
//│ 		α252 :> (int<number> -> int<number>)
//│ | | C α252 <! (1<int,number> -> α253)    (0)
//│ | | | C (int<number> -> int<number>) <! (1<int,number> -> α253)    (1)
//│ | | | | C (1<int,number>,) <! (int<number>,)    (2)
//│ | | | | C int<number> <! α253    (2)
//│ | 0. : α253
//│ | chaining for 45
//│ | local unquoted context:
//│ | List(α249)
//│ | {}
//│ 0. : Code[α253,({test1: α254, test2: α254} & ~({test1: α254}))]
//│ ⬤ Typed as: Code[α253,({test1: α254, test2: α254} & ~({test1: α254}))]
//│  where: 
//│ 		α253 :> int<number>
//│ n: 1
//│ res: Code[int, ?]

:NewParser
code"let a = 1; 
let b = 3"
//│ ╔══[LEXICAL ERROR] unclosed quotation mark
//│ ║  l.90: 	let b = 3"
//│ ╙──      	         ^
//│ ╔══[PARSE ERROR] Unmatched opening quasiquote
//│ ║  l.89: 	code"let a = 1; 
//│ ╙──      	^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found ';' keyword instead
//│ ║  l.89: 	code"let a = 1; 
//│ ╙──      	              ^
//│ a: 1



:NewParser
:d
:ne
:NoJS
code"let x = 1; ${y
}
"
//│ ╔══[LEXICAL ERROR] unclosed quotation mark
//│ ║  l.110: 	"
//│ ╙──       	^
//│ ╔══[PARSE ERROR] Unmatched opening quasiquote
//│ ║  l.108: 	code"let x = 1; ${y
//│ ╙──       	^^^^^
//│ ╔══[PARSE ERROR] Expected end of input; found ';' keyword instead
//│ ║  l.108: 	code"let x = 1; ${y
//│ ╙──       	              ^
//│ 1. Typing term 1
//│ 1. : 1<int,number>
//│ ⬤ Typed as: 1<int,number>
//│  where: 
//│ x: 1

:NewParser
:d
:ge
class Foo(
x
) 
let f = new Foo(
5)
//│ ╔══[PARSE ERROR] Unexpected identifier here
//│ ║  l.136: 	x
//│ ╙──       	^
//│ ╔══[PARSE ERROR] Unexpected literal here
//│ ║  l.139: 	5)
//│ ╙──       	^
//│ 0. Typing type Record(List())
//│ | vars=Map() newDefsInfo=Map(Foo -> (Cls,0))
//│ => ⊤ | 
//│ Defined class Foo
//│ 1. Typing term  => Foo ({},)
//│ | 1. Typing pattern 
//│ | 1. : ()
//│ | 1. Typing term Foo ({},)
//│ | | 1. Typing term Foo
//│ | | 1. : (⊤ -> foo<>)
//│ | | 1. Typing term {},
//│ | | | 1. Typing term {}
//│ | | | 1. : ⊤
//│ | | 1. : (⊤,)
//│ | | CONSTRAIN (⊤ -> foo<>) <! (⊤ -> α47')
//│ | |   where 
//│ | | C (⊤ -> foo<>) <! (⊤ -> α47')    (0)
//│ | | | C (⊤,) <! (⊤,)    (1)
//│ | | | C foo<> <! α47'    (1)
//│ | 1. : α47'
//│ 1. : (() -> α47')
//│ ⬤ Typed as: (() -> α47')
//│  where: 
//│ 		α47' :> foo<>
//│ 1. Typing term new Foo() {}
//│ | 1. Typing term Foo ()
//│ | | 1. Typing term Foo
//│ | | 1. : (() -> α49')
//│ | | 1. Typing term 
//│ | | 1. : ()
//│ | | CONSTRAIN (() -> α49') <! (() -> α50')
//│ | |   where 
//│ 		α49' :> foo<>
//│ | | C (() -> α49') <! (() -> α50')    (0)
//│ | | | C () <! ()    (1)
//│ | | | C α49' <! α50'    (1)
//│ | | | | C foo<> <! α50'    (2)
//│ | 1. : α50'
//│ 1. : α50'
//│ ⬤ Typed as: α50'
//│  where: 
//│ 		α50' :> foo<>
//│ Foo: () -> Foo
//│ f: Foo
