:NewParser
:ge

// Var 
// TODO: need to handle all keywords

// Lam 
let code_lam = code"(x, y) => x + 1"
//│ code_lam: code & {Code#C = anything, Code#T <: (int, anything,) -> int}
//│         = [
//│             'Lam',
//│             [ 'Tup', [ 'Var', 'x' ], [ 'Var', 'y' ] ],
//│             [ 'App', '+', [ 'Var', 'x' ], [ 1 ] ]
//│           ]

// App
let code_app = code"1 + 2 * 3"
//│ code_app: code & {Code#C = anything, Code#T <: int}
//│         = [ 'App', '+', [ 1 ], [ 'App', '*', [ 2 ], [ 3 ] ] ]


let code_app3 = code"test(x)"
//│ code_app3: code & {Code#C = anything, Code#T = nothing}
//│          = [ 'Fun', [ 'Var', 'test' ], [ 'Tup', [ 'Var', 'x' ] ] ]

// If
let code_if = code"if true then 1 else 3"
//│ code_if: code & {Code#C = anything, Code#T <: 1 | 3}
//│        = [ 'If', [ 'Var', 'true' ], [ 1 ], [ 3 ] ]

// Unquoted 

// Tup 
let code_tup = code"(1,2,3)"
//│ code_tup: code & {Code#C = anything, Code#T <: (1, 2, 3,)}
//│         = [ 'Tup', [ 1 ], [ 2 ], [ 3 ] ]

let code_tup2 = code"(x, y, z)"
//│ code_tup2: code & {Code#C = anything, Code#T <: (nothing, nothing, nothing,)}
//│          = [ 'Tup', [ 'Var', 'x' ], [ 'Var', 'y' ], [ 'Var', 'z' ] ]

// Rcd 
let code_res = code"{y: 1, x: 2}"
//│ code_res: code & {Code#C = anything, Code#T <: {x: 2, y: 1}}
//│         = [ 'Rcd', [ [ 'Var', 'y' ], [ 1 ] ], [ [ 'Var', 'x' ], [ 2 ] ] ]

// Sel
let code_sel = code"{ x: 1 }.x"
//│ code_sel: code & {Code#C = anything, Code#T <: 1}
//│         = [ 'Sel', [ 'Rcd', [ [Array], [Array] ] ], [ 'Var', 'x' ] ]

run(code_sel)
//│ res: 1
//│    = 0

// let code_sel2 = code"let a = {x : 1}; a.x" <- this has errors in normal code

// Let 
let code_let1 = code"let x = 2; let y = 3; y"
//│ code_let1: code & {Code#C = anything, Code#T <: 3}
//│          = [ 'Let', 'x', [ 2 ], [ 'Let', 'y', [ 3 ], [ 'Var', 'y' ] ] ]

let code_let2 = code"let x = (y) => y; let y = (z) => z + 2; x(3)"
//│ code_let2: code & {Code#C = anything, Code#T <: 3}
//│          = [
//│              'Let',
//│              'x',
//│              [ 'Lam', [ 'Tup', [Array] ], [ 'Var', 'y' ] ],
//│              [
//│                'Let',
//│                'y',
//│                [ 'Lam', [Array], [Array] ],
//│                [ 'Fun', [Array], [Array] ]
//│              ]
//│            ]

let code_let3 = code"let x = 3; x + x"
//│ code_let3: code & {Code#C = anything, Code#T <: int}
//│          = [ 'Let', 'x', [ 3 ], [ 'App', '+', [ 'Var', 'x' ], [ 'Var', 'x' ] ] ]



// Subs 
//let code_subs = code"let a = (1, 2); a[0]"

//run(code_subs)


//let code_subs2 = code"let a = (1, 2, 3); a[0]"

//let code_subs3 = code"(1,2,3)[1]"


// Assign <-
// TODO: find out how to generate

// Splc [ : ]
// TODO: find out how to generate

// New 
class Foo(x) 
let f = new Foo(1)
//│ Defined class Foo
//│ Foo: 'x -> (Foo with {x: 'x})
//│    = [Function: Foo1]
//│ f: Foo & {x: 1}
//│  = Foo { x: 1 }

let code_new = code"new Foo(1)"
//│ code_new: code & {Code#C = anything, Code#T <: Foo & {x: 1}}
//│ Code generation encountered an error:
//│   New HEAD (TypeName(Foo),1,) BODY TypingUnit(List())
//│ 	New not supported in quasiquotes... yet

// Quoted 
let d = code"code"3""
//│ d: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: 3}}
//│ Code generation encountered an error:
//│   missing implementation: Quoted(IntLit(3))

let code_fun = code"let x = (y) => y; x(3)"
//│ code_fun: code & {Code#C = anything, Code#T <: 3}
//│         = [
//│             'Let',
//│             'x',
//│             [ 'Lam', [ 'Tup', [Array] ], [ 'Var', 'y' ] ],
//│             [ 'Fun', [ 'Var', 'x' ], [ 'Tup', [Array] ] ]
//│           ]
