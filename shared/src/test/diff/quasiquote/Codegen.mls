:NewParser
:ge

// Notes for meeting (10 Feb)
// Free variables in quasiquote definition cause errors unless defined in an unquote 

// Example: free variable quasiquote defined first -> error and cannot be used 
let fx = code"x+1"
let q = code"let x = 2; ${fx}" -> code"let x = 2; x + 1"
//│ ╔══[PARSE ERROR] Expected end of input; found '->' keyword instead
//│ ║  l.9: 	let q = code"let x = 2; ${fx}" -> code"let x = 2; x + 1"
//│ ╙──     	                               ^^
//│ fx: code & {Code#C = anything, Code#T <: int}
//│ Runtime error:
//│   ReferenceError: x is not defined
//│ ╔══[ERROR] Type mismatch. Required: Code, found: [Code[α33',x.type27'34']]
//│ ║  l.9: 	let q = code"let x = 2; ${fx}" -> code"let x = 2; x + 1"
//│ ╙──     	                          ^^
//│ q: code & {Code#C = anything, Code#T <: error}
//│ Runtime error:
//│   ReferenceError: fx is not defined

// Example: free variable quasiquote in unquote, and there is a definition in scope -> no problem 
code"let z = x => ${let c = code"x + 1"; c}; z(3)"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: [Code[α40',x.type36''41']]
//│ ║  l.24: 	code"let z = x => ${let c = code"x + 1"; c}; z(3)"
//│ ╙──      	                            ^^^^^^^^^^^^^^
//│ res: code & {Code#C = anything, Code#T <: error}
//│    = [
//│        'Let',
//│        Symbol(z),
//│        [ [Function (anonymous)] ],
//│        [ 'Fun', [ 'Var', Symbol(z) ], [ [Array] ] ]
//│      ]

run(res)
//│ res: error
//│    = 4






// Lam  
let code_lam = code"let lambda = (x) => x; lambda(3)"
//│ code_lam: code & {Code#C = anything, Code#T <: 3}
//│         = [
//│             'Let',
//│             Symbol(lambda),
//│             [ [Function (anonymous)] ],
//│             [ 'Fun', [ 'Var', Symbol(lambda) ], [ [Array] ] ]
//│           ]

run(code_lam)
//│ res: 3
//│    = 3

// App
let code_app = code"3 + 2 * 2"
//│ code_app: code & {Code#C = anything, Code#T <: int}
//│         = [ 'App', '+', [ 3 ], [ 'App', '*', [ 2 ], [ 2 ] ] ]

run(code_app)
//│ res: int
//│    = 7

fun test(x) = x
//│ test: 'a -> 'a
//│     = [Function: test]

let code_app3 = code"test(3)"
//│ code_app3: code & {Code#C = anything, Code#T <: 3}
//│          = [ 'Fun', [ 'Var', [Function: test] ], [ [ 3 ] ] ]
 
run(code_app3)
//│ res: 3
//│    = 3

// If
let code_if = code"if false then 1 else 2 + 3"
//│ code_if: code & {Code#C = anything, Code#T <: int}
//│        = [ 'If', [ 'Var', false ], [ 1 ], [ 'App', '+', [ 2 ], [ 3 ] ] ]

run(code_if)
//│ res: int
//│    = 5

// Tup 
let code_tup = code"(1,2,3)"
//│ code_tup: code & {Code#C = anything, Code#T <: (1, 2, 3,)}
//│         = [ [ 1, 2, 3 ] ]

run(code_tup)
//│ res: (1, 2, 3,)
//│    = [ 1, 2, 3 ]

// Rcd 
let code_rcd = code"let r = { x: 10}; r.x"
//│ code_rcd: code & {Code#C = anything, Code#T <: 10}
//│         = [
//│             'Let',
//│             Symbol(r),
//│             [ { x: 10 } ],
//│             [ 'Sel', [ 'Var', Symbol(r) ], 'x' ]
//│           ]

run(code_rcd)
//│ res: 10
//│    = 10

// Let 
let code_let1 = code"let x = 100; let y = 10; y + x"
//│ code_let1: code & {Code#C = anything, Code#T <: int}
//│          = [
//│              'Let',
//│              Symbol(x),
//│              [ 100 ],
//│              [ 'Let', Symbol(y), [ 10 ], [ 'App', '+', [Array], [Array] ] ]
//│            ]

let code_let2 = code"let x = (y) => y * 3; let y = (z) => z + 2; x(3)"
//│ code_let2: code & {Code#C = anything, Code#T <: int}
//│          = [
//│              'Let',
//│              Symbol(x),
//│              [ [Function (anonymous)] ],
//│              [
//│                'Let',
//│                Symbol(y),
//│                [ [Function (anonymous)] ],
//│                [ 'Fun', [Array], [Array] ]
//│              ]
//│            ]

let code_let3 = code"let x = 3; x + x"
//│ code_let3: code & {Code#C = anything, Code#T <: int}
//│          = [
//│              'Let',
//│              Symbol(x),
//│              [ 3 ],
//│              [ 'App', '+', [ 'Var', Symbol(x) ], [ 'Var', Symbol(x) ] ]
//│            ]


// Subs 
let code_subs = code"let a = (1, 2); a[0]"
//│ code_subs: code & {Code#C = anything, Code#T <: 1 | 2 | undefined}
//│          = [
//│              'Let',
//│              Symbol(a),
//│              [ [ 1, 2 ] ],
//│              [ 'Subs', [ 'Var', Symbol(a) ], [ 0 ] ]
//│            ]

run(code_subs)
//│ res: 1 | 2 | undefined
//│    = 1

let code_subs3 = code"(1,2,3)[1]"
//│ code_subs3: code & {Code#C = anything, Code#T <: 1 | 2 | 3 | undefined}
//│           = [ 'Subs', [ [ 1, 2, 3 ] ], [ 1 ] ]

run(code_subs3)
//│ res: 1 | 2 | 3 | undefined
//│    = 2


// Assign <-
// TODO: find out how to generate

// Splc [ : ]
// TODO: find out how to generate

// New 
class Foo(x) 
let f = new Foo(1)
//│ Defined class Foo
//│ Foo: 'x -> (Foo with {x: 'x})
//│    = [Function: Foo1]
//│ f: Foo & {x: 1}
//│  = Foo { x: 1 }

let code_new = code"new Foo(1)"
//│ code_new: code & {Code#C = anything, Code#T <: Foo & {x: 1}}
//│ Code generation encountered an error:
//│   New HEAD (TypeName(Foo),1,) BODY TypingUnit(List())
//│ 	New not supported in quasiquotes... yet
