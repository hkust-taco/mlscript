:NewParser

// basic test from meeting on Mar 10
let c = code"x"
//│ c: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]

let r = code"x => ${c}"
//│ r: Code[anything -> 'a, {x: 'a}\x]
//│  = [ '_', [Function (anonymous)] ]

:e
run(r)(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	run(r)(1)
//│ ║        	^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = 1


// IntLit
let int_lit = code"1"
//│ int_lit: Code[1, anything]
//│        = [ '_', 1 ]

// Bra, Rcd, Sel 
let rcd = code"{x: 10, y: 100, z: 1000}.z"
//│ rcd: Code[1000, anything]
//│    = [ 'Sel', [ 'Bra', [ 'Rcd', [Object] ] ], 'z' ]

run(rcd)
//│ res: 1000
//│    = 1000


// Let, Var, App -> evaluates to 3
let let_var = code"let y = 1; y + 1 * 2"
//│ let_var: Code[int, anything\y]
//│        = [
//│            'Let',
//│            'y',
//│            Symbol(y),
//│            [ '_', 1 ],
//│            [
//│              'App',
//│              '+',
//│              [ 'Var', Symbol(y) ],
//│              [ 'App', '*', [Array], [Array] ]
//│            ]
//│          ]

run(let_var)
//│ res: int
//│    = 3

// Fun, If
fun id(x) = x 
//│ id: 'a -> 'a
//│   = [Function: id]

let global_fun = code"id(4)"
//│ global_fun: Code[4, anything]
//│           = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'id' ] ], [ 'Tup', [ [Array] ] ] ]

run(global_fun)
//│ res: 4
//│    = 4

let local_fun = code"let plus1 = x => x + 1; plus1(if true then 1 else 2)"
//│ local_fun: Code[int, anything\plus1\x]
//│          = [
//│              'Let',
//│              'plus1',
//│              Symbol(plus1),
//│              [ '_', [Function (anonymous)] ],
//│              [ 'App_Fun', [ 'Var', Symbol(plus1) ], [ 'Tup', [Array] ] ]
//│            ]

run(local_fun)
//│ res: int
//│    = 2

// Lam
code"x => x"
//│ res: Code['a -> 'a, anything\x]
//│    = [ '_', [Function (anonymous)] ]
run(res)(1)
//│ res: 1
//│    = 1

code"let id = x => x; id(3)"
//│ res: Code[3, anything\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
run(res)
//│ res: 3
//│    = 3


code"x => x + ${Const(1)}"
//│ res: Code[int -> int, anything\x]
//│    = [ '_', [Function (anonymous)] ]

run(res)(3)
//│ res: int
//│    = 4

// Tup, Subs
let tup = code"let x = 1; let y = 2; (x, y)[0]"
//│ tup: Code[1 | 2 | undefined, anything\x\y]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Subs', [Array], [Array] ] ]
//│      ]

run(tup)
//│ res: 1 | 2 | undefined
//│    = 1

// Quasiquote 
let code_in_code = code"let x = code"1"; x"
//│ code_in_code: Code[Code[1, anything], anything\x]
//│             = [ 'Let', 'x', Symbol(x), [ '_', [ '_', 1 ] ], [ 'Var', Symbol(x) ] ]

run(code_in_code)
//│ res: Code[1, anything]
//│    = [ '_', 1 ]

run(res)
//│ res: 1
//│    = 1

// Unquoted - Const function
let unquoted = code"let x = 3; ${Const(10)} * x"
//│ unquoted: Code[int, anything\x]
//│         = [
//│             'Let',
//│             'x',
//│             Symbol(x),
//│             [ '_', 3 ],
//│             [ 'App', '*', [ 'Unquoted', [Array] ], [ 'Var', Symbol(x) ] ]
//│           ]
run(unquoted)
//│ res: int
//│    = 30

// No obvious test for DecLit 
// No obvious test for UnitLit
// Parsing error for StrLit 

let str_lit = code"'''hello'''"
//│ str_lit: Code["hello", anything]
//│        = [ '_', 'hello' ]

// free variables 
let free = code"y"
//│ free: Code['a, {y: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'y' ] ]

// Unquote - variable name for quasiquote
let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: Code[int, {a: int, b: int}\a\b]
//│            = [
//│                'Let',
//│                'a',
//│                Symbol(a),
//│                [ '_', 1 ],
//│                [ 'Let', 'b', Symbol(b), [ '_', 2 ], [ 'Unquoted', [Array] ] ]
//│              ]

:e
run(code_nested)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.181: 	run(code_nested)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` is not a record (expected a record with fields: b, a)
//│ res: error | int
//│    = 3

code"let id = x => ${code"x"}; id(true)"
//│ res: Code['a, {x: 'a}\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.200: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = true

let free = code"x"
//│ free: Code['a, {x: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'x' ] ]

:e 
code"let id = x => ${free}; id(3)"
run(res)
//│ res: Code['a, {x: 'a}\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.214: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = 3

:e
let id_external = code"x => ${free}"
run(id_external)
//│ id_external: Code[anything -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.232: 	run(id_external)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: anything -> nothing | error
//│    = [Function (anonymous)]

res(10)
//│ res: error
//│    = 10

:e
let id_internal = code"x => ${code"x"}"
run(id_internal)(10)
//│ id_internal: Code[anything -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.248: 	run(id_internal)(10)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = 10

let free_y = code"y"
//│ free_y: Code['a, {y: 'a}]
//│       = [ 'Var', [ 'FreeVar', 'y' ] ]

let use_free = code"let y = 3; ${code"let y = 5; ${code"let y = 100; ${free_y}"} + y"} + y"
//│ use_free: Code[int, {y: int}\y]
//│         = [
//│             'Let',
//│             'y',
//│             Symbol(y),
//│             [ '_', 3 ],
//│             [ 'App', '+', [ 'Unquoted', [Array] ], [ 'Var', Symbol(y) ] ]
//│           ]

:e
run(use_free)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.273: 	run(use_free)
//│ ║         	^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'y'
//│ res: error | int
//│    = 108

code"let z = x => ${let c = code"x + 1"; c}; z"
//│ res: Code[anything -> 'a, {x: 'a}\c\x\z]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'Var', Symbol(z) ]
//│      ]

:e
run(res)(100)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.292: 	run(res)(100)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = 101

code"x => y => Const(x + y)"
//│ res: Code[int -> int -> Code[int, anything], anything\x\y]
//│    = [ '_', [Function (anonymous)] ]

run(res)(1)(10)
//│ res: Code[int, anything]
//│    = [ '_', 11 ]

// Testing error messages for unquotes -> is it ok that we handle Unquote directly in translateTerm?
let qq = code"x"
//│ qq: Code['a, {x: 'a}]
//│   = [ 'Var', [ 'FreeVar', 'x' ] ]

// 1. In general code - ERROR
:e
let x = ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.315: 	let x = ${qq}
//│ ╙──       	          ^^
//│ x: error
//│ Runtime error:
//│   ReferenceError: sub is not defined

// 2. In lambdas in general code - ERROR 
:e
let x2 = x => ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.325: 	let x2 = x => ${qq}
//│ ╙──       	                ^^
//│ x2: anything -> nothing
//│   = [Function: x2]

// 3. In quasiquotes - OK
let x3 = code"${qq}"
//│ x3: Code['a, {x: 'a}]
//│   = [ 'Unquoted', [ 'Var', [ 'FreeVar', 'x' ] ] ]

// 4. In lambdas in quasiquotes - OK 
let x4 = code"x => ${qq}"
//│ x4: Code[anything -> 'a, {x: 'a}\x]
//│   = [ '_', [Function (anonymous)] ]

:e
run(x4)(5)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.343: 	run(x4)(5)
//│ ║         	^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error
//│    = 5


let f = 0
//│ f: 0
//│  = 0

// Note the renaming of `f`, which means it won't be picked up by the QQ
:js
fun f(x) = x
//│ // Query 1
//│ globalThis.f1 = function f1(x) {
//│   return x;
//│ };
//│ // End of generated code
//│ f: 'a -> 'a
//│  = [Function: f1]

code"f(1)"
//│ res: Code[1, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'f' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: 1
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function


// See renaming
:js
class Foo(n)
//│ Defined class Foo
//│ // Prelude
//│ class Foo {
//│   constructor(fields) {
//│     this.n = fields.n;
//│   }
//│ }
//│ // Query 1
//│ globalThis.Foo1 = function Foo1(n) {
//│   return new Foo({ n: n });
//│ };
//│ // End of generated code
//│ Foo: 'n -> (Foo with {n: 'n})
//│    = [Function: Foo1]

code"Foo(1)"
//│ res: Code[Foo & {n: 1}, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'Foo' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: Foo & {n: 1}
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function

:e
let codeA = code"let y = 2; y"
let codeB = code"y + y"
//│ codeA: Code[2, anything\y]
//│      = [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.408: 	let codeB = code"y + y"
//│ ║         	                 ^^^^^
//│ ╟── reference of type `"y"` is not an instance of type `int`
//│ ║  l.408: 	let codeB = code"y + y"
//│ ╙──       	                     ^
//│ codeB: Code[error | int, {y: int}]
//│      = [
//│          'App',
//│          '+',
//│          [ 'Var', [ 'FreeVar', 'y' ] ],
//│          [ 'Var', [ 'FreeVar', 'y' ] ]
//│        ]

// because of the parse error, codeB is not handled => typing and codegen runs, but obviously codeB is ignored in codegen
:pe
let both = code"${codeA}; ${codeB}"
//│ ╔══[PARSE ERROR] Unexpected ';' keyword here
//│ ║  l.427: 	let both = code"${codeA}; ${codeB}"
//│ ╙──       	                        ^
//│ both: Code[2, anything]
//│     = [
//│         'Unquoted',
//│         [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│       ]
run(both)
//│ res: 2
//│    = 2

code"x + (let x = 1; x)"
//│ res: Code[int, {x: int}\x]
//│    = [
//│        'App',
//│        '+',
//│        [ 'Var', [ 'FreeVar', 'x' ] ],
//│        [ 'Let', 'x', Symbol(x), [ '_', 1 ], [ 'Var', Symbol(x) ] ]
//│      ]

:e // BUG: quasiquote still has a free variable
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.450: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined

let a = code"let x = 0; x"
let b = code"x"
let c = code"${a} + ${b}"
//│ a: Code[0, anything\x]
//│  = [ 'Let', 'x', Symbol(x), [ '_', 0 ], [ 'Var', Symbol(x) ] ]
//│ b: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ c: Code[int, {x: int}]
//│  = [
//│      'App',
//│      '+',
//│      [ 'Unquoted', [ 'Let', 'x', Symbol(x), [Array], [Array] ] ],
//│      [ 'Unquoted', [ 'Var', [Array] ] ]
//│    ]

run(c)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.474: 	run(c)
//│ ║         	^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined


:e
let c = x => code"1 + ${code"x"}"
//│ c: anything -> Code[int, {x: int}]
//│  = [Function: c2]
c(2)
//│ res: Code[int, {x: int}]
//│    = [ 'App', '+', [ '_', 1 ], [ 'Unquoted', [ 'Var', [Array] ] ] ]
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.491: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined
