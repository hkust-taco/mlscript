:NewParser

// basic test from meeting on Mar 10
let c = code"x"
//│ c: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]

:e // context tracking
let r = code"x => ${c}"
//│ r: Code[anything -> 'a, {x: 'a}\x]
//│  = [ '_', [Function (anonymous)] ]



run(r)(1)
//│ res: nothing
//│    = 1


// IntLit
let int_lit = code"1"
//│ int_lit: Code[1, anything]
//│        = [ '_', 1 ]

// Bra, Rcd, Sel 
let rcd = code"{x: 10, y: 100, z: 1000}.z"
//│ rcd: Code[1000, anything]
//│    = [ 'Sel', [ 'Bra', [ 'Rcd', [Object] ] ], 'z' ]

run(rcd)
//│ res: 1000
//│    = 1000


// Let, Var, App -> evaluates to 3
let let_var = code"let y = 1; y + 1 * 2"
//│ let_var: Code[int, anything\y]
//│        = [
//│            'Let',
//│            'y',
//│            Symbol(y),
//│            [ '_', 1 ],
//│            [
//│              'App',
//│              '+',
//│              [ 'Var', Symbol(y) ],
//│              [ 'App', '*', [Array], [Array] ]
//│            ]
//│          ]

run(let_var)
//│ res: int
//│    = 3

// Fun, If
fun id(x) = x 
//│ id: 'a -> 'a
//│   = [Function: id]

let global_fun = code"id(4)"
//│ global_fun: Code[4, anything]
//│           = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'id' ] ], [ 'Tup', [ [Array] ] ] ]

run(global_fun)
//│ res: 4
//│    = 4

let local_fun = code"let plus1 = x => x + 1; plus1(if true then 1 else 2)"
//│ local_fun: Code[int, anything\plus1\x]
//│          = [
//│              'Let',
//│              'plus1',
//│              Symbol(plus1),
//│              [ '_', [Function (anonymous)] ],
//│              [ 'App_Fun', [ 'Var', Symbol(plus1) ], [ 'Tup', [Array] ] ]
//│            ]

run(local_fun)
//│ res: int
//│    = 2

// Lam
:js
code"x => x"
//│ // Query 1
//│ res = [
//│   "_",
//│   (x) => x
//│ ];
//│ // End of generated code
//│ res: Code['a -> 'a, anything\x]
//│    = [ '_', [Function (anonymous)] ]
run(res)(1)
//│ res: 1
//│    = 1

code"let id = x => x; id(3)"
//│ res: Code[3, anything\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
run(res)
//│ res: 3
//│    = 3


:e // context tracking
code"x => x + ${Const(1)}"
//│ res: Code[int -> int, nothing\x]
//│    = [ '_', [Function (anonymous)] ]

run(res)(3)
//│ res: int
//│    = 4

// Tup, Subs
let tup = code"let x = 1; let y = 2; (x, y)[0]"
//│ tup: Code[2 | undefined | 'a, {x: 'a & ~undefined}\x\y]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Subs', [Array], [Array] ] ]
//│      ]

run(tup)
//│ res: 2 | undefined
//│    = 1

// Quasiquote 
let code_in_code = code"let x = code"1"; x"
//│ code_in_code: Code[Code[1, anything], anything\x]
//│             = [ 'Let', 'x', Symbol(x), [ '_', [ '_', 1 ] ], [ 'Var', Symbol(x) ] ]

run(code_in_code)
//│ res: Code[1, anything]
//│    = [ '_', 1 ]

run(res)
//│ res: 1
//│    = 1

// Unquoted - Const function
:e // context tracking
let unquoted = code"let x = 3; ${Const(10)} * x"
//│ unquoted: Code[int, nothing\x]
//│         = [
//│             'Let',
//│             'x',
//│             Symbol(x),
//│             [ '_', 3 ],
//│             [ 'App', '*', [ 'Unquoted', [Array] ], [ 'Var', Symbol(x) ] ]
//│           ]
run(unquoted)
//│ res: int
//│    = 30

// No obvious test for DecLit 
// No obvious test for UnitLit
// Parsing error for StrLit 
:pe
let str_lit = code""hello""
//│ ╔══[PARSE ERROR] Unexpected closing quasiquote
//│ ║  l.167: 	let str_lit = code""hello""
//│ ╙──       	                         ^
//│ ╔══[PARSE ERROR] Unexpected closing quasiquote
//│ ║  l.167: 	let str_lit = code""hello""
//│ ╙──       	                          ^
//│ ╔══[PARSE ERROR] Unexpected end of quasiquote section; an expression was expected here
//│ ║  l.167: 	let str_lit = code""hello""
//│ ╙──       	                   ^
//│ ╔══[PARSE ERROR] Expected end of input; found identifier instead
//│ ║  l.167: 	let str_lit = code""hello""
//│ ╙──       	                    ^^^^^
//│ str_lit: Code[undefined, anything]
//│        = [ '_', undefined ]

// free variables 
let free = code"y"
//│ free: Code['a, {y: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'y' ] ]

// Unquote - variable name for quasiquote
let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: Code[int, {a: int, b: int}\a\b]
//│            = [
//│                'Let',
//│                'a',
//│                Symbol(a),
//│                [ '_', 1 ],
//│                [ 'Let', 'b', Symbol(b), [ '_', 2 ], [ 'Unquoted', [Array] ] ]
//│              ]

run(code_nested)
//│ res: int
//│    = 3

code"let id = x => ${code"x"}; id(3)"
//│ res: Code['a, {x: 'a}\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]

run(res)
//│ res: nothing
//│    = 3

let free = code"x"
//│ free: Code['a, {x: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'x' ] ]

:e // context tracking
code"let id = x => ${free}; id(3)"
run(res)
//│ res: Code['a, {x: 'a}\id\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
//│ res: nothing
//│    = 3

:e
let id_external = code"x => ${free}"
run(id_external)(10)
//│ id_external: Code[anything -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ res: nothing
//│    = 10


let id_internal = code"x => ${code"x"}"
run(id_internal)(10)
//│ id_internal: Code[anything -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ res: nothing
//│    = 10

let free_y = code"y"
//│ free_y: Code['a, {y: 'a}]
//│       = [ 'Var', [ 'FreeVar', 'y' ] ]

:e // context tracking
let use_free = code"let y = 3; ${code"let y = 5; ${free_y} + y"} + y"
//│ use_free: Code[int, {y: int}\y]
//│         = [
//│             'Let',
//│             'y',
//│             Symbol(y),
//│             [ '_', 3 ],
//│             [ 'App', '+', [ 'Unquoted', [Array] ], [ 'Var', Symbol(y) ] ]
//│           ]

run(use_free)
//│ res: int
//│    = 13

:e // context tracking
code"let z = x => ${let c = code"x + 1"; c}; z"
//│ res: Code[anything -> 'a, {x: 'a}\c\x\z]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'Var', Symbol(z) ]
//│      ]

run(res)(100)
//│ res: nothing
//│    = 101

:e // context tracking
code"x => y => 100 + ${  Const(x + y)   }"
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.286: 	code"x => y => 100 + ${  Const(x + y)   }"
//│ ╙──       	                               ^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.286: 	code"x => y => 100 + ${  Const(x + y)   }"
//│ ╙──       	                                   ^
//│ res: Code[anything -> anything -> int, nothing\x\y]
//│    = [ '_', [Function (anonymous)] ]

run(res)(1)(10)
//│ res: int
//│    = 111


// Testing error messages for unquotes -> is it ok that we handle Unquote directly in translateTerm?
let qq = code"x"
//│ qq: Code['a, {x: 'a}]
//│   = [ 'Var', [ 'FreeVar', 'x' ] ]

// 1. In general code - ERROR
:pe
let x = ${qq}
//│ ╔══[LEXICAL ERROR] unexpected character '$'
//│ ║  l.302: 	let x = ${qq}
//│ ╙──       	        ^
//│ ╔══[PARSE ERROR] Unexpected error in expression position
//│ ║  l.302: 	let x = ${qq}
//│ ╙──       	        ^
//│ x: {qq: Code['a, {x: 'a}]}
//│  = { qq: [ 'Var', [ 'FreeVar', 'x' ] ] }

// 2. In lambdas in general code - ERROR 
:pe
let x2 = x => ${qq}
//│ ╔══[LEXICAL ERROR] unexpected character '$'
//│ ║  l.314: 	let x2 = x => ${qq}
//│ ╙──       	              ^
//│ ╔══[PARSE ERROR] Unexpected error in expression position
//│ ║  l.314: 	let x2 = x => ${qq}
//│ ╙──       	              ^
//│ x2: anything -> {qq: Code['a, {x: 'a}]}
//│   = [Function: x2]

// 3. In quasiquotes - OK
:e // TODO - context-tracking
let x3 = code"${qq}"
//│ x3: Code['a, {x: 'a}]
//│   = [ 'Unquoted', [ 'Var', [ 'FreeVar', 'x' ] ] ]

// 4. In lambdas in quasiquotes - OK 
:e 
let x4 = code"x => ${qq}"
//│ x4: Code[anything -> 'a, {x: 'a}\x]
//│   = [ '_', [Function (anonymous)] ]

run(x4)(5)
//│ res: nothing
//│    = 5


let f = 0
//│ f: 0
//│  = 0

// Note the renaming of `f`, which means it won't be picked up by the QQ
:js
fun f(x) = x
//│ // Query 1
//│ globalThis.f1 = function f1(x) {
//│   return x;
//│ };
//│ // End of generated code
//│ f: 'a -> 'a
//│  = [Function: f1]

code"f(1)"
//│ res: Code[1, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'f' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: 1
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function


// See renaming
:js
class Foo(n)
//│ Defined class Foo
//│ // Prelude
//│ class Foo {
//│   constructor(fields) {
//│     this.n = fields.n;
//│   }
//│ }
//│ // Query 1
//│ globalThis.Foo1 = function Foo1(n) {
//│   return new Foo({ n: n });
//│ };
//│ // End of generated code
//│ Foo: 'n -> (Foo with {n: 'n})
//│    = [Function: Foo1]

code"Foo(1)"
//│ res: Code[Foo & {n: 1}, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'Foo' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: Foo & {n: 1}
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function


