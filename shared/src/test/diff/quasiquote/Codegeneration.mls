:NewParser

// basic test from meeting on Mar 10
let c = code"x"
//│ c: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]

let r = code"x => ${c}"
//│ r: Code['a -> 'a, {x: 'a}\x]
//│  = [ '_', [Function (anonymous)] ]

:e
run(r)(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	run(r)(1)
//│ ║        	^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 1 | error
//│    = 1


// Bra, Rcd, Sel 
let rcd = code"{x: 10, y: 100, z: 1000}.z"
//│ rcd: Code[1000, anything]
//│    = [ 'Sel', [ 'Bra', [ 'Rcd', [Object] ] ], 'z' ]

run(rcd)
//│ res: 1000
//│    = 1000


// Let, Var, App -> evaluates to 3
let let_var = code"let y = 1; y + 1 * 2"
//│ let_var: Code[int, anything]
//│        = [
//│            'Let',
//│            'y',
//│            Symbol(y),
//│            [ '_', 1 ],
//│            [
//│              'App',
//│              '+',
//│              [ 'Var', Symbol(y) ],
//│              [ 'App', '*', [Array], [Array] ]
//│            ]
//│          ]

run(let_var)
//│ res: int
//│    = 3

// Fun, If
fun id(x) = x 
//│ id: 'a -> 'a
//│   = [Function: id]

let global_fun = code"id(4)"
//│ global_fun: Code[4, anything]
//│           = [ 'App_Fun', [ 'Var', [Function: id] ], [ 'Tup', [ [Array] ] ] ]

run(global_fun)
//│ res: 4
//│    = 4

let local_fun = code"let plus1 = x => x + 1; plus1(if true then 1 else 2)"
//│ local_fun: Code[int, anything]
//│          = [
//│              'Let',
//│              'plus1',
//│              Symbol(plus1),
//│              [ '_', [Function (anonymous)] ],
//│              [ 'App_Fun', [ 'Var', Symbol(plus1) ], [ 'Tup', [Array] ] ]
//│            ]

run(local_fun)
//│ res: int
//│    = 2

// Lam
code"x => x"
//│ res: Code['a -> 'a, anything]
//│    = [ '_', [Function (anonymous)] ]
run(res)(1)
//│ res: 1
//│    = 1

code"let id = x => x; id(3)"
//│ res: Code[3, anything]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
run(res)
//│ res: 3
//│    = 3


code"x => x + ${Const(1)}"
//│ res: Code[int -> int, anything\x]
//│    = [ '_', [Function (anonymous)] ]

run(res)(3)
//│ res: int
//│    = 4

// Tup, Subs
let tup = code"let x = 1; let y = 2; (x, y)[0]"
//│ tup: Code[1 | 2 | undefined, anything]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Subs', [Array], [Array] ] ]
//│      ]

run(tup)
//│ res: 1 | 2 | undefined
//│    = 1

// Quasiquote 
let code_in_code = code"let x = code"1"; x"
//│ code_in_code: Code[Code[1, anything], anything]
//│             = [
//│                 'Let',
//│                 'x',
//│                 Symbol(x),
//│                 [ 'Quoted', [ '_', 1 ] ],
//│                 [ 'Var', Symbol(x) ]
//│               ]

run(code_in_code)
//│ res: Code[1, anything]
//│    = [ '_', 1 ]

run(res)
//│ res: 1
//│    = 1

// Unquoted - Const function
let unquoted = code"let x = 3; ${Const(10)} * x"
//│ unquoted: Code[int, anything\x]
//│         = [
//│             'Let',
//│             'x',
//│             Symbol(x),
//│             [ '_', 3 ],
//│             [ 'App', '*', [ 'Unquoted', [Array] ], [ 'Var', Symbol(x) ] ]
//│           ]
run(unquoted)
//│ res: int
//│    = 30

// No obvious test for DecLit 
// No obvious test for UnitLit
// Parsing error for StrLit 

let str_lit = code""" "hello" """
//│ str_lit: Code["hello", anything]
//│        = [ '_', 'hello' ]

// free variables
let free = code"y"
//│ free: Code['a, {y: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'y' ] ]

// Unquote - variable name for quasiquote
let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: Code[int, {a: int, b: int}\a\b]
//│            = [
//│                'Let',
//│                'a',
//│                Symbol(a),
//│                [ '_', 1 ],
//│                [ 'Let', 'b', Symbol(b), [ '_', 2 ], [ 'Unquoted', [Array] ] ]
//│              ]

:e
run(code_nested)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.182: 	run(code_nested)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` is not a record (expected a record with fields: a, b)
//│ res: error | int
//│    = 3

let y = code"x"
code"let id = x => ${y}; id(true)"
//│ y: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ res: Code[true | 'a, {x: 'a}\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.204: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error | true
//│    = true

let free = code"x"
//│ free: Code['a, {x: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'x' ] ]

:e
code"let id = x => ${free}; id(3)"
run(res)
//│ res: Code[3 | 'a, {x: 'a}\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.218: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 3 | error
//│    = 3

:e
let id_external = code"x => ${free}"
run(id_external)
//│ id_external: Code['a -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.338: 	run(id_external)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 'a -> 'a | error
//│    = [Function (anonymous)]

res(10)
//│ res: 10 | error
//│    = 10

:e
let id_internal = code"x => ${code"x"}"
run(id_internal)(10)
//│ id_internal: Code['a -> 'a, {x: 'a}\x]
//│            = [ '_', [Function (anonymous)] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.354: 	run(id_internal)(10)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 10 | error
//│    = 10

let free_y = code"y"
//│ free_y: Code['a, {y: 'a}]
//│       = [ 'Var', [ 'Var', [ 'FreeVar', 'x' ] ] ]

let use_free = code"let y = 3; ${code"let y = 5; ${code"let y = 100; ${free_y}"} + y"} + y"
//│ use_free: Code[int, {y: int}\y]
//│         = [
//│             'Let',
//│             'y',
//│             Symbol(y),
//│             [ '_', 3 ],
//│             [ 'App', '+', [ 'Unquoted', [Array] ], [ 'Var', Symbol(y) ] ]
//│           ]

:e
run(use_free)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.379: 	run(use_free)
//│ ║         	^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'y'
//│ res: error | int
//│    = NaN

code"let z = x => ${let c = code"x + 1"; c}; z"
//│ res: Code['a -> 'a, {x: 'a}\c\x]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ '_', [Function (anonymous)] ],
//│        [ 'Var', Symbol(z) ]
//│      ]

:e
run(res)(100)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.398: 	run(res)(100)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 100 | error
//│    = 101

code"x => y => Const(x + y)"
//│ res: Code[int -> int -> Code[int, anything], anything]
//│    = [ '_', [Function (anonymous)] ]

run(res)(1)(10)
//│ res: Code[int, anything]
//│    = [ '_', 11 ]

// Testing error messages for unquotes -> is it ok that we handle Unquote directly in translateTerm?
let qq = code"x"
//│ qq: Code['a, {x: 'a}]
//│   = [ 'Var', [ 'FreeVar', 'x' ] ]

// 1. In general code - ERROR
:e
:ge
let x = ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.422: 	let x = ${qq}
//│ ╙──       	          ^^
//│ x: error
//│ Code generation encountered an error:
//│   unquote must be in quasiquote

// 2. In lambdas in general code - ERROR 
:e
:ge
let x2 = x => ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.433: 	let x2 = x => ${qq}
//│ ╙──       	                ^^
//│ x2: anything -> error
//│ Code generation encountered an error:
//│   unquote must be in quasiquote

// 3. In quasiquotes - OK
let x3 = code"${qq}"
//│ x3: Code['a, {x: 'a}]
//│   = [ 'Unquoted', [ 'Var', [ 'FreeVar', 'x' ] ] ]

// 4. In lambdas in quasiquotes - OK 
let x4 = code"x => ${qq}"
//│ x4: Code['a -> 'a, {x: 'a}\x]
//│   = [ '_', [Function (anonymous)] ]

:e
run(x4)(5)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.452: 	run(x4)(5)
//│ ║         	^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 5 | error
//│    = 5


let f = 0
//│ f: 0
//│  = 0

// Note the renaming of `f`, which means it won't be picked up by the QQ
// This was solved by tracing all runtime symbols (including parent scopes) when allocating new ones
:js
fun f(x) = x
//│ // Query 1
//│ globalThis.f1 = function f1(x) {
//│   return x;
//│ };
//│ // End of generated code
//│ f: 'a -> 'a
//│  = [Function: f1]

code"f(1)"
//│ res: Code[1, anything]
//│    = [ 'App_Fun', [ 'Var', [Function: f1] ], [ 'Tup', [ [Array] ] ] ]

run(res)
//│ res: 1
//│    = 1


// See renaming
:js
class Foo(n)
//│ Defined class Foo
//│ // Prelude
//│ class Foo {
//│   constructor(fields) {
//│     this.n = fields.n;
//│   }
//│ }
//│ // Query 1
//│ globalThis.Foo1 = function Foo1(n) {
//│   return new Foo({ n: n });
//│ };
//│ // End of generated code
//│ Foo: 'n -> (Foo with {n: 'n})
//│    = [Function: Foo1]

code"Foo(1)"
//│ res: Code[Foo & {n: 1}, anything]
//│    = [ 'App_Fun', [ 'Var', [Function: Foo1] ], [ 'Tup', [ [Array] ] ] ]

run(res)
//│ res: Foo & {n: 1}
//│    = Foo { n: 1 }


let codeA = code"let y = 2; y"
let codeB = code"y + y"
//│ codeA: Code[2, anything]
//│      = [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│ codeB: Code[int, {y: int}]
//│      = [
//│          'App',
//│          '+',
//│          [ 'Var', [ 'Var', [Array] ] ],
//│          [ 'Var', [ 'Var', [Array] ] ]
//│        ]

// because of the parse error, codeB is not handled => typing and codegen runs, but obviously codeB is ignored in codegen
:pe
let both = code"${codeA}; ${codeB}"
//│ ╔══[PARSE ERROR] Unexpected ';' keyword here
//│ ║  l.527: 	let both = code"${codeA}; ${codeB}"
//│ ╙──       	                        ^
//│ both: Code[2, anything]
//│     = [
//│         'Unquoted',
//│         [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│       ]
run(both)
//│ res: 2
//│    = 2

code"x + (let x = 1; x)"
//│ res: Code[int, {x: int}]
//│    = [
//│        'App',
//│        '+',
//│        [ 'Var', [ 'FreeVar', 'x' ] ],
//│        [ 'Let', 'x', Symbol(x), [ '_', 1 ], [ 'Var', Symbol(x) ] ]
//│      ]

:e // BUG: quasiquote still has a free variable
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.550: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined

let a = code"let x = 0; x"
let b = code"x"
let c = code"${a} + ${b}"
//│ a: Code[0, anything]
//│  = [ 'Let', 'x', Symbol(x), [ '_', 0 ], [ 'Var', Symbol(x) ] ]
//│ b: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ c: Code[int, {x: int}]
//│  = [
//│      'App',
//│      '+',
//│      [ 'Unquoted', [ 'Let', 'x', Symbol(x), [Array], [Array] ] ],
//│      [ 'Unquoted', [ 'Var', [Array] ] ]
//│    ]

:e
run(c)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.575: 	run(c)
//│ ║         	^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined




let c = x => code"2 + ${code"x"}"
let res = c(2)
//│ c: anything -> Code[int, {x: int}]
//│  = [Function: c2]
//│ res: Code[int, {x: int}]
//│    = [ 'App', '+', [ '_', 2 ], [ 'Unquoted', [ 'Var', 2 ] ] ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.595: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│    = NaN
