:NewParser

let c = code"x"
//│ c: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]

:e
run(c)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.8: 	run(c)
//│ ║       	^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error
//│    = 'x'

let r = code"x => ${c}"
//│ r: Code['a -> 'a, {x: 'a}\x]
//│  = [ 'Lam', [ [ '_', 'x', 'x' ] ], [ 'Unquoted', [ 'Var', [Array] ] ] ]

:e
run(r)(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.21: 	run(r)(1)
//│ ║        	^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 1 | error
//│    = 1


// Bra, Rcd, Sel 
let rcd = code"{x: 10, y: 100, z: 1000}.z"
//│ rcd: Code[1000, anything]
//│    = [ 'Sel', [ 'Bra', [ 'Rcd', [Object] ] ], 'z' ]

run(rcd)
//│ res: 1000
//│    = 1000


// Let, Var, App -> evaluates to 3
let let_var = code"let y = 1; y + 1 * 2"
//│ let_var: Code[int, anything]
//│        = [
//│            'Let',
//│            'y',
//│            Symbol(y),
//│            [ '_', 1 ],
//│            [
//│              'App',
//│              '+',
//│              [ 'Var', Symbol(y) ],
//│              [ 'App', '*', [Array], [Array] ]
//│            ]
//│          ]

run(let_var)
//│ res: int
//│    = 3

// Fun, If
fun id(x) = x 
//│ id: 'a -> 'a
//│   = [Function: id]

let global_fun = code"id(4)"
//│ global_fun: Code[4, anything]
//│           = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'id' ] ], [ 'Tup', [ [Array] ] ] ]

run(global_fun)
//│ res: 4
//│    = 4

let local_fun = code"let plus1 = x => x + 1; plus1(if true then 1 else 2)"
//│ local_fun: Code[int, anything]
//│          = [
//│              'Let',
//│              'plus1',
//│              Symbol(plus1),
//│              [ 'Lam', [ [Array] ], [ 'App', '+', [Array], [Array] ] ],
//│              [ 'App_Fun', [ 'Var', Symbol(plus1) ], [ 'Tup', [Array] ] ]
//│            ]

run(local_fun)
//│ res: int
//│    = 2

// Lam
code"x => x"
//│ res: Code['a -> 'a, anything]
//│    = [ 'Lam', [ [ '_', 'x', 'x' ] ], [ 'Var', [ 'FreeVar', 'x' ] ] ]
run(res)(1)
//│ res: 1
//│    = 1

code"let id = x => x; id(3)"
//│ res: Code[3, anything]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ 'Lam', [ [Array] ], [ 'Var', [Array] ] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
run(res)
//│ res: 3
//│    = 3


code"x => x + ${Const(1)}"
//│ res: Code[int -> int, anything\x]
//│    = [
//│        'Lam',
//│        [ [ '_', 'x', 'x' ] ],
//│        [ 'App', '+', [ 'Var', [Array] ], [ 'Unquoted', [Array] ] ]
//│      ]

run(res)(3)
//│ res: int
//│    = 4

// Tup, Subs
let tup = code"let x = 1; let y = 2; (x, y)[0]"
//│ tup: Code[1 | 2 | undefined, anything]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 1 ],
//│        [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Subs', [Array], [Array] ] ]
//│      ]

run(tup)
//│ res: 1 | 2 | undefined
//│    = 1

// Quasiquote 
let code_in_code = code"let x = code"1"; x"
//│ code_in_code: Code[Code[1, anything], anything]
//│             = [
//│                 'Let',
//│                 'x',
//│                 Symbol(x),
//│                 [ 'Quoted', [ '_', 1 ] ],
//│                 [ 'Var', Symbol(x) ]
//│               ]

run(code_in_code)
//│ res: Code[1, anything]
//│    = [ '_', 1 ]

run(res)
//│ res: 1
//│    = 1

// Unquoted - Const function
let unquoted = code"let x = 3; ${Const(10)} * x"
//│ unquoted: Code[int, anything\x]
//│         = [
//│             'Let',
//│             'x',
//│             Symbol(x),
//│             [ '_', 3 ],
//│             [ 'App', '*', [ 'Unquoted', [Array] ], [ 'Var', Symbol(x) ] ]
//│           ]
run(unquoted)
//│ res: int
//│    = 30

// No obvious test for DecLit 
// No obvious test for UnitLit
// Parsing error for StrLit 

let str_lit = code""" "hello" """
//│ str_lit: Code["hello", anything]
//│        = [ '_', 'hello' ]

// free variables
let free = code"y"
//│ free: Code['a, {y: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'y' ] ]

// Unquote - variable name for quasiquote
let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: Code[int, {a: int, b: int}\a\b]
//│            = [
//│                'Let',
//│                'a',
//│                Symbol(a),
//│                [ '_', 1 ],
//│                [ 'Let', 'b', Symbol(b), [ '_', 2 ], [ 'Unquoted', [Array] ] ]
//│              ]

:e
run(code_nested)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.194: 	run(code_nested)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` is not a record (expected a record with fields: a, b)
//│ res: error | int
//│    = 3

let y = code"x"
code"let id = x => ${y}; id(true)"
//│ y: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ res: Code[true, {x: anything}\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ 'Lam', [ [Array] ], [ 'Unquoted', [Array] ] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.216: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error | true
//│    = true

let free = code"x"
//│ free: Code['a, {x: 'a}]
//│     = [ 'Var', [ 'FreeVar', 'x' ] ]

:e
code"let id = x => ${free}; id(3)"
run(res)
//│ res: Code[3, {x: anything}\x]
//│    = [
//│        'Let',
//│        'id',
//│        Symbol(id),
//│        [ 'Lam', [ [Array] ], [ 'Unquoted', [Array] ] ],
//│        [ 'App_Fun', [ 'Var', Symbol(id) ], [ 'Tup', [Array] ] ]
//│      ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.230: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 3 | error
//│    = 3

:e
let id_external = code"x => ${free}"
run(id_external)
//│ id_external: Code['a -> 'a, {x: 'a}\x]
//│            = [ 'Lam', [ [ '_', 'x', 'x' ] ], [ 'Unquoted', [ 'Var', [Array] ] ] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.248: 	run(id_external)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 'a -> 'a | error
//│    = [Function (anonymous)]

res(10)
//│ res: 10 | error
//│    = 10

:e
let id_internal = code"x => ${code"x"}"
run(id_internal)(10)
//│ id_internal: Code['a -> 'a, {x: 'a}\x]
//│            = [ 'Lam', [ [ '_', 'x', 'x' ] ], [ 'Unquoted', [ 'Var', [Array] ] ] ]
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.264: 	run(id_internal)(10)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 10 | error
//│    = 10

let free_y = code"y"
//│ free_y: Code['a, {y: 'a}]
//│       = [ 'Var', [ 'FreeVar', 'y' ] ]

let use_free = code"let y = 3; ${code"let y = 5; ${code"let y = 100; ${free_y}"} + y"} + y"
//│ use_free: Code[int, {y: int}\y]
//│         = [
//│             'Let',
//│             'y',
//│             Symbol(y),
//│             [ '_', 3 ],
//│             [ 'App', '+', [ 'Unquoted', [Array] ], [ 'Var', Symbol(y) ] ]
//│           ]

:e
run(use_free)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.289: 	run(use_free)
//│ ║         	^^^^^^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'y'
//│ res: error | int
//│    = 108

code"let z = x => ${let c = code"x + 1"; c}; z"
//│ res: Code['a -> 'a, {x: anything}\c\x]
//│    = [
//│        'Let',
//│        'z',
//│        Symbol(z),
//│        [ 'Lam', [ [Array] ], [ 'Unquoted', [Array] ] ],
//│        [ 'Var', Symbol(z) ]
//│      ]

:e
run(res)(100)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.308: 	run(res)(100)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 100 | error
//│    = 101

// Testing error messages for unquotes -> is it ok that we handle Unquote directly in translateTerm?
let qq = code"x"
//│ qq: Code['a, {x: 'a}]
//│   = [ 'Var', [ 'FreeVar', 'x' ] ]

// 1. In general code - ERROR
:e
:ge
let x = ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.324: 	let x = ${qq}
//│ ╙──       	          ^^
//│ x: error
//│ Code generation encountered an error:
//│   unquote must be in quasiquote

// 2. In lambdas in general code - ERROR 
:e
:ge
let x2 = x => ${qq}
//│ ╔══[ERROR] Unquotes should be enclosed with a quasiquote.
//│ ║  l.335: 	let x2 = x => ${qq}
//│ ╙──       	                ^^
//│ x2: anything -> error
//│ Code generation encountered an error:
//│   unquote must be in quasiquote

// 3. In quasiquotes - OK
let x3 = code"${qq}"
//│ x3: Code['a, {x: 'a}]
//│   = [ 'Unquoted', [ 'Var', [ 'FreeVar', 'x' ] ] ]

// 4. In lambdas in quasiquotes - OK 
let x4 = code"x => ${qq}"
//│ x4: Code['a -> 'a, {x: 'a}\x]
//│   = [ 'Lam', [ [ '_', 'x', 'x' ] ], [ 'Unquoted', [ 'Var', [Array] ] ] ]

:e
run(x4)(5)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.354: 	run(x4)(5)
//│ ║         	^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: 5 | error
//│    = 5


let f = 0
//│ f: 0
//│  = 0

// Note the renaming of `f`, which means it won't be picked up by the QQ
:js
fun f(x) = x
//│ // Query 1
//│ globalThis.f1 = function f1(x) {
//│   return x;
//│ };
//│ // End of generated code
//│ f: 'a -> 'a
//│  = [Function: f1]

code"f(1)"
//│ res: Code[1, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'f' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: 1
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function


// See renaming
:js
class Foo(n)
//│ Defined class Foo
//│ // Prelude
//│ class Foo {
//│   constructor(fields) {
//│     this.n = fields.n;
//│   }
//│ }
//│ // Query 1
//│ globalThis.Foo1 = function Foo1(n) {
//│   return new Foo({ n: n });
//│ };
//│ // End of generated code
//│ Foo: 'n -> (Foo with {n: 'n})
//│    = [Function: Foo1]

code"Foo(1)"
//│ res: Code[Foo & {n: 1}, anything]
//│    = [ 'App_Fun', [ 'Var', [ 'FreeVar', 'Foo' ] ], [ 'Tup', [ [Array] ] ] ]

:re
run(res)
//│ res: Foo & {n: 1}
//│ Runtime error:
//│   TypeError: globalThis[callee] is not a function


let codeA = code"let y = 2; y"
let codeB = code"y + y"
//│ codeA: Code[2, anything]
//│      = [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│ codeB: Code[int, {y: int}]
//│      = [
//│          'App',
//│          '+',
//│          [ 'Var', [ 'FreeVar', 'y' ] ],
//│          [ 'Var', [ 'FreeVar', 'y' ] ]
//│        ]

// because of the parse error, codeB is not handled => typing and codegen runs, but obviously codeB is ignored in codegen
:pe
let both = code"${codeA}; ${codeB}"
//│ ╔══[PARSE ERROR] Unexpected ';' keyword here
//│ ║  l.432: 	let both = code"${codeA}; ${codeB}"
//│ ╙──       	                        ^
//│ both: Code[2, anything]
//│     = [
//│         'Unquoted',
//│         [ 'Let', 'y', Symbol(y), [ '_', 2 ], [ 'Var', Symbol(y) ] ]
//│       ]
run(both)
//│ res: 2
//│    = 2

let a = code"let x = 0; x"
let b = code"x"
let c = code"${a} + ${b}"
//│ a: Code[0, anything]
//│  = [ 'Let', 'x', Symbol(x), [ '_', 0 ], [ 'Var', Symbol(x) ] ]
//│ b: Code['a, {x: 'a}]
//│  = [ 'Var', [ 'FreeVar', 'x' ] ]
//│ c: Code[int, {x: int}]
//│  = [
//│      'App',
//│      '+',
//│      [ 'Unquoted', [ 'Let', 'x', Symbol(x), [Array], [Array] ] ],
//│      [ 'Unquoted', [ 'Var', [Array] ] ]
//│    ]
:e
run(c)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.460: 	run(c)
//│ ║         	^^^^^^
//│ ╙── type `anything` does not have field 'x'
//│ res: error | int
//│ Runtime error:
//│   ReferenceError: x is not defined

code"{x: y} => y"
//│ res: Code[{x: 'a} -> 'a, anything]
//│    = [ 'Lam', [ { x: [Array] } ], [ 'Var', [ 'FreeVar', 'y1' ] ] ]

run(res)({x:1})
//│ res: 1
//│    = 1


fun pow(cde, n) = if n > 0 then code"${cde} * ${pow(cde, n - 1)}" else code"1"
//│ pow: (Code[int, 'a], int,) -> Code[int, 'a]
//│    = [Function: pow]

let p = pow(code"x", 3)
//│ p: Code[int, {x: int}]
//│  = [
//│      'App',
//│      '*',
//│      [ 'Unquoted', [ 'Var', [Array] ] ],
//│      [ 'Unquoted', [ 'App', '*', [Array], [Array] ] ]
//│    ]

code"let x = 3; ${p}"
//│ res: Code[int, {x: int}\x]
//│    = [
//│        'Let',
//│        'x',
//│        Symbol(x),
//│        [ '_', 3 ],
//│        [ 'Unquoted', [ 'App', '*', [Array], [Array] ] ]
//│      ]

:e
run(res)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.502: 	run(res)
//│ ║         	^^^^^^^^
//│ ╙── expression of type `anything` does not have field 'x'
//│ res: error | int
//│    = 27
