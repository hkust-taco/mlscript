:NewParser
:ge


code"let f = x => x; f(if true then 1 else 2)"
//│ res: code & {Code#C = anything, Code#T <: 1 | 2}
//│    = [
//│        'Let',
//│        Symbol(f),
//│        [ [Function (anonymous)] ],
//│        [ 'Fun', [ 'Var', Symbol(f) ], [ [Array] ] ]
//│      ]

run(res)
//│ res: 1 | 2
//│    = 1

let x = x => x
x(3)
//│ x: 'a -> 'a
//│  = [Function: x]
//│ res: 3
//│    = 3

// The JS for creating symbols should appear here:
:js
code"x => x + 1"
//│ // Query 1
//│ res = [(x) => x + 1];
//│ // End of generated code
//│ res: code & {Code#C = anything, Code#T <: int -> int}
//│    = [ [Function (anonymous)] ]

// Bad way: Source quote ->(codegen) JS to construct the S-Expr ->(node) JS objects ->(run(*)) JS-string ->(eval) result
// Good way: Source quote ->(codegen) JS to construct the S-Expr ->(node(*)) JS objects ->(run) result
// (*) : symbols created here

// To create symbols, logically do:
//    res = { const x = Symbol("x"); [ ... ] }
// Encoded in real JS:
//    (x => [ ... ])(Symbol("x"))


let x = code"3 + 2"
//│ x: code & {Code#C = anything, Code#T <: int}
//│  = [ 'App', '+', [ 3 ], [ 2 ] ]

run(x)
//│ res: int
//│    = 5

let y = code"1"
//│ y: code & {Code#C = anything, Code#T <: 1}
//│  = [ 1 ]

run(y)
//│ res: 1
//│    = 1


code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α67
//│ ║  l.61: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──      	                                            ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.61: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ║        	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?b.type63, Code#T <: ?a}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α70
//│ ║  l.61: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──      	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ res: code & {Code#C = anything, Code#T <: error}
//│ Code generation encountered an error:
//│   unresolved symbol a

let code_function = code"let x = (y, z) => y + z; x(3, 30)"
//│ code_function: code & {Code#C = anything, Code#T <: int}
//│              = [
//│                  'Let',
//│                  Symbol(x),
//│                  [ [Function (anonymous)] ],
//│                  [ 'Fun', [ 'Var', Symbol(x) ], [ [Array] ] ]
//│                ]

run(code_function)
//│ res: int
//│    = 33


// Unquote
fun test(n) = if n > 0 then code"1000" else code"1"
//│ test: number -> (code & {Code#C = anything, Code#T <: 1000 | 1})
//│     = [Function: test]
let code_unquote = code"let x = 1; x + ${test(3)}"
run(code_unquote)
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α98'
//│ ║  l.94: 	let code_unquote = code"let x = 1; x + ${test(3)}"
//│ ╙──      	                                         ^^^^^^^
//│ code_unquote: code & {Code#C = anything, Code#T <: int}
//│             = [
//│                 'Let',
//│                 Symbol(x),
//│                 [ 1 ],
//│                 [ 'App', '+', [ 'Var', Symbol(x) ], [ 1000 ] ]
//│               ]
//│ res: int
//│    = 1001

let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
//│            = [
//│                'Let',
//│                Symbol(a),
//│                [ 1 ],
//│                [ 'Let', Symbol(b), [ 2 ], [ 'App', '+', [Array], [Array] ] ]
//│              ]

run(code_nested)
//│ res: code & {Code#C = anything, Code#T <: int}
//│    = 3

