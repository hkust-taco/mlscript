:NewParser
:ge

let x = code"3 + 2"
//│ x: code & {Code#C = anything, Code#T <: int}
//│  = [ 'App', '+', [ 3 ], [ 2 ] ]

run(x)
//│ res: int
//│    = 5

let y = code"1"
//│ y: code & {Code#C = anything, Code#T <: 1}
//│  = [ 1 ]

run(y)
//│ res: 1
//│    = 1


code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α44
//│ ║  l.21: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──      	                                            ^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.21: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ║        	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── expression of type `code & {Code#C :> ?b.type40, Code#T <: ?a}` is not an instance of type `int`
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α47
//│ ║  l.21: 	code"let a = 1; let b = 2; ${a + code"b + ${a + b}" }"
//│ ╙──      	                             ^^^^^^^^^^^^^^^^^^^^^^
//│ res: code & {Code#C = anything, Code#T <: error}
//│ Code generation encountered an error:
//│   unresolved symbol a


let z1 = 100
//│ z1: 100
//│   = 100
let z2 = 1000
//│ z2: 1000
//│   = 1000

let code_unquote = code"let z1 = 1; z1 + ${code"z1 + z2"}"
//│ code_unquote: code & {Code#C = anything, Code#T <: int}
//│             = [
//│                 'Let',
//│                 'z1',
//│                 [ 1 ],
//│                 [ 'App', '+', [ 'Var', 'z1' ], [ 'App', '+', [Array], [Array] ] ]
//│               ]

run(code_unquote)
//│ res: int
//│    = 1002

let z3 = 2
let code_function = code"let y = 100; let x = (y) => y + y; x(3)"
//│ z3: 2
//│   = 2
//│ code_function: code & {Code#C = anything, Code#T <: int}
//│              = [
//│                  'Let',
//│                  'y',
//│                  [ 100 ],
//│                  [
//│                    'Let',
//│                    'x',
//│                    [ 'Lam', [Array], [Array] ],
//│                    [ 'Fun', [Array], [Array] ]
//│                  ]
//│                ]

run(code_function)
//│ res: int
//│    = 6


// Unquote
fun test(n) = if n > 0 then code"1000" else code"1"
//│ test: number -> (code & {Code#C = anything, Code#T <: 1000 | 1})
//│     = [Function: test]
let x = 1
let code_unquote = code"let x = 1; x + ${test(3)}"
run(code_unquote)
//│ x: 1
//│  = 1
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α83'
//│ ║  l.84: 	let code_unquote = code"let x = 1; x + ${test(3)}"
//│ ╙──      	                                         ^^^^^^^
//│ code_unquote: code & {Code#C = anything, Code#T <: int}
//│             = [ 'Let', 'x', [ 1 ], [ 'App', '+', [ 'Var', 'x' ], [ 1000 ] ] ]
//│ res: int
//│    = 1001

let x = 0
run(code_unquote)
//│ x: 0
//│  = 0
//│ res: int
//│    = 1001

// Free variable
let code_free = code"x_free + 1"
run(code_free)
//│ code_free: code & {Code#C = anything, Code#T <: int}
//│          = [ 'App', '+', [ 'Var', 'x_free' ], [ 1 ] ]
//│ res: int
//│ Runtime error:
//│   ReferenceError: x_free is not defined

let x_free = 100
run(code_free)
//│ x_free: 100
//│       = 100
//│ res: int
//│    = 101

let x_free = 1000
run(code_free)
//│ x_free: 1000
//│       = 1000
//│ res: int
//│    = 101

let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
//│            = [
//│                'Let',
//│                'a',
//│                [ 1 ],
//│                [ 'Let', 'b', [ 2 ], [ 'App', '+', [Array], [Array] ] ]
//│              ]

run(code_nested)
//│ res: code & {Code#C = anything, Code#T <: int}
//│    = 3
