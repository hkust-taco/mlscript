:NewParser
:ge


code"let f = x => x; f(if true then 1 else 2)"
//│ res: code & {Code#C = anything, Code#T <: 1 | 2}
//│    = [
//│        'Let',
//│        Symbol(f),
//│        [ [Function (anonymous)] ],
//│        [ 'Fun', [ 'Var', Symbol(f) ], [ [Array] ] ]
//│      ]

run(res)
//│ res: 1 | 2
//│    = 1

let x = x => x
x(3)
//│ x: 'a -> 'a
//│  = [Function: x]
//│ res: 3
//│    = 3

// The JS for creating symbols should appear here:
:js
code"x => x + 1"
//│ // Query 1
//│ res = [(x) => x + 1];
//│ // End of generated code
//│ res: code & {Code#C = anything, Code#T <: int -> int}
//│    = [ [Function (anonymous)] ]

// Bad way: Source quote ->(codegen) JS to construct the S-Expr ->(node) JS objects ->(run(*)) JS-string ->(eval) result
// Good way: Source quote ->(codegen) JS to construct the S-Expr ->(node(*)) JS objects ->(run) result
// (*) : symbols created here

// To create symbols, logically do:
//    res = { const x = Symbol("x"); [ ... ] }
// Encoded in real JS:
//    (x => [ ... ])(Symbol("x"))



let code_function = code"let x = (y, z) => y + z; x(3, 30)"
//│ code_function: code & {Code#C = anything, Code#T <: int}
//│              = [
//│                  'Let',
//│                  Symbol(x),
//│                  [ [Function (anonymous)] ],
//│                  [ 'Fun', [ 'Var', Symbol(x) ], [ [Array] ] ]
//│                ]

run(code_function)
//│ res: int
//│    = 33


// Unquote
fun test(n) = if n > 0 then code"1000" else code"1"
//│ test: number -> (code & {Code#C = anything, Code#T <: 1000 | 1})
//│     = [Function: test]
let code_unquote = code"let x = 1; x + ${test(3)}"
run(code_unquote)
//│ ╔══[ERROR] Type mismatch. Required: Code, found: α74'
//│ ║  l.63: 	let code_unquote = code"let x = 1; x + ${test(3)}"
//│ ╙──      	                                         ^^^^^^^
//│ code_unquote: code & {Code#C = anything, Code#T <: int}
//│             = [
//│                 'Let',
//│                 Symbol(x),
//│                 [ 1 ],
//│                 [ 'App', '+', [ 'Var', Symbol(x) ], [ 1000 ] ]
//│               ]
//│ res: int
//│    = 1001



let code_nested = code"let a = 1; let b = 2; ${code"a + b"}"
//│ code_nested: code & {Code#C = anything, Code#T <: code & {Code#C = anything, Code#T <: int}}
//│            = [
//│                'Let',
//│                Symbol(a),
//│                [ 1 ],
//│                [ 'Let', Symbol(b), [ 2 ], [ 'App', '+', [Array], [Array] ] ]
//│              ]

run(code_nested)
//│ res: code & {Code#C = anything, Code#T <: int}
//│    = 3

:js
code"let z = x => ${code"x + 1"}; z(3)"
//│ // Query 1
//│ res = ((z) => [
//│   "Let",
//│   z,
//│   [
//│     (x) => run([
//│       "App",
//│       "+",
//│       [
//│         "Var",
//│         x
//│       ],
//│       [1]
//│     ])
//│   ],
//│   [
//│     "Fun",
//│     [
//│       "Var",
//│       z
//│     ],
//│     [[3]]
//│   ]
//│ ])(Symbol('z'));
//│ // End of generated code
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.94: 	code"let z = x => ${code"x + 1"}; z(3)"
//│ ║        	                         ^^^
//│ ╟── function of type `?a -> ?a` is not an instance of type `int`
//│ ║  l.18: 	let x = x => x
//│ ║        	        ^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.94: 	code"let z = x => ${code"x + 1"}; z(3)"
//│ ╙──      	                         ^
//│ res: code & {Code#C = anything, Code#T <: error | int}
//│    = [
//│        'Let',
//│        Symbol(z),
//│        [ [Function (anonymous)] ],
//│        [ 'Fun', [ 'Var', Symbol(z) ], [ [Array] ] ]
//│      ]


run(res)
//│ res: error | int
//│    = 4

// BUG? 
//let fx = code"x_free + 1"
//code"let x_free = 3; ${fx}"


:js
code"let z = x => x + 1; z(3)"
//│ // Query 1
//│ res = ((z) => [
//│   "Let",
//│   z,
//│   [(x) => x + 1],
//│   [
//│     "Fun",
//│     [
//│       "Var",
//│       z
//│     ],
//│     [[3]]
//│   ]
//│ ])(Symbol('z'));
//│ // End of generated code
//│ res: code & {Code#C = anything, Code#T <: int}
//│    = [
//│        'Let',
//│        Symbol(z),
//│        [ [Function (anonymous)] ],
//│        [ 'Fun', [ 'Var', Symbol(z) ], [ [Array] ] ]
//│      ]

run(res)
//│ res: int
//│    = 4
