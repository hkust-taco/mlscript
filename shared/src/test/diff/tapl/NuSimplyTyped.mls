:NewParser
:NewDefs

let str = toString
fun concat2(a, b) = concat(a)(b)
fun concat3(a, b, c) = concat2(a, concat2(b, c))
fun concat4(a, b, c, d) = concat2(a, concat3(b, c, d))
fun concat5(a, b, c, d, e) = concat2(a, concat4(b, c, d, e))
fun concat6(a, b, c, d, e, f) = concat2(a, concat5(b, c, d, e, f))
fun concat7(a, b, c, d, e, f, g) = concat2(a, concat6(b, c, d, e, f, g))
fun concat8(a, b, c, d, e, f, g, h) = concat2(a, concat7(b, c, d, e, f, g, h))
fun par(a) = concat3("(", a, ")")
//│ let str: anything -> Str
//│ fun concat2: (Str, Str,) -> Str
//│ fun concat3: (Str, Str, Str,) -> Str
//│ fun concat4: (Str, Str, Str, Str,) -> Str
//│ fun concat5: (Str, Str, Str, Str, Str,) -> Str
//│ fun concat6: (Str, Str, Str, Str, Str, Str,) -> Str
//│ fun concat7: (Str, Str, Str, Str, Str, Str, Str,) -> Str
//│ fun concat8: (Str, Str, Str, Str, Str, Str, Str, Str,) -> Str
//│ fun par: Str -> Str
//│ str
//│     = [Function: toString]

type Option[A] = Some[A] | None
class Some[A](value: A)
module None
//│ type Option[A] = None | Some[A]
//│ class Some[A](value: A)
//│ module None

type Result[A, B] = Ok[A] | Err[B]
class Ok[A](value: A)
class Err[A](message: A)
//│ type Result[A, B] = Err[B] | Ok[A]
//│ class Ok[A](value: A)
//│ class Err[A](message: A)

type Type = FunctionType | PrimitiveType
class PrimitiveType(name: Str)
class FunctionType(lhs: Type, rhs: Type)
//│ type Type = FunctionType | PrimitiveType
//│ class PrimitiveType(name: Str)
//│ class FunctionType(lhs: Type, rhs: Type)

// Helpers.
fun _f(lhs, rhs) = FunctionType(lhs, rhs)
fun _t(name) = PrimitiveType(name)
//│ fun _f: (Type, Type,) -> FunctionType
//│ fun _t: Str -> PrimitiveType

type Term = Lit | Var | Abs | App
class Lit(tag: Str, ty: Type)
class Var(name: Str)
class Abs(lhs: Var, lty: Type, rhs: Term)
class App(lhs: Term, rhs: Term)
// class App(lhs: Term, rhs: Term): Term
//│ type Term = Abs | App | Lit | Var
//│ class Lit(tag: Str, ty: Type)
//│ class Var(name: Str)
//│ class Abs(lhs: Var, lty: Type, rhs: Term)
//│ class App(lhs: Term, rhs: Term)

type TreeMap[A] = Node[A] | Empty
class Node[A](key: Str, value: A, left: TreeMap[A], right: TreeMap[A])
module Empty
//│ type TreeMap[A] = Empty | Node[A]
//│ class Node[A](key: Str, value: A, left: TreeMap[A], right: TreeMap[A])
//│ module Empty

fun insert(t, k, v) =
  if t is
    Node(k', _, l, r) and
      slt(k)(k') then Node(k', v, insert(l, k, v), r)
      sgt(k)(k') then Node(k', v, l, insert(r, k, v))
      _ then Node(k, v, l, r)
    Empty then Node(k, v, Empty, Empty)
fun find(t, k) =
  if t is
    Node(k', v, l, r) and
      slt(k)(k') then find(l, k)
      sgt(k)(k') then find(r, k)
      _ then Some(v)
    Empty then None
//│ fun insert: forall 'A. (Empty | Node['A], Str, 'A,) -> Node['A]
//│ fun find: forall 'A0. (Empty | Node['A0], Str,) -> (None | Some['A0])

fun showType(ty) =
  if ty is
    FunctionType(PrimitiveType(name), rhs) then concat3(name, " -> ", showType(rhs))
    FunctionType(lhs, rhs) then concat4("(", showType(lhs), ") -> ", showType(rhs))
    PrimitiveType(name) then name
//│ fun showType: (FunctionType | PrimitiveType) -> Str

showType(_t("int"))
showType(_f(_t("int"), _t("bool")))
showType(_f(_f(_t("int"), _t("bool")), _t("bool")))
showType(_f(_t("bool"), _f(_t("int"), _t("bool"))))
//│ Str
//│ res
//│     = 'int'
//│ res
//│     = 'int -> bool'
//│ res
//│     = '(int -> bool) -> bool'
//│ res
//│     = 'bool -> int -> bool'

fun typeEqual(t1, t2) =
  if
    t1 is PrimitiveType(name1) and t2 is PrimitiveType(name2) then eq(name1)(name2)
    t1 is FunctionType(lhs1, rhs1) and t2 is FunctionType(lhs2, rhs2) then
      typeEqual(lhs1, lhs2) and typeEqual(rhs1, rhs2)
    _ then false
//│ fun typeEqual: (Object, Object,) -> Bool

fun showTerm(t) =
  if t is
    Lit(tag, _) then toString(tag)
    Var(name) then toString(name)
    Abs(lhs, ty, rhs) then concat6("&", showTerm(lhs), ": ", showType(ty), " => ", showTerm(rhs))
    App(Abs(lhs0, ty, lhs1), rhs) then
      concat5("((", showTerm(Abs(lhs0, ty, rhs)), ") ", showTerm(rhs), ")")
    App(lhs, rhs) then par(concat3(showTerm(lhs), " ", showTerm(rhs)))
//│ fun showTerm: (Abs | App | Lit | Var) -> Str

showTerm(Var("x"))
showTerm(Abs(Var("x"), _t("int"), Var("y")))
showTerm(App(Var("x"), Var("y")))
showTerm(App(Abs(Var("x"), _t("int"), Var("y")), Var("z")))
//│ Str
//│ res
//│     = 'x'
//│ res
//│     = '&x: int => y'
//│ res
//│     = '(x y)'
//│ res
//│     = '((&x: int => z) z)'

// Removing the return type annotation causes stack overflow.
fun typeTerm(t: Term, ctx: TreeMap[Type]): Result[Type, Str] =
  if t is
    Lit(_, ty) then Ok(ty)
    Var(name) and find(ctx, name) is
      Some(ty) then Ok(ty)
      None then Err(concat3("unbound variable `", name, "`"))
    Abs(Var(name), ty, body) and typeTerm(body, insert(ctx, name, ty)) is
      Ok(resTy) then Ok(FunctionType(ty, resTy))
      Err(message) then Err(message)
    App(lhs, rhs) and typeTerm(lhs, ctx) is
      Ok(FunctionType(pTy, resTy)) and typeTerm(rhs, ctx) is
        Ok(aTy) and
          typeEqual(pTy, aTy) then Ok(resTy)
          else Err(concat5("expect the argument to be of type `", showType(pTy), "` but found `", showType(aTy), "`"))
        Err(message) then Err(message)
      Ok(PrimitiveType(name)) then Err(concat3("cannot apply primitive type `", name, "`"))
      Err(message) then Err(message)
//│ fun typeTerm: (t: Term, ctx: TreeMap[Type],) -> Result[Type, Str]

fun showTypeTerm(t, ctx) =
  if typeTerm(t, ctx) is
    Ok(ty) then concat3(showTerm(t), " : ", showType(ty))
    Err(message) then concat2("Type error: ", message)
//│ fun showTypeTerm: (Term, TreeMap[Type],) -> Str

showTypeTerm(Var("x"), Empty)
showTypeTerm(Abs(Var("x"), _t("int"), Var("x")), Empty)
showTypeTerm(App(Var("f"), Lit("0", _t("int"))), insert(Empty, "f", _f(_t("int"), _t("int"))))
showTypeTerm(App(Var("f"), Lit("0.2", _t("float"))), insert(Empty, "f", _f(_t("int"), _t("int"))))
showTypeTerm(App(Var("f"), Lit("0", _t("int"))), insert(Empty, "f", _t("Str")))
//│ Str
//│ res
//│     = 'Type error: unbound variable `x`'
//│ res
//│     = '&x: int => x : int -> int'
//│ res
//│     = '(f 0) : int'
//│ res
//│     = 'Type error: expect the argument to be of type `int` but found `float`'
//│ res
//│     = 'Type error: cannot apply primitive type `Str`'
