:NewParser
:NewDefs

fun concat2(a, b) = concat(a)(b)
fun concat3(a, b, c) = concat2(a, concat2(b, c))
fun concat4(a, b, c, d) = concat2(a, concat3(b, c, d))
fun concat5(a, b, c, d, e) = concat2(a, concat4(b, c, d, e))
fun concat6(a, b, c, d, e, f) = concat2(a, concat5(b, c, d, e, f))
fun concat7(a, b, c, d, e, f, g) = concat2(a, concat6(b, c, d, e, f, g))
fun concat8(a, b, c, d, e, f, g, h) = concat2(a, concat7(b, c, d, e, f, g, h))
fun par(a) = concat3("(", a, ")")
//│ fun concat2: (#Str, #Str,) -> #Str
//│ fun concat3: (#Str, #Str, #Str,) -> #Str
//│ fun concat4: (#Str, #Str, #Str, #Str,) -> #Str
//│ fun concat5: (#Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat6: (#Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat7: (#Str, #Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat8: (#Str, #Str, #Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun par: #Str -> #Str

:escape
let String: nothing
let makeString: anything => { length: int, charCodeAt: int => int } = String
let StringInstance: { fromCharCode: int => string } = String
//│ let String: nothing
//│ let makeString: anything -> {charCodeAt: int -> int, length: int}
//│ let StringInstance: {fromCharCode: int -> string}
//│ String
//│        = <missing implementation>
//│ makeString
//│            = [Function: String]
//│ StringInstance
//│                = [Function: String]


let anythingToString = toString
fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
fun stringCharCodeAt(s: string, i) = makeString(s).charCodeAt(i)
fun stringLength(s: string) = makeString(s).length
//│ let anythingToString: anything -> #Str
//│ fun fromCharCode: (n: int,) -> string
//│ fun stringCharCodeAt: (s: string, int,) -> int
//│ fun stringLength: (s: string,) -> int
//│ anythingToString
//│                  = [Function: toString]

type Option[A] = Some[A] | None
class Some[A](value: A) {
  fun toString() = concat3("Some(", anythingToString(value), ")")
}
module None {
  fun toString() = "None"
}
//│ type Option[A] = Some[A] | None
//│ class Some[A](value: A) {
//│   fun toString: () -> #Str
//│ }
//│ module None {
//│   fun toString: () -> "None"
//│ }

type List[A] = Cons[A] | Nil
class Cons[A](head: A, tail: List[A])
module Nil
//│ type List[A] = Cons[A] | Nil
//│ class Cons[A](head: A, tail: List[A])
//│ module Nil

fun list1(x) = Cons(x, Nil)
fun list2(x, y) = Cons(x, list1(y))
fun list3(x, y, z) = Cons(x, list2(y, z))
fun list4(x, y, z, w) = Cons(x, list3(y, z, w))
fun list5(x, y, z, w, v) = Cons(x, list4(y, z, w, v))
fun list6(x, y, z, w, v, u) = Cons(x, list5(y, z, w, v, u))
fun list7(x, y, z, w, v, u, t) = Cons(x, list6(y, z, w, v, u, t))
fun list8(x, y, z, w, v, u, t, s) = Cons(x, list7(y, z, w, v, u, t, s))
//│ fun list1: forall 'A. 'A -> Cons['A]
//│ fun list2: forall 'A. ('A, 'A,) -> Cons['A]
//│ fun list3: forall 'A. ('A, 'A, 'A,) -> Cons['A]
//│ fun list4: forall 'A. ('A, 'A, 'A, 'A,) -> Cons['A]
//│ fun list5: forall 'A. ('A, 'A, 'A, 'A, 'A,) -> Cons['A]
//│ fun list6: forall 'A. ('A, 'A, 'A, 'A, 'A, 'A,) -> Cons['A]
//│ fun list7: forall 'A. ('A, 'A, 'A, 'A, 'A, 'A, 'A,) -> Cons['A]
//│ fun list8: forall 'A. ('A, 'A, 'A, 'A, 'A, 'A, 'A, 'A,) -> Cons['A]

fun findFirst(list, p) =
  if list is
    Nil then None
    Cons(x, xs) and
      p(x) then Some(x)
      else findFirst(xs, p)
//│ fun findFirst: forall 'A. (Cons['A] | Nil, 'A -> #Object,) -> (None | Some['A])

fun listConcat(xs, ys) =
  if xs is
    Nil then ys
    Cons(x, xs') then Cons(x, listConcat(xs', ys))
//│ fun listConcat: forall 'A 'A0 'a. (Cons['A] | Nil, List['A0] & 'a,) -> (Cons['A0] | 'a)
//│   where
//│     'A <: 'A0

fun listContains(xs, x) =
  if xs is
    Nil then false
    Cons(x', xs') and
      eq(x)(x') then true
      _ then listContains(xs', x)
//│ fun listContains: forall 'A. (Cons['A] | Nil, anything,) -> (False | True)

// Remove all occurrences of x from xs.
fun listWithout(xs, x) =
  if xs is
    Nil then Nil
    Cons(x', xs') and
      eq(x)(x') then listWithout(xs', x)
      _ then Cons(x', listWithout(xs', x))
//│ fun listWithout: forall 'A 'A0. (Cons['A] | Nil, anything,) -> (Cons['A0] | Nil)
//│   where
//│     'A <: 'A0

// fix this:
// fun listJoin(xs, sep) =
//   if xs is
//     Nil then ""
//     Cons(x, Nil) then toString(x)
//     Cons(x, xs') then concat3(toString(x), sep, listJoin(xs', sep))
fun listJoin(xs, sep) =
  if xs is
    Nil then ""
    Cons(x, xs') and xs' is
      Nil then toString(x)
      _ then concat3(toString(x), sep, listJoin(xs', sep))
//│ fun listJoin: forall 'A. (Cons['A] | Nil, #Str,) -> #Str

listJoin(list3("x", "y", "z"), ", ")
//│ #Str
//│ res
//│     = 'x, y, z'

type Term = Var | Abs | App
class Var(name: string)
class Abs(lhs: Var, rhs: Term)
class App(lhs: Term, rhs: Term)
//│ type Term = Abs | App | Var
//│ class Var(name: string)
//│ class Abs(lhs: Var, rhs: Term)
//│ class App(lhs: Term, rhs: Term)

fun showTerm(t) =
  if t is
    Var(name) then toString(name)
    Abs(lhs, rhs) then concat4("&", showTerm(lhs), ". ", showTerm(rhs))
    App(Abs(lhs0, lhs1), rhs) then
      concat8("((", "&", showTerm(lhs0), ". ", showTerm(lhs1), ") ", showTerm(rhs), ")")
    App(lhs, rhs) then par(concat3(showTerm(lhs), " ", showTerm(rhs)))
//│ fun showTerm: (Abs | App | Var) -> #Str

showTerm(Var("x"))
showTerm(Abs(Var("x"), Var("y")))
showTerm(App(Var("x"), Var("y")))
showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.158: 	showTerm(Var("x"))
//│ ║         	         ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.158: 	showTerm(Var("x"))
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	showTerm(Abs(Var("x"), Var("y")))
//│ ║         	             ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.159: 	showTerm(Abs(Var("x"), Var("y")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.159: 	showTerm(Abs(Var("x"), Var("y")))
//│ ║         	                       ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.159: 	showTerm(Abs(Var("x"), Var("y")))
//│ ║         	                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.160: 	showTerm(App(Var("x"), Var("y")))
//│ ║         	             ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.160: 	showTerm(App(Var("x"), Var("y")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.160: 	showTerm(App(Var("x"), Var("y")))
//│ ║         	                       ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.160: 	showTerm(App(Var("x"), Var("y")))
//│ ║         	                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                 ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                     ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                           ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                                      ^^^^^^^^
//│ ╟── string literal of type `"z"` is not an instance of type `string`
//│ ║  l.161: 	showTerm(App(Abs(Var("x"), Var("y")), Var("z")))
//│ ║         	                                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ #Str
//│ res
//│     = 'x'
//│ res
//│     = '&x. y'
//│ res
//│     = '(x y)'
//│ res
//│     = '((&x. y) z)'

fun isValue(t) =
  if t is
    Var then true
    Abs then true
    App then false
//│ fun isValue: (Abs | App | Var) -> (False | True)

isValue(Var("x"))
isValue(Abs(Var("x"), Var("y")))
isValue(App(Var("x"), Var("y")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.251: 	isValue(Var("x"))
//│ ║         	        ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.251: 	isValue(Var("x"))
//│ ║         	            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.252: 	isValue(Abs(Var("x"), Var("y")))
//│ ║         	            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.252: 	isValue(Abs(Var("x"), Var("y")))
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.252: 	isValue(Abs(Var("x"), Var("y")))
//│ ║         	                      ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.252: 	isValue(Abs(Var("x"), Var("y")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.253: 	isValue(App(Var("x"), Var("y")))
//│ ║         	            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.253: 	isValue(App(Var("x"), Var("y")))
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.253: 	isValue(App(Var("x"), Var("y")))
//│ ║         	                      ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.253: 	isValue(App(Var("x"), Var("y")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ False | True
//│ res
//│     = true
//│ res
//│     = true
//│ res
//│     = false

fun hasFree(t, n) =
  if t is
    // let __ = debug(concat3(showTerm(t), ", ", n))
    Var(na) then eq(n)(na)
    Abs(Var(name), body) and eq(name)(n) then false
    Abs(Var(name), body) then hasFree(body, n)
    App(lhs, rhs) then hasFree(lhs, n) || hasFree(rhs, n)
    _ then false
//│ fun hasFree: (#Object, anything,) -> Bool

fun showHasFree(t, n) =
  concat4(showTerm(t), if hasFree(t, n) then " has " else " DOES NOT have ", "free variable ", n)
//│ fun showHasFree: (Abs | App | Var, #Str,) -> #Str

showHasFree(Var("x"), "x")
showHasFree(Var("x"), "y")
showHasFree(Abs(Var("x"), Var("x")), "x")
showHasFree(Abs(Var("x"), Var("x")), "y")
showHasFree(Abs(Var("x"), Var("y")), "x")
showHasFree(Abs(Var("x"), Var("y")), "y")
showHasFree(App(Var("x"), Var("y")), "x")
showHasFree(App(Var("x"), Var("y")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.321: 	showHasFree(Var("x"), "x")
//│ ║         	            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.321: 	showHasFree(Var("x"), "x")
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.322: 	showHasFree(Var("x"), "y")
//│ ║         	            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.322: 	showHasFree(Var("x"), "y")
//│ ║         	                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.323: 	showHasFree(Abs(Var("x"), Var("x")), "x")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.323: 	showHasFree(Abs(Var("x"), Var("x")), "x")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.323: 	showHasFree(Abs(Var("x"), Var("x")), "x")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.323: 	showHasFree(Abs(Var("x"), Var("x")), "x")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.324: 	showHasFree(Abs(Var("x"), Var("x")), "y")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.324: 	showHasFree(Abs(Var("x"), Var("x")), "y")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.324: 	showHasFree(Abs(Var("x"), Var("x")), "y")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.324: 	showHasFree(Abs(Var("x"), Var("x")), "y")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.325: 	showHasFree(Abs(Var("x"), Var("y")), "x")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.325: 	showHasFree(Abs(Var("x"), Var("y")), "x")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.325: 	showHasFree(Abs(Var("x"), Var("y")), "x")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.325: 	showHasFree(Abs(Var("x"), Var("y")), "x")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.326: 	showHasFree(Abs(Var("x"), Var("y")), "y")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.326: 	showHasFree(Abs(Var("x"), Var("y")), "y")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.326: 	showHasFree(Abs(Var("x"), Var("y")), "y")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.326: 	showHasFree(Abs(Var("x"), Var("y")), "y")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.327: 	showHasFree(App(Var("x"), Var("y")), "x")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.327: 	showHasFree(App(Var("x"), Var("y")), "x")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.327: 	showHasFree(App(Var("x"), Var("y")), "x")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.327: 	showHasFree(App(Var("x"), Var("y")), "x")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.328: 	showHasFree(App(Var("x"), Var("y")), "y")
//│ ║         	                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.328: 	showHasFree(App(Var("x"), Var("y")), "y")
//│ ║         	                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.328: 	showHasFree(App(Var("x"), Var("y")), "y")
//│ ║         	                          ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.328: 	showHasFree(App(Var("x"), Var("y")), "y")
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                                         ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.329: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "x")
//│ ║         	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                         ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.330: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                                         ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.331: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("y")), "y")
//│ ║         	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                         ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.332: 	showHasFree(App(Abs(Var("x"), Var("x")), Var("x")), "y")
//│ ║         	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ #Str
//│ res
//│     = 'x has free variable x'
//│ res
//│     = 'x DOES NOT have free variable y'
//│ res
//│     = '&x. x DOES NOT have free variable x'
//│ res
//│     = '&x. x DOES NOT have free variable y'
//│ res
//│     = '&x. y DOES NOT have free variable x'
//│ res
//│     = '&x. y has free variable y'
//│ res
//│     = '(x y) has free variable x'
//│ res
//│     = '(x y) has free variable y'
//│ res
//│     = '((&x. x) x) has free variable x'
//│ res
//│     = '((&x. x) x) DOES NOT have free variable y'
//│ res
//│     = '((&x. x) y) has free variable y'
//│ res
//│     = '((&x. x) x) DOES NOT have free variable y'

fun fv(t) =
  if t is
    Var(name) then list1(name)
    Abs(Var(name), body) then listWithout(fv(body), name)
    App(lhs, rhs) then listConcat(fv(lhs), fv(rhs))
//│ fun fv: forall 'A. (Abs | App | Var) -> (Cons['A] | Nil)
//│   where
//│     'A :> string

fun showFv(t) =
  concat2(showTerm(t), if fv(t) is
    Nil then " DOES NOT have free variables"
    _ then concat2(" has free variables: ", listJoin(fv(t), ", "))
  )
//│ fun showFv: (Abs | App | Var) -> #Str

showFv(Var("x"))
showFv(Abs(Var("x"), Var("x")))
showFv(Abs(Var("x"), Var("y")))
showFv(App(Var("x"), Var("y")))
showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.609: 	showFv(Var("x"))
//│ ║         	       ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.609: 	showFv(Var("x"))
//│ ║         	           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.610: 	showFv(Abs(Var("x"), Var("x")))
//│ ║         	           ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.610: 	showFv(Abs(Var("x"), Var("x")))
//│ ║         	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.610: 	showFv(Abs(Var("x"), Var("x")))
//│ ║         	                     ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.610: 	showFv(Abs(Var("x"), Var("x")))
//│ ║         	                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.611: 	showFv(Abs(Var("x"), Var("y")))
//│ ║         	           ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.611: 	showFv(Abs(Var("x"), Var("y")))
//│ ║         	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.611: 	showFv(Abs(Var("x"), Var("y")))
//│ ║         	                     ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.611: 	showFv(Abs(Var("x"), Var("y")))
//│ ║         	                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.612: 	showFv(App(Var("x"), Var("y")))
//│ ║         	           ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.612: 	showFv(App(Var("x"), Var("y")))
//│ ║         	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.612: 	showFv(App(Var("x"), Var("y")))
//│ ║         	                     ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.612: 	showFv(App(Var("x"), Var("y")))
//│ ║         	                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	               ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	                         ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	                                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.613: 	showFv(App(Abs(Var("x"), Var("x")), Var("x")))
//│ ║         	                                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ #Str
//│ res
//│     = 'x has free variables: x'
//│ res
//│     = '&x. x DOES NOT have free variables'
//│ res
//│     = '&x. y has free variables: y'
//│ res
//│     = '(x y) has free variables: x, y'
//│ res
//│     = '((&x. x) x) has free variables: x'

fun tryNextAlphabet(initialCode, currentCode, freeNames) =
  if
    currentCode
      > 122 then tryNextAlphabet(initialCode, 97, freeNames)
      == initialCode then None
    let name = fromCharCode(currentCode)
    listContains(freeNames, name) then tryNextAlphabet(initialCode, currentCode + 1, freeNames)
    _ then Some(name)
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.716: 	fun tryNextAlphabet(initialCode, currentCode, freeNames) =
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.717: 	  if
//│ ║         	^^^^^
//│ ║  l.718: 	    currentCode
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.719: 	      > 122 then tryNextAlphabet(initialCode, 97, freeNames)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.720: 	      == initialCode then None
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.722: 	    listContains(freeNames, name) then tryNextAlphabet(initialCode, currentCode + 1, freeNames)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.723: 	    _ then Some(name)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.722: 	    listContains(freeNames, name) then tryNextAlphabet(initialCode, currentCode + 1, freeNames)
//│ ║         	                                                                    ^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ fun tryNextAlphabet: forall 'A. (#Num, nothing, Cons['A] | Nil,) -> (None | Some[string])

toString(tryNextAlphabet(97, 97, list1("a")))
toString(tryNextAlphabet(97, 98, list1("a")))
toString(tryNextAlphabet(97, 98, list2("a", "b")))
toString(tryNextAlphabet(121, 122, list1("y")))
toString(tryNextAlphabet(121, 122, list2("y", "z")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.752: 	toString(tryNextAlphabet(97, 97, list1("a")))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `97` is not an instance of type `int`
//│ ║  l.752: 	toString(tryNextAlphabet(97, 97, list1("a")))
//│ ║         	                             ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.753: 	toString(tryNextAlphabet(97, 98, list1("a")))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `98` is not an instance of type `int`
//│ ║  l.753: 	toString(tryNextAlphabet(97, 98, list1("a")))
//│ ║         	                             ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.754: 	toString(tryNextAlphabet(97, 98, list2("a", "b")))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `98` is not an instance of type `int`
//│ ║  l.754: 	toString(tryNextAlphabet(97, 98, list2("a", "b")))
//│ ║         	                             ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.755: 	toString(tryNextAlphabet(121, 122, list1("y")))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `122` is not an instance of type `int`
//│ ║  l.755: 	toString(tryNextAlphabet(121, 122, list1("y")))
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.756: 	toString(tryNextAlphabet(121, 122, list2("y", "z")))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `122` is not an instance of type `int`
//│ ║  l.756: 	toString(tryNextAlphabet(121, 122, list2("y", "z")))
//│ ║         	                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.37: 	fun fromCharCode(n: int) = StringInstance.fromCharCode(n)
//│ ║        	                    ^^^
//│ ╟── from reference:
//│ ║  l.721: 	    let name = fromCharCode(currentCode)
//│ ╙──       	                            ^^^^^^^^^^^
//│ #Str
//│ res
//│     = 'None'
//│ res
//│     = 'Some(b)'
//│ res
//│     = 'Some(c)'
//│ res
//│     = 'Some(z)'
//│ res
//│     = 'Some(a)'

fun tryAppendDigits(name, index, freeNames) =
  if
    let currentName = concat2(name, toString(index))
    listContains(freeNames, currentName) then
      tryAppendDigits(name, index + 1, freeNames)
    _ then currentName
//│ fun tryAppendDigits: forall 'A. (#Str, Int, Cons['A] | Nil,) -> #Str

// Note: some weird behavior here... Just try the commented code.
fun findFreshName(name, freeNames) =
  if
    stringLength(name) == 1 and
      let charCode = stringCharCodeAt(name, 0)
      tryNextAlphabet(charCode, charCode + 1, freeNames) is
        Some(newName) then newName
    _ then tryAppendDigits(name, 0, freeNames)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.840: 	    stringLength(name) == 1 and
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.23: 	let makeString: anything => { length: int, charCodeAt: int => int } = String
//│ ║        	                                      ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.840: 	    stringLength(name) == 1 and
//│ ╙──       	    ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.841: 	      let charCode = stringCharCodeAt(name, 0)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.841: 	      let charCode = stringCharCodeAt(name, 0)
//│ ║         	                                            ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.23: 	let makeString: anything => { length: int, charCodeAt: int => int } = String
//│ ║        	                                                       ^^^
//│ ╟── from reference:
//│ ║  l.38: 	fun stringCharCodeAt(s: string, i) = makeString(s).charCodeAt(i)
//│ ╙──      	                                                              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.842: 	      tryNextAlphabet(charCode, charCode + 1, freeNames) is
//│ ║         	                                ^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.23: 	let makeString: anything => { length: int, charCodeAt: int => int } = String
//│ ║        	                                                              ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.842: 	      tryNextAlphabet(charCode, charCode + 1, freeNames) is
//│ ╙──       	                                ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.842: 	      tryNextAlphabet(charCode, charCode + 1, freeNames) is
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.23: 	let makeString: anything => { length: int, charCodeAt: int => int } = String
//│ ║        	                                                              ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.842: 	      tryNextAlphabet(charCode, charCode + 1, freeNames) is
//│ ║         	                      ^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.720: 	      == initialCode then None
//│ ╙──       	         ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.841: 	      let charCode = stringCharCodeAt(name, 0)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.841: 	      let charCode = stringCharCodeAt(name, 0)
//│ ║         	                                            ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.23: 	let makeString: anything => { length: int, charCodeAt: int => int } = String
//│ ║        	                                                       ^^^
//│ ╟── from reference:
//│ ║  l.38: 	fun stringCharCodeAt(s: string, i) = makeString(s).charCodeAt(i)
//│ ╙──      	                                                              ^
//│ fun findFreshName: forall 'A 'A0 'A1. (nothing, Cons[in 'A | 'A0 | 'A1 out 'A & 'A0 & 'A1] | Nil,) -> (#Str | string)

// Find a fresh name to replace `name` that does not conflict with any bound
// variables in the `body`.
fun freshName(name, body) = findFreshName(name, fv(body))
//│ fun freshName: (nothing, Abs | App | Var,) -> (#Str | string)

fun subst(t, n, v) =
  if t is
    Var(name) and eq(name)(n) then v
    Abs(Var(name), body) and ne(name)(n) and
      hasFree(v, name) and freshName(name, body) is newName then
        subst(Abs(Var(newName), subst(body, name, Var(newName))), n, v)
      _ then Abs(Var(name), subst(body, n, v))
    App(lhs, rhs) then App(subst(lhs, n, v), subst(rhs, n, v))
    _ then t
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.910: 	      hasFree(v, name) and freshName(name, body) is newName then
//│ ║         	                           ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.141: 	class Var(name: string)
//│ ║         	                ^^^^^^
//│ ╟── but it flows into reference with expected type `#Str`
//│ ║  l.910: 	      hasFree(v, name) and freshName(name, body) is newName then
//│ ║         	                                     ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.4: 	fun concat2(a, b) = concat(a)(b)
//│ ║       	                           ^
//│ ╟── from reference:
//│ ║  l.903: 	fun freshName(name, body) = findFreshName(name, fv(body))
//│ ╙──       	                                          ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.911: 	        subst(Abs(Var(newName), subst(body, name, Var(newName))), n, v)
//│ ║         	                  ^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.4: 	fun concat2(a, b) = concat(a)(b)
//│ ║       	                    ^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `string`
//│ ║  l.911: 	        subst(Abs(Var(newName), subst(body, name, Var(newName))), n, v)
//│ ║         	                      ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ fun subst: forall 'a. (Abs | App | Term & #Object & 'a & ~#Abs & ~#App & ~#Var | Var, anything, Term & #Object & 'a,) -> (Abs | App | Var | 'a)

fun showSubst(t, n, v) =
  concat8(showTerm(t), " [", n, " / ", showTerm(v), "]", " => ", showTerm(subst(t, n, v)))
//│ fun showSubst: (Abs | App | Var, #Str, Abs & Term | App & Term | Var & Term,) -> #Str

showSubst(Var("x"), "x", Var("y"))
showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.948: 	showSubst(Var("x"), "x", Var("y"))
//│ ║         	          ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.948: 	showSubst(Var("x"), "x", Var("y"))
//│ ║         	              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.948: 	showSubst(Var("x"), "x", Var("y"))
//│ ║         	                         ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.948: 	showSubst(Var("x"), "x", Var("y"))
//│ ║         	                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	                        ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	                            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	                                        ^^^^^^^^
//│ ╟── string literal of type `"z"` is not an instance of type `string`
//│ ║  l.949: 	showSubst(Abs(Var("x"), Var("x")), "x", Var("z"))
//│ ║         	                                            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                        ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                                            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                                                      ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.950: 	showSubst(App(Var("x"), Var("y")), "x", Abs(Var("x"), Var("x")))
//│ ║         	                                                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                  ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                      ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                       ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                                           ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                                                     ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.951: 	showSubst(App(Abs(Var("x"), Var("x")), Var("x")), "x", Abs(Var("y"), Var("y")))
//│ ║         	                                                                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	              ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                                      ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                                                       ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.952: 	showSubst(Abs(Var("x"), App(Var("x"), Var("y"))), "y", Var("x"))
//│ ║         	                                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	              ^^^^^^^^
//│ ╟── string literal of type `"z"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                          ^^^^^^^^
//│ ╟── string literal of type `"z"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                        ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                                  ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                                      ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                                                     ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.953: 	showSubst(Abs(Var("z"), Abs(Var("x"), App(Var("z"), App(Var("x"), Var("y"))))), "y", Var("x"))
//│ ║         	                                                                                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ #Str
//│ res
//│     = 'x [x / y] => y'
//│ res
//│     = '&x. x [x / z] => &x. x'
//│ res
//│     = '(x y) [x / &x. x] => ((&x. x) y)'
//│ res
//│     = '((&x. x) x) [x / &y. y] => ((&x. x) &y. y)'
//│ res
//│     = '&x. (x y) [y / x] => &z. (z x)'
//│ res
//│     = '&z. &x. (z (x y)) [y / x] => &z. &a. (z (a x))'

type Result = Normal | Stuck | Stepped
class Normal(term: Term) {
  fun toString() = concat2("Normal form: ", showTerm(term))
}
class Stuck(term: Term, part: Term) {
  fun toString() = concat4("Stuck: ", showTerm(part), " in ", showTerm(term))
}
class Stepped(from: Term, to: Term) {
  fun toString() = concat3(showTerm(from), " => ", showTerm(to))
}
//│ type Result = Normal | Stepped | Stuck
//│ class Normal(term: Term) {
//│   fun toString: () -> #Str
//│ }
//│ class Stuck(term: Term, part: Term) {
//│   fun toString: () -> #Str
//│ }
//│ class Stepped(from: Term, to: Term) {
//│   fun toString: () -> #Str
//│ }

fun stepByValue(t) =
  if t is
    Var then Stuck(t, t)
    Abs then Normal(t)
    App(lhs, rhs) and stepByValue(lhs) is
      Stepped(_, lhs) then Stepped(t, App(lhs, rhs))
      Stuck(_, part) then Stuck(t, part)
      Normal and stepByValue(rhs) is
        Stepped(_, rhs) then Stepped(t, App(lhs, rhs))
        Stuck(_, part) then Stuck(t, part)
        Normal and lhs is
          Abs(Var(name), body) then Stepped(t, subst(body, name, rhs))
          _ then Stuck(t, lhs)
//│ fun stepByValue: (Abs | App | Var) -> (Normal | Stepped | Stuck)

toString of stepByValue of Var("x")
toString of stepByValue of Abs(Var("x"), Var("y"))
toString of stepByValue of App(Var("x"), Var("y"))
toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1220: 	toString of stepByValue of Var("x")
//│ ║          	                           ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1220: 	toString of stepByValue of Var("x")
//│ ║          	                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1221: 	toString of stepByValue of Abs(Var("x"), Var("y"))
//│ ║          	                               ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1221: 	toString of stepByValue of Abs(Var("x"), Var("y"))
//│ ║          	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1221: 	toString of stepByValue of Abs(Var("x"), Var("y"))
//│ ║          	                                         ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.1221: 	toString of stepByValue of Abs(Var("x"), Var("y"))
//│ ║          	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1222: 	toString of stepByValue of App(Var("x"), Var("y"))
//│ ║          	                               ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1222: 	toString of stepByValue of App(Var("x"), Var("y"))
//│ ║          	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1222: 	toString of stepByValue of App(Var("x"), Var("y"))
//│ ║          	                                         ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.1222: 	toString of stepByValue of App(Var("x"), Var("y"))
//│ ║          	                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                   ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                       ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                             ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                                        ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1223: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Var("x"))
//│ ║          	                                                            ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                   ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                       ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                             ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                                            ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                                                      ^^^^^^^^
//│ ╟── string literal of type `"y"` is not an instance of type `string`
//│ ║  l.1224: 	toString of stepByValue of App(Abs(Var("x"), Var("x")), Abs(Var("y"), Var("y")))
//│ ║          	                                                                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ #Str
//│ res
//│     = 'Stuck: x in x'
//│ res
//│     = 'Normal form: &x. y'
//│ res
//│     = 'Stuck: x in (x y)'
//│ res
//│     = 'Stuck: x in ((&x. x) x)'
//│ res
//│     = '((&x. x) &y. y) => &y. y'

fun evalByValue(t) =
  if stepByValue(t) is result and result is
    Stepped(_, term) then evalByValue(term)
    else result
//│ fun evalByValue: (Abs | App | Var) -> (Normal | Stuck)

// Let's program with Church encoding!
let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
toString of stepByValue of zero
toString of stepByValue of one
let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
toString of stepByValue of succ
toString of stepByValue of App(succ, zero)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	               ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	                             ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	                                       ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1352: 	let zero = Abs(Var("f"), Abs(Var("x"), Var("x")))
//│ ║          	                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	              ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                            ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                                          ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                                              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                                                    ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1353: 	let one = Abs(Var("f"), Abs(Var("x"), App(Var("f"), Var("x"))))
//│ ║          	                                                        ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	               ^^^^^^^^
//│ ╟── string literal of type `"n"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                             ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                           ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                         ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                           ^^^^^^^^
//│ ╟── string literal of type `"n"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                                     ^^^^^^^^
//│ ╟── string literal of type `"f"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                                         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                                                ^^^^^^^^
//│ ╟── string literal of type `"x"` is not an instance of type `string`
//│ ║  l.1356: 	let succ = Abs(Var("n"), Abs(Var("f"), Abs(Var("x"), App(Var("f"), App(App(Var("n"), Var("f")), Var("x"))))))
//│ ║          	                                                                                                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.141: 	class Var(name: string)
//│ ╙──       	                ^^^^^^
//│ let zero: Abs
//│ let one: Abs
//│ let succ: Abs
//│ #Str
//│ zero
//│      = Abs {}
//│ one
//│     = Abs {}
//│ res
//│     = 'Normal form: &f. &x. x'
//│ res
//│     = 'Normal form: &f. &x. (f x)'
//│ succ
//│      = Abs {}
//│ res
//│     = 'Normal form: &n. &f. &x. (f ((n f) x))'
//│ res
//│     = '((&n. &f. &x. (f ((n f) x))) &f. &x. x) => &f. &x. (f (((&f. &x. x) f) x))'

toString of evalByValue of App(succ, App(succ, zero))
toString of evalByValue of App(succ, App(succ, App(succ, App(succ, zero))))
//│ #Str
//│ res
//│     = 'Normal form: &f. &x. (f (((&f. &x. (f (((&f. &x. x) f) x))) f) x))'
//│ res
//│     = 'Normal form: &f. &x. (f (((&f. &x. (f (((&f. &x. (f (((&f. &x. (f (((&f. &x. x) f) x))) f) x))) f) x))) f) x))'

fun equalTerm(a, b) =
  if a is
    Var(na) and b is Var(nb) then eq(na)(nb)
    Abs(la, ra) and b is Abs(lb, rb) then equalTerm(la, lb) && equalTerm(ra, rb)
    App(la, ra) and b is App(lb, rb) then equalTerm(la, lb) && equalTerm(ra, rb)
    _ then false
//│ fun equalTerm: (#Object, #Object,) -> Bool
