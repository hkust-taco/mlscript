:NoJS
:ts
{ a = "hello"; b = "world" }
1 + 2 - 5
let t = { a = 5; b = "world"} in if t.a == 1 then 1 else (fun f -> f.b )
def x = 1
def y = 2
def z = x + y
(1, 3, { a = { b = { c = "d"}}}, "hello hello")
// common values
//│ res: {a: "hello", b: "world"}
//│ res: int
//│ res: {b: 'a} -> 'a | 1
//│ x: 1
//│ y: 2
//│ z: int
//│ res: (1, 3, {a: {b: {c: "d"}}}, "hello hello",)
//│ // start ts
//│ export declare const res: {a: "hello", b: "world"}
//│ export declare const res: int
//│ export declare const res<a>: ((arg1: {b: a}) => a) | 1
//│ export declare const x: 1
//│ export declare const y: 2
//│ export declare const z: int
//│ export declare const res: [1, 3, {a: {b: {c: "d"}}}, "hello hello"]
//│ // end ts

:ts
def rcd = { x = 1 }
rcd.x
def funky f r = let t = r with { y = "nah" } in f t
def g = rcd with { y = "yeah" }
// records
//│ rcd: {x: 1}
//│ res: 1
//│ funky: (('a\y & {y: "nah"}) -> 'b) -> 'a -> 'b
//│ g: {x: 1, y: "yeah"}
//│ // start ts
//│ export declare const rcd: {x: 1}
//│ export declare const res: 1
//│ export declare const funky<a, b>: (arg1: (arg3: Omit<a, { y }> & {y: "nah"}) => b) => (arg5: a) => b
//│ export declare const g: {x: 1, y: "yeah"}
//│ // end ts

:ts
def f (a: int) (b: string) (c: bool) = if c then a else b
rec def fact x = if x == 1 then 1 else x * fact (x - 1)
def g x y = if x.b == 1 then x else x.a
// miscellaneous functions
//│ f: int -> string -> bool -> (int | string)
//│ fact: int -> int
//│ g: ({a: 'a, b: int} & 'a) -> anything -> 'a
//│ // start ts
//│ export declare const f: (arg1: int) => (arg3: string) => (arg5: bool) => int | string
//│ export declare const fact: (arg1: int) => int
//│ export declare const g<a>: (arg1: {a: a, b: int} & a) => (arg3: unknown) => a
//│ // end ts

:ts
rec def l (a: int) = l
rec def m (a: int) (b: int) = m
def f: ('c -> 'a as 'a) -> 'c -> int
// recursion type functions
//│ l: int -> 'a as 'a
//│ m: int -> int -> 'a as 'a
//│ f: ('c -> 'a as 'a) -> 'c -> int
//│ // start ts
//│ export type a = (arg1: int) => a
//│ export declare const l: a
//│ export type a = (arg1: int) => (arg3: int) => a
//│ export declare const m: a
//│ export type a<c> = (arg1: c) => a<c>
//│ export declare const f<c>: (arg1: a<c>) => (arg3: c) => int
//│ // end ts

:ts
:e
1: ?
{ a = "hello" }: { a: string } & { b: int }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.78: 	1: ?
//│ ║        	^
//│ ╟── integer literal of type `1` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.78: 	1: ?
//│ ╙──      	   ^
//│ res: anything
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.79: 	{ a = "hello" }: { a: string } & { b: int }
//│ ║        	^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{a: "hello"}` does not have field 'b'
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.79: 	{ a = "hello" }: { a: string } & { b: int }
//│ ╙──      	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: {a: string, b: int}
//│ // start ts
//│ export declare const res: unknown
//│ export declare const res: {a: string, b: int}
//│ // end ts

:ts
def nonsense x y = if x.a == y.b then x y else fun y -> x
def g = fun x -> fun y -> if x == y then x y else y x
// complex types
//│ nonsense: ('a -> 'b & {a: int} & 'c) -> ({b: int} & 'a) -> (anything -> 'c | 'b)
//│ g: nothing -> nothing -> nothing
//│ // start ts
//│ export declare const nonsense<c, a, b>: (arg1: ((arg3: a) => b) & {a: int} & c) => (arg5: {b: int} & a) => ((arg7: unknown) => c) | b
//│ export declare const g: (arg1: never) => (arg3: never) => never
//│ // end ts

:ts
def x: int | ~string
def y: "a" | "b" | ~string
// negative types
//│ x: int | ~string
//│ y: "a" | "b" | ~string
//│ // start ts
//│ type Neg<NegatedType, FromType> = FromType extends NegatedType ? never: FromType
//│ export declare const x: int | Neg<string, a>
//│ export declare const y: "a" | "b" | Neg<string, a>
//│ // end ts

:ts
def cont x = x + 1
def app y k = k (y - 1)
app 2 cont
//│ cont: int -> int
//│ app: int -> (int -> 'a) -> 'a
//│ res: int
//│ // start ts
//│ export declare const cont: (arg1: int) => int
//│ export declare const app<a>: (arg1: int) => (arg3: (arg5: int) => a) => a
//│ export declare const res: int
//│ // end ts

:ts
def g (x, y) = x + y
def h (x, (y, z)) = y z + x
def k (x, (y, z)) (l, (m), (n)) = (m (n + l)) (y (z + x))
def l: ((1, 2), (3, 4)) -> 5
//│ g: (int, int,) -> int
//│ h: (int, ('a -> int, 'a,),) -> int
//│ k: (int, (int -> 'a, int,),) -> (int, int -> 'a -> 'b, int,) -> 'b
//│ l: ((1, 2,), (3, 4,),) -> 5
//│ // start ts
//│ export declare const g: (arg1: int, arg2: int) => int
//│ export declare const h<a>: (arg1: int, arg2: [(arg4: a) => int, a]) => int
//│ export declare const k<a, b>: (arg1: int, arg2: [(arg4: int) => a, int]) => (arg6: int, arg7: (arg9: int) => (arg11: a) => b, arg12: int) => b
//│ export declare const l: (arg1: [1, 2], arg2: [3, 4]) => 5
//│ // end ts


:ts
def weird: ((int, int) -> 'a) as 'a
def weird: ('a -> (int, int)) as 'a
def weird: ((int, 'a) as 'a) -> int
def weird: ((int, bool) | 'a) -> 'a
//│ weird: (int, int,) -> 'a as 'a
//│ weird: 'a | ('b -> (int, int,) & 'a) -> (int, int,) as 'b
//│ weird: ((int, 'a,) as 'a) -> int
//│ weird: ('a | (int, bool,)) -> 'a
//│ // start ts
//│ export type a = (arg1: int, arg2: int) => a
//│ export declare const weird: a
//│ export type b<a> = a | ((arg1: ((arg3: b<a>) => [int, int]) & a) => [int, int])
//│ export declare const weird<a>: b<a>
//│ export type a = [int, a]
//│ export declare const weird: (arg1: a) => int
//│ export declare const weird<a>: (arg1: a | [int, bool]) => a
//│ // end ts
