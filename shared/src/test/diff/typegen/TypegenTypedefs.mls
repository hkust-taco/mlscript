:NoJS
:ts
type G[T] = { a : T }
type H = int | ~string
class Box[T]: { length: T }
class RectangleBox[T]: Box[T] & { breadth: T }
class StackedRectangleBoxes[T, N]: RectangleBox[T] & { size: N }
//│ Defined type alias G
//│ Defined type alias H
//│ Defined class Box
//│ Defined class RectangleBox
//│ Defined class StackedRectangleBoxes
//│ // start ts
//│ export type G = {a: T}
//│ type Neg<NegatedType, FromType> = FromType extends NegatedType ? never: FromType
//│ export type H = int | Neg<string, a>
//│ export declare class Box<T> {
//│     length: T
//│     constructor(fields: {length: T})
//│ }
//│ export declare class RectangleBox<T> extends Box<T> {
//│     breadth: T
//│     constructor(fields: {breadth: T, length: T})
//│ }
//│ export declare class StackedRectangleBoxes<N, T> extends RectangleBox<T> {
//│     size: N
//│     constructor(fields: {size: N, breadth: T, length: T})
//│ }
//│ // end ts


:ts
class Lock[T]: { pins: T }
  method Map: (T -> 'a) -> Lock['a]
  method Map f = Lock { pins = f this.pins }
  method Open = Lock { pins = 0 }
def Lock pins = Lock { pins = pins }
class Bank: { lock: Lock[int]; cash: int }
  method Potential: int
  method Potential = this.cash / this.lock.pins
  method Better: Bank -> bool
  method Better other = this.Potential > other.Potential
def Bank lock cash = Bank { lock = lock; cash = cash }
let lockA = Lock 20 in let lockB = Lock 30 in (Bank lockA 2000).Better(Bank lockB 30000)
//│ Defined class Lock
//│ Declared Lock.Map: Lock['T] -> ('T -> 'a) -> Lock['a]
//│ Defined Lock.Map: Lock['T] -> ('T -> ('a & 'T0)) -> (Lock['T0] with {pins: 'a})
//│ Defined Lock.Open: Lock['T] -> (Lock['a .. 0 | 'a] with {pins: 0})
//│ Defined class Bank
//│ Declared Bank.Potential: (Bank with {lock: Lock[int]}) -> int
//│ Declared Bank.Better: (Bank with {lock: Lock[int]}) -> (Bank with {lock: Lock[int]}) -> bool
//│ Defined Bank.Potential: (Bank with {lock: Lock[int]}) -> int
//│ Defined Bank.Better: (Bank with {lock: Lock[int]}) -> (Bank with {lock: Lock[int]}) -> bool
//│ Lock: ('pins & 'T) -> (Lock['T] with {pins: 'pins})
//│ Bank: (Lock[int] & 'lock) -> (int & 'cash) -> (Bank with {cash: 'cash, lock: 'lock})
//│ res: bool
//│ // start ts
//│ export declare class Lock<T> {
//│     pins: T
//│     constructor(fields: {pins: T})
//│     Map<a>(arg1: (arg3: T) => a): Lock<a>
//│     Open: Omit<Lock<0 | a>, "pins"> & {pins: 0}
//│ }
//│ export declare class Bank {
//│     lock: Lock<int>
//│     cash: int
//│     constructor(fields: {lock: Lock<int>, cash: int})
//│     Potential: int
//│     Better(arg1: Omit<Bank, "lock"> & {lock: Lock<int>}): bool
//│ }
//│ export declare const Lock<T, pins>: (arg1: pins & T) => Omit<Lock<T>, "pins"> & {pins: pins}
//│ export declare const Bank<lock, cash>: (arg1: Lock<int> & lock) => (arg3: int & cash) => Omit<Bank, "cash" | "lock"> & {cash: cash, lock: lock}
//│ export declare const res: bool
//│ // end ts

