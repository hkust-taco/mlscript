:NewParser
:NewDefs


// * Adapted example from Compositional Embeddings of Domain-Specific Languages (OOPSLA 2022)


// ******************* Initial System *******************

class Vector(x: int, y: int)
//│ class Vector(x: int, y: int)

class Circle(radius: int)
class Outside[Region](a: Region)
class Union[Region](a: Region, b: Region)
class Intersect[Region](a: Region, b: Region)
class Translate[Region](v: Vector, a: Region)
//│ class Circle(radius: int)
//│ class Outside[Region](a: Region)
//│ class Union[Region](a: Region, b: Region)
//│ class Intersect[Region](a: Region, b: Region)
//│ class Translate[Region](v: Vector, a: Region)

mixin SizeBase {
  fun size(r) =
    if r is
      Circle(_) then 1
      Outside(a) then this.size(a) + 1
      Union(a, b) then this.size(a) + this.size(b) + 1
      Intersect(a, b) then this.size(a) + this.size(b) + 1
      Translate(_, a) then this.size(a) + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.28: 	      Outside(a) then this.size(a) + 1
//│ ║        	                      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.28: 	      Outside(a) then this.size(a) + 1
//│ ╙──      	                                     ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.29: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.29: 	      Union(a, b) then this.size(a) + this.size(b) + 1
//│ ╙──      	                                                     ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.30: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ║        	                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.30: 	      Intersect(a, b) then this.size(a) + this.size(b) + 1
//│ ╙──      	                                                         ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	      Translate(_, a) then this.size(a) + 1
//│ ║        	                           ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.31: 	      Translate(_, a) then this.size(a) + 1
//│ ╙──      	                                          ^
//│ mixin SizeBase() {
//│   this: {size: ('a | 'a0 | 'a1 | 'a2) -> int}
//│   fun size: (Circle | Intersect['a1] | Outside['a] | Translate['a2] | Union['a0]) -> (1 | error | int)
//│ }

// ******************* Linguistic Reuse and Meta-Language Optimizations *******************

fun round(n: number): int = 0
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.64: 	fun round(n: number): int = 0
//│ ║        	                            ^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	fun round(n: number): int = 0
//│ ╙──      	                      ^^^
//│ fun round: (n: number,) -> int

fun go(x, offset) =
  if x is 0 then Circle(1)
  else
    let shared = go(x - 1, round(offset / 2))
    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ║        	     ^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `number`
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.76: 	  else
//│ ║        	^^^^^^
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ╙──      	     ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ║        	                 ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.75: 	  if x is 0 then Circle(1)
//│ ║        	                        ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ║        	                    ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ╙──      	                        ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ║        	                                 ^^^^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ╙──      	                                          ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	                           ^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ╙──      	                           ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	                                       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                        ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	                                                              ^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.78: 	    Union(Translate(Vector(0 - offset, 0), shared), Translate(Vector(offset, 0), shared))
//│ ║        	                                                                             ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                        ^^^
//│ fun go: forall 'Region. (int, int,) -> 'Region
//│   where
//│     'Region :> Circle | Union[Translate['Region]] | error

// * Note that first-class polymorphism manages (correctly) to preserve the universal quantification
let circles = go(2, 1024)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.147: 	let circles = go(2, 1024)
//│ ║         	              ^^^^^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.147: 	let circles = go(2, 1024)
//│ ║         	                 ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.77: 	    let shared = go(x - 1, round(offset / 2))
//│ ╙──      	                    ^
//│ let circles: error
//│ circles
//│         = Union {}

// ******************* Adding More Language Constructs *******************

class Univ
class Empty
class Scale[Region](v: Vector, a: Region)
//│ class Univ()
//│ class Empty()
//│ class Scale[Region](v: Vector, a: Region)

mixin SizeExt {
  fun size(a) =
    if a is
      Univ then 1
      Empty then 1
      Scale(_, b) then this.size(b) + 1
    else super.size(a)
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.175: 	      Scale(_, b) then this.size(b) + 1
//│ ║         	                       ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.175: 	      Scale(_, b) then this.size(b) + 1
//│ ╙──       	                                      ^
//│ mixin SizeExt() {
//│   super: {size: 'b -> 'c}
//│   this: {size: 'a -> int}
//│   fun size: (Empty | #Object & 'b & ~#Empty & ~#Scale & ~#Univ | Scale['a] | Univ) -> (1 | error | int | 'c)
//│ }

module TestSize extends SizeBase, SizeExt
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.190: 	module TestSize extends SizeBase, SizeExt
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.174: 	      Empty then 1
//│ ║         	                 ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.175: 	      Scale(_, b) then this.size(b) + 1
//│ ╙──       	                       ^^^^^^^^^^^^
//│ module TestSize() {
//│   fun size: 'a -> (1 | error | int)
//│ }
//│ where
//│   'a <: Circle | Empty | Intersect['a] | Outside['a] | Scale['a] | Translate['a] | Union['a] | Univ

// TODO investigate
:re
TestSize.size(Empty())
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
TestSize.size(circles)
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
TestSize.size(Scale(Vector(1, 1), circles))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.224: 	TestSize.size(Scale(Vector(1, 1), circles))
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.224: 	TestSize.size(Scale(Vector(1, 1), circles))
//│ ║         	                           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// ******************* Adding a New Interpretation *******************
// a stupid power (int ** int) implementation
fun pow(x, a) =
  if a is 0 then 1
  else x * pow(x, a - 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	     ^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `number`
//│ ║  l.242: 	  if a is 0 then 1
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	     ^^^^^^^^^^^^^
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.242: 	  if a is 0 then 1
//│ ╙──       	     ^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ║         	                  ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ╙──       	                      ^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.241: 	fun pow(x, a) =
//│ ║         	    ^^^^^^^^^^^
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	                 ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ╙──       	           ^^^^^^^^^^^^^
//│ fun pow: (int, int,) -> (1 | int)

mixin Contains {
  fun contains(a, p) =
    if a is
      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
      Outside(a) then not (this.contains(a, p))
      Union(lhs, rhs) then this.contains(lhs, p) || this.contains(rhs, p)
      Intersect(lhs, rhs) then this.contains(lhs, p) && this.contains(rhs, p)
      Translate(v, a) then this.contains(a, Vector(p.x - v.x, p.y - v.y))
}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                     ^^^^^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                              ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ╙──       	                  ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                     ^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	                 ^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ╙──       	                     ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                                   ^^^^^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                                            ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ╙──       	                  ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	                 ^
//│ ╟── but it flows into application with expected type `int`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ╙──       	                                   ^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                                                  ^^^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                                                         ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.243: 	  else x * pow(x, a - 1)
//│ ╙──       	                  ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.242: 	  if a is 0 then 1
//│ ║         	                 ^
//│ ╟── but it flows into application with expected type `number`
//│ ║  l.282: 	      Circle(r) then pow(p.x, 2) + pow(p.y, 2) <= pow(r, 2)
//│ ╙──       	                                                  ^^^^^^^^^
//│ mixin Contains() {
//│   this: {contains: ('a | 'a0 | 'a1, 'b,) -> bool & ('a2, Vector,) -> 'c}
//│   fun contains: (Circle | Intersect['a1] | Outside['a] | Translate['a2] | Union['a0], {x: int, y: int} & 'b,) -> (bool | error | 'c)
//│ }

module TestContains extends Contains
//│ module TestContains() {
//│   fun contains: ('a, {x: int, y: int},) -> (bool | error)
//│ }
//│ where
//│   'a <: Circle | Intersect['a] | Outside['a] | Translate['a] | Union['a]

// TODO investigate
:re
TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                              ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                                     ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                                          ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.356: 	TestContains.contains(Translate(Vector(0, 0), Circle(1)), Vector(0, 0))
//│ ║         	                                                                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ bool | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                          ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                        ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                               ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                                    ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                                           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                                                ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.391: 	TestContains.contains(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)), Vector(0, 0))
//│ ║         	                                                                                       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ bool | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
TestContains.contains(circles, Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.435: 	TestContains.contains(circles, Vector(0, 0))
//│ ║         	                               ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.435: 	TestContains.contains(circles, Vector(0, 0))
//│ ║         	                                      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ bool | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// ******************* Dependencies, Complex Interpretations, and Domain-Specific Optimizations *******************

fun toString(a: int): string = "foo"
fun concat(a: string, b: string): string = a
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.452: 	fun toString(a: int): string = "foo"
//│ ║         	                               ^^^^^
//│ ╟── string literal of type `"foo"` is not an instance of type `string`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.452: 	fun toString(a: int): string = "foo"
//│ ╙──       	                      ^^^^^^
//│ fun toString: (a: int,) -> string
//│ fun concat: (a: string, b: string,) -> string

mixin Text {
  fun text(e) =
    if e is
      Circle(r) then concat("a circular region of radius ", toString(r))
      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
      Union then concat("the union of two regions of size ", toString(this.size(e)))
      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
      Translate then concat("a translated region of size ", toString(this.size(e)))
}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.467: 	      Circle(r) then concat("a circular region of radius ", toString(r))
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a circular region of radius "` is not an instance of type `string`
//│ ║  l.467: 	      Circle(r) then concat("a circular region of radius ", toString(r))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.453: 	fun concat(a: string, b: string): string = a
//│ ╙──       	              ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.468: 	      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"outside a region of size "` is not an instance of type `string`
//│ ║  l.468: 	      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
//│ ║         	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.453: 	fun concat(a: string, b: string): string = a
//│ ╙──       	              ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.469: 	      Union then concat("the union of two regions of size ", toString(this.size(e)))
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"the union of two regions of size "` is not an instance of type `string`
//│ ║  l.469: 	      Union then concat("the union of two regions of size ", toString(this.size(e)))
//│ ║         	                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.453: 	fun concat(a: string, b: string): string = a
//│ ╙──       	              ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.470: 	      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"the intersection of two regions of size "` is not an instance of type `string`
//│ ║  l.470: 	      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.453: 	fun concat(a: string, b: string): string = a
//│ ╙──       	              ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.471: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a translated region of size "` is not an instance of type `string`
//│ ║  l.471: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ║         	                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.453: 	fun concat(a: string, b: string): string = a
//│ ╙──       	              ^^^^^^
//│ mixin Text() {
//│   this: {size: (Intersect['Region] | Translate['Region0] | Union['Region1] | 'a) -> int}
//│   fun text: (Circle | Intersect['Region] | Outside['a] | Translate['Region0] | Union['Region1]) -> (error | string)
//│ }

:e
module SizeText extends Text
//│ ╔══[ERROR] Module `SizeText` does not contain member `size`
//│ ║  l.471: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ╙──       	                                                                         ^^^^^
//│ ╔══[ERROR] Module `SizeText` does not contain member `size`
//│ ║  l.470: 	      Intersect then concat("the intersection of two regions of size ", toString(this.size(e)))
//│ ╙──       	                                                                                     ^^^^^
//│ ╔══[ERROR] Module `SizeText` does not contain member `size`
//│ ║  l.469: 	      Union then concat("the union of two regions of size ", toString(this.size(e)))
//│ ╙──       	                                                                          ^^^^^
//│ ╔══[ERROR] Module `SizeText` does not contain member `size`
//│ ║  l.468: 	      Outside(a) then concat("outside a region of size ", toString(this.size(a)))
//│ ╙──       	                                                                       ^^^^^
//│ module SizeText() {
//│   fun text: (Circle | Intersect[anything] | Outside[anything] | Translate[anything] | Union[anything]) -> (error | string)
//│ }

// * Note: this inferred type got *much worse* after this commit (field access type refinement)
module SizeText extends SizeBase, Text
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.542: 	module SizeText extends SizeBase, Text
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.27: 	      Circle(_) then 1
//│ ║        	                     ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.452: 	fun toString(a: int): string = "foo"
//│ ║         	                ^^^
//│ ╟── from application:
//│ ║  l.471: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ╙──       	                                                                     ^^^^^^^^^^^^
//│ module SizeText() {
//│   fun size: 'a -> (1 | error | int)
//│   fun text: (Circle | Intersect[Circle | Intersect['Region] | Outside['Region0] | Translate['Region1] | Union['Region2]] | Outside['a] | Translate[Circle | Intersect['Region] | Outside['Region0] | Translate['Region1] | Union['Region2]] | Union[Circle | Intersect['Region] | Outside['Region0] | Translate['Region1] | Union['Region2]]) -> (error | string)
//│ }
//│ where
//│   'a <: Circle | Intersect['Region] | Outside['Region0] | Translate['Region1] | Union['Region2]
//│   'Region2 <: 'a
//│   'Region1 <: 'a
//│   'Region0 <: 'a
//│   'Region <: 'a

SizeText.text(circles)
//│ error | string
//│ res
//│     = 'the union of two regions of size '

SizeText.size(circles)
//│ 1 | error | int
//│ res
//│     = 13

SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                  ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                         ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                            ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.576: 	SizeText.text(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ error | string
//│ res
//│     = 'the intersection of two regions of size '

SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                  ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                         ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                            ^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.608: 	SizeText.size(Intersect(Translate(Vector(0, 0), Circle(1)), Circle(1)))
//│ ║         	                                                                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.13: 	class Circle(radius: int)
//│ ╙──      	                     ^^^
//│ 1 | error | int
//│ res
//│     = 4

mixin IsUniv {
  fun isUniv(e) =
    if e is
      Univ then true
      Outside(a) then this.isEmpty(a)
      Union(a, b) then this.isUniv(a) || this.isUniv(b)
      Intersect(a, b) then this.isUniv(a) && this.isUniv(b)
      Translate(_, a) then this.isUniv(a)
      Scale(_, a) then this.isUniv(a)
    else false
}
//│ mixin IsUniv() {
//│   this: {isEmpty: 'a -> 'b, isUniv: ('a0 | 'a1) -> bool & ('a2 | 'a3) -> 'b}
//│   fun isUniv: (Intersect['a1] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['a] | Scale['a3] | Translate['a2] | Union['a0] | Univ) -> (bool | 'b)
//│ }

mixin IsEmpty {
  fun isEmpty(e) =
    if e is
      Univ then true
      Outside(a) then this.isUniv(a)
      Union(a, b) then this.isEmpty(a) || this.isEmpty(b)
      Intersect(a, b) then this.isEmpty(a) && this.isEmpty(b)
      Translate(_, a) then this.isEmpty(a)
      Scale(_, a) then this.isEmpty(a)
    else false
}
//│ mixin IsEmpty() {
//│   this: {isEmpty: ('a | 'a0) -> bool & ('a1 | 'a2) -> 'b, isUniv: 'a3 -> 'b}
//│   fun isEmpty: (Intersect['a0] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['a3] | Scale['a2] | Translate['a1] | Union['a] | Univ) -> (bool | 'b)
//│ }

module IsUnivIsEmpty extends IsUniv, IsEmpty
//│ module IsUnivIsEmpty() {
//│   fun isEmpty: 'a -> bool
//│   fun isUniv: 'b -> bool
//│ }
//│ where
//│   'a <: Intersect['a] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['b] | Scale['a] | Translate['a] | Union['a] | Univ
//│   'b <: Intersect['b] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['a] | Scale['b] | Translate['b] | Union['b] | Univ

module IsUnivIsEmpty extends IsEmpty, IsUniv
//│ module IsUnivIsEmpty() {
//│   fun isEmpty: 'a -> bool
//│   fun isUniv: 'b -> bool
//│ }
//│ where
//│   'a <: Intersect['a] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['b] | Scale['a] | Translate['a] | Union['a] | Univ
//│   'b <: Intersect['b] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['a] | Scale['b] | Translate['b] | Union['b] | Univ

IsUnivIsEmpty.isUniv(circles)
//│ bool
//│ res
//│     = false

IsUnivIsEmpty.isEmpty(circles)
//│ bool
//│ res
//│     = false

class Foo
IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.701: 	IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ║         	                            ^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.701: 	IsUnivIsEmpty.isEmpty(Scale(Vector(1, 2), Intersect(Foo(), circles)))
//│ ║         	                                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ class Foo()
//│ bool
//│ res
//│     = false

mixin Eliminate {
  fun eliminate(e) =
    if e is
      Outside(Outside(a)) then this.eliminate(a)
      Outside(a) then Outside(this.eliminate(a))
      Union(a, b) then Union(this.eliminate(a), this.eliminate(b))
      Intersect(a, b) then Intersect(this.eliminate(a), this.eliminate(b))
      Translate(v, a) then Translate(v, this.eliminate(a))
      Scale(v, a) then Scale(v, this.eliminate(a))
    else e
}
//│ mixin Eliminate() {
//│   this: {eliminate: 'a -> 'b & 'a0 -> 'c & 'a1 -> 'd & 'a2 -> 'e & 'a3 -> 'f & 'a4 -> 'g}
//│   fun eliminate: forall 'h. (Intersect['a2] | #Object & 'h & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union | Outside['a0 & (#Object & ~#Outside | Outside['a])] | Scale['a4] | Translate['a3] | Union['a1]) -> (Intersect['e] | Outside['c] | Scale['g] | Translate['f] | Union['d] | 'b | 'h)
//│ }

module TestElim extends Eliminate
//│ module TestElim() {
//│   fun eliminate: 'a -> 'b
//│ }
//│ where
//│   'a <: Intersect['a] | #Object & 'b & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union | Outside['a & (#Object & ~#Outside | Outside['a])] | Scale['a] | Translate['a] | Union['a]
//│   'b :> Outside['b] | Union['b] | Intersect['b] | Translate['b] | Scale['b]

TestElim.eliminate(Outside(Outside(Univ())))
//│ 'a
//│   where
//│     'a :> Outside['a] | Union['a] | Intersect['a] | Translate['a] | Scale['a] | Univ
//│ res
//│     = Univ {}

TestElim.eliminate(circles)
//│ 'a
//│   where
//│     'a :> Outside['a] | Union['a] | Intersect['a] | Translate['a] | Scale['a]
//│ res
//│     = Union {}

fun mk(n) = if n is
  1 then Outside(mk(n))
  2 then Union(mk(n), mk(n))
  3 then Intersect(mk(n), mk(n))
  4 then Translate(Vector(0, 0), mk(n))
  _ then Scale(Vector(0, 0), mk(n))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ╙──       	  ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ╙──       	  ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^
//│ ╟── integer literal of type `3` is not an instance of type `number`
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ╙──       	  ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	^^^
//│ ╟── integer literal of type `4` is not an instance of type `number`
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ╙──       	  ^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `bool` is not an instance of type `Object`
//│ ║  l.754: 	fun mk(n) = if n is
//│ ║         	               ^^^^
//│ ║  l.755: 	  1 then Outside(mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.756: 	  2 then Union(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.757: 	  3 then Intersect(mk(n), mk(n))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ╙──       	^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	                   ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.758: 	  4 then Translate(Vector(0, 0), mk(n))
//│ ║         	                          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	               ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	                      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ fun mk: forall 'Region. number -> 'Region
//│   where
//│     'Region :> Intersect['Region] | Outside['Region] | Scale['Region] | Translate['Region] | Union['Region]

:re
TestElim.eliminate(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.911: 	TestElim.eliminate(mk(100))
//│ ║         	                   ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.911: 	TestElim.eliminate(mk(100))
//│ ║         	                      ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ 'a
//│   where
//│     'a :> Outside['a] | Union['a] | Intersect['a] | Translate['a] | Scale['a]
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

// *************************************************************************

module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.930: 	module Lang extends SizeBase, SizeExt, Contains, Text, IsUniv, IsEmpty, Eliminate
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.174: 	      Empty then 1
//│ ║         	                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.452: 	fun toString(a: int): string = "foo"
//│ ║         	                ^^^
//│ ╟── from application:
//│ ║  l.471: 	      Translate then concat("a translated region of size ", toString(this.size(e)))
//│ ╙──       	                                                                     ^^^^^^^^^^^^
//│ module Lang() {
//│   fun contains: ('a, {x: int, y: int},) -> (bool | error)
//│   fun eliminate: 'b -> 'c
//│   fun isEmpty: 'd -> bool
//│   fun isUniv: 'e -> bool
//│   fun size: 'f -> (1 | error | int)
//│   fun text: (Circle | Intersect[Empty | #Object & 'g & ~#Empty & ~#Scale & ~#Univ | Scale['Region] | Univ] | Outside['f] | Translate[Empty | #Object & 'g & ~#Empty & ~#Scale & ~#Univ | Scale['Region] | Univ] | Union[Empty | #Object & 'g & ~#Empty & ~#Scale & ~#Univ | Scale['Region] | Univ]) -> (error | string)
//│ }
//│ where
//│   'f <: Empty | #Object & 'g & ~#Empty & ~#Scale & ~#Univ | Scale['Region] | Univ
//│   'Region <: 'f
//│   'g <: Circle | Intersect['f] | Outside['f] | Translate['f] | Union['f]
//│   'd <: Intersect['d] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['e] | Scale['d] | Translate['d] | Union['d] | Univ
//│   'e <: Intersect['e] | #Object & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union & ~#Univ | Outside['d] | Scale['e] | Translate['e] | Union['e] | Univ
//│   'b <: Intersect['b] | #Object & 'c & ~#Intersect & ~#Outside & ~#Scale & ~#Translate & ~#Union | Outside['b & (#Object & ~#Outside | Outside['b])] | Scale['b] | Translate['b] | Union['b]
//│   'c :> Outside['c] | Union['c] | Intersect['c] | Translate['c] | Scale['c]
//│   'a <: Circle | Intersect['a] | Outside['a] | Translate['a] | Union['a]

// TODO investigate
:re
Lang.size(circles)
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
Lang.contains(circles, Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.971: 	Lang.contains(circles, Vector(0, 0))
//│ ║         	                       ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.971: 	Lang.contains(circles, Vector(0, 0))
//│ ║         	                              ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ bool | error
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

// TODO investigate
:re
Lang.text(circles)
//│ error | string
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

Lang.isUniv(circles)
//│ bool
//│ res
//│     = false

Lang.isEmpty(circles)
//│ bool
//│ res
//│     = false

// TODO investigate
:re
Lang.size(Lang.eliminate(circles))
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   Error: non-exhaustive case expression

:re
Lang.size(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1013: 	Lang.size(mk(100))
//│ ║          	          ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1013: 	Lang.size(mk(100))
//│ ║          	             ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
Lang.contains(mk(100), Vector(0, 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	              ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	                 ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	                       ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	                              ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	class Vector(x: int, y: int)
//│ ╙──      	                ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Scale[?Region]` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region2] | Union[?Region3]`
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Circle | Intersect[?Region4] | Outside[?Region5] | Translate[?Region6] | Union[?Region7]`
//│ ║  l.1030: 	Lang.contains(mk(100), Vector(0, 0))
//│ ║          	              ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.281: 	    if a is
//│ ╙──       	       ^
//│ bool | error
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:e
:re
Lang.text(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1068: 	Lang.text(mk(100))
//│ ║          	          ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1068: 	Lang.text(mk(100))
//│ ║          	             ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1068: 	Lang.text(mk(100))
//│ ║          	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Scale[?Region]` does not match type `Circle | Intersect[?Region0] | Outside[?Region1] | Translate[?Region2] | Union[?Region3]`
//│ ║  l.759: 	  _ then Scale(Vector(0, 0), mk(n))
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Circle | Intersect[?Region4] | Outside[?Region5] | Translate[?Region6] | Union[?Region7]`
//│ ║  l.1068: 	Lang.text(mk(100))
//│ ║          	          ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.466: 	    if e is
//│ ╙──       	       ^
//│ error | string
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.isUniv(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1096: 	Lang.isUniv(mk(100))
//│ ║          	            ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1096: 	Lang.isUniv(mk(100))
//│ ║          	               ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ bool
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.isEmpty(mk(100))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1112: 	Lang.isEmpty(mk(100))
//│ ║          	             ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1112: 	Lang.isEmpty(mk(100))
//│ ║          	                ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ bool
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:re
Lang.size(Lang.eliminate(mk(100)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.1128: 	Lang.size(Lang.eliminate(mk(100)))
//│ ║          	                         ^^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `number`
//│ ║  l.1128: 	Lang.size(Lang.eliminate(mk(100)))
//│ ║          	                            ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.754: 	fun mk(n) = if n is
//│ ╙──       	               ^
//│ 1 | error | int
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded
