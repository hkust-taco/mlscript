:ts
:ne
{ a = "hello"; b = "world" }
1 + 2 - 5
let t = { a = 5; b = "world"} in if t.a == 1 then 1 else (fun f -> f.b )
def x = 1
def y = 2
def x = x + y
(1, 3, { a = { b = { c = "d"}}}, "hello hello")
// common values
//│ res: {a: "hello", b: "world"}
//│ // start ts
//│ export declare const res: {a: "hello", b: "world"}
//│ // end ts
//│ res: int
//│ // start ts
//│ export declare const res: int
//│ // end ts
//│ res: {b: 'a} -> 'a | 1
//│ // start ts
//│ export declare const res<a>: (arg0: {b: a}) => a | 1
//│ // end ts
//│ x: 1
//│ // start ts
//│ export declare const x: 1
//│ // end ts
//│ y: 2
//│ // start ts
//│ export declare const y: 2
//│ // end ts
//│ x: int
//│ // start ts
//│ export declare const x: int
//│ // end ts
//│ res: (1, 3, {a: {b: {c: "d"}}}, "hello hello",)
//│ // start ts
//│ export declare const res: [1, 3, {a: {b: {c: "d"}}}, "hello hello"]
//│ // end ts

:ts
:ne
def rcd = { x = 1 }
rcd.x
def funky f r = let t = r with { y = "nah" } in f t
def g = rcd with { y = "yeah "}
// records
//│ rcd: {x: 1}
//│ // start ts
//│ export declare const rcd: {x: 1}
//│ // end ts
//│ res: 1
//│ // start ts
//│ export declare const res: 1
//│ // end ts
//│ funky: (('a\y & {y: "nah"}) -> 'b) -> 'a -> 'b
//│ // start ts
//│ export declare const funky<a, b>: (arg0: (arg1: Omit<a, { y }> & {y: "nah"}) => b) => (arg2: a) => b
//│ // end ts
//│ g: {x: 1, y: "yeah "}
//│ // start ts
//│ export declare const g: {x: 1, y: "yeah "}
//│ // end ts


:ts
:ne
def f (a: int) (b: string) (c: bool) = if bool then a else b
rec def fact x = if x == 1 then 1 else x * fact (x - 1)
// miscellaneous functions
//│ f: int -> string -> bool -> (int | string)
//│ // start ts
//│ export declare const f: (arg0: int) => (arg1: string) => (arg2: bool) => int | string
//│ // end ts
//│ fact: int -> int
//│ // start ts
//│ export declare const fact: (arg0: int) => int
//│ // end ts

:ts
:ne
rec def l (a: int) = l
rec def m (a: int) (b: int) = m
// recursion type functions
//│ l: int -> 'a as 'a
//│ // start ts
//│ type a = (arg0: int) => a
//│ export declare const l: a
//│ // end ts
//│ m: int -> int -> 'a as 'a
//│ // start ts
//│ type a = (arg0: int) => (arg1: int) => a
//│ export declare const m: a
//│ // end ts

:ts
:ne
def f x y = if x.a == y.b then x y else fun y -> x
def g = fun x -> fun y -> if x == y then x y else y x
// complex types
//│ f: ('a -> 'b & {a: int} & 'c) -> ({b: int} & 'a) -> (anything -> 'c | 'b)
//│ // start ts
//│ export declare const f<a, b, c>: (arg0: (arg1: a) => b & {a: int} & c) => (arg2: {b: int} & a) => (arg3: unknown) => c | b
//│ // end ts
//│ g: nothing -> nothing -> nothing
//│ // start ts
//│ export declare const g: (arg0: never) => (arg1: never) => never
//│ // end ts


:ts
:ne
def cont x = x + 1
def app y k = k (y - 1)
app 2 cont
//│ cont: int -> int
//│ // start ts
//│ export declare const cont: (arg0: int) => int
//│ // end ts
//│ app: int -> (int -> 'a) -> 'a
//│ // start ts
//│ export declare const app<a>: (arg0: int) => (arg1: (arg2: int) => a) => a
//│ // end ts
//│ res: int
//│ // start ts
//│ export declare const res: int
//│ // end ts

:ts
:ne
:e
1: ?
{ a = "hello" }: { a: string } & { b: int }
// type casting and wildcards
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.131: 	1: ?
//│ ║         	^
//│ ╟── integer literal of type `1` does not match type `nothing`
//│ ╟── Note: constraint arises from type wildcard:
//│ ║  l.131: 	1: ?
//│ ╙──       	   ^
//│ res: anything
//│ // start ts
//│ export declare const res: unknown
//│ // end ts
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.132: 	{ a = "hello" }: { a: string } & { b: int }
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{a: "hello"}` does not have field 'b'
//│ ╟── Note: constraint arises from intersection type:
//│ ║  l.132: 	{ a = "hello" }: { a: string } & { b: int }
//│ ╙──       	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: {a: string, b: int}
//│ // start ts
//│ export declare const res: {a: string, b: int}
//│ // end ts

:ts
:ne
type T = int | ~string
def foo: T
def bar: ~T
def gee: T -> { a: int; b: { a: T }}
// negative types
//│ Defined type alias T
//│ foo: int | ~string
//│ // start ts
//│ type talias1<T0> = T0 extends string ? never : T0
//│ export declare const foo<T0>: int | talias1<T0>
//│ // end ts
//│ bar: string
//│ // start ts
//│ export declare const bar: string
//│ // end ts
//│ gee: (int | ~string) -> {a: int, b: {a: int | ~string}}
//│ // start ts
//│ type talias4<T3> = T3 extends string ? never : T3
//│ type talias2<T1> = T1 extends string ? never : T1
//│ export declare const gee<T3, T1>: (arg0: int | talias2<T1>) => {a: int, b: {a: int | talias4<T3>}}
//│ // end ts
