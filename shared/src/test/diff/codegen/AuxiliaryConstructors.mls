:NewParser
:NewDefs

:js
class A(x: Int) {}
//│ class A(x: Int)
//│ // Prelude
//│ let res;
//│ class TypingUnit {
//│   #A;
//│   constructor() {
//│   }
//│   get A() {
//│     const qualifier = this;
//│     if (this.#A === undefined) {
//│       class A {
//│         #x;
//│         constructor(x) {
//│           this.#x = x;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#x];
//│         }
//│       };
//│       this.#A = ((x) => Object.freeze(new A(x)));
//│       this.#A.class = A;
//│       this.#A.unapply = A.unapply;
//│     }
//│     return this.#A;
//│   }
//│ }
//│ const typing_unit = new TypingUnit;
//│ globalThis.A = typing_unit.A;
//│ // End of generated code

:js
class B {}
//│ class B {
//│   constructor()
//│ }
//│ // Prelude
//│ class TypingUnit1 {
//│   #B;
//│   constructor() {
//│   }
//│   get B() {
//│     const qualifier = this;
//│     if (this.#B === undefined) {
//│       class B {};
//│       this.#B = B;
//│     }
//│     return this.#B;
//│   }
//│ }
//│ const typing_unit1 = new TypingUnit1;
//│ globalThis.B = typing_unit1.B;
//│ // End of generated code

new B
//│ B
//│ res
//│     = B {}

:e
B()
//│ ╔══[ERROR] Construction of unparameterized class B should use the `new` keyword
//│ ║  l.66: 	B()
//│ ╙──      	^
//│ B
//│ res
//│ Runtime error:
//│   TypeError: Class constructor B cannot be invoked without 'new'

abstract class C
//│ abstract class C

:e
new C
//│ ╔══[ERROR] Class C is abstract and cannot be instantiated
//│ ║  l.79: 	new C
//│ ╙──      	^^^^^
//│ ╔══[ERROR] Class C cannot be instantiated as it exposes no such constructor
//│ ║  l.79: 	new C
//│ ╙──      	^^^^^
//│ error
//│ res
//│     = C {}

:e
C()
//│ ╔══[ERROR] Class C is abstract and cannot be instantiated
//│ ║  l.91: 	C()
//│ ╙──      	^
//│ ╔══[ERROR] Class C cannot be instantiated as it exposes no such constructor
//│ ║  l.91: 	C()
//│ ╙──      	^
//│ error
//│ res
//│ Runtime error:
//│   TypeError: Class constructor C cannot be invoked without 'new'

:js
class C {
  constructor(x: Int) { log(x) }
}
//│ class C {
//│   constructor(x: Int)
//│ }
//│ // Prelude
//│ function log(x) {
//│   return console.info(x);
//│ }
//│ class TypingUnit7 {
//│   #C;
//│   constructor() {
//│   }
//│   get C() {
//│     const qualifier = this;
//│     if (this.#C === undefined) {
//│       class C {
//│         constructor(x) {
//│           log(x);
//│         }
//│       };
//│       this.#C = C;
//│     }
//│     return this.#C;
//│   }
//│ }
//│ const typing_unit7 = new TypingUnit7;
//│ globalThis.C = typing_unit7.C;
//│ // End of generated code

:e
let c = new C()
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.136: 	let c = new C()
//│ ║         	        ^^^^^^^
//│ ╟── argument of type `[]` does not match type `[x: Int]`
//│ ║  l.136: 	let c = new C()
//│ ╙──       	             ^^
//│ let c: C | error
//│ c
//│   = C {}
//│ // Output
//│ undefined

let c = new C(1)
//│ let c: C
//│ c
//│   = C {}
//│ // Output
//│ 1

:js
class D(val x: Int) {
  constructor(y: Int) {
    x = y + 1
  }
  log(x)
}
//│ class D(x: Int) {
//│   constructor(y: Int)
//│ }
//│ // Prelude
//│ class TypingUnit10 {
//│   #D;
//│   constructor() {
//│   }
//│   get D() {
//│     const qualifier = this;
//│     if (this.#D === undefined) {
//│       class D {
//│         #x;
//│         get x() { return this.#x; }
//│         constructor(y) {
//│           this.#x = y + 1;
//│           const x = this.#x;
//│           log(x);
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#x];
//│         }
//│       };
//│       this.#D = ((x) => Object.freeze(new D(x)));
//│       this.#D.class = D;
//│       this.#D.unapply = D.unapply;
//│     }
//│     return this.#D;
//│   }
//│ }
//│ const typing_unit10 = new TypingUnit10;
//│ globalThis.D = typing_unit10.D;
//│ // End of generated code

let dd = new D(41)
dd.x
//│ let dd: D
//│ Int
//│ dd
//│    = D {}
//│ // Output
//│ 42
//│ res
//│     = 42

let dd = D(41)
dd.x
//│ let dd: D
//│ Int
//│ dd
//│    = D {}
//│ // Output
//│ 42
//│ res
//│     = 42

:pe
class E {
  constructor(x: Int)
  constructor(y: Int)
}
//│ ╔══[PARSE ERROR] A class may only have at most one explicit constructor
//│ ║  l.221: 	class E {
//│ ╙──       	^^^^^
//│ class E {
//│   constructor()
//│ }

:e
constructor(x: Int)
//│ ╔══[ERROR] constructor must be in a class.
//│ ║  l.233: 	constructor(x: Int)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ []
//│ Code generation encountered an error:
//│   unexpected constructor.

:js
class F(x: Int) extends C(x + 1) {}
class G extends C(2) {}
class H extends B {}
//│ class F(x: Int) extends C
//│ class G extends C {
//│   constructor()
//│ }
//│ class H extends B {
//│   constructor()
//│ }
//│ // Prelude
//│ class TypingUnit14 {
//│   #F;
//│   #G;
//│   #H;
//│   constructor() {
//│   }
//│   get F() {
//│     const qualifier = this;
//│     if (this.#F === undefined) {
//│       class F extends C {
//│         #x;
//│         constructor(x) {
//│           super(x + 1);
//│           this.#x = x;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#x];
//│         }
//│       };
//│       this.#F = ((x) => Object.freeze(new F(x)));
//│       this.#F.class = F;
//│       this.#F.unapply = F.unapply;
//│     }
//│     return this.#F;
//│   }
//│   get G() {
//│     const qualifier = this;
//│     if (this.#G === undefined) {
//│       class G extends C {
//│         constructor() {
//│           super(2);
//│         }
//│       };
//│       this.#G = G;
//│     }
//│     return this.#G;
//│   }
//│   get H() {
//│     const qualifier = this;
//│     if (this.#H === undefined) {
//│       class H extends B {
//│         constructor() {
//│           super();
//│         }
//│       };
//│       this.#H = H;
//│     }
//│     return this.#H;
//│   }
//│ }
//│ const typing_unit14 = new TypingUnit14;
//│ globalThis.F = typing_unit14.F;
//│ globalThis.G = typing_unit14.G;
//│ globalThis.H = typing_unit14.H;
//│ // End of generated code

:js
fun f(c) =
  if c is
    F(x) then x
    G() then 2
    _ then 0
//│ fun f: Object -> Int
//│ // Prelude
//│ class TypingUnit15 {}
//│ const typing_unit15 = new TypingUnit15;
//│ // Query 1
//│ globalThis.f = function f(c) {
//│   return ((() => {
//│     let a;
//│     return a = c, a instanceof F.class ? (([x]) => x)(F.unapply(c)) : a instanceof G ? 2 : 0;
//│   })());
//│ };
//│ // End of generated code

f(F(12))
f(new G())
//│ Int
//│ res
//│     = 12
//│ // Output
//│ 13
//│ res
//│     = 2
//│ // Output
//│ 2

:js
module I {
  class J {
    constructor(x: Int)
  }
  module K {
    class L extends J(0)
  }
}
//│ module I {
//│   class J {
//│     constructor(x: Int)
//│   }
//│   module K {
//│     class L extends J {
//│       constructor()
//│     }
//│   }
//│ }
//│ // Prelude
//│ class TypingUnit17 {
//│   #I;
//│   constructor() {
//│   }
//│   get I() {
//│     const qualifier = this;
//│     if (this.#I === undefined) {
//│       class I {
//│         #J;
//│         #K;
//│         constructor() {
//│         }
//│         get K() {
//│           const qualifier1 = this;
//│           if (this.#K === undefined) {
//│             class K {
//│               #L;
//│               constructor() {
//│               }
//│               get L() {
//│                 const qualifier2 = this;
//│                 if (this.#L === undefined) {
//│                   class L extends qualifier1.J {
//│                     constructor() {
//│                       super(0);
//│                     }
//│                   };
//│                   this.#L = L;
//│                 }
//│                 return this.#L;
//│               }
//│             }
//│             this.#K = new K();
//│             this.#K.class = K;
//│           }
//│           return this.#K;
//│         }
//│         get J() {
//│           const qualifier1 = this;
//│           if (this.#J === undefined) {
//│             class J {};
//│             this.#J = J;
//│           }
//│           return this.#J;
//│         }
//│       }
//│       this.#I = new I();
//│       this.#I.class = I;
//│     }
//│     return this.#I;
//│   }
//│ }
//│ const typing_unit17 = new TypingUnit17;
//│ globalThis.I = typing_unit17.I;
//│ // End of generated code

:js
fun g(x: Int) =
  class L(y: Int) {
    constructor(z: Int) {
      y = z + 1
    }
    fun ll = x + y
  }
  L
//│ fun g: (x: Int) -> (y: Int) -> L
//│ // Prelude
//│ class TypingUnit18 {}
//│ const typing_unit18 = new TypingUnit18;
//│ // Query 1
//│ globalThis.g = function g(x) {
//│   return ((() => {
//│     const L = (() => {
//│       class L {
//│         #y;
//│         constructor(z) {
//│           this.#y = z + 1;
//│           const y = this.#y;
//│         }
//│         get ll() {
//│           const y = this.#y;
//│           return x + y;
//│         }
//│       static
//│         unapply(x) {
//│           return [x.#y];
//│         }
//│       }
//│       let ctor;
//│       ctor = ((y) => new L(y));
//│       ctor.class = L;
//│       return ctor;
//│     })();
//│     return L;
//│   })());
//│ };
//│ // End of generated code

:js
let m = g(1)
let n = m(2)
n.ll
//│ let m: (y: Int) -> L
//│ let n: L
//│ Int
//│ // Prelude
//│ class TypingUnit19 {}
//│ const typing_unit19 = new TypingUnit19;
//│ // Query 1
//│ globalThis.m = g(1);
//│ // Query 2
//│ globalThis.n = m(2);
//│ // Query 3
//│ res = n.ll;
//│ // End of generated code
//│ m
//│   = [Function: ctor] { class: [class L] }
//│ n
//│   = L {}
//│ res
//│     = 4

class M()
//│ class M()

:js
let mm = new M()
//│ let mm: M
//│ // Prelude
//│ class TypingUnit21 {}
//│ const typing_unit21 = new TypingUnit21;
//│ // Query 1
//│ globalThis.mm = new M.class();
//│ // End of generated code
//│ mm
//│    = M {}

:e // TODO support first-class classes
fun h(z: Int) =
  class N {
    constructor(x: Int) {
      log(x + z)
    }
  }
  N
//│ ╔══[ERROR] Construction of unparameterized class N should use the `new` keyword
//│ ║  l.505: 	  N
//│ ╙──       	  ^
//│ fun h: (z: Int) -> (x: Int) -> N

let hh = h(1)
//│ let hh: (x: Int) -> N
//│ hh
//│    = [class N]

:e
new hh(1)
//│ ╔══[ERROR] Value hh cannot be used in `new` expression
//│ ║  l.517: 	new hh(1)
//│ ╙──       	^^^^^^^^^
//│ error
//│ res
//│     = N {}
//│ // Output
//│ 2

:e
module O {
  constructor(x: Int)
}
mixin P {
  constructor(x: Int)
}
//│ ╔══[ERROR] Explicit module constructors are not supported
//│ ║  l.529: 	  constructor(x: Int)
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Explicit mixin constructors are not supported
//│ ║  l.532: 	  constructor(x: Int)
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^
//│ module O {
//│   constructor(x: Int)
//│ }
//│ mixin P()

:w
:e
class QQ(qq: Str) {
  constructor(foo: Int) {
    lol
    qq = foo
  }
}
//│ ╔══[ERROR] identifier not found: lol
//│ ║  l.549: 	    lol
//│ ╙──       	    ^^^
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.549: 	    lol
//│ ╙──       	    ^^^
//│ ╔══[ERROR] Type mismatch in auxiliary class constructor:
//│ ║  l.548: 	  constructor(foo: Int) {
//│ ║         	  ^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.549: 	    lol
//│ ║         	^^^^^^^
//│ ║  l.550: 	    qq = foo
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `Int` is not an instance of `Str`
//│ ║  l.548: 	  constructor(foo: Int) {
//│ ║         	                   ^^^
//│ ╟── but it flows into reference with expected type `Str`
//│ ║  l.550: 	    qq = foo
//│ ║         	         ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.547: 	class QQ(qq: Str) {
//│ ╙──       	             ^^^
//│ class QQ(qq: Str) {
//│   constructor(foo: Int)
//│ }
//│ Code generation encountered an error:
//│   unresolved symbol lol

