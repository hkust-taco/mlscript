:NewDefs


:js
fun foo =
  fun bar(x) = x + 1
  bar(10)
//│ fun foo: Int
//│ // Prelude
//│ let res;
//│ class TypingUnit {}
//│ const typing_unit = new TypingUnit;
//│ // Query 1
//│ globalThis.foo = function foo() {
//│   return ((() => {
//│     let bar = (x) => x + 1;
//│     return bar(10);
//│   })());
//│ };
//│ // End of generated code

fun foo =
  class C(a: int) { fun bar(x) = a + x + 1 }
  C(100).bar(10)
foo
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.23: 	  class C(a: int) { fun bar(x) = a + x + 1 }
//│ ║        	                                 ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.23: 	  class C(a: int) { fun bar(x) = a + x + 1 }
//│ ║        	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.23: 	  class C(a: int) { fun bar(x) = a + x + 1 }
//│ ╙──      	                                 ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.24: 	  C(100).bar(10)
//│ ║        	  ^^^^^^
//│ ╟── integer literal of type `100` is not an instance of type `int`
//│ ║  l.24: 	  C(100).bar(10)
//│ ║        	    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.23: 	  class C(a: int) { fun bar(x) = a + x + 1 }
//│ ╙──      	             ^^^
//│ fun foo: Int | error
//│ Int | error
//│ res
//│     = [Function: foo1]

fun main =
  mixin B { log(1) }
  log(0)
  module M extends B
  log(2)
main
//│ fun main: unit
//│ unit
//│ res
//│     = [Function: main]
