:js
n = 123 with { x = 1 }
//│ // Prelude
//│ function withConstruct(target, fields) {
//│   if (typeof target === "string" || typeof target === "number" || typeof target === "boolean" || typeof target === "bigint" || typeof target === "symbol") {
//│     return Object.assign(target, fields);
//│   }
//│   if (target instanceof String || target instanceof Number || target instanceof Boolean || target instanceof BigInt) {
//│     return Object.assign(target.valueOf(), target, fields);
//│   }
//│   const copy = Object.assign({}, target, fields);
//│   Object.setPrototypeOf(copy, Object.getPrototypeOf(target));
//│   return copy;
//│ }
//│ function id(x) {
//│   return x;
//│ }
//│ function succ(x) {
//│   return x + 1;
//│ }
//│ function add(x, y) {
//│   if (arguments.length === 2) {
//│     return x + y;
//│   }else {
//│     return (y) => (x + y);
//│   }
//│ }
//│ function mul(x, y) {
//│   if (arguments.length === 2) {
//│     return x * y;
//│   }else {
//│     return (y) => (x * y);
//│   }
//│ }
//│ function gt(x, y) {
//│   if (arguments.length === 2) {
//│     return x > y;
//│   }else {
//│     return (y) => (x > y);
//│   }
//│ }
//│ function not(x) {
//│   return !x;
//│ }
//│ let res;
//│ // Query 1
//│ const n = withConstruct(123, { 
//│ x: 1
//│  });
//│ res = n;
//│ // End of generated code
//│ n: 123 & {x: 1}
//│  = [Number: 123] { x: 1 }

// `withConstruct` should works on extended primitive values.
m = n with { y = 2 }
//│ m: 123 & {x: 1, y: 2}
//│  = [Number: 123] { x: 1, y: 2 }

// `m` should work well with following operations.
m.x
m.y
m + 1
//│ res: 1
//│    = 1
//│ res: 2
//│    = 2
//│ res: int
//│    = 124
