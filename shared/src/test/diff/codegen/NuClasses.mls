:NewDefs

:js
class Test(n: int) {
  fun inc = Test(n + 1)
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.5: 	  fun inc = Test(n + 1)
//│ ║       	                 ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.5: 	  fun inc = Test(n + 1)
//│ ╙──     	                     ^
//│ class Test(n: int) {
//│   fun inc: Test
//│ }
//│ // Prelude
//│ let res;
//│ class TypingUnit {
//│   #Test;
//│   constructor() {
//│   }
//│   get Test() {
//│     const outer = this;
//│     if (this.#Test === undefined) {
//│       class Test {
//│         #n;
//│         get n() { return this.#n; }
//│         constructor(n) {
//│           this.#n = n;
//│         }
//│         get inc() {
//│           const n = this.#n;
//│           return outer.Test(n + 1);
//│         }
//│       };
//│       this.#Test = ((n) => new Test(n));
//│       this.#Test.class = Test;
//│     }
//│     return this.#Test;
//│   }
//│ }
//│ const typing_unit = new TypingUnit;
//│ globalThis.Test = typing_unit.Test;
//│ // End of generated code

Test(0).inc.n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.46: 	Test(0).inc.n
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.46: 	Test(0).inc.n
//│ ║        	     ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.4: 	class Test(n: int) {
//│ ╙──     	              ^^^
//│ error | int
//│ res
//│     = 1

class Test2(n: int) {
  fun inc = Test3.inc(n)
}
module Test3 {
  fun inc(n) = Test2(n + 1)
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.64: 	  fun inc(n) = Test2(n + 1)
//│ ║        	                     ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.64: 	  fun inc(n) = Test2(n + 1)
//│ ╙──      	                         ^
//│ class Test2(n: int) {
//│   fun inc: Test2 | error
//│ }
//│ module Test3() {
//│   fun inc: int -> Test2
//│ }

Test2(0).inc.n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	Test2(0).inc.n
//│ ║        	^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.79: 	Test2(0).inc.n
//│ ║        	      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.60: 	class Test2(n: int) {
//│ ╙──      	               ^^^
//│ error | int
//│ res
//│     = 1

class C[A](n: A) {
  fun f = g
  fun g = n
}
//│ class C[A](n: A) {
//│   fun f: A
//│   fun g: A
//│ }

:e
let a = C[int](42)
a.f
//│ ╔══[ERROR] Type application syntax is not yet supported
//│ ║  l.103: 	let a = C[int](42)
//│ ╙──       	        ^^^^^^
//│ let a: error
//│ error
//│ a
//│   = C {}
//│ res
//│     = 42


module Foo {
  fun f = C0()
  class C0()
}
//│ module Foo() {
//│   class C0()
//│   fun f: C0
//│ }


mixin M0(n: int) {
  let m = n // this refers to specifically the `n` we had in parameter, not necessarily this.n
  fun bar = m
  fun foo = [n, m, bar] // should this be the same as `[this.n, this.m, this.bar]`?
}
//│ mixin M0(n: int) {
//│   fun bar: int
//│   fun foo: (int, int, int,)
//│   let m: int
//│ }

module M1 extends M0(123) {
  fun n = "n"
  fun m = "m"
  fun bar = "bar"
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.137: 	module M1 extends M0(123) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.138: 	  fun n = "n"
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.139: 	  fun m = "m"
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.140: 	  fun bar = "bar"
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.141: 	}
//│ ║         	^
//│ ╟── integer literal of type `123` is not an instance of type `int`
//│ ║  l.137: 	module M1 extends M0(123) {
//│ ║         	                     ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.126: 	mixin M0(n: int) {
//│ ╙──       	            ^^^
//│ module M1() {
//│   fun bar: "bar"
//│   fun foo: (int, int, int,)
//│   fun m: "m"
//│   fun n: "n"
//│ }

[M1.n, M1.m, M1.bar]
//│ ("n", "m", "bar",)
//│ res
//│     = [ 'n', 'm', 'bar' ]

// FIXME typing/runtime mismatch
M1.foo
//│ (int, int, int,)
//│ res
//│     = [ 123, 'm', 'bar' ]

:e
:js
module M2 {
  let m = 100
  fun foo(y) =
    fun bar(x) = x + y + this.m
    bar(10)
}
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.182: 	    fun bar(x) = x + y + this.m
//│ ╙──       	                             ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.183: 	    bar(10)
//│ ║         	    ^^^^^^^
//│ ╟── integer literal of type `10` is not an instance of type `int`
//│ ║  l.183: 	    bar(10)
//│ ║         	        ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.182: 	    fun bar(x) = x + y + this.m
//│ ╙──       	                 ^
//│ module M2() {
//│   fun foo: int -> (error | int)
//│   let m: 100
//│ }
//│ // Prelude
//│ class TypingUnit11 {
//│   #M2;
//│   constructor() {
//│   }
//│   get M2() {
//│     const outer = this;
//│     if (this.#M2 === undefined) {
//│       class M2 {
//│         #m;
//│         get m() { return this.#m; }
//│         constructor() {
//│           this.#m = 100;
//│           const m = this.#m;
//│         }
//│         foo(y) {
//│           const self = this;
//│           return ((() => {
//│             let bar = (x) => x + y + self.m;
//│             return bar(10);
//│           })());
//│         }
//│       }
//│       this.#M2 = new M2();
//│       this.#M2.class = M2;
//│     }
//│     return this.#M2;
//│   }
//│ }
//│ const typing_unit11 = new TypingUnit11;
//│ globalThis.M2 = typing_unit11.M2;
//│ // End of generated code

M2.foo(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.234: 	M2.foo(1)
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.234: 	M2.foo(1)
//│ ║         	       ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.182: 	    fun bar(x) = x + y + this.m
//│ ╙──       	                     ^
//│ error | int
//│ res
//│     = 111

