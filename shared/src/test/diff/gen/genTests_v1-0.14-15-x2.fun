// Automatically generated by mlscript.EnumeratePrograms — DO NOT EDIT

:AllowTypeErrors
:ShowRelativeLineNums


0
//│ res: 0

add
//│ res: int -> int -> int

(0 0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(0 0)
//│ ║        	 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(0 0)
//│ ╙──      	 ^
//│ res: error



(0 add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(0 add)
//│ ║        	 ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(0 add)
//│ ╙──      	 ^
//│ res: error



(0 {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(0 {u: 0})
//│ ║        	 ^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(0 {u: 0})
//│ ╙──      	 ^
//│ res: error



(0 {u: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(0 {u: add})
//│ ║        	 ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(0 {u: add})
//│ ╙──      	 ^
//│ res: error



(add 0)
//│ res: int -> int

(add add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(add add)
//│ ║        	 ^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	(add add)
//│ ╙──      	     ^^^
//│ res: int -> int | error



(add 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add 0.u)
//│ ║        	      ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(add 0.u)
//│ ╙──      	     ^
//│ res: int -> int



(add add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add add.u)
//│ ║        	        ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(add add.u)
//│ ╙──      	     ^^^
//│ res: int -> int



(add 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add 0.v)
//│ ║        	      ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(add 0.v)
//│ ╙──      	     ^
//│ res: int -> int



(add add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add add.v)
//│ ║        	        ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(add add.v)
//│ ╙──      	     ^^^
//│ res: int -> int



(add {v: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(add {v: 0})
//│ ║        	 ^^^^^^^^^^
//│ ╟── record of type `{v: 0}` is not an instance of type `int`
//│ ║  l.+1: 	(add {v: 0})
//│ ╙──      	     ^^^^^^
//│ res: int -> int | error



(add {v: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(add {v: add})
//│ ║        	 ^^^^^^^^^^^^
//│ ╟── record of type `{v: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	(add {v: add})
//│ ╙──      	     ^^^^^^^^
//│ res: int -> int | error



(add {v: 0.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add {v: 0.v})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(add {v: 0.v})
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(add {v: 0.v})
//│ ║        	 ^^^^^^^^^^^^
//│ ╟── record of type `{v: ?v}` is not an instance of type `int`
//│ ║  l.+1: 	(add {v: 0.v})
//│ ╙──      	     ^^^^^^^^
//│ res: int -> int | error





(add {v: add.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(add {v: add.v})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(add {v: add.v})
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(add {v: add.v})
//│ ║        	 ^^^^^^^^^^^^^^
//│ ╟── record of type `{v: ?v}` is not an instance of type `int`
//│ ║  l.+1: 	(add {v: add.v})
//│ ╙──      	     ^^^^^^^^^^
//│ res: int -> int | error





((x => 0) 0)
//│ res: 0

((x => 0) add)
//│ res: 0

((x => 0) {u: 0})
//│ res: 0

((x => 0) {u: 0, v: 0})
//│ res: 0

((x => 0) {u: 0, v: add})
//│ res: 0

((x => 0) {u: add})
//│ res: 0

((x => add) 0)
//│ res: int -> int -> int

((x => add) add)
//│ res: int -> int -> int

((x => add) 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) 0.u)
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => add) 0.u)
//│ ╙──      	            ^
//│ res: int -> int -> int



((x => add) add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) add.u)
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add) add.u)
//│ ╙──      	            ^^^
//│ res: int -> int -> int



((x => add) {u: 0})
//│ res: int -> int -> int

((x => add) {u: add})
//│ res: int -> int -> int

((x => add) {u: add, v: 0})
//│ res: int -> int -> int

((x => add) {u: add, v: add})
//│ res: int -> int -> int

((x => add) {u: 0.u})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) {u: 0.u})
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => add) {u: 0.u})
//│ ╙──      	                ^
//│ res: int -> int -> int



((x => add) {u: add.u})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) {u: add.u})
//│ ║        	                   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add) {u: add.u})
//│ ╙──      	                ^^^
//│ res: int -> int -> int



((x => add) 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) 0.v)
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	((x => add) 0.v)
//│ ╙──      	            ^
//│ res: int -> int -> int



((x => add) add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add) add.v)
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	((x => add) add.v)
//│ ╙──      	            ^^^
//│ res: int -> int -> int



((let x = 0; add) 0)
//│ res: int -> int

((let x = 0; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) add)
//│ ╙──      	                  ^^^
//│ res: int -> int | error



((let x = 0; add) (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (0 0))
//│ ║        	                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = 0; add) (0 0))
//│ ╙──      	                   ^
//│ res: int -> int



((let x = 0; add) (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (0 add))
//│ ║        	                   ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = 0; add) (0 add))
//│ ╙──      	                   ^
//│ res: int -> int



((let x = 0; add) (x => 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (x => 0))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> 0` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => 0))
//│ ║        	                   ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => 0))
//│ ╙──      	                  ^^^^^^^^
//│ res: int -> int | error




((let x = 0; add) (let x = 0; 0))
//│ res: int -> int

((let x = 0; add) (let x = add; 0))
//│ res: int -> int

((let x = 0; add) (let rec x = x; 0))
//│ res: int -> int

((let x = 0; add) (let x = 0.u; 0))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = 0; add) (let x = 0.u; 0))
//│ ║        	                            ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((let x = 0; add) (let x = 0.u; 0))
//│ ╙──      	                           ^
//│ res: int -> int



((let x = 0; add) (let x = add.u; 0))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = 0; add) (let x = add.u; 0))
//│ ║        	                              ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((let x = 0; add) (let x = add.u; 0))
//│ ╙──      	                           ^^^
//│ res: int -> int



((let x = 0; add) (let rec x = x.u; 0))
//│ res: int -> int

((let x = 0; add) (x => add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (x => add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => add))
//│ ║        	                   ^^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => add))
//│ ╙──      	                  ^^^^^^^^^^
//│ res: int -> int | error




((let x = 0; add) (x => x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (x => x))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?a` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => x))
//│ ║        	                   ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = 0; add) (x => x))
//│ ╙──      	                  ^^^^^^^^
//│ res: int -> int | error




((let x = 0; add) (let x = 0; x))
//│ res: int -> int

((let x = 0; add) (let x = add; x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) (let x = add; x))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) (let x = add; x))
//│ ║        	                           ^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.+1: 	((let x = 0; add) (let x = add; x))
//│ ╙──      	                                ^
//│ res: int -> int | error




((let x = 0; add) (let rec x = x; x))
//│ res: int -> int

((let x = 0; add) 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = 0; add) 0.u)
//│ ║        	                   ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((let x = 0; add) 0.u)
//│ ╙──      	                  ^
//│ res: int -> int



((let x = 0; add) add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = 0; add) add.u)
//│ ║        	                     ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((let x = 0; add) add.u)
//│ ╙──      	                  ^^^
//│ res: int -> int



((let x = 0; add) {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) {u: 0})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{u: 0}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) {u: 0})
//│ ╙──      	                  ^^^^^^
//│ res: int -> int | error



((let x = 0; add) {u: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) {u: add})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{u: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) {u: add})
//│ ╙──      	                  ^^^^^^^^
//│ res: int -> int | error



((let x = 0; add) {v: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) {v: 0})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: 0}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) {v: 0})
//│ ╙──      	                  ^^^^^^
//│ res: int -> int | error



((let x = 0; add) {v: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = 0; add) {v: add})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = 0; add) {v: add})
//│ ╙──      	                  ^^^^^^^^
//│ res: int -> int | error



((let x = add; add) 0)
//│ res: int -> int

((let x = add; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) add)
//│ ╙──      	                    ^^^
//│ res: int -> int | error



((let x = add; add) (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (0 0))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) (0 0))
//│ ╙──      	                     ^
//│ res: int -> int



((let x = add; add) (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (0 add))
//│ ║        	                     ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) (0 add))
//│ ╙──      	                     ^
//│ res: int -> int



((let x = add; add) (0 {u: 0}))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (0 {u: 0}))
//│ ║        	                     ^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) (0 {u: 0}))
//│ ╙──      	                     ^
//│ res: int -> int



((let x = add; add) (0 {u: add}))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (0 {u: add}))
//│ ║        	                     ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) (0 {u: add}))
//│ ╙──      	                     ^
//│ res: int -> int



((let x = add; add) ((0 add) 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) ((0 add) 0))
//│ ║        	                      ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) ((0 add) 0))
//│ ╙──      	                      ^
//│ res: int -> int



((let x = add; add) ((0 add) add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) ((0 add) add))
//│ ║        	                      ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((let x = add; add) ((0 add) add))
//│ ╙──      	                      ^
//│ res: int -> int



((let x = add; add) (x => 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (x => 0))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> 0` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (x => 0))
//│ ║        	                     ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (x => 0))
//│ ╙──      	                    ^^^^^^^^
//│ res: int -> int | error




((let x = add; add) (let x = 0; 0))
//│ res: int -> int

((let x = add; add) (let x = add; 0))
//│ res: int -> int

((let x = add; add) (let rec x = x; 0))
//│ res: int -> int

((let x = add; add) (x => add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (x => add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (x => add))
//│ ║        	                     ^^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (x => add))
//│ ╙──      	                    ^^^^^^^^^^
//│ res: int -> int | error




((let x = add; add) (let x = 0; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (let x = 0; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (let x = 0; add))
//│ ║        	                                ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (let x = 0; add))
//│ ╙──      	                    ^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = add; add) (let x = add; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (let x = add; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (let x = add; add))
//│ ║        	                                  ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (let x = add; add))
//│ ╙──      	                    ^^^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = add; add) (let rec x = x; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (let rec x = x; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (let rec x = x; add))
//│ ║        	                                    ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (let rec x = x; add))
//│ ╙──      	                    ^^^^^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = add; add) (x => x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = add; add) (x => x))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?a` is not an instance of type `int`
//│ ║  l.+1: 	((let x = add; add) (x => x))
//│ ║        	                     ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = add; add) (x => x))
//│ ╙──      	                    ^^^^^^^^
//│ res: int -> int | error




((let rec x = x; add) 0)
//│ res: int -> int

((let rec x = x; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) add)
//│ ╙──      	                      ^^^
//│ res: int -> int | error



((let rec x = x; add) 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let rec x = x; add) 0.u)
//│ ║        	                       ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((let rec x = x; add) 0.u)
//│ ╙──      	                      ^
//│ res: int -> int



((let rec x = x; add) add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let rec x = x; add) add.u)
//│ ║        	                         ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((let rec x = x; add) add.u)
//│ ╙──      	                      ^^^
//│ res: int -> int



((let rec x = x; add) {u: 0}.u)
//│ res: int -> int

((let rec x = x; add) {u: add}.u)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) {u: add}.u)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) {u: add}.u)
//│ ║        	                          ^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.+1: 	((let rec x = x; add) {u: add}.u)
//│ ╙──      	                              ^^
//│ res: int -> int | error




((let rec x = x; add) {v: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) {v: 0})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: 0}` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) {v: 0})
//│ ╙──      	                      ^^^^^^
//│ res: int -> int | error



((let rec x = x; add) {v: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) {v: add})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) {v: add})
//│ ╙──      	                      ^^^^^^^^
//│ res: int -> int | error



((let rec x = x; add) {v: 0.u})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let rec x = x; add) {v: 0.u})
//│ ║        	                           ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((let rec x = x; add) {v: 0.u})
//│ ╙──      	                          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) {v: 0.u})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: ?u}` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) {v: 0.u})
//│ ╙──      	                      ^^^^^^^^
//│ res: int -> int | error





((let rec x = x; add) {v: add.u})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let rec x = x; add) {v: add.u})
//│ ║        	                             ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((let rec x = x; add) {v: add.u})
//│ ╙──      	                          ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = x; add) {v: add.u})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: ?u}` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = x; add) {v: add.u})
//│ ╙──      	                      ^^^^^^^^^^
//│ res: int -> int | error





((let x = {v: 0}; add) 0)
//│ res: int -> int

((let x = {v: 0}; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) add)
//│ ╙──      	                       ^^^
//│ res: int -> int | error



((let x = {v: 0}; add) (add 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (add 0))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (add 0))
//│ ║        	                        ^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (add 0))
//│ ╙──      	                       ^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (add add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (add add))
//│ ║        	                        ^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (add add))
//│ ╙──      	                            ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (add add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (add add))
//│ ║        	                        ^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (add add))
//│ ╙──      	                       ^^^^^^^^^
//│ res: int -> int | error






((let x = {v: 0}; add) (x => 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> 0` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0))
//│ ║        	                        ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0))
//│ ╙──      	                       ^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (let x = 0; 0))
//│ res: int -> int

((let x = {v: 0}; add) (let x = add; 0))
//│ res: int -> int

((let x = {v: 0}; add) (let rec x = x; 0))
//│ res: int -> int

((let x = {v: 0}; add) (x => add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add))
//│ ║        	                        ^^^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add))
//│ ╙──      	                       ^^^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (let x = 0; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = 0; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = 0; add))
//│ ║        	                                   ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = 0; add))
//│ ╙──      	                       ^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (let x = add; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = add; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = add; add))
//│ ║        	                                     ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let x = add; add))
//│ ╙──      	                       ^^^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (let rec x = x; add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (let rec x = x; add))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let rec x = x; add))
//│ ║        	                                       ^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (let rec x = x; add))
//│ ╙──      	                       ^^^^^^^^^^^^^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) (x => x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x))
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?a` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x))
//│ ║        	                        ^^^^^^
//│ ╟── but it flows into argument with expected type `int`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x))
//│ ╙──      	                       ^^^^^^^^
//│ res: int -> int | error




((let x = {v: 0}; add) 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = {v: 0}; add) 0.v)
//│ ║        	                        ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	((let x = {v: 0}; add) 0.v)
//│ ╙──      	                       ^
//│ res: int -> int



((let x = {v: 0}; add) add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = {v: 0}; add) add.v)
//│ ║        	                          ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	((let x = {v: 0}; add) add.v)
//│ ╙──      	                       ^^^
//│ res: int -> int



((let x = {v: 0}; add) (x => 0).v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0).v)
//│ ║        	                               ^^
//│ ╟── function of type `?a -> 0` does not have field 'v'
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0).v)
//│ ║        	                        ^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => 0).v)
//│ ╙──      	                       ^^^^^^^^
//│ res: int -> int




((let x = {v: 0}; add) (x => add).v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add).v)
//│ ║        	                                 ^^
//│ ╟── function of type `?a -> int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add).v)
//│ ║        	                        ^^^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => add).v)
//│ ╙──      	                       ^^^^^^^^^^
//│ res: int -> int




((let x = {v: 0}; add) (x => x).v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x).v)
//│ ║        	                               ^^
//│ ╟── function of type `?a -> ?a` does not have field 'v'
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x).v)
//│ ║        	                        ^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	((let x = {v: 0}; add) (x => x).v)
//│ ╙──      	                       ^^^^^^^^
//│ res: int -> int




((let x = {v: add}; add) 0)
//│ res: int -> int

((let x = {v: add}; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: add}; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: add}; add) add)
//│ ╙──      	                         ^^^
//│ res: int -> int | error



((let x = {v: add}; add) {v: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: add}; add) {v: 0})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: 0}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: add}; add) {v: 0})
//│ ╙──      	                         ^^^^^^
//│ res: int -> int | error



((let x = {v: add}; add) {v: add})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let x = {v: add}; add) {v: add})
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record of type `{v: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	((let x = {v: add}; add) {v: add})
//│ ╙──      	                         ^^^^^^^^
//│ res: int -> int | error



((let rec x = {v: x}; add) 0)
//│ res: int -> int

((let rec x = {v: x}; add) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((let rec x = {v: x}; add) add)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	((let rec x = {v: x}; add) add)
//│ ╙──      	                           ^^^
//│ res: int -> int | error



((x => x) 0)
//│ res: 0

((x => x) add)
//│ res: int -> int -> int

((x => x) (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x) (0 0))
//│ ║        	           ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((x => x) (0 0))
//│ ╙──      	           ^
//│ res: error



((x => x) (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x) (0 add))
//│ ║        	           ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((x => x) (0 add))
//│ ╙──      	           ^
//│ res: error



((x => x) (0 (x => 0)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x) (0 (x => 0)))
//│ ║        	           ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((x => x) (0 (x => 0)))
//│ ╙──      	           ^
//│ res: error



((x => x) (0 (x => add)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x) (0 (x => add)))
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((x => x) (0 (x => add)))
//│ ╙──      	           ^
//│ res: error



((x => x) (0 (x => x)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x) (0 (x => x)))
//│ ║        	           ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	((x => x) (0 (x => x)))
//│ ╙──      	           ^
//│ res: error



((x => x) {v: 0})
//│ res: {v: 0}

((x => x) {v: add})
//│ res: {v: int -> int -> int}

((x => 0.u) 0)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => 0.u) 0)
//│ ║        	        ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => 0.u) 0)
//│ ╙──      	       ^
//│ res: error



((x => 0.u) add)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => 0.u) add)
//│ ║        	        ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => 0.u) add)
//│ ╙──      	       ^
//│ res: error



((x => add.u) 0)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) 0)
//│ ║        	          ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) 0)
//│ ╙──      	       ^^^
//│ res: error



((x => add.u) add)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) add)
//│ ║        	          ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) add)
//│ ╙──      	       ^^^
//│ res: error



((x => add.u) 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) 0.u)
//│ ║        	          ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) 0.u)
//│ ╙──      	       ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) 0.u)
//│ ║        	               ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) 0.u)
//│ ╙──      	              ^
//│ res: error





((x => add.u) add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) add.u)
//│ ║        	          ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) add.u)
//│ ╙──      	       ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => add.u) add.u)
//│ ║        	                 ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => add.u) add.u)
//│ ╙──      	              ^^^
//│ res: error





((x => x.u) 0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x.u) 0)
//│ ║        	 ^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) 0)
//│ ║        	            ^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+1: 	((x => x.u) 0)
//│ ║        	        ^^
//│ ╟── from reference:
//│ ║  l.+1: 	((x => x.u) 0)
//│ ╙──      	       ^
//│ res: error





((x => x.u) add)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x.u) add)
//│ ║        	 ^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) add)
//│ ║        	            ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+1: 	((x => x.u) add)
//│ ║        	        ^^
//│ ╟── from reference:
//│ ║  l.+1: 	((x => x.u) add)
//│ ╙──      	       ^
//│ res: error





((x => x.u) 0.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => x.u) 0.u)
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) 0.u)
//│ ╙──      	            ^
//│ res: error



((x => x.u) add.u)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	((x => x.u) add.u)
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) add.u)
//│ ╙──      	            ^^^
//│ res: error



((x => x.u) {u: 0}.u)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x.u) {u: 0}.u)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) {u: 0}.u)
//│ ║        	                ^
//│ ╟── but it flows into field selection with expected type `{u: ?u}`
//│ ║  l.+1: 	((x => x.u) {u: 0}.u)
//│ ║        	                  ^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+1: 	((x => x.u) {u: 0}.u)
//│ ║        	        ^^
//│ ╟── from reference:
//│ ║  l.+1: 	((x => x.u) {u: 0}.u)
//│ ╙──      	       ^
//│ res: error






((x => x.u) {u: add}.u)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	((x => x.u) {u: add}.u)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	((x => x.u) {u: add}.u)
//│ ║        	                ^^^
//│ ╟── but it flows into field selection with expected type `{u: ?u}`
//│ ║  l.+1: 	((x => x.u) {u: add}.u)
//│ ║        	                    ^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+1: 	((x => x.u) {u: add}.u)
//│ ║        	        ^^
//│ ╟── from reference:
//│ ║  l.+1: 	((x => x.u) {u: add}.u)
//│ ╙──      	       ^
//│ res: error






(x => 0)
//│ res: anything -> 0

(let x = 0; 0)
//│ res: 0

(let x = add; 0)
//│ res: 0

(let rec x = x; 0)
//│ res: 0

(let x = 0.u; 0)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; 0)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; 0)
//│ ╙──      	         ^
//│ res: 0



(let x = add.u; 0)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; 0)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; 0)
//│ ╙──      	         ^^^
//│ res: 0



(let rec x = x.u; 0)
//│ res: 0

(x => add)
//│ res: anything -> int -> int -> int

(let x = 0; add)
//│ res: int -> int -> int

(let x = add; add)
//│ res: int -> int -> int

(let rec x = x; add)
//│ res: int -> int -> int

(let x = 0.v; add)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; add)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; add)
//│ ╙──      	         ^
//│ res: int -> int -> int



(let x = add.v; add)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; add)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; add)
//│ ╙──      	         ^^^
//│ res: int -> int -> int



(let rec x = x.v; add)
//│ res: int -> int -> int

(x => x)
//│ res: 'a -> 'a

(let x = 0; x)
//│ res: 0

(let x = add; x)
//│ res: int -> int -> int

(let rec x = x; x)
//│ res: nothing

(let x = (0 0); x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); x)
//│ ║        	          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); x)
//│ ╙──      	          ^
//│ res: error



(let x = (0 add); x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); x)
//│ ║        	          ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); x)
//│ ╙──      	          ^
//│ res: error



(let rec x = (0 x); x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); x)
//│ ║        	              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); x)
//│ ╙──      	              ^
//│ res: error



(let x = 0.u; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; x)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; x)
//│ ╙──      	         ^
//│ res: error



(let x = add.u; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; x)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; x)
//│ ╙──      	         ^^^
//│ res: error



(let rec x = x.u; x)
//│ res: nothing

(let x = {v: 0}.u; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: 0}.u; x)
//│ ║        	               ^^
//│ ╟── record of type `{v: 0}` does not have field 'u'
//│ ║  l.+1: 	(let x = {v: 0}.u; x)
//│ ╙──      	         ^^^^^^
//│ res: error



(let x = {v: add}.u; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: add}.u; x)
//│ ║        	                 ^^
//│ ╟── record of type `{v: int -> int -> int}` does not have field 'u'
//│ ║  l.+1: 	(let x = {v: add}.u; x)
//│ ╙──      	         ^^^^^^^^
//│ res: error



(let rec x = {v: x}.u; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = {v: x}.u; x)
//│ ║        	                   ^^
//│ ╟── record of type `{v: ?x}` does not have field 'u'
//│ ║  l.+1: 	(let rec x = {v: x}.u; x)
//│ ╙──      	             ^^^^^^
//│ res: error



(let x = {u: 0}; x)
//│ res: {u: 0}

(let x = {u: 0, v: 0}; x)
//│ res: {u: 0, v: 0}

(let x = {u: 0, v: add}; x)
//│ res: {u: 0, v: int -> int -> int}

(let rec x = {u: 0, v: x}; x)
//│ res: 'x
//│   where
//│     'x :> {u: 0, v: 'x}

(let x = {u: 0, v: 0.v}; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: 0, v: 0.v}; x)
//│ ║        	                    ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: 0, v: 0.v}; x)
//│ ╙──      	                   ^
//│ res: {u: 0, v: error}



(let x = {u: 0, v: add.v}; x)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: 0, v: add.v}; x)
//│ ║        	                      ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: 0, v: add.v}; x)
//│ ╙──      	                   ^^^
//│ res: {u: 0, v: error}



(let rec x = {u: 0, v: x.v}; x)
//│ res: {u: 0, v: nothing}

(let x = {u: add}; x)
//│ res: {u: int -> int -> int}

(let rec x = {u: x}; x)
//│ res: 'x
//│   where
//│     'x :> {u: 'x}

(x => (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(x => (0 0))
//│ ║        	       ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(x => (0 0))
//│ ╙──      	       ^
//│ res: anything -> error



(let x = 0; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = 0; (0 0))
//│ ║        	             ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = 0; (0 0))
//│ ╙──      	             ^
//│ res: error



(let x = add; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = add; (0 0))
//│ ║        	               ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = add; (0 0))
//│ ╙──      	               ^
//│ res: error



(let rec x = x; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = x; (0 0))
//│ ║        	                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = x; (0 0))
//│ ╙──      	                 ^
//│ res: error



(let x = (0 0); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); (0 0))
//│ ║        	          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); (0 0))
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); (0 0))
//│ ║        	                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); (0 0))
//│ ╙──      	                 ^
//│ res: error





(let x = (0 add); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); (0 0))
//│ ║        	          ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); (0 0))
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); (0 0))
//│ ║        	                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); (0 0))
//│ ╙──      	                   ^
//│ res: error





(let rec x = (0 x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); (0 0))
//│ ║        	              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); (0 0))
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); (0 0))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); (0 0))
//│ ╙──      	                     ^
//│ res: error





(let x = (y => 0); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => 0); (0 0))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => 0); (0 0))
//│ ╙──      	                    ^
//│ res: error



(let x = (y => add); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => add); (0 0))
//│ ║        	                      ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => add); (0 0))
//│ ╙──      	                      ^
//│ res: error



(let x = (y => y); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => y); (0 0))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => y); (0 0))
//│ ╙──      	                    ^
//│ res: error



(let x = (let y = 0; y); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let y = 0; y); (0 0))
//│ ║        	                          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let y = 0; y); (0 0))
//│ ╙──      	                          ^
//│ res: error



(let x = (let y = add; y); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let y = add; y); (0 0))
//│ ║        	                            ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let y = add; y); (0 0))
//│ ╙──      	                            ^
//│ res: error



(let x = (let rec y = y; y); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let rec y = y; y); (0 0))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let rec y = y; y); (0 0))
//│ ╙──      	                              ^
//│ res: error



(let rec x = (let y = x; y); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = x; y); (0 0))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = x; y); (0 0))
//│ ╙──      	                              ^
//│ res: error



(let rec x = (y => x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (y => x); (0 0))
//│ ║        	                        ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (y => x); (0 0))
//│ ╙──      	                        ^
//│ res: error



(let rec x = (let y = 0; x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = 0; x); (0 0))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = 0; x); (0 0))
//│ ╙──      	                              ^
//│ res: error



(let rec x = (let y = add; x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = add; x); (0 0))
//│ ║        	                                ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = add; x); (0 0))
//│ ╙──      	                                ^
//│ res: error



(let rec x = (let rec y = y; x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let rec y = y; x); (0 0))
//│ ║        	                                  ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let rec y = y; x); (0 0))
//│ ╙──      	                                  ^
//│ res: error



(let rec x = (let y = x; x); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = x; x); (0 0))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = x; x); (0 0))
//│ ╙──      	                              ^
//│ res: error



(let x = (y => (z => 0)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => (z => 0)); (0 0))
//│ ║        	                           ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => (z => 0)); (0 0))
//│ ╙──      	                           ^
//│ res: error



(let x = (y => (z => add)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => (z => add)); (0 0))
//│ ║        	                             ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => (z => add)); (0 0))
//│ ╙──      	                             ^
//│ res: error



(let x = (y => (z => z)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => (z => z)); (0 0))
//│ ║        	                           ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => (z => z)); (0 0))
//│ ╙──      	                           ^
//│ res: error



(let x = (y => (z => y)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => (z => y)); (0 0))
//│ ║        	                           ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => (z => y)); (0 0))
//│ ╙──      	                           ^
//│ res: error



(let x = (let y = 0; (z => y)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let y = 0; (z => y)); (0 0))
//│ ║        	                                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let y = 0; (z => y)); (0 0))
//│ ╙──      	                                 ^
//│ res: error



(let x = (let y = add; (z => y)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let y = add; (z => y)); (0 0))
//│ ║        	                                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let y = add; (z => y)); (0 0))
//│ ╙──      	                                   ^
//│ res: error



(let x = (let rec y = y; (z => y)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (let rec y = y; (z => y)); (0 0))
//│ ║        	                                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (let rec y = y; (z => y)); (0 0))
//│ ╙──      	                                     ^
//│ res: error



(let rec x = (let y = x; (z => y)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = x; (z => y)); (0 0))
//│ ║        	                                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = x; (z => y)); (0 0))
//│ ╙──      	                                     ^
//│ res: error



(let rec x = (y => (z => x)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (y => (z => x)); (0 0))
//│ ║        	                               ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (y => (z => x)); (0 0))
//│ ╙──      	                               ^
//│ res: error



(let rec x = (let y = 0; (z => x)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = 0; (z => x)); (0 0))
//│ ║        	                                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = 0; (z => x)); (0 0))
//│ ╙──      	                                     ^
//│ res: error



(let rec x = (let y = add; (z => x)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = add; (z => x)); (0 0))
//│ ║        	                                       ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = add; (z => x)); (0 0))
//│ ╙──      	                                       ^
//│ res: error



(let rec x = (let rec y = y; (z => x)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let rec y = y; (z => x)); (0 0))
//│ ║        	                                         ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let rec y = y; (z => x)); (0 0))
//│ ╙──      	                                         ^
//│ res: error



(let rec x = (let y = x; (z => x)); (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = x; (z => x)); (0 0))
//│ ║        	                                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = x; (z => x)); (0 0))
//│ ╙──      	                                     ^
//│ res: error



(let x = {u: 0}; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: 0}; (0 0))
//│ ║        	                  ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: 0}; (0 0))
//│ ╙──      	                  ^
//│ res: error



(let x = {u: add}; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: add}; (0 0))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: add}; (0 0))
//│ ╙──      	                    ^
//│ res: error



(let rec x = {u: x}; (0 0))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = {u: x}; (0 0))
//│ ║        	                      ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = {u: x}; (0 0))
//│ ╙──      	                      ^
//│ res: error



(x => (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(x => (0 add))
//│ ║        	       ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(x => (0 add))
//│ ╙──      	       ^
//│ res: anything -> error



(let x = 0; (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = 0; (0 add))
//│ ║        	             ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = 0; (0 add))
//│ ╙──      	             ^
//│ res: error



(let x = add; (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = add; (0 add))
//│ ║        	               ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = add; (0 add))
//│ ╙──      	               ^
//│ res: error



(let rec x = x; (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = x; (0 add))
//│ ║        	                 ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = x; (0 add))
//│ ╙──      	                 ^
//│ res: error



(let x = 0.v; (0 add))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; (0 add))
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; (0 add))
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = 0.v; (0 add))
//│ ║        	               ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = 0.v; (0 add))
//│ ╙──      	               ^
//│ res: error





(let x = add.v; (0 add))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; (0 add))
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; (0 add))
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = add.v; (0 add))
//│ ║        	                 ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = add.v; (0 add))
//│ ╙──      	                 ^
//│ res: error





(let rec x = x.v; (0 add))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = x.v; (0 add))
//│ ║        	                   ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = x.v; (0 add))
//│ ╙──      	                   ^
//│ res: error



(x => (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(x => (0 x))
//│ ║        	       ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(x => (0 x))
//│ ╙──      	       ^
//│ res: anything -> error



(let x = 0; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = 0; (0 x))
//│ ║        	             ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = 0; (0 x))
//│ ╙──      	             ^
//│ res: error



(let x = add; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = add; (0 x))
//│ ║        	               ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = add; (0 x))
//│ ╙──      	               ^
//│ res: error



(let rec x = x; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = x; (0 x))
//│ ║        	                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = x; (0 x))
//│ ╙──      	                 ^
//│ res: error



(let x = (0 0); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); (0 x))
//│ ║        	          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); (0 x))
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); (0 x))
//│ ║        	                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); (0 x))
//│ ╙──      	                 ^
//│ res: error





(let x = (0 add); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); (0 x))
//│ ║        	          ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); (0 x))
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); (0 x))
//│ ║        	                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); (0 x))
//│ ╙──      	                   ^
//│ res: error





(let rec x = (0 x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); (0 x))
//│ ║        	              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); (0 x))
//│ ╙──      	              ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); (0 x))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); (0 x))
//│ ╙──      	                     ^
//│ res: error





(let x = (add 0); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (add 0); (0 x))
//│ ║        	                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (add 0); (0 x))
//│ ╙──      	                   ^
//│ res: error



(let x = (add add); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (add add); (0 x))
//│ ║        	          ^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	(let x = (add add); (0 x))
//│ ╙──      	              ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (add add); (0 x))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (add add); (0 x))
//│ ╙──      	                     ^
//│ res: error





(let rec x = (add x); (0 x))
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	(let rec x = (add x); (0 x))
//│ ║        	             ^^^^^^^
//│ ╟── application of type `int -> int` is not an instance of type `int`
//│ ║  l.+1: 	(let rec x = (add x); (0 x))
//│ ║        	              ^^^^^
//│ ╟── Note: constraint arises from argument:
//│ ║  l.+1: 	(let rec x = (add x); (0 x))
//│ ╙──      	                  ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (add x); (0 x))
//│ ║        	                       ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (add x); (0 x))
//│ ╙──      	                       ^
//│ res: error






(let rec x = (x 0); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (x 0); (0 x))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (x 0); (0 x))
//│ ╙──      	                     ^
//│ res: error



(let rec x = (x add); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (x add); (0 x))
//│ ║        	                       ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (x add); (0 x))
//│ ╙──      	                       ^
//│ res: error



(let rec x = (x x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (x x); (0 x))
//│ ║        	                     ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (x x); (0 x))
//│ ╙──      	                     ^
//│ res: error



(let x = (y => 0); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => 0); (0 x))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => 0); (0 x))
//│ ╙──      	                    ^
//│ res: error



(let x = (y => add); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => add); (0 x))
//│ ║        	                      ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => add); (0 x))
//│ ╙──      	                      ^
//│ res: error



(let x = (y => y); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (y => y); (0 x))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (y => y); (0 x))
//│ ╙──      	                    ^
//│ res: error



(let rec x = (y => x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (y => x); (0 x))
//│ ║        	                        ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (y => x); (0 x))
//│ ╙──      	                        ^
//│ res: error



(let rec x = (let y = 0; x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = 0; x); (0 x))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = 0; x); (0 x))
//│ ╙──      	                              ^
//│ res: error



(let rec x = (let y = add; x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = add; x); (0 x))
//│ ║        	                                ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = add; x); (0 x))
//│ ╙──      	                                ^
//│ res: error



(let rec x = (let rec y = y; x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let rec y = y; x); (0 x))
//│ ║        	                                  ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let rec y = y; x); (0 x))
//│ ╙──      	                                  ^
//│ res: error



(let rec x = (let y = x; x); (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (let y = x; x); (0 x))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (let y = x; x); (0 x))
//│ ╙──      	                              ^
//│ res: error



(let x = {u: 0}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: 0}; (0 x))
//│ ║        	                  ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: 0}; (0 x))
//│ ╙──      	                  ^
//│ res: error



(let x = {u: add}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: add}; (0 x))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: add}; (0 x))
//│ ╙──      	                    ^
//│ res: error



(let x = {u: add, v: 0}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: add, v: 0}; (0 x))
//│ ║        	                          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: add, v: 0}; (0 x))
//│ ╙──      	                          ^
//│ res: error



(let x = {u: add, v: add}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {u: add, v: add}; (0 x))
//│ ║        	                            ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {u: add, v: add}; (0 x))
//│ ╙──      	                            ^
//│ res: error



(let rec x = {u: add, v: x}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = {u: add, v: x}; (0 x))
//│ ║        	                              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = {u: add, v: x}; (0 x))
//│ ╙──      	                              ^
//│ res: error



(let rec x = {u: x}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = {u: x}; (0 x))
//│ ║        	                      ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = {u: x}; (0 x))
//│ ╙──      	                      ^
//│ res: error



(let x = 0.v; (0 x))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; (0 x))
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; (0 x))
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = 0.v; (0 x))
//│ ║        	               ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = 0.v; (0 x))
//│ ╙──      	               ^
//│ res: error





(let x = add.v; (0 x))
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; (0 x))
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; (0 x))
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = add.v; (0 x))
//│ ║        	                 ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = add.v; (0 x))
//│ ╙──      	                 ^
//│ res: error





(let rec x = x.v; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = x.v; (0 x))
//│ ║        	                   ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = x.v; (0 x))
//│ ╙──      	                   ^
//│ res: error



(let x = {v: 0}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {v: 0}; (0 x))
//│ ║        	                  ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {v: 0}; (0 x))
//│ ╙──      	                  ^
//│ res: error



(let x = {v: add}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = {v: add}; (0 x))
//│ ║        	                    ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = {v: add}; (0 x))
//│ ╙──      	                    ^
//│ res: error



(let rec x = {v: x}; (0 x))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = {v: x}; (0 x))
//│ ║        	                      ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = {v: x}; (0 x))
//│ ╙──      	                      ^
//│ res: error



(x => {u: 0})
//│ res: anything -> {u: 0}

(let x = 0; {u: 0})
//│ res: {u: 0}

(let x = add; {u: 0})
//│ res: {u: 0}

(let rec x = x; {u: 0})
//│ res: {u: 0}

(let x = (0 0); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 0); {u: 0})
//│ ║        	          ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 0); {u: 0})
//│ ╙──      	          ^
//│ res: {u: 0}



(let x = (0 add); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 add); {u: 0})
//│ ║        	          ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 add); {u: 0})
//│ ╙──      	          ^
//│ res: {u: 0}



(let rec x = (0 x); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 x); {u: 0})
//│ ║        	              ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 x); {u: 0})
//│ ╙──      	              ^
//│ res: {u: 0}



(let x = (0 {v: 0}); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 {v: 0}); {u: 0})
//│ ║        	          ^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 {v: 0}); {u: 0})
//│ ╙──      	          ^
//│ res: {u: 0}



(let x = (0 {v: add}); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (0 {v: add}); {u: 0})
//│ ║        	          ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let x = (0 {v: add}); {u: 0})
//│ ╙──      	          ^
//│ res: {u: 0}



(let rec x = (0 {v: x}); {u: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let rec x = (0 {v: x}); {u: 0})
//│ ║        	              ^^^^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	(let rec x = (0 {v: x}); {u: 0})
//│ ╙──      	              ^
//│ res: {u: 0}



(let x = 0.u; {u: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; {u: 0})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; {u: 0})
//│ ╙──      	         ^
//│ res: {u: 0}



(let x = add.u; {u: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; {u: 0})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; {u: 0})
//│ ╙──      	         ^^^
//│ res: {u: 0}



(let rec x = x.u; {u: 0})
//│ res: {u: 0}

(let x = 0.u.u; {u: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u.u; {u: 0})
//│ ║        	            ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u.u; {u: 0})
//│ ╙──      	         ^
//│ res: {u: 0}



(let x = add.u.u; {u: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u.u; {u: 0})
//│ ║        	              ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u.u; {u: 0})
//│ ╙──      	         ^^^
//│ res: {u: 0}



(let rec x = x.u.u; {u: 0})
//│ res: {u: 0}

(x => {u: 0, v: 0})
//│ res: anything -> {u: 0, v: 0}

(let x = 0; {u: 0, v: 0})
//│ res: {u: 0, v: 0}

(let x = add; {u: 0, v: 0})
//│ res: {u: 0, v: 0}

(let rec x = x; {u: 0, v: 0})
//│ res: {u: 0, v: 0}

(let x = (add 0); {u: 0, v: 0})
//│ res: {u: 0, v: 0}

(let x = (add add); {u: 0, v: 0})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	(let x = (add add); {u: 0, v: 0})
//│ ║        	          ^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	(let x = (add add); {u: 0, v: 0})
//│ ╙──      	              ^^^
//│ res: {u: 0, v: 0}



(let rec x = (add x); {u: 0, v: 0})
//│ ╔══[ERROR] Type mismatch in binding of application:
//│ ║  l.+1: 	(let rec x = (add x); {u: 0, v: 0})
//│ ║        	             ^^^^^^^
//│ ╟── application of type `int -> int` is not an instance of type `int`
//│ ║  l.+1: 	(let rec x = (add x); {u: 0, v: 0})
//│ ║        	              ^^^^^
//│ ╟── Note: constraint arises from argument:
//│ ║  l.+1: 	(let rec x = (add x); {u: 0, v: 0})
//│ ╙──      	                  ^
//│ res: {u: 0, v: 0}




(let x = 0.u; {u: 0, v: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; {u: 0, v: 0})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; {u: 0, v: 0})
//│ ╙──      	         ^
//│ res: {u: 0, v: 0}



(let x = add.u; {u: 0, v: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; {u: 0, v: 0})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; {u: 0, v: 0})
//│ ╙──      	         ^^^
//│ res: {u: 0, v: 0}



(let rec x = x.u; {u: 0, v: 0})
//│ res: {u: 0, v: 0}

(x => {u: 0, v: add})
//│ res: anything -> {u: 0, v: int -> int -> int}

(let x = 0; {u: 0, v: add})
//│ res: {u: 0, v: int -> int -> int}

(let x = add; {u: 0, v: add})
//│ res: {u: 0, v: int -> int -> int}

(let rec x = x; {u: 0, v: add})
//│ res: {u: 0, v: int -> int -> int}

(x => {u: 0, v: x})
//│ res: 'a -> {u: 0, v: 'a}

(let x = 0; {u: 0, v: x})
//│ res: {u: 0, v: 0}

(let x = add; {u: 0, v: x})
//│ res: {u: 0, v: int -> int -> int}

(let rec x = x; {u: 0, v: x})
//│ res: {u: 0, v: nothing}

(let rec x = (x 0); {u: 0, v: x})
//│ res: {u: 0, v: nothing}

(let rec x = (x add); {u: 0, v: x})
//│ res: {u: 0, v: nothing}

// FIXME
(let rec x = (x x); {u: 0, v: x})
//│ res: {u: 0, v: nothing}

(x => {u: add})
//│ res: anything -> {u: int -> int -> int}

(let x = 0; {u: add})
//│ res: {u: int -> int -> int}

(let x = add; {u: add})
//│ res: {u: int -> int -> int}

(let rec x = x; {u: add})
//│ res: {u: int -> int -> int}

(let x = (y => 0); {u: add})
//│ res: {u: int -> int -> int}

(let x = (let y = 0; 0); {u: add})
//│ res: {u: int -> int -> int}

(let x = (let y = add; 0); {u: add})
//│ res: {u: int -> int -> int}

(let x = (let rec y = y; 0); {u: add})
//│ res: {u: int -> int -> int}

(let rec x = (let y = x; 0); {u: add})
//│ res: {u: int -> int -> int}

(let x = (y => add); {u: add})
//│ res: {u: int -> int -> int}

(let x = (y => y); {u: add})
//│ res: {u: int -> int -> int}

(let rec x = (y => x); {u: add})
//│ res: {u: int -> int -> int}

(let x = 0.v; {u: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; {u: add})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; {u: add})
//│ ╙──      	         ^
//│ res: {u: int -> int -> int}



(let x = add.v; {u: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; {u: add})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; {u: add})
//│ ╙──      	         ^^^
//│ res: {u: int -> int -> int}



(let rec x = x.v; {u: add})
//│ res: {u: int -> int -> int}

(let x = {v: 0}; {u: add})
//│ res: {u: int -> int -> int}

(let x = {v: add}; {u: add})
//│ res: {u: int -> int -> int}

(let rec x = {v: x}; {u: add})
//│ res: {u: int -> int -> int}

(x => {u: x})
//│ res: 'a -> {u: 'a}

(let x = 0; {u: x})
//│ res: {u: 0}

(let x = add; {u: x})
//│ res: {u: int -> int -> int}

(let rec x = x; {u: x})
//│ res: {u: nothing}

(let x = {v: 0}; {u: x})
//│ res: {u: {v: 0}}

(let x = {v: add}; {u: x})
//│ res: {u: {v: int -> int -> int}}

(let rec x = {v: x}; {u: x})
//│ res: {u: 'x}
//│   where
//│     'x :> {v: 'x}

(x => {u: x, v: 0})
//│ res: 'a -> {u: 'a, v: 0}

(let x = 0; {u: x, v: 0})
//│ res: {u: 0, v: 0}

(let x = add; {u: x, v: 0})
//│ res: {u: int -> int -> int, v: 0}

(let rec x = x; {u: x, v: 0})
//│ res: {u: nothing, v: 0}

(let x = 0.v; {u: x, v: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; {u: x, v: 0})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; {u: x, v: 0})
//│ ╙──      	         ^
//│ res: {u: error, v: 0}



(let x = add.v; {u: x, v: 0})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; {u: x, v: 0})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; {u: x, v: 0})
//│ ╙──      	         ^^^
//│ res: {u: error, v: 0}



(let rec x = x.v; {u: x, v: 0})
//│ res: {u: nothing, v: 0}

(x => {u: x, v: add})
//│ res: 'a -> {u: 'a, v: int -> int -> int}

(let x = 0; {u: x, v: add})
//│ res: {u: 0, v: int -> int -> int}

(let x = add; {u: x, v: add})
//│ res: {u: int -> int -> int, v: int -> int -> int}

(let rec x = x; {u: x, v: add})
//│ res: {u: nothing, v: int -> int -> int}

(let x = 0.u; {u: x, v: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; {u: x, v: add})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; {u: x, v: add})
//│ ╙──      	         ^
//│ res: {u: error, v: int -> int -> int}



(let x = add.u; {u: x, v: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; {u: x, v: add})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; {u: x, v: add})
//│ ╙──      	         ^^^
//│ res: {u: error, v: int -> int -> int}



(let rec x = x.u; {u: x, v: add})
//│ res: {u: nothing, v: int -> int -> int}

(let x = 0.v; {u: x, v: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; {u: x, v: add})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; {u: x, v: add})
//│ ╙──      	         ^
//│ res: {u: error, v: int -> int -> int}



(let x = add.v; {u: x, v: add})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; {u: x, v: add})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; {u: x, v: add})
//│ ╙──      	         ^^^
//│ res: {u: error, v: int -> int -> int}



(let rec x = x.v; {u: x, v: add})
//│ res: {u: nothing, v: int -> int -> int}

(x => {u: x, v: x})
//│ res: 'a -> {u: 'a, v: 'a}

(let x = 0; {u: x, v: x})
//│ res: {u: 0, v: 0}

(let x = add; {u: x, v: x})
//│ res: {u: int -> int -> int, v: int -> int -> int}

(let rec x = x; {u: x, v: x})
//│ res: {u: nothing, v: nothing}

(let x = {u: 0}; {u: x, v: x})
//│ res: {u: {u: 0}, v: {u: 0}}

(let x = {u: add}; {u: x, v: x})
//│ res: {u: {u: int -> int -> int}, v: {u: int -> int -> int}}

(let rec x = {u: x}; {u: x, v: x})
//│ res: {u: 'x, v: 'x}
//│   where
//│     'x :> {u: 'x}

(let rec x = {u: x, v: 0}; {u: x, v: x})
//│ res: {u: 'x, v: 'x}
//│   where
//│     'x :> {u: 'x, v: 0}

(let rec x = {u: x, v: add}; {u: x, v: x})
//│ res: {u: 'x, v: 'x}
//│   where
//│     'x :> {u: 'x, v: int -> int -> int}

(let rec x = {u: x, v: x}; {u: x, v: x})
//│ res: {u: 'x, v: 'x}
//│   where
//│     'x :> {u: 'x, v: 'x}

(let x = {v: 0}; {u: x, v: x})
//│ res: {u: {v: 0}, v: {v: 0}}

(let x = {v: add}; {u: x, v: x})
//│ res: {u: {v: int -> int -> int}, v: {v: int -> int -> int}}

(let rec x = {v: x}; {u: x, v: x})
//│ res: {u: 'x, v: 'x}
//│   where
//│     'x :> {v: 'x}

(x => {u: 0.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(x => {u: 0.v})
//│ ║        	           ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(x => {u: 0.v})
//│ ╙──      	          ^
//│ res: anything -> {u: error}



(let x = 0; {u: 0.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; {u: 0.v})
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; {u: 0.v})
//│ ╙──      	                ^
//│ res: {u: error}



(let x = add; {u: 0.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; {u: 0.v})
//│ ║        	                   ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = add; {u: 0.v})
//│ ╙──      	                  ^
//│ res: {u: error}



(let rec x = x; {u: 0.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x; {u: 0.v})
//│ ║        	                     ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x; {u: 0.v})
//│ ╙──      	                    ^
//│ res: {u: error}



(x => {u: add.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(x => {u: add.v})
//│ ║        	             ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(x => {u: add.v})
//│ ╙──      	          ^^^
//│ res: anything -> {u: error}



(let x = 0; {u: add.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; {u: add.v})
//│ ║        	                   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; {u: add.v})
//│ ╙──      	                ^^^
//│ res: {u: error}



(let x = add; {u: add.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; {u: add.v})
//│ ║        	                     ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add; {u: add.v})
//│ ╙──      	                  ^^^
//│ res: {u: error}



(let rec x = x; {u: add.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x; {u: add.v})
//│ ║        	                       ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x; {u: add.v})
//│ ╙──      	                    ^^^
//│ res: {u: error}



(x => {u: x.v})
//│ res: {v: 'v} -> {u: 'v}

(let x = 0; {u: x.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; {u: x.v})
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; {u: x.v})
//│ ║        	         ^
//│ ╟── but it flows into reference with expected type `{v: ?v}`
//│ ║  l.+1: 	(let x = 0; {u: x.v})
//│ ╙──      	                ^
//│ res: {u: error}




(let x = add; {u: x.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; {u: x.v})
//│ ║        	                   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add; {u: x.v})
//│ ║        	         ^^^
//│ ╟── but it flows into reference with expected type `{v: ?v}`
//│ ║  l.+1: 	(let x = add; {u: x.v})
//│ ╙──      	                  ^
//│ res: {u: error}




(let rec x = x; {u: x.v})
//│ res: {u: nothing}

(let x = 0.v; {u: x.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; {u: x.v})
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; {u: x.v})
//│ ╙──      	         ^
//│ res: {u: error}



(let x = add.v; {u: x.v})
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; {u: x.v})
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; {u: x.v})
//│ ╙──      	         ^^^
//│ res: {u: error}



(let rec x = x.v; {u: x.v})
//│ res: {u: nothing}

(let x = {v: 0}; {u: x.v})
//│ res: {u: 0}

(let x = {v: add}; {u: x.v})
//│ res: {u: int -> int -> int}

(let rec x = {v: x}; {u: x.v})
//│ res: {u: 'x}
//│   where
//│     'x :> {v: 'x}

(let x = {v: (y => 0)}; {u: x.v})
//│ res: {u: anything -> 0}

(let x = {v: (y => add)}; {u: x.v})
//│ res: {u: anything -> int -> int -> int}

(let x = {v: (y => y)}; {u: x.v})
//│ res: {u: 'a -> 'a}

(let rec x = {v: (y => x)}; {u: x.v})
//│ res: {u: 'v}
//│   where
//│     'v :> anything -> {v: 'v}

(x => 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(x => 0.v)
//│ ║        	       ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(x => 0.v)
//│ ╙──      	      ^
//│ res: anything -> error



(let x = 0; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; 0.v)
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; 0.v)
//│ ╙──      	            ^
//│ res: error



(let x = add; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; 0.v)
//│ ║        	               ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = add; 0.v)
//│ ╙──      	              ^
//│ res: error



(let rec x = x; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x; 0.v)
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x; 0.v)
//│ ╙──      	                ^
//│ res: error



(let x = 0.u; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; 0.v)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	(let x = 0.u; 0.v)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.u; 0.v)
//│ ║        	               ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.u; 0.v)
//│ ╙──      	              ^
//│ res: error





(let x = add.u; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; 0.v)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	(let x = add.u; 0.v)
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.u; 0.v)
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = add.u; 0.v)
//│ ╙──      	                ^
//│ res: error





(let rec x = x.u; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x.u; 0.v)
//│ ║        	                   ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x.u; 0.v)
//│ ╙──      	                  ^
//│ res: error



(let x = 0.v; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; 0.v)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; 0.v)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; 0.v)
//│ ║        	               ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; 0.v)
//│ ╙──      	              ^
//│ res: error





(let x = add.v; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; 0.v)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; 0.v)
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; 0.v)
//│ ║        	                 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; 0.v)
//│ ╙──      	                ^
//│ res: error





(let rec x = x.v; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x.v; 0.v)
//│ ║        	                   ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x.v; 0.v)
//│ ╙──      	                  ^
//│ res: error



(let x = {v: 0}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: 0}; 0.v)
//│ ║        	                  ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: 0}; 0.v)
//│ ╙──      	                 ^
//│ res: error



(let x = {v: add}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: add}; 0.v)
//│ ║        	                    ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: add}; 0.v)
//│ ╙──      	                   ^
//│ res: error



(let rec x = {v: x}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = {v: x}; 0.v)
//│ ║        	                      ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = {v: x}; 0.v)
//│ ╙──      	                     ^
//│ res: error



(let x = {v: 0.v}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: 0.v}; 0.v)
//│ ║        	              ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: 0.v}; 0.v)
//│ ╙──      	             ^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: 0.v}; 0.v)
//│ ║        	                    ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: 0.v}; 0.v)
//│ ╙──      	                   ^
//│ res: error





(let x = {v: add.v}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: add.v}; 0.v)
//│ ║        	                ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: add.v}; 0.v)
//│ ╙──      	             ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {v: add.v}; 0.v)
//│ ║        	                      ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = {v: add.v}; 0.v)
//│ ╙──      	                     ^
//│ res: error





(let rec x = {v: x.v}; 0.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = {v: x.v}; 0.v)
//│ ║        	                        ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let rec x = {v: x.v}; 0.v)
//│ ╙──      	                       ^
//│ res: error



(x => add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(x => add.v)
//│ ║        	         ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(x => add.v)
//│ ╙──      	      ^^^
//│ res: anything -> error



(let x = 0; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; add.v)
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; add.v)
//│ ╙──      	            ^^^
//│ res: error



(let x = add; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; add.v)
//│ ║        	                 ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add; add.v)
//│ ╙──      	              ^^^
//│ res: error



(let rec x = x; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x; add.v)
//│ ║        	                   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x; add.v)
//│ ╙──      	                ^^^
//│ res: error



(let x = {u: 0}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: 0}; add.v)
//│ ║        	                    ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: 0}; add.v)
//│ ╙──      	                 ^^^
//│ res: error



(let x = {u: add}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: add}; add.v)
//│ ║        	                      ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: add}; add.v)
//│ ╙──      	                   ^^^
//│ res: error



(let rec x = {u: x}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = {u: x}; add.v)
//│ ║        	                        ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let rec x = {u: x}; add.v)
//│ ╙──      	                     ^^^
//│ res: error



(let x = {u: {v: 0}}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: {v: 0}}; add.v)
//│ ║        	                         ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: {v: 0}}; add.v)
//│ ╙──      	                      ^^^
//│ res: error



(let x = {u: {v: add}}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = {u: {v: add}}; add.v)
//│ ║        	                           ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = {u: {v: add}}; add.v)
//│ ╙──      	                        ^^^
//│ res: error



(let rec x = {u: {v: x}}; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = {u: {v: x}}; add.v)
//│ ║        	                             ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let rec x = {u: {v: x}}; add.v)
//│ ╙──      	                          ^^^
//│ res: error



(let x = 0.v; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; add.v)
//│ ║        	          ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; add.v)
//│ ╙──      	         ^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0.v; add.v)
//│ ║        	                 ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = 0.v; add.v)
//│ ╙──      	              ^^^
//│ res: error





(let x = add.v; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; add.v)
//│ ║        	            ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; add.v)
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add.v; add.v)
//│ ║        	                   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add.v; add.v)
//│ ╙──      	                ^^^
//│ res: error





(let rec x = x.v; add.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let rec x = x.v; add.v)
//│ ║        	                     ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let rec x = x.v; add.v)
//│ ╙──      	                  ^^^
//│ res: error



(x => x.v)
//│ res: {v: 'v} -> 'v

(let x = 0; x.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = 0; x.v)
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	(let x = 0; x.v)
//│ ║        	         ^
//│ ╟── but it flows into reference with expected type `{v: ?v}`
//│ ║  l.+1: 	(let x = 0; x.v)
//│ ╙──      	            ^
//│ res: error




(let x = add; x.v)
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	(let x = add; x.v)
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	(let x = add; x.v)
//│ ║        	         ^^^
//│ ╟── but it flows into reference with expected type `{v: ?v}`
//│ ║  l.+1: 	(let x = add; x.v)
//│ ╙──      	              ^
//│ res: error




(let rec x = x; x.v)
//│ res: nothing

(let x = {v: 0}; x.v)
//│ res: 0

(let x = {v: add}; x.v)
//│ res: int -> int -> int

(let rec x = {v: x}; x.v)
//│ res: 'x
//│   where
//│     'x :> {v: 'x}

(let x = {v: {v: 0}}; x.v)
//│ res: {v: 0}

(let x = {v: {v: add}}; x.v)
//│ res: {v: int -> int -> int}

(let rec x = {v: {v: x}}; x.v)
//│ res: 'v
//│   where
//│     'v :> {v: {v: 'v}}

0.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	0.u
//│ ║        	 ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	0.u
//│ ╙──      	^
//│ res: error



add.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	add.u
//│ ║        	   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	add.u
//│ ╙──      	^^^
//│ res: error



0.v.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	0.v.u
//│ ║        	   ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	0.v.u
//│ ╙──      	^
//│ res: error



add.v.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	add.v.u
//│ ║        	     ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	add.v.u
//│ ╙──      	^^^
//│ res: error



{v: 0}.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: 0}.u
//│ ║        	      ^^
//│ ╟── record of type `{v: 0}` does not have field 'u'
//│ ║  l.+1: 	{v: 0}.u
//│ ╙──      	^^^^^^
//│ res: error



{v: add}.u
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: add}.u
//│ ║        	        ^^
//│ ╟── record of type `{v: int -> int -> int}` does not have field 'u'
//│ ║  l.+1: 	{v: add}.u
//│ ╙──      	^^^^^^^^
//│ res: error



{u: 0}
//│ res: {u: 0}

{u: 0, v: 0}
//│ res: {u: 0, v: 0}

{u: 0, v: add}
//│ res: {u: 0, v: int -> int -> int}

{u: 0, v: (x => 0)}
//│ res: {u: 0, v: anything -> 0}

{u: 0, v: (let x = 0; 0)}
//│ res: {u: 0, v: 0}

{u: 0, v: (let x = add; 0)}
//│ res: {u: 0, v: 0}

{u: 0, v: (let rec x = x; 0)}
//│ res: {u: 0, v: 0}

{u: 0, v: (let x = 0.u; 0)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: 0, v: (let x = 0.u; 0)}
//│ ║        	                    ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: 0, v: (let x = 0.u; 0)}
//│ ╙──      	                   ^
//│ res: {u: 0, v: 0}



{u: 0, v: (let x = add.u; 0)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: 0, v: (let x = add.u; 0)}
//│ ║        	                      ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	{u: 0, v: (let x = add.u; 0)}
//│ ╙──      	                   ^^^
//│ res: {u: 0, v: 0}



{u: 0, v: (let rec x = x.u; 0)}
//│ res: {u: 0, v: 0}

{u: 0, v: (x => add)}
//│ res: {u: 0, v: anything -> int -> int -> int}

{u: 0, v: (x => x)}
//│ res: {u: 0, v: 'a -> 'a}

{u: 0, v: {u: 0}}
//│ res: {u: 0, v: {u: 0}}

{u: 0, v: {u: 0, v: 0}}
//│ res: {u: 0, v: {u: 0, v: 0}}

{u: 0, v: {u: 0, v: add}}
//│ res: {u: 0, v: {u: 0, v: int -> int -> int}}

{u: 0, v: {u: add}}
//│ res: {u: 0, v: {u: int -> int -> int}}

{u: 0, v: {v: 0}}
//│ res: {u: 0, v: {v: 0}}

{u: 0, v: {v: add}}
//│ res: {u: 0, v: {v: int -> int -> int}}

{u: add}
//│ res: {u: int -> int -> int}

{u: add, v: 0}
//│ res: {u: int -> int -> int, v: 0}

{u: add, v: add}
//│ res: {u: int -> int -> int, v: int -> int -> int}

{u: add, v: {u: 0}}
//│ res: {u: int -> int -> int, v: {u: 0}}

{u: add, v: {u: add}}
//│ res: {u: int -> int -> int, v: {u: int -> int -> int}}

{u: add, v: {u: add, v: 0}}
//│ res: {u: int -> int -> int, v: {u: int -> int -> int, v: 0}}

{u: add, v: {u: add, v: add}}
//│ res: {u: int -> int -> int, v: {u: int -> int -> int, v: int -> int -> int}}

{u: add, v: {u: (x => 0)}}
//│ res: {u: int -> int -> int, v: {u: anything -> 0}}

{u: add, v: {u: (x => add)}}
//│ res: {u: int -> int -> int, v: {u: anything -> int -> int -> int}}

{u: add, v: {u: (x => add), v: 0}}
//│ res: {u: int -> int -> int, v: {u: anything -> int -> int -> int, v: 0}}

{u: add, v: {u: (x => add), v: add}}
//│ res: {u: int -> int -> int, v: {u: anything -> int -> int -> int, v: int -> int -> int}}

{u: add, v: {u: (x => x)}}
//│ res: {u: int -> int -> int, v: {u: 'a -> 'a}}

{u: add, v: {u: {v: 0}}}
//│ res: {u: int -> int -> int, v: {u: {v: 0}}}

{u: add, v: {u: {v: add}}}
//│ res: {u: int -> int -> int, v: {u: {v: int -> int -> int}}}

{u: add, v: 0.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: 0.v}
//│ ║        	             ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: 0.v}
//│ ╙──      	            ^
//│ res: {u: int -> int -> int, v: error}



{u: add, v: add.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: add.v}
//│ ║        	               ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: add.v}
//│ ╙──      	            ^^^
//│ res: {u: int -> int -> int, v: error}



{u: add, v: (x => 0).v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: (x => 0).v}
//│ ║        	                    ^^
//│ ╟── function of type `?a -> 0` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: (x => 0).v}
//│ ║        	             ^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	{u: add, v: (x => 0).v}
//│ ╙──      	            ^^^^^^^^
//│ res: {u: int -> int -> int, v: error}




{u: add, v: (x => add).v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: (x => add).v}
//│ ║        	                      ^^
//│ ╟── function of type `?a -> int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: (x => add).v}
//│ ║        	             ^^^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	{u: add, v: (x => add).v}
//│ ╙──      	            ^^^^^^^^^^
//│ res: {u: int -> int -> int, v: error}




{u: add, v: (x => x).v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: (x => x).v}
//│ ║        	                    ^^
//│ ╟── function of type `?a -> ?a` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: (x => x).v}
//│ ║        	             ^^^^^^
//│ ╟── but it flows into receiver with expected type `{v: ?v}`
//│ ║  l.+1: 	{u: add, v: (x => x).v}
//│ ╙──      	            ^^^^^^^^
//│ res: {u: int -> int -> int, v: error}




{u: add, v: {u: 0}.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: {u: 0}.v}
//│ ║        	                  ^^
//│ ╟── record of type `{u: 0}` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: {u: 0}.v}
//│ ╙──      	            ^^^^^^
//│ res: {u: int -> int -> int, v: error}



{u: add, v: {u: add}.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: add, v: {u: add}.v}
//│ ║        	                    ^^
//│ ╟── record of type `{u: int -> int -> int}` does not have field 'v'
//│ ║  l.+1: 	{u: add, v: {u: add}.v}
//│ ╙──      	            ^^^^^^^^
//│ res: {u: int -> int -> int, v: error}



{u: add, v: {v: 0}}
//│ res: {u: int -> int -> int, v: {v: 0}}

{u: add, v: {v: add}}
//│ res: {u: int -> int -> int, v: {v: int -> int -> int}}

{u: {u: 0}}
//│ res: {u: {u: 0}}

{u: {u: 0}, v: 0}
//│ res: {u: {u: 0}, v: 0}

{u: {u: 0}, v: add}
//│ res: {u: {u: 0}, v: int -> int -> int}

{u: {u: 0}, v: (add 0)}
//│ res: {u: {u: 0}, v: int -> int}

{u: {u: 0}, v: (add add)}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	{u: {u: 0}, v: (add add)}
//│ ║        	                ^^^^^^^
//│ ╟── reference of type `int -> int -> int` is not an instance of type `int`
//│ ║  l.+1: 	{u: {u: 0}, v: (add add)}
//│ ╙──      	                    ^^^
//│ res: {u: {u: 0}, v: int -> int | error}



{u: {u: 0}, v: (add {v: 0})}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	{u: {u: 0}, v: (add {v: 0})}
//│ ║        	                ^^^^^^^^^^
//│ ╟── record of type `{v: 0}` is not an instance of type `int`
//│ ║  l.+1: 	{u: {u: 0}, v: (add {v: 0})}
//│ ╙──      	                    ^^^^^^
//│ res: {u: {u: 0}, v: int -> int | error}



{u: {u: 0}, v: (add {v: add})}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	{u: {u: 0}, v: (add {v: add})}
//│ ║        	                ^^^^^^^^^^^^
//│ ╟── record of type `{v: int -> int -> int}` is not an instance of type `int`
//│ ║  l.+1: 	{u: {u: 0}, v: (add {v: add})}
//│ ╙──      	                    ^^^^^^^^
//│ res: {u: {u: 0}, v: int -> int | error}



{u: {u: 0}, v: (x => 0)}
//│ res: {u: {u: 0}, v: anything -> 0}

{u: {u: 0}, v: (x => add)}
//│ res: {u: {u: 0}, v: anything -> int -> int -> int}

{u: {u: 0}, v: (x => x)}
//│ res: {u: {u: 0}, v: 'a -> 'a}

{u: {u: 0}, v: (x => 0.u)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: (x => 0.u)}
//│ ║        	                      ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: {u: 0}, v: (x => 0.u)}
//│ ╙──      	                     ^
//│ res: {u: {u: 0}, v: anything -> error}



{u: {u: 0}, v: (let x = 0; 0.u)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: (let x = 0; 0.u)}
//│ ║        	                            ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: {u: 0}, v: (let x = 0; 0.u)}
//│ ╙──      	                           ^
//│ res: {u: {u: 0}, v: error}



{u: {u: 0}, v: (let x = add; 0.u)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: (let x = add; 0.u)}
//│ ║        	                              ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: {u: 0}, v: (let x = add; 0.u)}
//│ ╙──      	                             ^
//│ res: {u: {u: 0}, v: error}



{u: {u: 0}, v: (let rec x = x; 0.u)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: (let rec x = x; 0.u)}
//│ ║        	                                ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: {u: 0}, v: (let rec x = x; 0.u)}
//│ ╙──      	                               ^
//│ res: {u: {u: 0}, v: error}



{u: {u: 0}, v: (x => add.u)}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: (x => add.u)}
//│ ║        	                        ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	{u: {u: 0}, v: (x => add.u)}
//│ ╙──      	                     ^^^
//│ res: {u: {u: 0}, v: anything -> error}



{u: {u: 0}, v: (x => x.u)}
//│ res: {u: {u: 0}, v: {u: 'u} -> 'u}

{u: {u: 0}, v: 0.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: 0.v}
//│ ║        	                ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	{u: {u: 0}, v: 0.v}
//│ ╙──      	               ^
//│ res: {u: {u: 0}, v: error}



{u: {u: 0}, v: add.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {u: 0}, v: add.v}
//│ ║        	                  ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	{u: {u: 0}, v: add.v}
//│ ╙──      	               ^^^
//│ res: {u: {u: 0}, v: error}



{u: {u: add}}
//│ res: {u: {u: int -> int -> int}}

{u: {u: add}, v: 0}
//│ res: {u: {u: int -> int -> int}, v: 0}

{u: {u: add}, v: add}
//│ res: {u: {u: int -> int -> int}, v: int -> int -> int}

{u: {u: add}, v: (x => 0)}
//│ res: {u: {u: int -> int -> int}, v: anything -> 0}

{u: {u: add}, v: (x => add)}
//│ res: {u: {u: int -> int -> int}, v: anything -> int -> int -> int}

{u: {u: add}, v: (let x = 0; add)}
//│ res: {u: {u: int -> int -> int}, v: int -> int -> int}

{u: {u: add}, v: (let x = add; add)}
//│ res: {u: {u: int -> int -> int}, v: int -> int -> int}

{u: {u: add}, v: (let rec x = x; add)}
//│ res: {u: {u: int -> int -> int}, v: int -> int -> int}

{u: {u: add}, v: (x => x)}
//│ res: {u: {u: int -> int -> int}, v: 'a -> 'a}

{u: {v: 0}}
//│ res: {u: {v: 0}}

{u: {v: 0}, v: 0}
//│ res: {u: {v: 0}, v: 0}

{u: {v: 0}, v: add}
//│ res: {u: {v: 0}, v: int -> int -> int}

{u: {v: 0}, v: (0 0)}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	{u: {v: 0}, v: (0 0)}
//│ ║        	                ^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	{u: {v: 0}, v: (0 0)}
//│ ╙──      	                ^
//│ res: {u: {v: 0}, v: error}



{u: {v: 0}, v: (0 add)}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	{u: {v: 0}, v: (0 add)}
//│ ║        	                ^^^^^
//│ ╟── integer literal of type `0` is not a function
//│ ║  l.+1: 	{u: {v: 0}, v: (0 add)}
//│ ╙──      	                ^
//│ res: {u: {v: 0}, v: error}



{u: {v: 0}, v: (x => 0)}
//│ res: {u: {v: 0}, v: anything -> 0}

{u: {v: 0}, v: (let x = 0; 0)}
//│ res: {u: {v: 0}, v: 0}

{u: {v: 0}, v: (let x = add; 0)}
//│ res: {u: {v: 0}, v: 0}

{u: {v: 0}, v: (let rec x = x; 0)}
//│ res: {u: {v: 0}, v: 0}

{u: {v: 0}, v: (x => add)}
//│ res: {u: {v: 0}, v: anything -> int -> int -> int}

{u: {v: 0}, v: (let x = 0; add)}
//│ res: {u: {v: 0}, v: int -> int -> int}

{u: {v: 0}, v: (let x = add; add)}
//│ res: {u: {v: 0}, v: int -> int -> int}

{u: {v: 0}, v: (let rec x = x; add)}
//│ res: {u: {v: 0}, v: int -> int -> int}

{u: {v: 0}, v: (x => x)}
//│ res: {u: {v: 0}, v: 'a -> 'a}

{u: {v: add}}
//│ res: {u: {v: int -> int -> int}}

{u: {v: add}, v: 0}
//│ res: {u: {v: int -> int -> int}, v: 0}

{u: {v: add}, v: add}
//│ res: {u: {v: int -> int -> int}, v: int -> int -> int}

{u: {v: add}, v: 0.u}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {v: add}, v: 0.u}
//│ ║        	                  ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{u: {v: add}, v: 0.u}
//│ ╙──      	                 ^
//│ res: {u: {v: int -> int -> int}, v: error}



{u: {v: add}, v: add.u}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {v: add}, v: add.u}
//│ ║        	                    ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	{u: {v: add}, v: add.u}
//│ ╙──      	                 ^^^
//│ res: {u: {v: int -> int -> int}, v: error}



{u: {v: add}, v: 0.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {v: add}, v: 0.v}
//│ ║        	                  ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	{u: {v: add}, v: 0.v}
//│ ╙──      	                 ^
//│ res: {u: {v: int -> int -> int}, v: error}



{u: {v: add}, v: add.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{u: {v: add}, v: add.v}
//│ ║        	                    ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	{u: {v: add}, v: add.v}
//│ ╙──      	                 ^^^
//│ res: {u: {v: int -> int -> int}, v: error}



{u: {v: add}, v: {v: 0}}
//│ res: {u: {v: int -> int -> int}, v: {v: 0}}

{u: {v: add}, v: {v: add}}
//│ res: {u: {v: int -> int -> int}, v: {v: int -> int -> int}}

0.v
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	0.v
//│ ║        	 ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	0.v
//│ ╙──      	^
//│ res: error



add.v
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	add.v
//│ ║        	   ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	add.v
//│ ╙──      	^^^
//│ res: error



{v: 0}
//│ res: {v: 0}

{v: add}
//│ res: {v: int -> int -> int}

{v: 0.u}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: 0.u}
//│ ║        	     ^^
//│ ╟── integer literal of type `0` does not have field 'u'
//│ ║  l.+1: 	{v: 0.u}
//│ ╙──      	    ^
//│ res: {v: error}



{v: add.u}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: add.u}
//│ ║        	       ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'u'
//│ ║  l.+1: 	{v: add.u}
//│ ╙──      	    ^^^
//│ res: {v: error}



{v: 0.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: 0.v}
//│ ║        	     ^^
//│ ╟── integer literal of type `0` does not have field 'v'
//│ ║  l.+1: 	{v: 0.v}
//│ ╙──      	    ^
//│ res: {v: error}



{v: add.v}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+1: 	{v: add.v}
//│ ║        	       ^^
//│ ╟── reference of type `int -> int -> int` does not have field 'v'
//│ ║  l.+1: 	{v: add.v}
//│ ╙──      	    ^^^
//│ res: {v: error}



{v: {v: 0}}
//│ res: {v: {v: 0}}

{v: {v: add}}
//│ res: {v: {v: int -> int -> int}}


// Number of expressions generated: 499

// Program sizes:
//   1: 2
//   2: 8
//   3: 34
//   4: 62
//   5: 123
//   6: 128
//   7: 99
//   8: 22
//   9: 21

