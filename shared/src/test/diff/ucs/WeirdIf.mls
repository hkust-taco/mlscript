:NewParser

// Should report duplicated else branches.
:w
if
  _ then 0
  else 0
else 1
//│ ╔══[WARNING] Found a duplicated branch
//│ ╟── This branch
//│ ║  l.7: 	  else 0
//│ ║       	       ^
//│ ╟── is subsumed by the branch here.
//│ ║  l.6: 	  _ then 0
//│ ╙──     	         ^
//│ ╔══[WARNING] Found a duplicated branch
//│ ╟── This branch
//│ ║  l.8: 	else 1
//│ ║       	     ^
//│ ╟── is subsumed by the branch here.
//│ ║  l.6: 	  _ then 0
//│ ╙──     	         ^
//│ res: 0
//│    = 0

:w
if else 0 else 1
//│ ╔══[WARNING] Found a duplicated branch
//│ ╟── This branch
//│ ║  l.27: 	if else 0 else 1
//│ ║        	               ^
//│ ╟── is subsumed by the branch here.
//│ ║  l.27: 	if else 0 else 1
//│ ╙──      	        ^
//│ res: 0
//│    = 0

:w
fun f(x) = if x is else 0 else 1
//│ ╔══[WARNING] Found a duplicated branch
//│ ╟── This branch
//│ ║  l.39: 	fun f(x) = if x is else 0 else 1
//│ ║        	                               ^
//│ ╟── is subsumed by the branch here.
//│ ║  l.39: 	fun f(x) = if x is else 0 else 1
//│ ╙──      	                        ^
//│ f: anything -> 0
//│  = [Function: f]

fun f(x) = if x is else 0 
//│ f: anything -> 0
//│  = [Function: f1]

:e
:ge
if true
  then 0
//│ ╔══[ERROR] The case when this is false is not handled: true
//│ ║  l.56: 	if true
//│ ╙──      	   ^^^^
//│ res: error
//│ Code generation encountered an error:
//│   if expression was not desugared

// This cannot be parsed. But the next one works.
:pe
:e
:ge
fun f(x) =
  if x ==
    else "bruh"
//│ ╔══[PARSE ERROR] Unexpected indented block in expression position
//│ ║  l.71: 	    else "bruh"
//│ ╙──      	^^^^
//│ ╔══[PARSE ERROR] Unexpected end of indented block; an expression was expected here
//│ ║  l.71: 	    else "bruh"
//│ ╙──      	    ^
//│ ╔══[PARSE ERROR] Expected 'then'/'else' clause; found operator application instead
//│ ║  l.70: 	  if x ==
//│ ║        	     ^^^^
//│ ║  l.71: 	    else "bruh"
//│ ║        	^^^^
//│ ╟── Note: 'if' expression started here:
//│ ║  l.70: 	  if x ==
//│ ╙──      	  ^^
//│ ╔══[ERROR] The case when this is false is not handled: == (x,) (undefined,)
//│ ║  l.70: 	  if x ==
//│ ║        	     ^^^^
//│ ║  l.71: 	    else "bruh"
//│ ╙──      	^^^^
//│ f: anything -> error
//│ Code generation encountered an error:
//│   if expression was not desugared

// But this works.
fun f(x) =
  if x ==
    _ then "bruh"
//│ f: anything -> "bruh"
//│  = [Function: f3]

fun boolToStr(x) =
  if x is
    true then "yah"
    false then "nah"
//│ boolToStr: bool -> ("nah" | "yah")
//│          = [Function: boolToStr]

boolToStr of true
boolToStr of false
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.109: 	boolToStr of true
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` does not match type `false & ?a | true & ?b`
//│ ║  l.109: 	boolToStr of true
//│ ║         	             ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.103: 	  if x is
//│ ╙──       	     ^
//│ res: "nah" | "yah" | error
//│    = 'yah'
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.110: 	boolToStr of false
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `false` does not match type `false & ?a | true & ?b`
//│ ║  l.110: 	boolToStr of false
//│ ║         	             ^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.103: 	  if x is
//│ ╙──       	     ^
//│ res: "nah" | "yah" | error
//│    = 'nah'
