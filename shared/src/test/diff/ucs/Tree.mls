:NewDefs

type Option[A] = Some[A] | None
class Some[A](value: A)
module None
//│ type Option[A] = Some[A] | None
//│ class Some[A](value: A)
//│ module None

type Tree[A] = Node[A] | Empty
module Empty
class Node[A](value: int, left: Tree[A], right: Tree[A])
//│ type Tree[A] = Node[A] | Empty
//│ module Empty
//│ class Node[A](value: int, left: Tree[A], right: Tree[A])

fun find(t, v) = if t is
  Node(v', l, r) and
    v < v' then find(l, v)
    v > v' then find(r, v)
    _ then Some(v)
  Empty then None
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.19: 	    v < v' then find(l, v)
//│ ║        	    ^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.12: 	class Node[A](value: int, left: Tree[A], right: Tree[A])
//│ ║        	                     ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.19: 	    v < v' then find(l, v)
//│ ╙──      	        ^^
//│ fun find: forall 'A 'A0. (Empty | Node['A], #Num & 'A0,) -> (None | Some['A0])

fun insert(t, v) = if t is
  Node(v', l, r) and
    v < v' then Node(v', insert(l, v), r)
    v > v' then Node(v', l, insert(r, v))
    _ then t
  Empty then Node(v, Empty, Empty)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.36: 	    v < v' then Node(v', insert(l, v), r)
//│ ║        	    ^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.12: 	class Node[A](value: int, left: Tree[A], right: Tree[A])
//│ ║        	                     ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.36: 	    v < v' then Node(v', insert(l, v), r)
//│ ╙──      	        ^^
//│ fun insert: forall 'A. (Empty | Node['A], nothing,) -> Node['A]

find(Empty, 0)
find(Node(0, Empty, Empty), 0)
find(Node(1, Empty, Empty), 0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	find(Node(0, Empty, Empty), 0)
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.52: 	find(Node(0, Empty, Empty), 0)
//│ ║        	          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Node[A](value: int, left: Tree[A], right: Tree[A])
//│ ╙──      	                     ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.53: 	find(Node(1, Empty, Empty), 0)
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.53: 	find(Node(1, Empty, Empty), 0)
//│ ║        	          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Node[A](value: int, left: Tree[A], right: Tree[A])
//│ ╙──      	                     ^^^
//│ None | Some[0]
//│ res
//│     = None { class: [class None] }
//│ res
//│     = Some {}
//│ res
//│     = None { class: [class None] }
