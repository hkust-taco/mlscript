:NewDefs

type Option[out T] = None | Some[T]
module None
class Some[out T](val value: T)
//│ type Option[T] = None | Some[T]
//│ module None
//│ class Some[T](value: T)

type Either[A, B] = Left[A] | Right[B]
class Left[A](val leftValue: A)
class Right[B](val rightValue: B)
//│ type Either[A, B] = Left[A] | Right[B]
//│ class Left[A](leftValue: A)
//│ class Right[B](rightValue: B)

type List[out A] = Nil | Cons[A]
module Nil
class Cons[out A](head: A, tail: List[A])
//│ type List[A] = Cons[A] | Nil
//│ module Nil
//│ class Cons[A](head: A, tail: List[A])

fun h0(a) =
  if
    a is Some(Left(y)) then y
    a is Some(Right(z)) then z
    a is None then 0
//│ fun h0: forall 'A 'B. (None | Some[Left['A] | Right['B] | ~??T]) -> (0 | ??A & 'A | ??B & 'B)

// FIXME: Precise scrutinee identification (easy)
// This seems fine. But the subtrees are not merged.
fun h1(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(y) and y is Right(z) then z
    a is None then 0
//│ fun h1: forall 'B. (None | Some[Right['B] | ~??T]) -> (0 | ??B & 'B)

// This is the desugared version of the test case above.
fun h1'(a) =
  if a is
    Some then
      let x = a.value
      let y = a.value
      if x is
        Left then
          let y = x.leftValue
          y
        _ then
          if y is
            Right then
              let z = y.rightValue
              z
    None then 0
//│ fun h1': forall 'B. (None | Some[Right['B] | ~??T]) -> (0 | ??B & 'B)

// FIXME This seems fine but the desugared term does not merge the cases.
// See the example below.
fun h1''(a) =
  if
    a is Some(x) and x is Left(y) then y
    a is Some(x) and x is Right(z) then z
    a is None then 0
//│ fun h1'': forall 'A 'B. (None | Some[Left['A] | Right['B] | ~??T]) -> (0 | ??A & 'A | ??B & 'B)

// FIXME
h1(Some(Left(0)))
h1'(Some(Left(0)))
h1''(Some(Left(0)))
//│ ╔══[ERROR] Type `Left[?A] & ??T` does not contain member `Right#B`
//│ ║  l.12: 	class Right[B](val rightValue: B)
//│ ╙──      	            ^
//│ ╔══[ERROR] Type `Left[?A] & ??T` does not contain member `Right#B`
//│ ║  l.12: 	class Right[B](val rightValue: B)
//│ ╙──      	            ^
//│ 0
//│ res
//│     = 0
//│ res
//│     = 0
//│ res
//│     = 0

// FIXME: Precise scrutinee identification (hard)
fun h2(a) =
  if
    a is Some(x) and x is x' and x' is Left(y) then y
    a is Some(y) and
      let y' = y
      y' is Right(z) then z
    a is None then 0
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.90: 	      let y' = y
//│ ╙──      	               ^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.90: 	      let y' = y
//│ ╙──      	               ^
//│ fun h2: forall 'A. (None | Some[Left['A] | Object & ~#Left | ~??T]) -> (0 | ??A & 'A)
//│ Code generation encountered an error:
//│   unresolved symbol y

// FIXME: Some results are wrong.
fun h3(x, y, f, p) =
  if x is
    _ and f(x) is y and p(x) then y
    None then y
    _ then "anyway"
h3("anything", "not me", _ => "should be me", _ => true)
h3(None, "should be me", _ => "not me", _ => false)
h3("anything", "anything", _ => "not me", _ => false)
//│ fun h3: forall 'a 'b. (None | Object & 'a & ~#None, 'b, (None | 'a) -> anything, None -> Object & 'a -> Object) -> ("anyway" | 'b)
//│ "anything" | "anyway"
//│ res
//│     = 'not me'
//│ res
//│     = 'should be me'
//│ res
//│     = 'anyway'

// FIXME: Some results are wrong.
fun h4(x, y, p) =
  if x is
    y and p(x) then y
    None then y
    _ then "default"
h4("should be me", "not me", _ => true) // WRONG!
h4(None, "not me", _ => true) // WRONG!
h4(None, "should be me", _ => false)
h4("anything", "not me", _ => false)
//│ fun h4: forall 'a 'b. (None | Object & 'a & ~#None, 'b, None -> Object & 'a -> Object) -> ("default" | 'b)
//│ "default" | "not me"
//│ res
//│     = 'not me'
//│ res
//│     = 'not me'
//│ res
//│     = 'should be me'
//│ res
//│     = 'default'
