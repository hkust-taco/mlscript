:NewParser
:NewDefs

:escape
// We need to use some native methods on `String`.
let String: nothing
let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
let StringInstance: { fromCharCode: int => string } = String
// We will validate our implementation with the built-in `JSON.parse`.
let JSON: { parse: string => anything, stringify: anything => string }
//│ let String: nothing
//│ let asNativeString: anything -> {charAt: int -> string, charCodeAt: int -> int, length: int, slice: int -> string}
//│ let StringInstance: {fromCharCode: int -> string}
//│ let JSON: {parse: string -> anything, stringify: anything -> string}
//│ String
//│        = <missing implementation>
//│ asNativeString
//│                = [Function: String]
//│ StringInstance
//│                = [Function: String]
//│ JSON
//│      = <missing implementation>

JSON.parse("{ \"xs\": [1, 2, 3], \"yes\": true, \"no\": false, \"insane\": null }")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.24: 	JSON.parse("{ \"xs\": [1, 2, 3], \"yes\": true, \"no\": false, \"insane\": null }")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"{ "xs": [1, 2, 3], "yes": true, "no": false, "insane": null }"` is not an instance of type `string`
//│ ║  l.24: 	JSON.parse("{ \"xs\": [1, 2, 3], \"yes\": true, \"no\": false, \"insane\": null }")
//│ ║        	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.10: 	let JSON: { parse: string => anything, stringify: anything => string }
//│ ╙──      	                   ^^^^^^
//│ anything
//│ res
//│     = { xs: [ 1, 2, 3 ], yes: true, no: false, insane: null }

let getStringOf = toString
fun fromCharCode(n) = StringInstance.fromCharCode(n)
fun firstCharCode(s) = asNativeString(s).charCodeAt(0)
fun getCharAtIndex(s, i) = asNativeString(s).charAt(i)
fun strlen(s) = asNativeString(s).length
fun stringHead(s) = asNativeString(s).charAt(0)
fun stringTail(s) = asNativeString(s).slice(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	fun firstCharCode(s) = asNativeString(s).charCodeAt(0)
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.40: 	fun firstCharCode(s) = asNativeString(s).charCodeAt(0)
//│ ║        	                                                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ╙──     	                                                           ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.43: 	fun stringHead(s) = asNativeString(s).charAt(0)
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.43: 	fun stringHead(s) = asNativeString(s).charAt(0)
//│ ║        	                                             ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ╙──     	                                                                               ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.44: 	fun stringTail(s) = asNativeString(s).slice(1)
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.44: 	fun stringTail(s) = asNativeString(s).slice(1)
//│ ║        	                                            ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ╙──     	                                                                                                     ^^^
//│ let getStringOf: anything -> #Str
//│ fun fromCharCode: int -> string
//│ fun firstCharCode: anything -> (error | int)
//│ fun getCharAtIndex: (anything, int,) -> string
//│ fun strlen: anything -> int
//│ fun stringHead: anything -> (error | string)
//│ fun stringTail: anything -> (error | string)
//│ getStringOf
//│             = [Function: toString]

fun isWhiteSpace(ch) =
  if (firstCharCode of ch) ==
    9 then true // horizontal tab
    10 then true // linefeed
    32 then true // space
    _ then false
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                  ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                  ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                  ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.83: 	  if (firstCharCode of ch) ==
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^
//│ fun isWhiteSpace: anything -> (False | True)

fun isDigit(ch) =
  let n = firstCharCode of ch
  if 48 <= n and n <= 57 then true else false
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.119: 	  if 48 <= n and n <= 57 then true else false
//│ ║         	     ^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                  ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.119: 	  if 48 <= n and n <= 57 then true else false
//│ ╙──       	           ^
//│ fun isDigit: anything -> (False | True)

fun isAlphabet(ch) =
  let n = firstCharCode of ch
  if n <=
    90  and n >= 65 then true
    122 and n >= 97 then true
    else false
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.133: 	  if n <=
//│ ║         	     ^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                  ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.133: 	  if n <=
//│ ╙──       	     ^
//│ fun isAlphabet: anything -> (False | True)

fun concat2(a, b) = concat(a)(b)
fun concat3(a, b, c) = concat2(a, concat2(b, c))
fun concat4(a, b, c, d) = concat2(a, concat3(b, c, d))
fun concat5(a, b, c, d, e) = concat2(a, concat4(b, c, d, e))
fun concat6(a, b, c, d, e, f) = concat2(a, concat5(b, c, d, e, f))
fun concat7(a, b, c, d, e, f, g) = concat2(a, concat6(b, c, d, e, f, g))
fun concat8(a, b, c, d, e, f, g, h) = concat2(a, concat7(b, c, d, e, f, g, h))
fun par(a) = concat3("(", a, ")")
//│ fun concat2: (#Str, #Str,) -> #Str
//│ fun concat3: (#Str, #Str, #Str,) -> #Str
//│ fun concat4: (#Str, #Str, #Str, #Str,) -> #Str
//│ fun concat5: (#Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat6: (#Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat7: (#Str, #Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun concat8: (#Str, #Str, #Str, #Str, #Str, #Str, #Str, #Str,) -> #Str
//│ fun par: #Str -> #Str

type Option[A] = Some[A] | None
module None
class Some[A](value: A)
//│ type Option[A] = Some[A] | None
//│ module None
//│ class Some[A](value: A)

type List[A] = Cons[A] | Nil
module Nil
class Cons[A](head: A, tail: List[A])
fun listConcat(xs, ys) =
  if xs is
    Nil then ys
    Cons(x, xs') then Cons(x, listConcat(xs', ys))
fun listJoin(xs, sep) =
  if xs is
    Nil then ""
    Cons(x, xs') and xs' is
      Nil then toString(x)
      _ then concat3(toString(x), sep, listJoin(xs', sep))
//│ type List[A] = Cons[A] | Nil
//│ module Nil
//│ class Cons[A](head: A, tail: List[A])
//│ fun listConcat: forall 'A 'A0 'a. (Cons['A] | Nil, List['A0] & 'a,) -> (Cons['A0] | 'a)
//│ fun listJoin: forall 'A1. (Cons['A1] | Nil, #Str,) -> #Str
//│ where
//│   'A <: 'A0

type TreeMap[A] = Node[A] | Empty
module Empty
class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
fun insert(t, k, v) =
  if t is
    Node(k', _, l, r) and
      slt(k)(k') then Node(k', v, insert(l, k, v), r)
      sgt(k)(k') then Node(k', v, l, insert(r, k, v))
      _ then Node(k, v, l, r)
    Empty then Node(k, v, Empty, Empty)
fun find(t, k) =
  if t is
    Node(k', v, l, r) and
      slt(k)(k') then find(l, k)
      sgt(k)(k') then find(r, k)
      _ then Some(v)
    Empty then None
fun traverse(t, f) =
  if t is
    Empty then Nil
    Node(key, value, left, right) then
      listConcat(traverse(left, f), Cons(f(key, value), traverse(right, f)))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.199: 	      slt(k)(k') then Node(k', v, insert(l, k, v), r)
//│ ║         	      ^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.195: 	class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
//│ ║         	                   ^^^^^^
//│ ╟── but it flows into reference with expected type `#Str`
//│ ║  l.199: 	      slt(k)(k') then Node(k', v, insert(l, k, v), r)
//│ ╙──       	             ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.206: 	      slt(k)(k') then find(l, k)
//│ ║         	      ^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.195: 	class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
//│ ║         	                   ^^^^^^
//│ ╟── but it flows into reference with expected type `#Str`
//│ ║  l.206: 	      slt(k)(k') then find(l, k)
//│ ╙──       	             ^^
//│ type TreeMap[A] = Node[A] | Empty
//│ module Empty
//│ class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
//│ fun insert: forall 'A. (Empty | Node['A], nothing, 'A,) -> Node['A]
//│ fun find: forall 'A0. (Empty | Node['A0], #Str,) -> (None | Some['A0])
//│ fun traverse: forall 'A1 'A2. (Empty | Node['A1], (string, 'A1,) -> 'A2,) -> (Cons['A2] | Nil)

type JsonValue = JsonNull | JsonNumber | JsonString | JsonBoolean | JsonObject | JsonArray
module JsonNull {
  fun toString() = "null"
}
class JsonBoolean(value: bool) {
  fun toString() = getStringOf(value)
}
class JsonNumber(value: number) {
  fun toString() = getStringOf(value)
}
class JsonString(value: string) {
  fun toString() = JSON.stringify(value)
}
class JsonObject(entries: TreeMap[JsonValue]) {
  fun toString() =
    if entries is Empty then "{}"
      else concat3("{ ", listJoin(traverse(entries, (k, v) => concat3(k, ": ", getStringOf(v))), ", "), " }")
}
class JsonArray(elements: List[JsonValue]) {
  fun toString() = concat3("[", listJoin(elements, ", "), "]")
}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.256: 	      else concat3("{ ", listJoin(traverse(entries, (k, v) => concat3(k, ": ", getStringOf(v))), ", "), " }")
//│ ║         	                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.195: 	class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
//│ ║         	                   ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                           ^
//│ ╟── from reference:
//│ ║  l.256: 	      else concat3("{ ", listJoin(traverse(entries, (k, v) => concat3(k, ": ", getStringOf(v))), ", "), " }")
//│ ╙──       	                                                                      ^
//│ type JsonValue = JsonArray | JsonBoolean | JsonNumber | JsonObject | JsonString | JsonNull
//│ module JsonNull {
//│   fun toString: () -> "null"
//│ }
//│ class JsonBoolean(value: bool) {
//│   fun toString: () -> #Str
//│ }
//│ class JsonNumber(value: number) {
//│   fun toString: () -> #Str
//│ }
//│ class JsonString(value: string) {
//│   fun toString: () -> string
//│ }
//│ class JsonObject(entries: TreeMap[JsonValue]) {
//│   fun toString: () -> #Str
//│ }
//│ class JsonArray(elements: List[JsonValue]) {
//│   fun toString: () -> #Str
//│ }

toString of JsonNull
toString of JsonBoolean(true)
toString of JsonBoolean(false)
toString of JsonNumber(42)
toString of JsonArray of Nil
toString of JsonArray of Cons(JsonNumber(0), Cons(JsonNull, Cons(JsonNumber(1), Nil)))
toString of JsonObject of Empty
toString of JsonObject of insert(Empty, "hello", JsonString("world"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.294: 	toString of JsonBoolean(true)
//│ ║         	            ^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `True` is not an instance of type `bool`
//│ ║  l.294: 	toString of JsonBoolean(true)
//│ ║         	                        ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.244: 	class JsonBoolean(value: bool) {
//│ ╙──       	                         ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.295: 	toString of JsonBoolean(false)
//│ ║         	            ^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `False` is not an instance of type `bool`
//│ ║  l.295: 	toString of JsonBoolean(false)
//│ ║         	                        ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.244: 	class JsonBoolean(value: bool) {
//│ ╙──       	                         ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.296: 	toString of JsonNumber(42)
//│ ║         	            ^^^^^^^^^^^^^^
//│ ╟── integer literal of type `42` is not an instance of type `number`
//│ ║  l.296: 	toString of JsonNumber(42)
//│ ║         	                       ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.247: 	class JsonNumber(value: number) {
//│ ╙──       	                        ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.298: 	toString of JsonArray of Cons(JsonNumber(0), Cons(JsonNull, Cons(JsonNumber(1), Nil)))
//│ ║         	                              ^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `number`
//│ ║  l.298: 	toString of JsonArray of Cons(JsonNumber(0), Cons(JsonNull, Cons(JsonNumber(1), Nil)))
//│ ║         	                                         ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.247: 	class JsonNumber(value: number) {
//│ ╙──       	                        ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.298: 	toString of JsonArray of Cons(JsonNumber(0), Cons(JsonNull, Cons(JsonNumber(1), Nil)))
//│ ║         	                                                                 ^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.298: 	toString of JsonArray of Cons(JsonNumber(0), Cons(JsonNull, Cons(JsonNumber(1), Nil)))
//│ ║         	                                                                            ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.247: 	class JsonNumber(value: number) {
//│ ╙──       	                        ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.300: 	toString of JsonObject of insert(Empty, "hello", JsonString("world"))
//│ ║         	                                                 ^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"world"` is not an instance of type `string`
//│ ║  l.300: 	toString of JsonObject of insert(Empty, "hello", JsonString("world"))
//│ ║         	                                                            ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.250: 	class JsonString(value: string) {
//│ ╙──       	                        ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.300: 	toString of JsonObject of insert(Empty, "hello", JsonString("world"))
//│ ║         	                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `string`
//│ ║  l.300: 	toString of JsonObject of insert(Empty, "hello", JsonString("world"))
//│ ║         	                                        ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.195: 	class Node[A](key: string, value: A, left: TreeMap[A], right: TreeMap[A])
//│ ║         	                   ^^^^^^
//│ ╟── from reference:
//│ ║  l.202: 	    Empty then Node(k, v, Empty, Empty)
//│ ╙──       	                    ^
//│ #Str
//│ res
//│     = 'null'
//│ res
//│     = 'true'
//│ res
//│     = 'false'
//│ res
//│     = '42'
//│ res
//│     = '[]'
//│ res
//│     = '[0, null, 1]'
//│ res
//│     = '{}'
//│ res
//│     = '{ hello: "world" }'

class Scanner(source: string, at: int) {
  fun peek: Option[string] =
    if at < strlen(source) then Some(getCharAtIndex(source, at)) else None
  fun advance: Scanner =
    if at < strlen(source) then Scanner(source, at + 1) else this
}
fun scan(source) = Scanner(source, 0)
fun skipWhiteSpace(s: Scanner) =
  if s.peek is Some(ch) and isWhiteSpace(ch) then
    skipWhiteSpace(s.advance)
  else
    s
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.387: 	    if at < strlen(source) then Some(getCharAtIndex(source, at)) else None
//│ ║         	       ^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                                  ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.387: 	    if at < strlen(source) then Some(getCharAtIndex(source, at)) else None
//│ ╙──       	       ^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.387: 	    if at < strlen(source) then Some(getCharAtIndex(source, at)) else None
//│ ║         	       ^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                          ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.387: 	    if at < strlen(source) then Some(getCharAtIndex(source, at)) else None
//│ ╙──       	            ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ║         	       ^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                                  ^^^
//│ ╟── but it flows into reference with expected type `#Num`
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ╙──       	       ^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ║         	       ^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                          ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ╙──       	            ^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ║         	                                                ^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                                  ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ╙──       	                                                ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ║         	                                ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.389: 	    if at < strlen(source) then Scanner(source, at + 1) else this
//│ ║         	                                                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ╙──       	                                  ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ║         	                   ^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ║         	                                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ╙──       	                                  ^^^
//│ class Scanner(source: string, at: int) {
//│   fun advance: Scanner
//│   fun peek: Option[string]
//│ }
//│ fun scan: string -> (Scanner | error)
//│ fun skipWhiteSpace: (s: Scanner,) -> Scanner

type ParseResult[T] = ParseSuccess[T] | ParseFailure
class ParseSuccess[T](value: T, scanner: Scanner) {
  fun toString() = concat2("Success: ", getStringOf(value))
}
class ParseFailure(message: string, scanner: Scanner) {
  fun toString() = concat4("Failure at ", getStringOf(scanner.at), ": ", message)
}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.472: 	  fun toString() = concat4("Failure at ", getStringOf(scanner.at), ": ", message)
//│ ║         	                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ║         	                            ^^^^^^
//│ ╟── but it flows into reference with expected type `#Str`
//│ ║  l.472: 	  fun toString() = concat4("Failure at ", getStringOf(scanner.at), ": ", message)
//│ ║         	                                                                         ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                              ^
//│ ╟── from reference:
//│ ║  l.150: 	fun concat4(a, b, c, d) = concat2(a, concat3(b, c, d))
//│ ╙──       	                                                   ^
//│ type ParseResult[T] = ParseFailure | ParseSuccess[T]
//│ class ParseSuccess[T](value: T, scanner: Scanner) {
//│   fun toString: () -> #Str
//│ }
//│ class ParseFailure(message: string, scanner: Scanner) {
//│   fun toString: () -> (#Str | error)
//│ }

fun expect(scanner, ch) =
  if skipWhiteSpace(scanner).peek is
    Some(ch') and
      eq(ch)(ch') then ParseSuccess((), scanner.advance)
      else ParseFailure(concat4("expect '", ch, "' but found ", ch'), scanner)
    None then ParseFailure(concat3("expect '", ch, "' but found EOF"), scanner)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.501: 	      else ParseFailure(concat4("expect '", ch, "' but found ", ch'), scanner)
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.501: 	      else ParseFailure(concat4("expect '", ch, "' but found ", ch'), scanner)
//│ ║         	                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.502: 	    None then ParseFailure(concat3("expect '", ch, "' but found EOF"), scanner)
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.502: 	    None then ParseFailure(concat3("expect '", ch, "' but found EOF"), scanner)
//│ ║         	                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.498: 	  if skipWhiteSpace(scanner).peek is
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.499: 	    Some(ch') and
//│ ║         	^^^^^^^^^^^^^^^^^
//│ ║  l.500: 	      eq(ch)(ch') then ParseSuccess((), scanner.advance)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.501: 	      else ParseFailure(concat4("expect '", ch, "' but found ", ch'), scanner)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.502: 	    None then ParseFailure(concat3("expect '", ch, "' but found EOF"), scanner)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `string & ?A` is not an instance of type `Str`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                              ^
//│ ╟── from field selection:
//│ ║  l.498: 	  if skipWhiteSpace(scanner).peek is
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.167: 	class Some[A](value: A)
//│ ╙──       	           ^
//│ fun expect: (Scanner & {advance: Scanner}, #Str,) -> (ParseFailure | ParseSuccess[()] | error)

fun expectWord(scanner, word, result) =
  if
    strlen(word) > 0 and
      let head = stringHead(word)
      let tail = stringTail(word)
      expect(scanner, head) is
        ParseSuccess(_, scanner) then expectWord(scanner, tail, result)
        ParseFailure(m, s) then ParseFailure(m, s)
    scanner.peek is
      Some(ch) and isAlphabet(ch) then
        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
      else
        ParseSuccess(result, scanner)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.552: 	    strlen(word) > 0 and
//│ ║         	    ^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Num`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                          ^^^
//│ ╟── but it flows into application with expected type `#Num`
//│ ║  l.552: 	    strlen(word) > 0 and
//│ ╙──       	    ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.555: 	      expect(scanner, head) is
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                                      ^^^^^^
//│ ╟── but it flows into reference with expected type `#Str`
//│ ║  l.555: 	      expect(scanner, head) is
//│ ║         	                      ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                           ^
//│ ╟── from reference:
//│ ║  l.502: 	    None then ParseFailure(concat3("expect '", ch, "' but found EOF"), scanner)
//│ ╙──       	                                               ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.550: 	fun expectWord(scanner, word, result) =
//│ ║         	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.551: 	  if
//│ ║         	^^^^^
//│ ║  l.552: 	    strlen(word) > 0 and
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.553: 	      let head = stringHead(word)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.554: 	      let tail = stringTail(word)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.555: 	      expect(scanner, head) is
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.556: 	        ParseSuccess(_, scanner) then expectWord(scanner, tail, result)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.557: 	        ParseFailure(m, s) then ParseFailure(m, s)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.558: 	    scanner.peek is
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ║  l.559: 	      Some(ch) and isAlphabet(ch) then
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.561: 	      else
//│ ║         	^^^^^^^^^^
//│ ║  l.562: 	        ParseSuccess(result, scanner)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Str`
//│ ║  l.7: 	let asNativeString: anything => { length: int, charCodeAt: int => int, charAt: int => string, slice: int => string } = String
//│ ║       	                                                                                                            ^^^^^^
//│ ╟── but it flows into application with expected type `#Str`
//│ ║  l.554: 	      let tail = stringTail(word)
//│ ║         	                 ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                           ^
//│ ╟── from reference:
//│ ║  l.560: 	        ParseFailure(concat3("there should not be other alphabets after\"", word, "\""), scanner)
//│ ╙──       	                                                                            ^^^^
//│ fun expectWord: forall 'T. (Scanner & {peek: #Object & ~#Some | Some[anything], advance: Scanner}, #Str, 'T,) -> (ParseFailure | ParseSuccess['T] | error)

// If we put this function together with the next block, there will be type
// mismatch errors.
fun parseMatched(scanner, closingSymbol, parse, fn) =
  if parse(scanner.advance) is
    ParseSuccess(outcome, scanner) and expect(scanner, closingSymbol) is
      ParseSuccess(_, scanner) then ParseSuccess(fn(outcome), scanner)
      ParseFailure(message, scanner) then ParseFailure(message, scanner)
    ParseFailure(message, scanner) then ParseFailure(message, scanner)
//│ fun parseMatched: forall 'advance 'value 'T. ({advance: 'advance}, #Str, 'advance -> (ParseFailure | ParseSuccess['value]), 'value -> 'T,) -> (ParseFailure | ParseSuccess['T])

:ng
fun parseEntries(scanner): ParseResult[TreeMap[JsonValue]] = error
fun parseElements(scanner): ParseResult[List[JsonValue]] =
  let scanner' = skipWhiteSpace(scanner)
  if scanner'.peek is
    Some(ch) and
      eq(ch)("]") then ParseSuccess(Nil, scanner')
      parse(scanner') is
        ParseSuccess(head, scanner') and scanner'.peek is
          Some(ch) and eq(ch)(",") and parseElements(scanner'.advance) is
            ParseSuccess(tail, scanner') then ParseSuccess(Cons(head, tail), scanner')
            ParseFailure(m, s) then ParseFailure(m, s)
          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
        ParseFailure(m, s) then ParseFailure(m, s)
    None then ParseFailure("unexpected EOF", scanner)
fun parseStringContent(scanner): ParseResult[string] = error
fun parseNumber(scanner): ParseResult[JsonNumber] = error
fun parse(scanner) =
  let scanner' = skipWhiteSpace(scanner)
  if scanner'.peek is
    None then ParseFailure("expect a JSON value instead of EOF", scanner')
    Some(ch) and
      eq(ch)("{") then parseMatched(scanner', "}", parseEntries, JsonObject)
      eq(ch)("[") then parseMatched(scanner', "]", parseElements, JsonArray)
      eq(ch)("\"") then parseMatched(scanner', "\"", parseStringContent, JsonString)
      eq(ch)("-") then parseNumber(scanner')
      eq(ch)("t") then expectWord(scanner', "true", JsonBoolean(true))
      eq(ch)("f") then expectWord(scanner', "false", JsonBoolean(false))
      eq(ch)("n") then expectWord(scanner', "null", JsonNull)
      else
        ParseFailure(concat3("unrecognized character '", ch, "'"), scanner)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.682: 	    None then ParseFailure("expect a JSON value instead of EOF", scanner')
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"expect a JSON value instead of EOF"` is not an instance of type `string`
//│ ║  l.682: 	    None then ParseFailure("expect a JSON value instead of EOF", scanner')
//│ ║         	                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.688: 	      eq(ch)("t") then expectWord(scanner', "true", JsonBoolean(true))
//│ ║         	                                                    ^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `True` is not an instance of type `bool`
//│ ║  l.688: 	      eq(ch)("t") then expectWord(scanner', "true", JsonBoolean(true))
//│ ║         	                                                                ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.244: 	class JsonBoolean(value: bool) {
//│ ╙──       	                         ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.689: 	      eq(ch)("f") then expectWord(scanner', "false", JsonBoolean(false))
//│ ║         	                                                     ^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `False` is not an instance of type `bool`
//│ ║  l.689: 	      eq(ch)("f") then expectWord(scanner', "false", JsonBoolean(false))
//│ ║         	                                                                 ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.244: 	class JsonBoolean(value: bool) {
//│ ╙──       	                         ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.692: 	        ParseFailure(concat3("unrecognized character '", ch, "'"), scanner)
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `#Str` is not an instance of type `string`
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                    ^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `string`
//│ ║  l.692: 	        ParseFailure(concat3("unrecognized character '", ch, "'"), scanner)
//│ ║         	                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.681: 	  if scanner'.peek is
//│ ║         	     ^^^^^^^^^^^^^^^^
//│ ║  l.682: 	    None then ParseFailure("expect a JSON value instead of EOF", scanner')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.683: 	    Some(ch) and
//│ ║         	^^^^^^^^^^^^^^^^
//│ ║  l.684: 	      eq(ch)("{") then parseMatched(scanner', "}", parseEntries, JsonObject)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.685: 	      eq(ch)("[") then parseMatched(scanner', "]", parseElements, JsonArray)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.686: 	      eq(ch)("\"") then parseMatched(scanner', "\"", parseStringContent, JsonString)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.687: 	      eq(ch)("-") then parseNumber(scanner')
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.688: 	      eq(ch)("t") then expectWord(scanner', "true", JsonBoolean(true))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.689: 	      eq(ch)("f") then expectWord(scanner', "false", JsonBoolean(false))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.690: 	      eq(ch)("n") then expectWord(scanner', "null", JsonNull)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.691: 	      else
//│ ║         	^^^^^^^^^^
//│ ║  l.692: 	        ParseFailure(concat3("unrecognized character '", ch, "'"), scanner)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `string & ?A` is not an instance of type `Str`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.148: 	fun concat2(a, b) = concat(a)(b)
//│ ║         	                           ^
//│ ╟── from field selection:
//│ ║  l.681: 	  if scanner'.peek is
//│ ║         	     ^^^^^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.167: 	class Some[A](value: A)
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"expect ']' or ',' instead of EOF"` is not an instance of type `string`
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"expect ']' or ',' instead of EOF"` is not an instance of type `string`
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"expect ']' or ',' instead of EOF"` is not an instance of type `string`
//│ ║  l.674: 	          _ then ParseFailure("expect ']' or ',' instead of EOF", scanner')
//│ ║         	                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.676: 	    None then ParseFailure("unexpected EOF", scanner)
//│ ║         	              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"unexpected EOF"` is not an instance of type `string`
//│ ║  l.676: 	    None then ParseFailure("unexpected EOF", scanner)
//│ ║         	                           ^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.471: 	class ParseFailure(message: string, scanner: Scanner) {
//│ ╙──       	                            ^^^^^^
//│ fun parseEntries: anything -> ParseResult[TreeMap[JsonValue]]
//│ fun parseElements: Scanner -> ParseResult[List[JsonValue]]
//│ fun parseStringContent: anything -> ParseResult[string]
//│ fun parseNumber: anything -> ParseResult[JsonNumber]
//│ fun parse: Scanner -> (ParseFailure | ParseSuccess[JsonArray | JsonBoolean | JsonNull | JsonObject | JsonString | error] | error | ParseResult[JsonNumber])

:ng
toString of parse of scan of "    true"
toString of parse of scan of "  false"
toString of parse of scan of "  null"
toString of parse of scan of "[null]"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.810: 	toString of parse of scan of "    true"
//│ ║         	                     ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"    true"` is not an instance of type `string`
//│ ║  l.810: 	toString of parse of scan of "    true"
//│ ║         	                             ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                      ^^^^^^
//│ ╟── from reference:
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ╙──       	                           ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.811: 	toString of parse of scan of "  false"
//│ ║         	                     ^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"  false"` is not an instance of type `string`
//│ ║  l.811: 	toString of parse of scan of "  false"
//│ ║         	                             ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                      ^^^^^^
//│ ╟── from reference:
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ╙──       	                           ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.812: 	toString of parse of scan of "  null"
//│ ║         	                     ^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"  null"` is not an instance of type `string`
//│ ║  l.812: 	toString of parse of scan of "  null"
//│ ║         	                             ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                      ^^^^^^
//│ ╟── from reference:
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ╙──       	                           ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.813: 	toString of parse of scan of "[null]"
//│ ║         	                     ^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"[null]"` is not an instance of type `string`
//│ ║  l.813: 	toString of parse of scan of "[null]"
//│ ║         	                             ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.385: 	class Scanner(source: string, at: int) {
//│ ║         	                      ^^^^^^
//│ ╟── from reference:
//│ ║  l.391: 	fun scan(source) = Scanner(source, 0)
//│ ╙──       	                           ^^^^^^
//│ #Str
