:NewDefs


class Base0(n: number)
//│ class Base0(n: number)

// TODO
class Derived0(n: int) extends Base
//│ ╔══[ERROR] Could not find definition `Base`
//│ ║  l.8: 	class Derived0(n: int) extends Base
//│ ╙──     	                               ^^^^
//│ class Derived0(n: int)
//│ Code generation encountered an error:
//│   unresolved symbol Base


mixin Base1(n: number) {
  fun original = n
}
//│ mixin Base1(n: number) {
//│   fun original: number
//│ }

:e
mixin DerivedBad(n: int) extends Base
//│ ╔══[ERROR] mixin definitions cannot yet extend parents
//│ ║  l.25: 	mixin DerivedBad(n: int) extends Base
//│ ╙──      	                                 ^^^^
//│ mixin DerivedBad(n: int)

mixin Derived1(n: int) {
  fun foo = [n, this.n, super.n]
}
//│ mixin Derived1(n: int) {
//│   super: {n: 'n}
//│   this: {n: 'n0}
//│   fun foo: (int, 'n0, 'n,)
//│ }


class Test0 extends Base1(1/2), Derived1(1)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ║        	                          ^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ╙──      	                          ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ║        	                          ^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ╙──      	                            ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.41: 	class Test0 extends Base1(1/2), Derived1(1)
//│ ║        	                                         ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.31: 	mixin Derived1(n: int) {
//│ ╙──      	                  ^^^
//│ class Test0() {
//│   fun foo: (int, 1, error | number,)
//│   fun original: number
//│ }

let t = Test0()
//│ let t: Test0
//│ t
//│   = Test0 {}

t.n
//│ 1
//│ res
//│     = 1

t.original
//│ number
//│ res
//│     = 0.5

t.foo
//│ (int, 1, error | number,)
//│ res
//│     = [ 1, 1, 0.5 ]


module Test1 extends Base1(1/2), Derived1(1) {
  fun n = this.n
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ║        	                           ^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ╙──      	                           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ║        	                           ^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ╙──      	                             ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.90: 	  fun n = this.n
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.91: 	}
//│ ║        	^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.89: 	module Test1 extends Base1(1/2), Derived1(1) {
//│ ║        	                                          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.31: 	mixin Derived1(n: int) {
//│ ╙──      	                  ^^^
//│ module Test1() {
//│   fun foo: (int, 1, error | number,)
//│   fun n: 1
//│   fun original: number
//│ }

:re
Test1.n
//│ 1
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


class Test2(n: string) extends Base1(1/2), Derived1(1) {
  fun bar = [this.foo, n, this.n, this.original]
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ║         	                                     ^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ╙──       	                                     ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ║         	                                     ^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ╙──       	                                       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.132: 	  fun bar = [this.foo, n, this.n, this.original]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	}
//│ ║         	^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ║         	                                                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.31: 	mixin Derived1(n: int) {
//│ ╙──      	                  ^^^
//│ class Test2(n: string) {
//│   fun bar: ((int, string, error | number,), string, string, number,)
//│   fun foo: (int, string, error | number,)
//│   fun original: number
//│ }

Test2("test").bar
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.165: 	Test2("test").bar
//│ ║         	^^^^^^^^^^^^^
//│ ╟── string literal of type `"test"` is not an instance of type `string`
//│ ║  l.165: 	Test2("test").bar
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.131: 	class Test2(n: string) extends Base1(1/2), Derived1(1) {
//│ ╙──       	               ^^^^^^
//│ ((int, string, error | number,), string, string, number,) | error
//│ res
//│     = [ [ 1, 'test', 0.5 ], 'test', 'test', 0.5 ]


class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
  fun foo = [super.foo, n, this.original]
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.180: 	class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
//│ ║         	                                     ^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.180: 	class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
//│ ╙──       	                                     ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.180: 	class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
//│ ║         	                                     ^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.180: 	class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
//│ ╙──       	                                       ^
//│ class Test3(n: string) {
//│   fun foo: ((int, string, error | number,), string, number,)
//│   fun original: number
//│ }

Test3("test").foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.200: 	Test3("test").foo
//│ ║         	^^^^^^^^^^^^^
//│ ╟── string literal of type `"test"` is not an instance of type `string`
//│ ║  l.200: 	Test3("test").foo
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.180: 	class Test3(n: string) extends Base1(1/2), Derived1(length(n)) {
//│ ╙──       	               ^^^^^^
//│ ((int, string, error | number,), string, number,) | error
//│ res
//│     = [ [ 4, 'test', 0.5 ], 'test', 0.5 ]


