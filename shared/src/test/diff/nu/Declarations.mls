:NewDefs



declare fun btoa: nothing
declare fun atob: nothing
//│ fun btoa: nothing
//│ fun atob: nothing

let str = btoa("hello")
atob(str)
//│ let str: nothing
//│ nothing
//│ str
//│     = 'aGVsbG8='
//│ res
//│     = 'hello'


declare module console {
  fun error: string -> unit
}
//│ module console() {
//│   fun error: string -> unit
//│ }

console.error("hello")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.27: 	console.error("hello")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `string`
//│ ║  l.27: 	console.error("hello")
//│ ║        	              ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.21: 	  fun error: string -> unit
//│ ╙──      	             ^^^^^^
//│ error | unit
//│ res
//│     = undefined
//│ // Output
//│ hello

:e
console.log("hello")
//│ ╔══[ERROR] Module `console` does not contain member `log`
//│ ║  l.44: 	console.log("hello")
//│ ╙──      	       ^^^^
//│ error
//│ res
//│     = undefined



declare module Foo {
  fun foo: int
}
//│ module Foo() {
//│   fun foo: int
//│ }

:re
Foo.foo
//│ int
//│ res
//│ Runtime error:
//│   ReferenceError: Foo is not defined


declare type A = int
//│ type A = int

42 : A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.72: 	42 : A
//│ ║        	^^
//│ ╟── integer literal of type `42` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.69: 	declare type A = int
//│ ║        	                 ^^^
//│ ╟── from type reference:
//│ ║  l.72: 	42 : A
//│ ╙──      	     ^
//│ A
//│ res
//│     = 42



declare class Sanitizer {
  fun sanitizeFor(element: string, input: string): string
}
//│ class Sanitizer() {
//│   fun sanitizeFor: (element: string, input: string,) -> string
//│ }

:re
let s = Sanitizer()
//│ let s: Sanitizer
//│ s
//│ Runtime error:
//│   ReferenceError: Sanitizer is not defined



// * TODO allow Buffer2 to be named Buffer...
// :d
declare module Buffer {
  class Buffer2 {
    val length: int
  }
  fun bar: int
  fun from(a: Array[int]): Buffer2 = from(a)
  // fun from1(a: Array[int]): this.Buffer2 = from1(a) // FIXME
  // fun from2(a: Array[int]): Buffer.Buffer2 = from2(a) // FIXME
}
//│ module Buffer() {
//│   class Buffer2() {
//│     let length: int
//│   }
//│   fun bar: int
//│   fun from: (a: Array[int],) -> Buffer2
//│ }

let b = Buffer.from([0, 1, 2])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.124: 	let b = Buffer.from([0, 1, 2])
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.124: 	let b = Buffer.from([0, 1, 2])
//│ ║         	                     ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.112: 	  fun from(a: Array[int]): Buffer2 = from(a)
//│ ╙──       	                    ^^^
//│ let b: Buffer2 | error
//│ b
//│   = <Buffer 00 01 02>

b.length
//│ error | int
//│ res
//│     = 3




:pe
declare 42
//│ ╔══[PARSE ERROR] Unexpected literal token after modifier
//│ ║  l.147: 	declare 42
//│ ╙──       	        ^^
//│ ╔══[PARSE ERROR] Unexpected literal token after modifier
//│ ║  l.147: 	declare 42
//│ ╙──       	        ^^
//│ 42
//│ res
//│     = 42


