:NewDefs


module M {
  type T = int -> int
  class C(n: int)
  fun mkC = C
}
//│ module M() {
//│   class C(n: int)
//│   type T = int -> int
//│   fun mkC: (n: int,) -> C
//│ }

let x: M.T = id
//│ let x: int -> int
//│ x
//│   = [Function: id]

fun foo(x: M.C) = x
//│ fun foo: (x: C,) -> C


foo(M.mkC(42))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.24: 	foo(M.mkC(42))
//│ ║        	    ^^^^^^^^^
//│ ╟── integer literal of type `42` is not an instance of type `int`
//│ ║  l.24: 	foo(M.mkC(42))
//│ ║        	          ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.6: 	  class C(n: int)
//│ ╙──     	             ^^^
//│ C
//│ res
//│     = C {}


:e
42 : M.mkC
//│ ╔══[ERROR] Illegal selection of value member in type position
//│ ║  l.40: 	42 : M.mkC
//│ ╙──      	      ^^^^
//│ error
//│ res
//│     = 42


