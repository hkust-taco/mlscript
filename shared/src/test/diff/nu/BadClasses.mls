:NewDefs



mixin M0(x: int)
//│ mixin M0(x: int)

:e
class C0 extends M0
//│ ╔══[ERROR] mixin M0 expects 1 parameters; got 0
//│ ║  l.9: 	class C0 extends M0
//│ ╙──     	                 ^^
//│ class C0()

:e
class C0 extends M0(1, 2)
//│ ╔══[ERROR] mixin M0 expects 1 parameters; got 2
//│ ║  l.16: 	class C0 extends M0(1, 2)
//│ ╙──      	                 ^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.16: 	class C0 extends M0(1, 2)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.16: 	class C0 extends M0(1, 2)
//│ ║        	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	mixin M0(x: int)
//│ ╙──     	            ^^^
//│ class C0()

:e
class C0 extends M0(true)
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.32: 	class C0 extends M0(true)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `True` is not an instance of type `int`
//│ ║  l.32: 	class C0 extends M0(true)
//│ ║        	                    ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	mixin M0(x: int)
//│ ╙──     	            ^^^
//│ class C0()


// TODO catch this at typing (lack of `this`)
class Foo {
  fun foo = 0
  fun bar = foo
}
//│ class Foo() {
//│   fun bar: 0
//│   fun foo: 0
//│ }

// FIXME
class Foo {
  let foo = 0
  fun bar = foo
}
//│ class Foo() {
//│   fun bar: 0
//│   let foo: 0
//│ }


module Bar {
  fun hello = 0
  type I = int
}
//│ module Bar() {
//│   type I = int
//│   fun hello: 0
//│ }

:e
hello
//│ ╔══[ERROR] identifier not found: hello
//│ ║  l.76: 	hello
//│ ╙──      	^^^^^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol hello

:e
1 : I
//│ ╔══[ERROR] type identifier not found: I
//│ ║  l.85: 	1 : I
//│ ╙──      	    ^
//│ error
//│ res
//│     = 1


:e
class Foo[A] { 42: A }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.95: 	class Foo[A] { 42: A }
//│ ║        	               ^^
//│ ╟── integer literal of type `42` does not match type `A`
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.95: 	class Foo[A] { 42: A }
//│ ╙──      	          ^
//│ class Foo[A]()


:e
class C1 { fun oops = this.x }
//│ ╔══[ERROR] Class `C1` does not contain member `x`
//│ ║  l.107: 	class C1 { fun oops = this.x }
//│ ╙──       	                          ^^
//│ class C1() {
//│   fun oops: error
//│ }


