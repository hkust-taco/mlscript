:NewDefs
:NoJS

trait Test {
  fun foo: int
  fun bar: bool -> bool
}
//│ trait Test() {
//│   fun bar: bool -> bool
//│   fun foo: int
//│ }

fun ts(x: Test) = x.foo
//│ fun ts: (x: Test,) -> int


module M extends Test {
  fun foo = 0
  fun bar = not
}
//│ module M() {
//│   fun bar: bool -> bool
//│   fun foo: 0
//│ }

M: Test
//│ Test

ts(M)
//│ int

trait Oth extends Test {
  let a : int
  fun cool : int -> bool
}
//│ trait Oth() {
//│   let a: int
//│   fun bar: bool -> bool
//│   fun cool: int -> bool
//│   fun foo: int
//│ }

let oth1: Oth
//│ let oth1: Oth

oth1.bar(true)
//│ bool

oth1: Test
//│ Test

:e
M : Oth
oth1: M
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.53: 	M : Oth
//│ ║        	^
//│ ╟── reference of type `M` is not an instance of type `Oth`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.53: 	M : Oth
//│ ╙──      	    ^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.54: 	oth1: M
//│ ║        	^^^^
//│ ╟── type `#Oth` is not an instance of type `M`
//│ ║  l.43: 	let oth1: Oth
//│ ║        	          ^^^
//│ ╟── but it flows into reference with expected type `M`
//│ ║  l.54: 	oth1: M
//│ ║        	^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.54: 	oth1: M
//│ ╙──      	      ^
//│ M

trait Geo { 
  let v: 2 | 3 
  fun get: int | bool
  fun ter: int
}
trait Anemo { 
  let v: 1 | 2
  fun get: bool | string
  fun ter: bool
}
//│ trait Geo() {
//│   fun get: bool | int
//│   fun ter: int
//│   let v: 2 | 3
//│ }
//│ trait Anemo() {
//│   fun get: bool | string
//│   fun ter: bool
//│   let v: 1 | 2
//│ }

trait Mixed extends Geo, Anemo
//│ trait Mixed() {
//│   fun get: bool
//│   fun ter: nothing
//│   let v: 2
//│ }


class C extends Test {
  fun foo: 1 = 1
  fun bar(x) = x
}
//│ class C() {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: 1
//│ }

mixin M {
  fun m1 = 3
}
//│ mixin M() {
//│   fun m1: 3
//│ }

class F extends Oth, M, Mixed {
  fun cool(x) = x == 1
  fun foo = 2
  fun bar(x) = x
  fun get = true
  fun ter = ter
  let a = 3
  let v = 2
}
//│ class F() {
//│   let a: 3
//│   fun bar: forall 'a. 'a -> 'a
//│   fun cool: number -> bool
//│   fun foo: 2
//│   fun get: true
//│   fun m1: 3
//│   fun ter: nothing
//│   let v: 2
//│ }

let fi = F()
//│ let fi: F

fi : Oth & Geo
//│ Geo & Oth

fi.get
//│ true

fi: Test & Anemo
//│ Anemo & Test

let fog: Oth & Mixed
//│ let fog: Mixed & Oth

fog: Test & Anemo
//│ Anemo & Test

:e
fog: F
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.160: 	fog: F
//│ ║         	^^^
//│ ╟── type `Mixed & Oth` is not an instance of type `F`
//│ ║  l.153: 	let fog: Oth & Mixed
//│ ║         	         ^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `F`
//│ ║  l.160: 	fog: F
//│ ║         	^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.160: 	fog: F
//│ ╙──       	     ^
//│ F

let c = C()
//│ let c: C

c: Eql<C>
//│ Eql[C]

let ct: Test = c
//│ let ct: Test

c.foo
//│ 1

c.bar(true)
//│ true

// :d
c: Test
//│ Test

:e
c: Oth
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.195: 	c: Oth
//│ ║         	^
//│ ╟── application of type `C` is not an instance of type `Oth`
//│ ║  l.175: 	let c = C()
//│ ║         	        ^^^
//│ ╟── but it flows into reference with expected type `#Oth`
//│ ║  l.195: 	c: Oth
//│ ║         	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.195: 	c: Oth
//│ ╙──       	   ^^^
//│ Oth

// :d
let c1: Test = C()
//│ let c1: Test

// :d
fun fcc(x: C) = x.foo
//│ fun fcc: (x: C,) -> 1

fun fc(x: Test) = x
fun ffm(x: F) = x.get
//│ fun fc: (x: Test,) -> Test
//│ fun ffm: (x: F,) -> true

:e
fun fee(x: Test) = x: Oth
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.224: 	fun fee(x: Test) = x: Oth
//│ ║         	                   ^
//│ ╟── type `#Test` is not an instance of type `Oth`
//│ ║  l.224: 	fun fee(x: Test) = x: Oth
//│ ║         	           ^^^^
//│ ╟── but it flows into reference with expected type `#Oth`
//│ ║  l.224: 	fun fee(x: Test) = x: Oth
//│ ║         	                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.224: 	fun fee(x: Test) = x: Oth
//│ ╙──       	                      ^^^
//│ fun fee: (x: Test,) -> Oth

fc(c)
//│ Test

fun fts['a](x: 'a & Test) = x.foo
fts(c)
//│ fun fts: forall 'foo. (x: Test & {foo: 'foo} | Test & ~#Test,) -> 'foo
//│ 1

fts(oth1)
//│ int

fts(c1)
//│ int

trait A1 { fun a1: 1 | 2 | 3 }
trait A2 { fun a1: 2 | 3 | 4 }
//│ trait A1() {
//│   fun a1: 1 | 2 | 3
//│ }
//│ trait A2() {
//│   fun a1: 2 | 3 | 4
//│ }

:e
class Ea1 extends A1, A2 {
  fun a1 = 4
}
//│ ╔══[ERROR] Type mismatch in definition of method a1:
//│ ║  l.264: 	  fun a1 = 4
//│ ║         	      ^^^^^^
//│ ╟── integer literal of type `4` does not match type `1 | 2 | 3`
//│ ║  l.264: 	  fun a1 = 4
//│ ║         	           ^
//│ ╟── but it flows into definition of method a1 with expected type `1 | 2 | 3`
//│ ║  l.264: 	  fun a1 = 4
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.253: 	trait A1 { fun a1: 1 | 2 | 3 }
//│ ║         	                   ^^^^^^^^^
//│ ╟── from signature of member a1:
//│ ║  l.253: 	trait A1 { fun a1: 1 | 2 | 3 }
//│ ╙──       	               ^^^^^^^^^^^^^
//│ class Ea1() {
//│   fun a1: 4
//│ }

trait Ele {
  fun ce: Oth -> Test
}
//│ trait Ele() {
//│   fun ce: Oth -> Test
//│ }

class CE extends Ele {
  fun ce(x) = x
}
//│ class CE() {
//│   fun ce: forall 'a. 'a -> 'a
//│ }

:e
class E1 extends Test {
  fun foo = 2
}
//│ ╔══[ERROR] Member bar is declared in parent trait but not implemented
//│ ║  l.300: 	class E1 extends Test {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.301: 	  fun foo = 2
//│ ║         	^^^^^^^^^^^^^
//│ ║  l.302: 	}
//│ ╙──       	^
//│ class E1() {
//│   fun foo: 2
//│ }

:e
trait TE1 extends C
trait TE2 extends M, Test
//│ ╔══[ERROR] trait can only inherit traits
//│ ║  l.315: 	trait TE1 extends C
//│ ╙──       	                  ^
//│ ╔══[ERROR] trait can only inherit traits
//│ ║  l.316: 	trait TE2 extends M, Test
//│ ╙──       	                  ^
//│ trait TE1()
//│ trait TE2()

:e
class E2 extends Test {
  fun foo = true
  fun bar(x) = x
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.328: 	  fun foo = true
//│ ║         	      ^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ║  l.328: 	  fun foo = true
//│ ║         	            ^^^^
//│ ╟── but it flows into definition of method foo with expected type `int`
//│ ║  l.328: 	  fun foo = true
//│ ║         	      ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	  fun foo: int
//│ ║       	           ^^^
//│ ╟── from signature of member foo:
//│ ║  l.5: 	  fun foo: int
//│ ╙──     	      ^^^^^^^^
//│ class E2() {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: true
//│ }

// TODO
:e
class D extends Test[int], Test[bool]
//│ ╔══[ERROR] trait Test expects 0 type parameter(s); got 1
//│ ║  l.353: 	class D extends Test[int], Test[bool]
//│ ╙──       	                ^^^^^^^^
//│ ╔══[ERROR] trait Test expects 0 type parameter(s); got 1
//│ ║  l.353: 	class D extends Test[int], Test[bool]
//│ ╙──       	                           ^^^^^^^^^
//│ ╔══[ERROR] Member foo is declared in parent trait but not implemented
//│ ║  l.353: 	class D extends Test[int], Test[bool]
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Member bar is declared in parent trait but not implemented
//│ ║  l.353: 	class D extends Test[int], Test[bool]
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ class D()



trait Base: A | B
class A extends Base
class B extends Base
//│ trait Base()
//│ class A()
//│ class B()


let b: Base = A()
//│ let b: Base

b: Base & (A | B)
//│ A & Base | B & Base

if b is
  A then 0
  B then 1
//│ 0 | 1


fun f(x: Base) = if x is
  A then 0
  B then 1
//│ fun f: (x: Base,) -> (0 | 1)

trait Base: Foo | Bar
class Foo[A](aa: (A, A)) extends Base
class Bar[B](f: B => B) extends Base
//│ trait Base()
//│ class Foo[A](aa: (A, A,))
//│ class Bar[B](f: B -> B)

let f: Foo = Foo((1, 2))
//│ let f: Foo[anything]

f.aa
//│ (??A, ??A,)

let b: Base = f
//│ let b: Base

if b is Foo(a) then a else 0
//│ (??A, ??A,) | 0

// FIXME? why does it happen in this case and not above?
if b is Bar(f) then f else 0
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.415: 	if b is Bar(f) then f else 0
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `B` leaks out of its scope
//│ ║  l.397: 	class Bar[B](f: B => B) extends Base
//│ ╙──       	          ^
//│ (??B & 'B) -> ('B | ??B0) | 0

// FIXME?
if b is
  Foo(a) then a
  Bar(f) then f
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.425: 	if b is
//│ ║         	   ^^^^
//│ ║  l.426: 	  Foo(a) then a
//│ ║         	^^^^^^^^^^^^^^^
//│ ║  l.427: 	  Bar(f) then f
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── type variable `B` leaks out of its scope
//│ ║  l.397: 	class Bar[B](f: B => B) extends Base
//│ ╙──       	          ^
//│ anything


// TODO report proper error
fun mt(x) = if x is Test then 1 else 0
//│ ╔══[ERROR] Cannot find constructor `Test` in scope
//│ ║  l.442: 	fun mt(x) = if x is Test then 1 else 0
//│ ╙──       	                    ^^^^
//│ fun mt: anything -> error

trait Geo
trait ZL extends Geo
trait GL extends Geo
trait WP extends ZL, GL
trait EM extends WP, Geo
//│ trait Geo()
//│ trait ZL()
//│ trait GL()
//│ trait WP()
//│ trait EM()

let g: Geo
let z: ZL
let w: WP
let e: EM
//│ let g: Geo
//│ let z: ZL
//│ let w: WP
//│ let e: EM

fun fot(x: EM): Geo = x
fun fit(x: EM): WP = x
w: Geo
z: Geo
e: WP
w: ZL & GL
e: ZL & Geo
//│ fun fot: (x: EM,) -> Geo
//│ fun fit: (x: EM,) -> WP
//│ Geo & ZL

:e
fun fto(w: WP): EM = w
z: WP
g: ZL
e: ZL & WP
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.480: 	fun fto(w: WP): EM = w
//│ ║         	                     ^
//│ ╟── type `#WP` is not an instance of type `EM`
//│ ║  l.480: 	fun fto(w: WP): EM = w
//│ ║         	           ^^
//│ ╟── but it flows into reference with expected type `#EM`
//│ ║  l.480: 	fun fto(w: WP): EM = w
//│ ║         	                     ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.480: 	fun fto(w: WP): EM = w
//│ ╙──       	                ^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.481: 	z: WP
//│ ║         	^
//│ ╟── type `#ZL` is not an instance of type `WP`
//│ ║  l.460: 	let z: ZL
//│ ║         	       ^^
//│ ╟── but it flows into reference with expected type `#WP`
//│ ║  l.481: 	z: WP
//│ ║         	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.481: 	z: WP
//│ ╙──       	   ^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.482: 	g: ZL
//│ ║         	^
//│ ╟── type `#Geo` is not an instance of type `ZL`
//│ ║  l.459: 	let g: Geo
//│ ║         	       ^^^
//│ ╟── but it flows into reference with expected type `#ZL`
//│ ║  l.482: 	g: ZL
//│ ║         	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.482: 	g: ZL
//│ ╙──       	   ^^
//│ fun fto: (w: WP,) -> EM
//│ WP & ZL

class Bs(a: bool) {
  fun foo(x) = x + 1
}
//│ class Bs(a: bool) {
//│   fun foo: int -> int
//│ }

class Ih extends Bs(false) {
  fun bar(x) = x
  fun foo(x) = 1
}
//│ class Ih() {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: anything -> 1
//│ }

let ih1 = Ih()
//│ let ih1: Ih

ih1.foo(1)
//│ 1

ih1: Bs
//│ Bs

ih1.a
//│ bool

:e
class Eh2 extends Bs(true), Ele {
    fun foo(x) = x && false
    fun ce(x) = x
}
//│ class Eh2() {
//│   fun ce: forall 'a. 'a -> 'a
//│   fun foo: bool -> bool
//│ }

:e
class Eh extends Bs(1)
class Eh1 extends Bs
class Eh3 extends Bs(false), Test
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.562: 	class Eh extends Bs(1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `bool`
//│ ║  l.562: 	class Eh extends Bs(1)
//│ ║         	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.523: 	class Bs(a: bool) {
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] class Bs expects 1 parameter(s); got 0
//│ ║  l.563: 	class Eh1 extends Bs
//│ ╙──       	                  ^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.524: 	  fun foo(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type `int`
//│ ║  l.524: 	  fun foo(x) = x + 1
//│ ║         	         ^^^^^^^^^^^
//│ ╟── but it flows into definition of method foo with expected type `int`
//│ ║  l.524: 	  fun foo(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	  fun foo: int
//│ ║       	           ^^^
//│ ╟── from signature of member foo:
//│ ║  l.5: 	  fun foo: int
//│ ╙──     	      ^^^^^^^^
//│ ╔══[ERROR] Member bar is declared in parent trait but not implemented
//│ ║  l.564: 	class Eh3 extends Bs(false), Test
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ class Eh() {
//│   fun foo: int -> int
//│ }
//│ class Eh1() {
//│   fun foo: int -> int
//│ }
//│ class Eh3() {
//│   fun foo: int -> int
//│ }

class Ca(a: int) extends Oth {
  fun foo = 1
  fun cool(x) = false
  fun bar(x) = x
}
//│ class Ca(a: int) {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun cool: anything -> false
//│   fun foo: 1
//│ }

class Cx(a: 1 | 2, b: bool) extends Ca(a)
//│ class Cx(a: 1 | 2, b: bool) {
//│   fun bar: 'a -> 'a
//│   fun cool: anything -> false
//│   fun foo: 1
//│ }

let cx1 = Cx(2, true)
//│ let cx1: Cx

cx1.bar(cx1.b)
//│ bool

cx1: Test
//│ Test

cx1: Ca
//│ Ca

class Bc1(foo: int)
class Bc2(bar: bool)
class Bc3 {
  let baz : int
}
//│ class Bc1(foo: int)
//│ class Bc2(bar: bool)
//│ class Bc3() {
//│   let baz: int
//│ }

:e
class Bc12 extends Bc1(1), Bc2(true)
//│ ╔══[ERROR] cannot inherit from more than one base class: Bc1 and Bc2
//│ ║  l.647: 	class Bc12 extends Bc1(1), Bc2(true)
//│ ╙──       	                           ^^^
//│ class Bc12()

class Bc02 extends Bc1(1:int) {
  let foo = 2
}
//│ class Bc02() {
//│   let foo: 2
//│ }

Bc02().foo
//│ 2

:e
class Bc31(baz: bool) extends Bc3
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.664: 	class Bc31(baz: bool) extends Bc3
//│ ║         	                ^^^^
//│ ╟── type `bool` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.638: 	  let baz : int
//│ ╙──       	            ^^^
//│ class Bc31(baz: bool)

:e
class Bc11 extends Bc1(1) {
  let foo = true
}
//│ ╔══[ERROR] Type mismatch in reference:
//│ ║  l.676: 	  let foo = true
//│ ║         	            ^^^^
//│ ╟── reference of type `true` does not match type `1`
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.675: 	class Bc11 extends Bc1(1) {
//│ ╙──       	                       ^
//│ ╔══[ERROR] Type mismatch in reference:
//│ ║  l.676: 	  let foo = true
//│ ║         	            ^^^^
//│ ╟── reference of type `true` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.635: 	class Bc1(foo: int)
//│ ╙──       	               ^^^
//│ class Bc11() {
//│   let foo: true
//│ }


trait Base[A] { fun f: A -> A }
//│ trait Base[A]() {
//│   fun f: A -> A
//│ }

class Der1 extends Base[int] { fun f(x) = x + 1 }
//│ class Der1() {
//│   fun f: int -> int
//│ }

class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (x, y) }
//│ class Der2[A, B]() {
//│   fun f: forall 'a 'b. ('b, 'a,) -> ('b, 'a,)
//│ }

trait BInt extends Base[int] {
  fun f = error
}
//│ trait BInt() {
//│   fun f: nothing
//│ }

trait BPar[T] extends Base[(int,T)]
//│ trait BPar[T]() {
//│   fun f: (int, T,) -> (int, T,)
//│ }

let bi: BInt
let bp: BPar[bool]
//│ let bi: BInt
//│ let bp: BPar[bool]

bp: Base[(int, bool)]
//│ ╔══[ERROR] Type `#BPar` does not contain member `Base#A`
//│ ║  l.697: 	trait Base[A] { fun f: A -> A }
//│ ╙──       	           ^
//│ Base[(int, bool,)]

bi.f(1)
//│ nothing

bp.f
//│ forall 'T. (int, 'T,) -> (int, 'T,)

fun fb[T](x: Base[(int, T)], y: T) = x.f((1, y))
//│ fun fb: forall 'T. (x: Base[(int, 'T,)], y: 'T,) -> (int, 'T,)

fb(bp, false)
//│ ╔══[ERROR] Type `#BPar` does not contain member `Base#A`
//│ ║  l.697: 	trait Base[A] { fun f: A -> A }
//│ ╙──       	           ^
//│ (int, false,) | error

class CP extends BPar[int] {
  fun f(x) = (x._2, x._1)
}
//│ class CP() {
//│   fun f: forall 'a 'b. {_1: 'a, _2: 'b} -> ('b, 'a,)
//│ }

let cp1 = CP()
//│ let cp1: CP

fb(cp1, 2)
//│ ╔══[ERROR] Type `CP` does not contain member `Base#A`
//│ ║  l.697: 	trait Base[A] { fun f: A -> A }
//│ ╙──       	           ^
//│ (int, 2,) | error

:e
trait BErr1 extends Base
//│ ╔══[ERROR] trait Base expects 1 type parameter(s); got 0
//│ ║  l.767: 	trait BErr1 extends Base
//│ ╙──       	                    ^^^^
//│ trait BErr1() {
//│   fun f: 'A -> 'A
//│ }

:e
class DerBad1 extends Base[int, int]
//│ ╔══[ERROR] trait Base expects 1 type parameter(s); got 2
//│ ║  l.776: 	class DerBad1 extends Base[int, int]
//│ ╙──       	                      ^^^^^^^^^^^^^
//│ ╔══[ERROR] Member f is declared in parent trait but not implemented
//│ ║  l.776: 	class DerBad1 extends Base[int, int]
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ class DerBad1()

:e
class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ╔══[ERROR] Type mismatch in definition of method f:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	                                            ^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `B` does not match type `A`
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	                                                         ^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	           ^
//│ ╟── Note: type parameter B is defined at:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ╙──       	              ^
//│ ╔══[ERROR] Type mismatch in definition of method f:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	                                            ^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `A` does not match type `B`
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	                                                            ^
//│ ╟── Note: constraint arises from type parameter:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ║         	              ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.786: 	class Der2[A, B] extends Base[(A, B)] { fun f((x, y)) = (y, x) }
//│ ╙──       	           ^
//│ class Der2[A, B]() {
//│   fun f: forall 'a 'b. ('a, 'b,) -> ('b, 'a,)
//│ }

trait Ta[T] {
  let p: bool
  let g: T
}
class K[A](k: Ta[A])
//│ trait Ta[T]() {
//│   let g: T
//│   let p: bool
//│ }
//│ class K[A](k: Ta[A])

let ta1: Ta[int]
//│ let ta1: Ta[int]

let k1 = K(ta1)
//│ let k1: K[int]

k1.k : Ta[int]
//│ Ta[int]

k1.k.g
//│ int

k1.k.p
//│ bool

trait Tb extends Ta[int] {
  let p = false
}
//│ trait Tb() {
//│   let g: int
//│   let p: false
//│ }

class Ctb extends Tb {
  let p = false
  let g = 2
}
//│ class Ctb() {
//│   let g: 2
//│   let p: false
//│ }

class G1[A](x: A)
//│ class G1[A](x: A)

// TODO
class GI(x: int) extends G1[int]
//│ ╔══[ERROR] class G1 expects 1 parameter(s); got 0
//│ ║  l.862: 	class GI(x: int) extends G1[int]
//│ ╙──       	                         ^^
//│ class GI(x: int)

trait Oz {
  let age: int
}
//│ trait Oz() {
//│   let age: int
//│ }

:e
class Fischl(age: bool) extends Oz
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.876: 	class Fischl(age: bool) extends Oz
//│ ║         	                  ^^^^
//│ ╟── type `bool` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.869: 	  let age: int
//│ ╙──       	           ^^^
//│ class Fischl(age: bool)

// TODO
class Klee(age: 1 | 2 | 3) extends Oz
//│ class Klee(age: 1 | 2 | 3)
