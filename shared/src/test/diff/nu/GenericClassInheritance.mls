:NewDefs

class Room[A](name: string) {
    fun foo(x: A) = x
}
//│ class Room[A](name: string) {
//│   fun foo: (x: A,) -> A
//│ }

class BigRoom extends Room[bool]("big")
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.10: 	class BigRoom extends Room[bool]("big")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"big"` is not an instance of type `string`
//│ ║  l.10: 	class BigRoom extends Room[bool]("big")
//│ ║        	                                 ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Room[A](name: string) {
//│ ╙──     	                    ^^^^^^
//│ class BigRoom extends Room {
//│   fun foo: (x: 'A,) -> 'A
//│ }
//│ where
//│   'A := bool

// * Note that this essentially infers Room[Bool]
class InferredRoom extends Room("infer") {
    fun foo(x) = x && true
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.27: 	class InferredRoom extends Room("infer") {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.28: 	    fun foo(x) = x && true
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"infer"` is not an instance of type `string`
//│ ║  l.27: 	class InferredRoom extends Room("infer") {
//│ ║        	                                ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Room[A](name: string) {
//│ ╙──     	                    ^^^^^^
//│ class InferredRoom extends Room {
//│   fun foo: Bool -> Bool
//│ }

(new InferredRoom) : Room['X]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.45: 	(new InferredRoom) : Room['X]
//│ ║        	^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `InferredRoom` is not an instance of type `Room`
//│ ║  l.45: 	(new InferredRoom) : Room['X]
//│ ║        	     ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.45: 	(new InferredRoom) : Room['X]
//│ ╙──      	                     ^^^^^^^^
//│ Room[Bool]
//│ res
//│     = InferredRoom {}

:e
class TooManyRoom extends Room[int, string]("too many")
//│ ╔══[ERROR] class Room expects 1 type parameter(s); got 2
//│ ║  l.60: 	class TooManyRoom extends Room[int, string]("too many")
//│ ╙──      	                          ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.60: 	class TooManyRoom extends Room[int, string]("too many")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"too many"` is not an instance of type `string`
//│ ║  l.60: 	class TooManyRoom extends Room[int, string]("too many")
//│ ║        	                                            ^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Room[A](name: string) {
//│ ╙──     	                    ^^^^^^
//│ class TooManyRoom extends Room {
//│   fun foo: (x: 'A,) -> 'A
//│ }
//│ where
//│   'A := int

:e
class WrongRoom extends Room[bool]("wrong") {
    fun foo(x) = x + 1
}
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.80: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.81: 	    fun foo(x) = x + 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"wrong"` is not an instance of type `string`
//│ ║  l.80: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	                                   ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.3: 	class Room[A](name: string) {
//│ ╙──     	                    ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.81: 	    fun foo(x) = x + 1
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── type `bool` is not an instance of type `Int`
//│ ║  l.80: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	                             ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.81: 	    fun foo(x) = x + 1
//│ ╙──      	                 ^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.81: 	    fun foo(x) = x + 1
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `bool`
//│ ║  l.81: 	    fun foo(x) = x + 1
//│ ║        	                 ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.80: 	class WrongRoom extends Room[bool]("wrong") {
//│ ║        	                             ^^^^
//│ ╟── from reference:
//│ ║  l.4: 	    fun foo(x: A) = x
//│ ╙──     	                    ^
//│ class WrongRoom extends Room {
//│   fun foo: Int -> Int
//│ }


class C0[A] { val a: A }
//│ class C0[A] {
//│   let a: A
//│ }

class C1[A] extends C0[A] { val a = a }
//│ class C1[A] extends C0 {
//│   let a: nothing
//│ }

:pe
:e
new C1 : C1[int]
//│ ╔══[PARSE ERROR] Unexpected type ascription after `new` keyword
//│ ║  l.132: 	new C1 : C1[int]
//│ ╙──       	    ^^
//│ ╔══[ERROR] Currently unsupported `new` syntax
//│ ║  l.132: 	new C1 : C1[int]
//│ ╙──       	^^^
//│ error
//│ res
//│     = {}

((new C1) : C1[int]) : C0['X]
//│ C0[int]
//│ res
//│     = C1 {}

(new C1).a
//│ nothing
//│ res
//│     = undefined


mixin M1[A] {
    fun f1(x: A): A = x
    fun f2(x: A): (A, A) = (x, x)
}
//│ mixin M1[A]() {
//│   fun f1: (x: A,) -> A
//│   fun f2: (x: A,) -> (A, A,)
//│ }

class A1 extends M1 {
    fun f1(x: int) = x
}
//│ class A1 {
//│   fun f1: (x: int,) -> int
//│   fun f2: (x: 'A,) -> ('A, 'A,)
//│ }

class A2[S, T] extends M1[(S, T)]
//│ class A2[S, T] {
//│   fun f1: (x: (S, T,),) -> (S, T,)
//│   fun f2: (x: (S, T,),) -> ((S, T,), (S, T,),)
//│ }

class A3(f1: bool => bool) extends M1
//│ class A3(f1: bool -> bool) {
//│   fun f1: (x: 'A,) -> 'A
//│   fun f2: (x: 'A,) -> ('A, 'A,)
//│ }

mixin M2[A] {
    fun m: A = this.a
}
//│ mixin M2[A]() {
//│   this: {a: A}
//│   fun m: A
//│ }

class B1(a: int) extends M2[int]
//│ class B1(a: int) {
//│   fun m: int
//│ }

class B2[A](a: int => A) extends M2
//│ class B2[A](a: int -> A) {
//│   fun m: int -> A
//│ }

:e
class E1(a: int) extends M2[bool]
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.202: 	class E1(a: int) extends M2[bool]
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `int` is not an instance of type `bool`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.202: 	class E1(a: int) extends M2[bool]
//│ ║         	                            ^^^^
//│ ╟── from field selection:
//│ ║  l.184: 	    fun m: A = this.a
//│ ╙──       	               ^^^^^^
//│ class E1(a: int) {
//│   fun m: bool
//│ }
