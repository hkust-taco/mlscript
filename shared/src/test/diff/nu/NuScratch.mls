:NewDefs


1; 2
//│ 2
//│ res
//│     = 1
//│ res
//│     = 2

// :dp
1, 2
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.12: 	1, 2
//│ ╙──      	^
//│ 2
//│ res
//│     = 2

1, ()
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.20: 	1, ()
//│ ╙──      	^
//│ ()
//│ res
//│     = undefined

log(1), 2
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

let a = 1, 2
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.29: 	let a = 1, 2
//│ ╙──      	        ^
//│ let a: 2
//│ a
//│   = 2

let a = 1; 2
//│ let a: 1
//│ 2
//│ a
//│   = 1
//│ res
//│     = 2

:pe // TODO support; make `;` have even less precedence than `,`
(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.46: 	(1;2)
//│ ╙──      	  ^
//│ 1
//│ res
//│     = 1

(1,2;3)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.54: 	(1,2;3)
//│ ╙──      	    ^
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.54: 	(1,2;3)
//│ ╙──      	 ^
//│ 2
//│ res
//│     = 2

(log(1), 2)
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

fun foo(x) = x
//│ fun foo: forall 'a. 'a -> 'a

foo(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.75: 	foo(1;2)
//│ ╙──      	     ^
//│ 1
//│ res
//│     = 1

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

foo(let x = log(0), 1; log(x), x + 1)
//│ Int
//│ res
//│     = 2
//│ // Output
//│ 0
//│ 1

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:e
foo(let x = 1 in x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.102: 	foo(let x = 1 in x + 1)
//│ ╙──       	              ^^
//│ ()
//│ res
//│     = undefined

foo((log(1), 2))
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

foo(1), 2
//│ ╔══[WARNING] Expression in statement position should have type `unit`.
//│ ╟── Use the `discard` function to discard non-unit values, making the intent clearer.
//│ ╟── Type mismatch in application:
//│ ║  l.117: 	foo(1), 2
//│ ║         	^^^^^^
//│ ╟── integer literal of type `1` does not match type `()`
//│ ║  l.117: 	foo(1), 2
//│ ║         	    ^
//│ ╟── but it flows into application with expected type `()`
//│ ║  l.117: 	foo(1), 2
//│ ╙──       	^^^^^^
//│ 2
//│ res
//│     = 2



let x = 2 in log(x), x + 1
//│ ╔══[PARSE ERROR] Expected end of input; found 'in' keyword instead
//│ ║  l.135: 	let x = 2 in log(x), x + 1
//│ ╙──       	          ^^
//│ let x: 2
//│ x
//│   = 2

let x = 2; log(x), x + 1
//│ let x: 2
//│ Int
//│ x
//│   = 2
//│ res
//│     = 3
//│ // Output
//│ 2




fun foo(x, y) = [x, y]
//│ fun foo: forall 'a 'b. ('a, 'b) -> ['a, 'b]

foo(1,2)
//│ [1, 2]
//│ res
//│     = [ 1, 2 ]

foo(log(1),2)
//│ [(), 2]
//│ res
//│     = [ undefined, 2 ]
//│ // Output
//│ 1

:pe
:e
foo(log(1);2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.173: 	foo(log(1);2)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.173: 	foo(log(1);2)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.173: 	foo(log(1);2)
//│ ║         	   ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 1

:e
foo((log(1),2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.193: 	foo((log(1),2))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── argument of type `[2]` does not match type `[?a, ?b]`
//│ ║  l.193: 	foo((log(1),2))
//│ ║         	   ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 1

foo((let x = log(0), 1; log(x), x + 1), 2)
//│ [Int, 2]
//│ res
//│     = [ 2, 2 ]
//│ // Output
//│ 0
//│ 1

:e
foo(let x = log(0), 1; log(x), x + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.218: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.218: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ 1

:e
foo(let x = log(0), 1 in log(x), x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.236: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.236: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[()]` does not match type `[?a, ?b]`
//│ ║  l.236: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 0

:e
foo(let x = log(0), 1; log(x), 1 + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.256: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.256: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ 1




