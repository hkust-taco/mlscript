:NewDefs


1; 2
//│ 2
//│ res
//│     = 1
//│ res
//│     = 2

// :dp
:js
1, 2
//│ 2
//│ // Prelude
//│ class TypingUnit1 {}
//│ const typing_unit1 = new TypingUnit1;
//│ // Query 1
//│ res = (1 , 2);
//│ // End of generated code
//│ res
//│     = 2

(1, 2)
//│ 2
//│ res
//│     = 2

(1, 2, 3)
//│ 3
//│ res
//│     = 3

1, ()
//│ ()
//│ res
//│     = undefined

log(1), 2
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

let a = 1, 2
//│ let a: 2
//│ a
//│   = 2

let a = 1; 2
//│ let a: 1
//│ 2
//│ a
//│   = 1
//│ res
//│     = 2

:pe // TODO support; make `;` have even less precedence than `,`
(1;2)
//│ ╔══[PARSE ERROR] Unexpected semicolon here
//│ ║  l.60: 	(1;2)
//│ ╙──      	  ^
//│ 1
//│ res
//│     = 1

:pe // ?
// :w
(1,2;3)
//│ ╔══[PARSE ERROR] Unexpected semicolon here
//│ ║  l.70: 	(1,2;3)
//│ ╙──      	    ^
//│ 2
//│ res
//│     = 2

(log(1), 2)
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

fun foo(x) = x
//│ fun foo: forall 'a. 'a -> 'a

:pe // ?
foo(1;2)
//│ ╔══[PARSE ERROR] Unexpected semicolon here
//│ ║  l.89: 	foo(1;2)
//│ ╙──      	     ^
//│ 1
//│ res
//│     = 1

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:js
foo(let x = log(0), 1; log(x), x + 1)
//│ Int
//│ // Prelude
//│ class TypingUnit14 {}
//│ const typing_unit14 = new TypingUnit14;
//│ // Query 1
//│ res = foo(((x) => (log(x) , x + 1))((log(0) , 1)));
//│ // End of generated code
//│ res
//│     = 2
//│ // Output
//│ 0
//│ 1


:js
foo((1, 2))
//│ 2
//│ // Prelude
//│ class TypingUnit15 {}
//│ const typing_unit15 = new TypingUnit15;
//│ // Query 1
//│ res = foo((1 , 2));
//│ // End of generated code
//│ res
//│     = 2

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

foo(let x = 1 in x + 1)
//│ Int
//│ res
//│     = 2

foo((log(1), 2))
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

foo(1), 2
//│ 2
//│ res
//│     = 2


:ge // FIXME
let rec x() = x() in x
//│ nothing
//│ Code generation encountered an error:
//│   recursive non-function definition x is not supported


:pe
let x[T] = 1 in x
//│ ╔══[PARSE ERROR] Expected function parameter list; found square bracket section instead
//│ ║  l.161: 	let x[T] = 1 in x
//│ ╙──       	     ^^^
//│ 1
//│ res
//│     = 1


let x = 2 in log(x), x + 1
//│ Int
//│ res
//│     = 3
//│ // Output
//│ 2

let x = 2; log(x), x + 1
//│ let x: 2
//│ Int
//│ x
//│   = 2
//│ res
//│     = 3
//│ // Output
//│ 2




fun foo(x, y) = [x, y]
//│ fun foo: forall 'a 'b. ('a, 'b) -> ['a, 'b]

foo(1,2)
//│ [1, 2]
//│ res
//│     = [ 1, 2 ]

foo(log(1),2)
//│ [(), 2]
//│ res
//│     = [ undefined, 2 ]
//│ // Output
//│ 1

:pe
:e
foo(log(1);2)
//│ ╔══[PARSE ERROR] Unexpected semicolon here
//│ ║  l.207: 	foo(log(1);2)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.207: 	foo(log(1);2)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.207: 	foo(log(1);2)
//│ ║         	   ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.190: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 1

:e
foo((log(1),2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.227: 	foo((log(1),2))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.227: 	foo((log(1),2))
//│ ║         	   ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.190: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 1

foo((let x = log(0), 1; log(x), x + 1), 2)
//│ [Int, 2]
//│ res
//│     = [ 2, 2 ]
//│ // Output
//│ 0
//│ 1

:e
foo(let x = log(0), 1; log(x), x + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.252: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.252: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.190: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ 1

:e
foo(let x = log(0), 1 in log(x), x + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.270: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.270: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.190: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ 1

:e
foo(let x = log(0), 1; log(x), 1 + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.288: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.288: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.190: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ 1





