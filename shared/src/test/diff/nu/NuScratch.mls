:NewDefs


1; 2
//│ 2
//│ res
//│     = 1
//│ res
//│     = 2

// :dp
:js
1, 2
//│ 2
//│ // Prelude
//│ class TypingUnit1 {}
//│ const typing_unit1 = new TypingUnit1;
//│ // Query 1
//│ res = (1 , 2);
//│ // End of generated code
//│ res
//│     = 2

1, ()
//│ ()
//│ res
//│     = undefined

log(1), 2
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

let a = 1, 2
//│ let a: 2
//│ a
//│   = 2

let a = 1; 2
//│ let a: 1
//│ 2
//│ a
//│   = 1
//│ res
//│     = 2

:pe // TODO support; make `;` have even less precedence than `,`
(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.50: 	(1;2)
//│ ╙──      	  ^
//│ 1
//│ res
//│     = 1

:pe // ?
(1,2;3)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.59: 	(1,2;3)
//│ ╙──      	    ^
//│ ╔══[WARNING] Pure expression does nothing in statement position.
//│ ║  l.59: 	(1,2;3)
//│ ╙──      	 ^
//│ 2
//│ res
//│     = 2

(log(1), 2)
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

fun foo(x) = x
//│ fun foo: forall 'a. 'a -> 'a

:pe // ?
foo(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.81: 	foo(1;2)
//│ ╙──      	     ^
//│ 1
//│ res
//│     = 1

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:js
foo(let x = log(0), 1; log(x), x + 1)
//│ Int
//│ // Prelude
//│ class TypingUnit12 {}
//│ const typing_unit12 = new TypingUnit12;
//│ // Query 1
//│ res = foo(((x) => log(x) , x + 1)(log(0) , 1));
//│ // End of generated code
//│ res
//│ Runtime error:
//│   ReferenceError: x is not defined

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:e
foo(let x = 1 in x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.113: 	foo(let x = 1 in x + 1)
//│ ╙──       	              ^^
//│ ()
//│ res
//│     = undefined

foo((log(1), 2))
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

foo(1), 2
//│ 2
//│ res
//│     = 2



let x = 2 in log(x), x + 1
//│ ╔══[PARSE ERROR] Expected end of input; found 'in' keyword instead
//│ ║  l.135: 	let x = 2 in log(x), x + 1
//│ ╙──       	          ^^
//│ let x: 2
//│ x
//│   = 2

let x = 2; log(x), x + 1
//│ let x: 2
//│ Int
//│ x
//│   = 2
//│ res
//│     = 3
//│ // Output
//│ 2




fun foo(x, y) = [x, y]
//│ fun foo: forall 'a 'b. ('a, 'b) -> ['a, 'b]

foo(1,2)
//│ [1, 2]
//│ res
//│     = [ 1, 2 ]

foo(log(1),2)
//│ [(), 2]
//│ res
//│     = [ undefined, 2 ]
//│ // Output
//│ 1

:pe
:e
foo(log(1);2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.173: 	foo(log(1);2)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.173: 	foo(log(1);2)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.173: 	foo(log(1);2)
//│ ║         	   ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 1

:e
foo((log(1),2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.193: 	foo((log(1),2))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── argument of type `[2]` does not match type `[?a, ?b]`
//│ ║  l.193: 	foo((log(1),2))
//│ ║         	   ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 1

foo((let x = log(0), 1; log(x), x + 1), 2)
//│ [Int, 2]
//│ res
//│ Runtime error:
//│   ReferenceError: x is not defined

:e
foo(let x = log(0), 1; log(x), x + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.216: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.216: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│ Runtime error:
//│   ReferenceError: x is not defined

:e
foo(let x = log(0), 1 in log(x), x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.232: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.232: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[()]` does not match type `[?a, ?b]`
//│ ║  l.232: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 0

:e
foo(let x = log(0), 1; log(x), 1 + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.252: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.252: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.156: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│ Runtime error:
//│   TypeError: ((intermediate value) , 2) is not a function
//│ // Output
//│ 0




