:NewDefs


1; 2
//│ 2
//│ res
//│     = 1
//│ res
//│     = 2

// :dp
:js
1, 2
//│ 2
//│ // Prelude
//│ class TypingUnit1 {}
//│ const typing_unit1 = new TypingUnit1;
//│ // Query 1
//│ res = (1 , 2);
//│ // End of generated code
//│ res
//│     = 2

(1, 2)
//│ 2
//│ res
//│     = 2

(1, 2, 3)
//│ 3
//│ res
//│     = 3

1, ()
//│ ()
//│ res
//│     = undefined

log(1), 2
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

let a = 1, 2
//│ let a: 2
//│ a
//│   = 2

let a = 1; 2
//│ let a: 1
//│ 2
//│ a
//│   = 1
//│ res
//│     = 2

:pe // TODO support; make `;` have even less precedence than `,`
(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.57: 	(1;2)
//│ ╙──      	  ^
//│ 1
//│ res
//│     = 1

:pe // ?
// :w
(1,2;3)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.67: 	(1,2;3)
//│ ╙──      	    ^
//│ 2
//│ res
//│     = 2

(log(1), 2)
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

fun foo(x) = x
//│ fun foo: forall 'a. 'a -> 'a

:pe // ?
foo(1;2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.86: 	foo(1;2)
//│ ╙──      	     ^
//│ 1
//│ res
//│     = 1

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:js
foo(let x = log(0), 1; log(x), x + 1)
//│ Int
//│ // Prelude
//│ class TypingUnit14 {}
//│ const typing_unit14 = new TypingUnit14;
//│ // Query 1
//│ res = foo(((x) => (log(x) , x + 1))(log(0) , 1));
//│ // End of generated code
//│ res
//│     = NaN
//│ // Output
//│ 0
//│ undefined

:js
foo((1, 2))
//│ 2
//│ // Prelude
//│ class TypingUnit15 {}
//│ const typing_unit15 = new TypingUnit15;
//│ // Query 1
//│ res = foo((1 , 2));
//│ // End of generated code
//│ res
//│     = 2

foo(let x = 1; x + 1)
//│ Int
//│ res
//│     = 2

:pe
foo(let x = 1 in x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.132: 	foo(let x = 1 in x + 1)
//│ ╙──       	              ^^
//│ ()
//│ res
//│     = undefined

foo((log(1), 2))
//│ 2
//│ res
//│     = 2
//│ // Output
//│ 1

foo(1), 2
//│ 2
//│ res
//│     = 2



let x = 2 in log(x), x + 1
//│ ╔══[PARSE ERROR] Expected end of input; found 'in' keyword instead
//│ ║  l.154: 	let x = 2 in log(x), x + 1
//│ ╙──       	          ^^
//│ let x: 2
//│ x
//│   = 2

let x = 2; log(x), x + 1
//│ let x: 2
//│ Int
//│ x
//│   = 2
//│ res
//│     = 3
//│ // Output
//│ 2




fun foo(x, y) = [x, y]
//│ fun foo: forall 'a 'b. ('a, 'b) -> ['a, 'b]

foo(1,2)
//│ [1, 2]
//│ res
//│     = [ 1, 2 ]

foo(log(1),2)
//│ [(), 2]
//│ res
//│     = [ undefined, 2 ]
//│ // Output
//│ 1

:pe
:e
foo(log(1);2)
//│ ╔══[PARSE ERROR] Unexpected ';' here
//│ ║  l.192: 	foo(log(1);2)
//│ ╙──       	          ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.192: 	foo(log(1);2)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.192: 	foo(log(1);2)
//│ ║         	   ^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.175: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 1

:e
foo((log(1),2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	foo((log(1),2))
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.212: 	foo((log(1),2))
//│ ║         	   ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.175: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 1

foo((let x = log(0), 1; log(x), x + 1), 2)
//│ [Int, 2]
//│ res
//│     = [ NaN, 2 ]
//│ // Output
//│ 0
//│ undefined

:e
foo(let x = log(0), 1; log(x), x + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.237: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.237: 	foo(let x = log(0), 1; log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.175: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ NaN, undefined ]
//│ // Output
//│ 0
//│ undefined

:e
foo(let x = log(0), 1 in log(x), x + 1)
//│ ╔══[PARSE ERROR] Unexpected 'in' keyword here
//│ ║  l.255: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.255: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[()]` does not match type `[?a, ?b]`
//│ ║  l.255: 	foo(let x = log(0), 1 in log(x), x + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.175: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ undefined, undefined ]
//│ // Output
//│ 0

:e
foo(let x = log(0), 1; log(x), 1 + 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.275: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── argument of type `[?a]` does not match type `[?b, ?c]`
//│ ║  l.275: 	foo(let x = log(0), 1; log(x), 1 + 1)
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.175: 	fun foo(x, y) = [x, y]
//│ ╙──       	       ^^^^^^
//│ error | [nothing, nothing]
//│ res
//│     = [ 2, undefined ]
//│ // Output
//│ 0
//│ undefined





