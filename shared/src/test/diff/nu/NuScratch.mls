:NewDefs



abstract class C0: C1 | C2
module C1 extends C0
class C2() extends C0
//│ abstract class C0: C1 | C2
//│ module C1 extends C0
//│ class C2() extends C0

fun foo(x: C0) = if x is
  C1 then 1
  C2 then 2
//│ fun foo: (x: C0) -> (1 | 2)

fun foo(x: C0) = x : C1 | C2
//│ fun foo: (x: C0) -> (C1 | C2)



abstract class Foo(): Int
//│ abstract class Foo(): Int


fun foo(x: Foo) = x : Int
//│ fun foo: (x: Foo) -> Int

:e
let f = Foo() : Foo
//│ ╔══[ERROR] Class Foo is abstract and cannot be instantiated
//│ ║  l.30: 	let f = Foo() : Foo
//│ ╙──      	        ^^^
//│ let f: Foo
//│ f
//│   = Foo {}

f : Int | 0
//│ Int
//│ res
//│     = Foo {}

:d
f : Int
//│ 0. Typing TypingUnit(List(Asc(Var(f),TypeName(Int))))
//│ | Typing unit statements
//│ | | 0. Typing term Asc(Var(f),TypeName(Int))
//│ | | | 0. Typing term Var(f)
//│ | | | 0. : Foo
//│ | | | Typing type TypeName(Int)
//│ | | | | vars=Map() newDefsInfo=Map()
//│ | | | | 0. type TypeName(Int)
//│ | | | | => Int
//│ | | | => Int ——— 
//│ | | | CONSTRAIN Foo <! Int
//│ | | |   where 
//│ | | | 0. C Foo <! Int    (0)
//│ | | | | 0. C (#Foo<Object> & Int) <! #Int<Object,Num>    (2)
//│ | | | | | Already a subtype by <:<
//│ | | 0. : Int
//│ | : Some(Int)
//│ ======== TYPED ========
//│ res: Some(Int) where 
//│ Int
//│ res
//│     = Foo {}


// FIXME
Foo() + 1
//│ ╔══[ERROR] Class Foo is abstract and cannot be instantiated
//│ ║  l.71: 	Foo() + 1
//│ ╙──      	^^^
//│ Int
//│ res
//│     = '[object Object]1'

// FIXME
(Foo() : Foo) + 1
//│ ╔══[ERROR] Class Foo is abstract and cannot be instantiated
//│ ║  l.80: 	(Foo() : Foo) + 1
//│ ╙──      	 ^^^
//│ Int
//│ res
//│     = '[object Object]1'



// FIXME
module Foo: Int
Foo + 1
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.91: 	module Foo: Int
//│ ║        	^^^^^^^^^^
//│ ╟── expression of type `#Foo` is not an instance of type `Int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.91: 	module Foo: Int
//│ ╙──      	            ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.92: 	Foo + 1
//│ ║        	^^^^^^^
//│ ╟── reference of type `Foo` is not an instance of type `Int`
//│ ║  l.92: 	Foo + 1
//│ ╙──      	^^^
//│ module Foo: Int
//│ Int | error
//│ res
//│     = '[object Object]1'




