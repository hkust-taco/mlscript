:NewDefs


:d
abstract class C0: C1 | C2
class C1() extends C0
module C2 extends C0
//│ 0. Typing ‹class C0: C1 | C2 {}; class C1(): C0 {}; module C2: C0 {}›
//│ | 0. Created lazy type info for class C0: C1 | C2 {}
//│ | 0. Created lazy type info for class C1(): C0 {}
//│ | 0. Created lazy type info for module C2: C0 {}
//│ | Completing class C0: C1 | C2 {}
//│ | | Type params 
//│ | | Params 
//│ | | Typing type Union(TypeName(C1),TypeName(C2))
//│ | | | vars=Map() newDefsInfo=Map()
//│ | | | 2. type Union(TypeName(C1),TypeName(C2))
//│ | | | | 2. type TypeName(C1)
//│ | | | | => C1
//│ | | | | 2. type TypeName(C2)
//│ | | | | => C2
//│ | | | => (C1 | C2)
//│ | | => (C1 | C2) ——— 
//│ | | CONSTRAIN (C1 | C2) <! α29'
//│ | |   where 
//│ | | 1. C (C1 | C2) <! α29'    (0)
//│ | | | NEW α29' LB (0)
//│ | | Done inheriting: Pack({},List(),None,List(),List(),Map(),⊤)
//│ | | 1. Finalizing inheritance with (({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)) <: c030'
//│ | | | CONSTRAIN (({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)) <! c030'
//│ | | |   where 
//│ | | | 1. C (({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)) <! c030'    (0)
//│ | | | | NEW c030' LB (0)
//│ | | 1. Typing ‹›
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C0
//│ | | | Trav(+)((({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)))
//│ | | | | Trav(+)(({} w/ {} & #C0<Object>))
//│ | | | | | Trav(+)({} w/ {})
//│ | | | | | | Trav(+)({})
//│ | | | | | Trav(+)(#C0<Object>)
//│ | | | | Trav(+)(⊤..(C1 | C2))
//│ | | | | | Trav(+)((C1 | C2))
//│ | | | | | | Trav(+)(C1)
//│ | | | | | | Trav(+)(C2)
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: ⊤..(C1 | C2), Set(), Map())((({} w/ {} & #C0<Object>) & ⊤..(C1 | C2))) where 
//│ | Completing class C1(): C0 {}
//│ | | Type params 
//│ | | Params List()
//│ | | 1. Typing parent spec C0
//│ | | | Class arg members List()
//│ | | => Inheriting from TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: ⊤..(C1 | C2), Set(), Map())((({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)))
//│ | | argMembs List()
//│ | | st ⊤..(C1 | C2)
//│ | | Done inheriting: Pack({},List(),Some(C0),List(),List(),Map(),⊤)
//│ | | 1. Finalizing inheritance with ({} w/ {} & #C1<Object,C0>) <: c131'
//│ | | | CONSTRAIN ({} w/ {} & #C1<Object,C0>) <! c131'
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C1<Object,C0>) <! c131'    (0)
//│ | | | | NEW c131' LB (0)
//│ | | 1. Typing ‹›
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C1
//│ | | | Trav(+)(({} w/ {} & #C1<Object,C0>))
//│ | | | | Trav(+)({} w/ {})
//│ | | | | | Trav(+)({})
//│ | | | | Trav(+)(#C1<Object,C0>)
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C1),
//│ 	List(),
//│ 	Some(List()),
//│ 	this: ⊤, ,
//│ 	: ⊤, Set(TypeName(C0)), Map())(({} w/ {} & #C1<Object,C0>)) where 
//│ | Completing module C2: C0 {}
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing parent spec C0
//│ | | | Class arg members List()
//│ | | => Inheriting from TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: ⊤..(C1 | C2), Set(), Map())((({} w/ {} & #C0<Object>) & ⊤..(C1 | C2)))
//│ | | argMembs List()
//│ | | st ⊤..(C1 | C2)
//│ | | Done inheriting: Pack({},List(),Some(C0),List(),List(),Map(),⊤)
//│ | | 1. Finalizing inheritance with ({} w/ {} & #C2<Object,C0>) <: c232'
//│ | | | CONSTRAIN ({} w/ {} & #C2<Object,C0>) <! c232'
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C2<Object,C0>) <! c232'    (0)
//│ | | | | NEW c232' LB (0)
//│ | | 1. Typing ‹›
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C2
//│ | | | Trav(+)(({} w/ {} & #C2<Object,C0>))
//│ | | | | Trav(+)({} w/ {})
//│ | | | | | Trav(+)({})
//│ | | | | Trav(+)(#C2<Object,C0>)
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C2),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: ⊤, Set(TypeName(C0)), Map())(({} w/ {} & #C2<Object,C0>)) where 
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ class C0
//│   this: ⊤ 
//│ class C1
//│   this: ⊤ 
//│ class C2
//│   this: ⊤ 
//│ abstract class C0: C1 | C2
//│ class C1() extends C0
//│ module C2 extends C0

:e
class C2 extends C0
//│ class C2 extends C0 {
//│   constructor()
//│ }



class Foo(): {}
//│ class Foo()

class Foo(): {} {
  fun x = 0
}
//│ class Foo() {
//│   fun x: 0
//│ }

class Foo(): { x: Int } {
  fun x = 0
}
//│ class Foo(): {x: Int} {
//│   fun x: 0
//│ }

class Foo(): { x: 'FigureItOut } {
  fun x = 0
}
//│ class Foo(): {x: ??FigureItOut} {
//│   fun x: 0
//│ }

:e
not(Foo().x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.144: 	not(Foo().x)
//│ ║         	^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `Bool`
//│ ║  l.137: 	  fun x = 0
//│ ║         	          ^
//│ ╟── but it flows into field selection with expected type `Bool`
//│ ║  l.144: 	not(Foo().x)
//│ ╙──       	    ^^^^^^^
//│ error | false | true
//│ res
//│     = true

(f: Foo) => f.x
//│ (f: Foo) -> (0 & ??FigureItOut)
//│ res
//│     = [Function: res]


trait B
//│ trait B

// :e // TODO check classes against their signatures
// :d
class A(): B
//│ class A(): B

:e
A() : B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.173: 	A() : B
//│ ║         	^^^
//│ ╟── application of type `A` is not an instance of type `B`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.173: 	A() : B
//│ ╙──       	      ^
//│ B
//│ res
//│     = A {}

abstract class A(): B
//│ abstract class A(): B

:e
A() : B
//│ ╔══[ERROR] Class A is abstract and cannot be instantiated
//│ ║  l.189: 	A() : B
//│ ╙──       	^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.189: 	A() : B
//│ ║         	^^^
//│ ╟── application of type `A` is not an instance of type `B`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.189: 	A() : B
//│ ╙──       	      ^
//│ B
//│ res
//│     = A {}

module C extends A, B
//│ module C extends A, B

C : B
//│ B
//│ res
//│     = C { class: [class C extends A] }


class A(): C
class B() extends A
class C() extends B
//│ class A(): C
//│ class B() extends A
//│ class C() extends A, B

:e // FIXME transitivity of self types
fun test(x: B): C = x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.221: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── type `B` is not an instance of `C`
//│ ║  l.221: 	fun test(x: B): C = x
//│ ║         	            ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.221: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.221: 	fun test(x: B): C = x
//│ ╙──       	                ^
//│ fun test: (x: B) -> C



