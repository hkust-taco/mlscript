:NewDefs


:d
abstract class C0: C1 | C2
class C1() extends C0
module C2 extends C0
//│ 0. Typing TypingUnit(List(NuTypeDef(Cls,TypeName(C0),List(),None,None,Some(Union(TypeName(C1),TypeName(C2))),List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(C1),List(),Some(Tup(List())),None,None,List(Var(C0)),None,None,TypingUnit(List())), NuTypeDef(Mod,TypeName(C2),List(),None,None,None,List(Var(C0)),None,None,TypingUnit(List()))))
//│ | 0. Created lazy type info for NuTypeDef(Cls,TypeName(C0),List(),None,None,Some(Union(TypeName(C1),TypeName(C2))),List(),None,None,TypingUnit(List()))
//│ | 0. Created lazy type info for NuTypeDef(Cls,TypeName(C1),List(),Some(Tup(List())),None,None,List(Var(C0)),None,None,TypingUnit(List()))
//│ | 0. Created lazy type info for NuTypeDef(Mod,TypeName(C2),List(),None,None,None,List(Var(C0)),None,None,TypingUnit(List()))
//│ | Completing class C0: C1 | C2 {}
//│ | | Type params 
//│ | | Params 
//│ | | Typing type Union(TypeName(C1),TypeName(C2))
//│ | | | vars=Map() newDefsInfo=Map()
//│ | | | 2. type Union(TypeName(C1),TypeName(C2))
//│ | | | | 2. type TypeName(C1)
//│ | | | | => C1
//│ | | | | 2. type TypeName(C2)
//│ | | | | => C2
//│ | | | => (C1 | C2)
//│ | | => (C1 | C2) ——— 
//│ | | CONSTRAIN (C1 | C2) <! α29'
//│ | |   where 
//│ | | 1. C (C1 | C2) <! α29'    (0)
//│ | | | NEW α29' LB (0)
//│ | | Done inheriting: Pack({},List(),None,List(),List(),Map(),(C1 | C2))
//│ | | 1. Finalizing inheritance with ({} w/ {} & #C0<Object>) <: c030'
//│ | | | CONSTRAIN (({} w/ {} & #C0<Object>) & (C1 | C2)) <! c030'
//│ | | |   where 
//│ | | | 1. C (({} w/ {} & #C0<Object>) & (C1 | C2)) <! c030'    (0)
//│ | | | | NEW c030' LB (0)
//│ | | 1. Typing TypingUnit(List())
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C0
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: (C1 | C2), Set(), Map()) where 
//│ | Completing class C1(): C0 {}
//│ | | Type params 
//│ | | Params List()
//│ | | 1. Typing parent spec Var(C0)
//│ | | | Class arg members List()
//│ | | => Inheriting from TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: (C1 | C2), Set(), Map())
//│ | | argMembs List()
//│ | | selfSig (C1 | C2)
//│ | | Done inheriting: Pack({},List(),Some(C0),List(),List(),Map(),(C1 | C2))
//│ | | 1. Finalizing inheritance with ({} w/ {} & #C1<Object,C0>) <: c131'
//│ | | | CONSTRAIN ({} w/ {} & #C1<Object,C0>) <! c131'
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C1<Object,C0>) <! c131'    (0)
//│ | | | | NEW c131' LB (0)
//│ | | Checking self signature...
//│ | | | CONSTRAIN ({} w/ {} & #C1<Object,C0>) <! (C1 | C2)
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C1<Object,C0>) <! (C1 | C2)    (0)
//│ | | | | 1. ARGH  DNF(0, #C1<Object,C0>{})  <!  DNF(0, #C1<Object,C0>{} | #C2<Object,C0>{})
//│ | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | Consider #C1<Object,C0>{} <: DNF(0, #C1<Object,C0>{} | #C2<Object,C0>{})
//│ | | | | | OK  #C1<Object,C0>{} <: #C1<Object,C0>{}
//│ | | 1. Typing TypingUnit(List())
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C1
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C1),
//│ 	List(),
//│ 	Some(List()),
//│ 	this: ⊤, ,
//│ 	: ⊤, Set(TypeName(C0)), Map()) where 
//│ | Completing module C2: C0 {}
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing parent spec Var(C0)
//│ | | | Class arg members List()
//│ | | => Inheriting from TypedNuCls(0, TypeName(C0),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: (C1 | C2), Set(), Map())
//│ | | argMembs List()
//│ | | selfSig (C1 | C2)
//│ | | Done inheriting: Pack({},List(),Some(C0),List(),List(),Map(),(C1 | C2))
//│ | | 1. Finalizing inheritance with ({} w/ {} & #C2<Object,C0>) <: c232'
//│ | | | CONSTRAIN ({} w/ {} & #C2<Object,C0>) <! c232'
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C2<Object,C0>) <! c232'    (0)
//│ | | | | NEW c232' LB (0)
//│ | | Checking self signature...
//│ | | | CONSTRAIN ({} w/ {} & #C2<Object,C0>) <! (C1 | C2)
//│ | | |   where 
//│ | | | 1. C ({} w/ {} & #C2<Object,C0>) <! (C1 | C2)    (0)
//│ | | | | 1. ARGH  DNF(0, #C2<Object,C0>{})  <!  DNF(0, #C1<Object,C0>{} | #C2<Object,C0>{})
//│ | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | Consider #C2<Object,C0>{} <: DNF(0, #C1<Object,C0>{} | #C2<Object,C0>{})
//│ | | | | | OK  #C2<Object,C0>{} <: #C2<Object,C0>{}
//│ | | 1. Typing TypingUnit(List())
//│ | | | Typing unit statements
//│ | | | : None
//│ | | baseClsImplemMembers List()
//│ | | Checking `this` accesses...
//│ | | Checking base class implementations against inherited signatures...
//│ | | Checking new implementations against inherited signatures...
//│ | | Checking new signatures against inherited signatures...
//│ | | allMembers Map()
//│ | | Computing variances of C2
//│ | | = HashMap()
//│ | Completed TypedNuCls(0, TypeName(C2),
//│ 	List(),
//│ 	None,
//│ 	this: ⊤, ,
//│ 	: ⊤, Set(TypeName(C0)), Map()) where 
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ class C0
//│   this: ⊤ 
//│ class C1
//│   this: ⊤ 
//│ class C2
//│   this: ⊤ 
//│ abstract class C0: C1 | C2
//│ class C1() extends C0
//│ module C2 extends C0

// :d
:e
class C3 extends C0
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.149: 	class C3 extends C0
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#C3` does not match type `C1 | C2`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.5: 	abstract class C0: C1 | C2
//│ ╙──     	                   ^^^^^^^
//│ class C3 extends C0 {
//│   constructor()
//│ }



class Foo(): {}
//│ class Foo()

class Foo(): {} {
  fun x = 0
}
//│ class Foo() {
//│   fun x: 0
//│ }

:e
class Foo(): { x: Int } {
  fun x = 0
}
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.174: 	class Foo(): { x: Int } {
//│ ╙──       	               ^
//│ class Foo(): {x: Int} {
//│   fun x: 0
//│ }

class Foo(): { x: Int } {
  fun x: Int
  fun x = 0
}
//│ class Foo(): {x: Int} {
//│   fun x: Int
//│ }

:e
class Foo(): { x: 'FigureItOut } {
  fun x: Int
  fun x = 0
}
//│ ╔══[ERROR] Type error in type declaration
//│ ║  l.193: 	class Foo(): { x: 'FigureItOut } {
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.194: 	  fun x: Int
//│ ║         	^^^^^^^^^^^^
//│ ║  l.195: 	  fun x = 0
//│ ║         	^^^^^^^^^^^
//│ ║  l.196: 	}
//│ ║         	^
//│ ╟── type variable `'FigureItOut` leaks out of its scope
//│ ║  l.194: 	  fun x: Int
//│ ╙──       	         ^^^
//│ class Foo(): {x: ??FigureItOut} {
//│   fun x: Int
//│ }

:e
not(Foo().x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.214: 	not(Foo().x)
//│ ║         	^^^^^^^^^^^^
//│ ╟── field selection of type `Int & ??FigureItOut` is not an instance of type `Bool`
//│ ║  l.214: 	not(Foo().x)
//│ ╙──       	    ^^^^^^^
//│ error | false | true
//│ res
//│     = true

(f: Foo) => f.x
//│ (f: Foo) -> (Int & ??FigureItOut)
//│ res
//│     = [Function: res]


trait B
//│ trait B

<<<<<<<
// :e // TODO check classes against their signatures!
||||||| b14bd8d83
// :e // TODO check classes against their signatures
=======
:e
// :d
>>>>>>>
class A(): B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.242: 	class A(): B
//│ ║         	^^^^^^^^^
//│ ╟── expression of type `#A` is not an instance of type `B`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.242: 	class A(): B
//│ ╙──       	           ^
//│ TEST CASE FAILURE: There was an unexpected type error
//│ class A(): B

A() : B
//│ B
//│ res
//│     = A {}

abstract class A(): B
//│ abstract class A(): B

:e
A() : B
//│ ╔══[ERROR] Class A is abstract and cannot be instantiated
//│ ║  l.262: 	A() : B
//│ ╙──       	^
//│ B
//│ res
//│     = A {}

module C extends A, B
//│ module C extends A, B

C : B
//│ B
//│ res
//│     = C { class: [class C extends A] }


// TODO warn on non-asbtract class with a self-sig

:e
class A(): C
class B() extends A
class C() extends B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.282: 	class A(): C
//│ ║         	^^^^^^^^^
//│ ╟── expression of type `#A` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.282: 	class A(): C
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.283: 	class B() extends A
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#B` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.282: 	class A(): C
//│ ╙──       	           ^
//│ class A(): C
//│ class B() extends A
//│ class C() extends A, B

:e // FIXME transitivity
abstract class A(): C
class B() extends A
class C() extends B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.305: 	class B() extends A
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#B` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.304: 	abstract class A(): C
//│ ╙──       	                    ^
//│ abstract class A(): C
//│ class B() extends A
//│ class C() extends A, B

abstract class A(): C
abstract class B() extends A
class C() extends B
//│ abstract class A(): C
//│ abstract class B() extends A
//│ class C() extends A, B

:e
class D() extends B
//│ class D() extends A, B
//│ TEST CASE FAILURE: There was an unexpected lack of type error

:e // FIXME transitivity of self types
fun test(x: B): C = x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.331: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── type `B` is not an instance of `C`
//│ ║  l.331: 	fun test(x: B): C = x
//│ ║         	            ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.331: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.331: 	fun test(x: B): C = x
//│ ╙──       	                ^
//│ fun test: (x: B) -> C





