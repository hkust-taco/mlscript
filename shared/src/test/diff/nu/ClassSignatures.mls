:NewDefs


abstract class C0: C1 | C2
class C1() extends C0
module C2 extends C0
//│ abstract class C0: C1 | C2
//│ class C1() extends C0
//│ module C2 extends C0

fun foo(x: C0) = if x is
  C1 then 1
  C2 then 2
//│ fun foo: (x: C0) -> (1 | 2)

fun foo(x: C0) = x : C1 | C2
//│ fun foo: (x: C0) -> (C1 | C2)

fun foo(x) = if x is
  C1 then 1
  C2 then 2
//│ fun foo: (C1 | C2) -> (1 | 2)

foo(C1()) + foo(C2)
//│ Int
//│ res
//│     = 3


:e
class C3 extends C0
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.31: 	class C3 extends C0
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#C3` does not match type `C1 | C2`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.4: 	abstract class C0: C1 | C2
//│ ╙──     	                   ^^^^^^^
//│ class C3 extends C0 {
//│   constructor()
//│ }


class Foo(): {}
//│ class Foo()

class Foo(): {} {
  fun x = 0
}
//│ class Foo() {
//│   fun x: 0
//│ }

:e
class Foo(): { x: Int } {
  fun x = 0
}
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.55: 	class Foo(): { x: Int } {
//│ ╙──      	               ^
//│ class Foo(): {x: Int} {
//│   fun x: 0
//│ }

class Foo(): { x: Int } {
  fun x: Int
  fun x = 0
}
//│ class Foo(): {x: Int} {
//│   fun x: Int
//│ }

:e
class Foo(): { x: 'FigureItOut } {
  fun x: Int
  fun x = 0
}
//│ ╔══[ERROR] Type error in type declaration
//│ ║  l.74: 	class Foo(): { x: 'FigureItOut } {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.75: 	  fun x: Int
//│ ║        	^^^^^^^^^^^^
//│ ║  l.76: 	  fun x = 0
//│ ║        	^^^^^^^^^^^
//│ ║  l.77: 	}
//│ ║        	^
//│ ╟── type variable `'FigureItOut` leaks out of its scope
//│ ║  l.75: 	  fun x: Int
//│ ╙──      	         ^^^
//│ class Foo(): {x: ??FigureItOut} {
//│   fun x: Int
//│ }

:e
not(Foo().x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.95: 	not(Foo().x)
//│ ║        	^^^^^^^^^^^^
//│ ╟── field selection of type `Int & ??FigureItOut` is not an instance of type `Bool`
//│ ║  l.95: 	not(Foo().x)
//│ ╙──      	    ^^^^^^^
//│ error | false | true
//│ res
//│     = true

(f: Foo) => f.x
//│ (f: Foo) -> (Int & ??FigureItOut)
//│ res
//│     = [Function: res]


trait B
//│ trait B

:e
class A(): B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.116: 	class A(): B
//│ ║         	^^^^^^^^^
//│ ╟── expression of type `#A` is not an instance of type `B`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.116: 	class A(): B
//│ ╙──       	           ^
//│ class A(): B

A() : B
//│ B
//│ res
//│     = A {}

abstract class A(): B
//│ abstract class A(): B

:e
A() : B
//│ ╔══[ERROR] Class A is abstract and cannot be instantiated
//│ ║  l.135: 	A() : B
//│ ╙──       	^
//│ B
//│ res
//│     = A {}

module C extends A, B
//│ module C extends A, B

C : B
//│ B
//│ res
//│     = C { class: [class C extends A] }


// TODO warn on non-asbtract class with a self-sig

:e
class A(): C
class B() extends A
class C() extends B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.155: 	class A(): C
//│ ║         	^^^^^^^^^
//│ ╟── expression of type `#A` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.155: 	class A(): C
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.156: 	class B() extends A
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#B` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.155: 	class A(): C
//│ ╙──       	           ^
//│ class A(): C
//│ class B() extends A
//│ class C() extends A, B

:e
abstract class A(): C
class B() extends A
class C() extends B
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.178: 	class B() extends A
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `#B` is not an instance of type `C`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.177: 	abstract class A(): C
//│ ╙──       	                    ^
//│ abstract class A(): C
//│ class B() extends A
//│ class C() extends A, B

abstract class A(): C
abstract class B() extends A
class C() extends B
//│ abstract class A(): C
//│ abstract class B() extends A
//│ class C() extends A, B

// :e // FIXME transitivity of self types
class D() extends B
//│ class D() extends A, B

:e // FIXME transitivity of self types
fun test(x: B): C = x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.203: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── type `B` is not an instance of `C`
//│ ║  l.203: 	fun test(x: B): C = x
//│ ║         	            ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.203: 	fun test(x: B): C = x
//│ ║         	                    ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.203: 	fun test(x: B): C = x
//│ ╙──       	                ^
//│ fun test: (x: B) -> C


