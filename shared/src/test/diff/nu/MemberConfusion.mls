:NewDefs


mixin T { fun a = "hi" }
//│ mixin T() {
//│   fun a: "hi"
//│ }

class C(a: int) extends T
//│ class C(a: int) {
//│   fun a: "hi"
//│ }

class B { let a = "hi" }
//│ class B {
//│   let a: "hi"
//│ }

:e
class C(a: int) extends B
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.20: 	class C(a: int) extends B
//│ ║        	           ^^^
//│ ╟── type `int` does not match type `"hi"`
//│ ╟── Note: constraint arises from string literal:
//│ ║  l.14: 	class B { let a = "hi" }
//│ ╙──      	                  ^^^^
//│ class C(a: int) extends B


mixin M { let b = "hi" }
//│ mixin M() {
//│   let b: "hi"
//│ }

class B { let a = 1 : int }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.36: 	class B { let a = 1 : int }
//│ ║        	                  ^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.36: 	class B { let a = 1 : int }
//│ ╙──      	                      ^^^
//│ class B {
//│   let a: int
//│ }

class C(a: int, b: int) extends B, M
//│ class C(a: int, b: int) extends B {
//│   let b: "hi"
//│ }

let c = C(2, 3)
(c.a, c.b)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.53: 	let c = C(2, 3)
//│ ║        	        ^^^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.53: 	let c = C(2, 3)
//│ ║        	          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	class C(a: int, b: int) extends B, M
//│ ╙──      	           ^^^
//│ let c: C | error
//│ (error | int, "hi" | error,)
//│ c
//│   = C {}
//│ res
//│     = [ 2, 3 ]

class C(a: int) { let a = 1 }
//│ class C(a: int) {
//│   let a: 1
//│ }

class C(a: int) { fun a = 1 }
//│ class C(a: int) {
//│   fun a: 1
//│ }

class C(a: int) { fun a = a }
//│ class C(a: int) {
//│   fun a: nothing
//│ }

class C(a: int, b: int) extends B, M { let b = "hi" }
//│ class C(a: int, b: int) extends B {
//│   let b: "hi"
//│ }


