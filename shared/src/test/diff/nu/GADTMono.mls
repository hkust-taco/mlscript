:NewDefs

abstract class Option[type T]: None | Some[T]
module None extends Option[nothing]
class Some[T](get: T) extends Option[T]
//│ abstract class Option[T]: None | Some[T]
//│ module None extends Option
//│ class Some[T](get: T) extends Option

fun map(f, x) = if x is
    None then None
    Some(g) then Some(f(g))
//│ fun map: forall 'T 'a. ((??T & 'T) -> 'a, None | Some['T]) -> (None | Some['a])

fun map[A, B](f: A -> B, x: Option[A]) = if x is
    None then None
    Some(g) then Some(f(g))
//│ fun map: forall 'A 'B. (f: 'A -> 'B, x: Option['A]) -> (None | Some['B])

fun getOr(x, d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'T 'a. (None | Some['T], 'a) -> (??T & 'T | 'a)

fun getOr(x: Option['a], d) = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'a 'b. (x: Option['a], 'b) -> (??T & 'a | 'b)

fun getOr[T](x: Option[T], d: T): T = if x is
    None then d
    Some(g) then g
//│ fun getOr: forall 'T. (x: Option['T], d: 'T) -> 'T

fun get(x) = if x is Some(r) then r else error
//│ fun get: forall 'T. (Object & ~#Some | Some['T]) -> (??T & 'T)

fun get(x: Option['a]): x.T = if x is Some(r) then r else error
//│ fun get: forall 'a. (x: Option['a]) -> 'a
