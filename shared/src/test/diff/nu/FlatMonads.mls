:NewDefs


abstract class IO[A] {
  fun bind(f) = Bind(this, f)
  fun run: A
}
class Pure[A](value: A) extends IO[A] {
  fun run = value
}
class Bind[A, B](underlying: IO[A], f: A -> IO[B]) extends IO[B] {
  fun run = f(underlying.run).run
}
//│ abstract class IO[A] {
//│   fun bind: forall 'B. (A -> IO['B]) -> Bind[A, 'B]
//│   fun run: A
//│ }
//│ class Pure[A](value: A) extends IO {
//│   fun bind: forall 'A 'B0. ('A -> IO['B0]) -> Bind['A, 'B0]
//│   fun run: A
//│ }
//│ class Bind[A, B](underlying: IO[A], f: A -> IO[B]) extends IO {
//│   fun bind: forall 'B1 'A0. ('A0 -> IO['B1]) -> Bind['A0, 'B1]
//│   fun run: B
//│ }
//│ where
//│   'A0 <: 'A1
//│   'A1 := B
//│   'A <: 'A2
//│   'A2 := A

module readInt extends IO[Int] { fun run = 42 }
class printLine(str: Str) extends IO[undefined] { fun run = log(str) }
declare fun String: anything -> Str
//│ module readInt extends IO {
//│   fun bind: forall 'A 'B. ('A -> IO['B]) -> Bind['A, 'B]
//│   fun run: 42
//│ }
//│ class printLine(str: Str) extends IO {
//│   fun bind: forall 'A0 'B0. ('A0 -> IO['B0]) -> Bind['A0, 'B0]
//│   fun run: undefined
//│ }
//│ fun String: anything -> Str
//│ where
//│   'A0 <: 'A1
//│   'A1 := undefined
//│   'A <: 'A2
//│   'A2 := Int


// * Nested indent:
val main =
  printLine("Hi! Input two numbers: ").bind of _ =>
    readInt.bind of n =>
      readInt.bind of m =>
        val sum = n + m
        printLine(concat("The sum is: ")(String of sum)).bind of _ =>
          Pure(sum)
//│ val main: Bind['A, 'B]
//│   where
//│     'B :> Int
//│     'A <: undefined
//│ main
//│      = Bind {}

main.run
//│ Int
//│ res
//│     = 84
//│ // Output
//│ Hi! Input two numbers: 
//│ The sum is: 84


// * Flat indent:
val main =
  printLine("Hi! Input two numbers: ").bind of _ =>
  readInt.bind of n =>
  readInt.bind of m =>
  val sum = n + m
  printLine(concat("The sum is: ")(String of sum)).bind of _ =>
  Pure(sum)
//│ val main: Bind['A, 'B]
//│   where
//│     'B :> Int
//│     'A <: undefined
//│ main
//│      = Bind {}

main.run
//│ Int
//│ res
//│     = 84
//│ // Output
//│ Hi! Input two numbers: 
//│ The sum is: 84


// * TODO improve this error
:e
printLine("").bind of [] => error
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.101: 	printLine("").bind of [] => error
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `[?A]` does not match type `[]`
//│ ║  l.11: 	class Bind[A, B](underlying: IO[A], f: A -> IO[B]) extends IO[B] {
//│ ╙──      	                                       ^
//│ Bind['A, 'B] | error
//│   where
//│     'A <: undefined
//│ res
//│     = Bind {}


// * Using a shortand operator for `bind`

fun (|>=) bindOp[A, B](x: IO[A], f: A -> IO[B]): IO[B] = x.bind(f)
//│ fun (|>=) bindOp: forall 'A 'B. (x: IO['A], f: 'A -> IO['B]) -> IO['B]

val main =
  printLine("Hi! Input two numbers: ") |>= _ =>
  readInt |>= n =>
  readInt |>= m =>
  val sum = n + m
  printLine(concat("The sum is: ")(String of sum)) |>= _ =>
  Pure(sum)
//│ val main: IO['B]
//│   where
//│     'B :> Int
//│ main
//│      = Bind {}


// * With no type annotations:

fun (|>=) bindOp(x, f) = x.bind(f)
//│ fun (|>=) bindOp: forall 'a 'b. ({bind: 'a -> 'b}, 'a) -> 'b

val main =
  printLine("Hi! Input two numbers: ") |>= _ =>
  readInt |>= n =>
  readInt |>= m =>
  val sum = n + m
  printLine(concat("The sum is: ")(String of sum)) |>= _ =>
  Pure(sum)
//│ val main: Bind['A, 'B]
//│   where
//│     'B :> Int
//│     'A <: undefined
//│ main
//│      = Bind {}

main.run
//│ Int
//│ res
//│     = 84
//│ // Output
//│ Hi! Input two numbers: 
//│ The sum is: 84


// * Abstracting over the monad:

fun (|>=) bindOp(x, f) = x.bind(f)
//│ fun (|>=) bindOp: forall 'a 'b. ({bind: 'a -> 'b}, 'a) -> 'b

fun main(ctx) =
  ctx.printLine("Hi! Input two numbers: ") |>= _ =>
  ctx.readInt |>= n =>
  ctx.readInt |>= m =>
  val sum = n + m
  ctx.printLine(concat("The sum is: ")(String of sum)) |>= _ =>
  ctx.pure(sum)
//│ fun main: forall 'a 'b 'c 'd 'e. {
//│   printLine: "Hi! Input two numbers: " -> {bind: (anything -> 'a) -> 'e} & Str -> {bind: (anything -> 'd) -> 'b},
//│   pure: Int -> 'd,
//│   readInt: {bind: (Int -> 'c) -> 'a & (Int -> 'b) -> 'c}
//│ } -> 'e

val defaultCtx = {printLine, readInt, pure: Pure}
//│ val defaultCtx: {
//│   printLine: (str: Str) -> printLine,
//│   pure: forall 'A. (value: 'A) -> Pure['A],
//│   readInt: readInt
//│ }
//│ defaultCtx
//│            = {
//│                printLine: [Function (anonymous)] {
//│                  class: [class printLine extends IO],
//│                  unapply: [Function: unapply]
//│                },
//│                readInt: readInt { class: [class readInt extends IO] },
//│                pure: [Function (anonymous)] {
//│                  class: [class Pure extends IO],
//│                  unapply: [Function: unapply]
//│                }
//│              }

main(defaultCtx).run
//│ Int
//│ res
//│     = 84
//│ // Output
//│ Hi! Input two numbers: 
//│ The sum is: 84

fun loop(ctx) =
  ctx.printLine("Input a positive number: ") |>= _ =>
  ctx.readInt |>= n =>
  if n < 0 then loop(ctx) else ctx.pure(n)
//│ fun loop: forall 'a 'b 'c 'd. {
//│   printLine: "Input a positive number: " -> {bind: (anything -> 'a) -> 'b},
//│   pure: 'c -> 'd,
//│   readInt: {bind: ((Num & 'c) -> ('d | 'b)) -> 'a}
//│ } -> 'b

// * FIXME why `nothing`?
let r = loop(defaultCtx).run
//│ let r: nothing
//│ r
//│   = 42
//│ // Output
//│ Input a positive number: 

not(r)
//│ Bool
//│ res
//│     = false


// * Note: using inferred type parent arguments

module readInt extends IO { fun run = 42 }
class printLine(str: Str) extends IO { fun run = log(str) }
declare fun String: anything -> Str
//│ module readInt extends IO {
//│   fun bind: forall 'A 'B. ('A -> IO['B]) -> Bind['A, 'B]
//│   fun run: 42
//│ }
//│ class printLine(str: Str) extends IO {
//│   fun bind: forall 'A0 'B0. ('A0 -> IO['B0]) -> Bind['A0, 'B0]
//│   fun run: undefined
//│ }
//│ fun String: anything -> Str
//│ where
//│   'A0 <: 'A1
//│   'A1 :> undefined
//│   'A <: 'A2
//│   'A2 :> 42

val main =
  printLine("Hi! Input two numbers: ").bind of _ =>
  readInt.bind of n =>
  readInt.bind of m =>
  val sum = n + m
  printLine(concat("The sum is: ")(String of sum)).bind of _ =>
  Pure(sum)
//│ val main: Bind['A, 'B]
//│   where
//│     'B :> Int
//│ main
//│      = Bind {}

main
//│ Bind['A, 'B]
//│   where
//│     'B :> Int
//│ res
//│     = Bind {}


// :e // * FIXME this should be an error
let r = printLine("").bind of 0 => Pure(1)
//│ let r: Bind['A, 'B]
//│   where
//│     'B :> 1
//│     'A <: 0
//│ r
//│   = Bind {}

// :e // * FIXME this should be an error
let r = printLine("").bind of x =>
log(x.a)
Pure(1)
//│ let r: Bind['A, 'B]
//│   where
//│     'B :> 1
//│     'A <: {a: anything}
//│ r
//│   = Bind {}

:re
r.run
//│ 1
//│ res
//│ Runtime error:
//│   TypeError: Cannot read properties of undefined (reading 'a')



// * We can even have the following syntax... what's the use of a `do` notation?!

:NoJS // * TODO We'll need to support functions extended with fields

// * An interface that describes monadic functions with a field `run`
declare trait IO[A]: forall 'b; (A -> IO['b]) -> IO['b] {
  fun run: A
}
declare fun pure: 'a -> IO['a]
declare fun readInt: IO[Int]
declare fun printLine: Str -> IO[()]
//│ declare trait IO[A]: forall 'b. (A -> IO['b]) -> IO['b] {
//│   fun run: A
//│ }
//│ fun printLine: Str -> IO[[]]
//│ fun pure: forall 'a. 'a -> IO['a]
//│ fun readInt: IO[Int]

val main =
  printLine("Hi! Input two numbers: ") of _ =>
  readInt of n =>
  readInt of m =>
  val sum = n + m
  printLine(concat("The sum is: ")(String of sum)) of _ =>
  pure(sum)
//│ val main: IO['b]
//│   where
//│     'b :> Int

main.run
//│ Int


