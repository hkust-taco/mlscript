:NewDefs


false : Bool
//│ Bool
//│ res
//│     = false

// FIXME parsing!
let b = true | false : Bool
//│ let b: (Bool,)
//│ b
//│   = 1

let b = false : Bool
//│ let b: Bool
//│ b
//│   = false

:d
b : true | false
//│ 0. Typing TypingUnit(List(b : bool))
//│ | Typing unit statements
//│ | | 0. Typing term b : bool
//│ | | | 0. Typing term b
//│ | | | 0. : Bool
//│ | | | Typing type Union(TypeName(true),TypeName(false))
//│ | | | | vars=Map() newDefsInfo=Map()
//│ | | | | 0. type Union(TypeName(true),TypeName(false))
//│ | | | | | 0. type TypeName(true)
//│ | | | | | => True
//│ | | | | | 0. type TypeName(false)
//│ | | | | | => False
//│ | | | | => (True | False)
//│ | | | => (True | False) ——— 
//│ | | | CONSTRAIN Bool <! (True | False)
//│ | | |   where 
//│ | | | 0. C Bool <! (True | False)    (0)
//│ | | | | ???
//│ | | | | !!! class Bool(): True | False {}
//│ | | | | ???
//│ | | | | !!! module true(): Bool {}
//│ | | | | ???
//│ | | | | !!! class Bool(): True | False {}
//│ | | | | ???
//│ | | | | !!! module false(): Bool {}
//│ | | | | ???
//│ | | | | !!! class Bool(): True | False {}
//│ | | | | 0. C Bool<Object,Eql> <! (True | False)    (2)
//│ | | | | | ???
//│ | | | | | !!! module true(): Bool {}
//│ | | | | | ???
//│ | | | | | !!! module false(): Bool {}
//│ | | | | | ???
//│ | | | | | !!! module true(): Bool {}
//│ | | | | | ???
//│ | | | | | !!! module false(): Bool {}
//│ | | | | | 0. ARGH  DNF(0, Bool<Object,Eql>{})  <!  DNF(0, true<Object,Eql,Bool>{} | false<Object,Eql,Bool>{})
//│ | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | Consider Bool<Object,Eql>{} <: DNF(0, true<Object,Eql,Bool>{} | false<Object,Eql,Bool>{})
//│ | | | | | | Possible: List(true<Object,Eql,Bool>{}, false<Object,Eql,Bool>{})
//│ | | | | | | 0. A  Bool<Object,Eql>{}  %  List()  <!  List(true<Object,Eql,Bool>, false<Object,Eql,Bool>)  %  ⊥
//│ | | | | | | | 0. A  Bool<Object,Eql>{}  %  List()  <!  List(false<Object,Eql,Bool>)  %  true<Object,Eql,Bool>
//│ | | | | | | | | 0. A  Bool<Object,Eql>{}  %  List()  <!  List()  %  false<Object,Eql,Bool>|true<Object,Eql,Bool>
//│ | | | | | | | | | class checking Bool<Object,Eql> List(false<Object,Eql,Bool>, true<Object,Eql,Bool>)
//│ | | | | | | | | | 0. A  {}  %  List()  <!  List()  %  
//│ | | | | | | | | | | CONSTRAINT FAILURE: Bool<Object,Eql> <: (True | False)
//│ | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | normLike[-] (True | False)
//│ | | | | | | | | | | | norm[-] (True | False)
//│ | | | | | | | | | | | | ???
//│ | | | | | | | | | | | | !!! module true(): Bool {}
//│ | | | | | | | | | | | | ???
//│ | | | | | | | | | | | | !!! module false(): Bool {}
//│ | | | | | | | | | | | | DNF: DNF(0, true<Object,Eql,Bool>{} | false<Object,Eql,Bool>{})
//│ | | | | | | | | | | | | factorize? false<Object,Eql,Bool> | true<Object,Eql,Bool>
//│ | | | | | | | | | | | | | Factors 
//│ | | | | | | | | | | | | yes: (false<Object,Eql,Bool> | true<Object,Eql,Bool>)
//│ | | | | | | | | | | | ~> (false<Object,Eql,Bool> | true<Object,Eql,Bool>)
//│ | | | | | | | | | | allVarPols: 
//│ | | | | | | | | | | normLike[+] Bool<Object,Eql>
//│ | | | | | | | | | | | norm[+] Bool<Object,Eql>
//│ | | | | | | | | | | | | DNF: DNF(0, Bool<Object,Eql>{})
//│ | | | | | | | | | | | ~> Bool<Object,Eql>
//│ | | | | | | | | | | CONSTRAIN error<> <! (True | False)
//│ | | | | | | | | | |   where 
//│ | | | | | | | | | | 0. C error<> <! (True | False)    (0)
//│ | | | | | | | | | | | ???
//│ | | | | | | | | | | | !!! module true(): Bool {}
//│ | | | | | | | | | | | ???
//│ | | | | | | | | | | | !!! module false(): Bool {}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.21: 	b : true | false
//│ ║        	^
//│ ╟── type `Bool` does not match type `Bool`
//│ ║  l.15: 	let b = false : Bool
//│ ║        	                ^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.21: 	b : true | false
//│ ╙──      	    ^^^^^^^^^^^^
//│ | | 0. : (True | False)
//│ | : Some((True | False))
//│ ======== TYPED ========
//│ res: Some((True | False)) where 
//│ Bool
//│ res
//│     = false

if false is false then 0
//│ 0
//│ res
//│     = 0

fun foo(x) = if x is
  false then 0
//│ fun foo: nothing -> 0

fun foo(x) = if x is
  false then 0
  true  then 1
//│ fun foo: nothing -> (0 | 1)


