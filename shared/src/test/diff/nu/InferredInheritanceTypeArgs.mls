:NewDefs


mixin Test[A] {
    fun bar: (A, A)
    fun bar = (this.a, this.a)
}
//│ mixin Test[A]() {
//│   this: {a: A}
//│   fun bar: (A, A,)
//│ }

class A(a: int) extends Test
//│ class A(a: int) {
//│   fun bar: (int, int,)
//│ }

mixin Test2[S, T] {
    fun x: (S, T)
    fun x = (this.s, this.t)
    fun fb: S => (S, S)
    fun fb(h: S) = (this.s, h)
}
//│ mixin Test2[S, T]() {
//│   this: {s: S, t: T}
//│   fun fb: S -> (S, S,)
//│   fun x: (S, T,)
//│ }

class A1[B](s: bool, t: B) extends Test2[bool, B]
//│ class A1[B](s: bool, t: B) {
//│   fun fb: bool -> (bool, bool,)
//│   fun x: (bool, B,)
//│ }

// TODO: Investigate type of fb
class A2[A](s: A, t: int) extends Test2
//│ class A2[A](s: A, t: int) {
//│   fun fb: 'S -> (A | 'S, A | 'S,)
//│   fun x: (A | 'S, int,)
//│ }

// TODO: Investigate type of fb
class A3(s: int, t: bool) extends Test2
//│ class A3(s: int, t: bool) {
//│   fun fb: 'S -> ('S | int, 'S | int,)
//│   fun x: ('S | int, bool,)
//│ }

class P(p: int) { 
    fun foo(x) = x + p 
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.51: 	    fun foo(x) = x + p 
//│ ║        	                 ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.50: 	class P(p: int) { 
//│ ║        	           ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.51: 	    fun foo(x) = x + p 
//│ ╙──      	                     ^
//│ class P(p: int) {
//│   fun foo: Int -> (Int | error)
//│ }

:e // FIXME
class C1(a: int) extends P(a) { fun bar = this.foo(0) }
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.67: 	class C1(a: int) extends P(a) { fun bar = this.foo(0) }
//│ ╙──      	                                              ^^^^
//│ class C1(a: int) extends P {
//│   fun bar: error
//│   fun foo: Int -> (Int | error)
//│ }

:e // FIXME
class C2(a: int, b: int) extends P(a + b) {
    fun foo(x) = x * this.p + a * b
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	                                   ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	            ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ╙──      	                                   ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	                                   ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	                    ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ╙──      	                                       ^
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	                                   ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.50: 	class P(p: int) { 
//│ ╙──      	           ^^^
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ╙──      	                         ^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ║        	                              ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	            ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ╙──      	                              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ║        	                              ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ║        	                    ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.78: 	    fun foo(x) = x * this.p + a * b
//│ ╙──      	                                  ^
//│ class C2(a: int, b: int) extends P {
//│   fun foo: Int -> Int
//│ }

let c2 =  C2(1, 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.134: 	let c2 =  C2(1, 2)
//│ ║         	          ^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.134: 	let c2 =  C2(1, 2)
//│ ║         	             ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.77: 	class C2(a: int, b: int) extends P(a + b) {
//│ ╙──      	            ^^^
//│ let c2: C2 | error
//│ c2
//│    = C2 {}

c2.foo(2)
//│ Int | error
//│ res
//│     = 8

c2.p
//│ Int | error
//│ res
//│     = 3


class Test[A](x: A)
//│ class Test[A](x: A)

class A(a: int) extends Test(a)
//│ class A(a: int) extends Test

let a1 = A(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.165: 	let a1 = A(1)
//│ ║         	         ^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.165: 	let a1 = A(1)
//│ ║         	           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.162: 	class A(a: int) extends Test(a)
//│ ╙──       	           ^^^
//│ let a1: A | error
//│ a1
//│    = A {}

a1: Test['x]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.179: 	a1: Test['x]
//│ ║         	^^
//│ ╟── application of type `A` is not an instance of type `Test`
//│ ║  l.165: 	let a1 = A(1)
//│ ║         	         ^^^^
//│ ╟── but it flows into reference with expected type `Test[anything]`
//│ ║  l.179: 	a1: Test['x]
//│ ║         	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.179: 	a1: Test['x]
//│ ╙──       	    ^^^^^^^^
//│ Test['x]
//│   where
//│     'x :> int
//│ res
//│     = A {}

a1.x
//│ error | int
//│ res
//│     = 1




trait Foo[A] { fun foo(x: A): A }
//│ trait Foo[A] {
//│   fun foo: (x: A,) -> A
//│ }

// * This is pretty funky but it seems sound for now...
// * Inherited Foo's type arg is left "unspecified", and since it is not constrained,
// * it can be instantiated to any type by downstream callers of the methods!
module B extends Foo { fun foo(x) = x }
//│ module B extends Foo {
//│   fun foo: 'A -> 'A
//│ }

B : Foo['X]
//│ Foo['X]
//│ res
//│     = B { class: [class B extends Object] }

B.foo
//│ 'a -> 'a
//│ res
//│     = [Function: foo]

B.foo(1)
//│ 1
//│ res
//│     = 1

module B extends Foo { fun foo(x) = x + 1 }
//│ module B extends Foo {
//│   fun foo: Int -> Int
//│ }

B : Foo['X]
//│ Foo[Int]
//│ res
//│     = B { class: [class B extends Object] }

B.foo
//│ Int -> Int
//│ res
//│     = [Function: foo]


// * TODO: when 
:pe
trait Foo[type A] { fun foo(x: A): A }
//│ ╔══[PARSE ERROR] Unexpected 'type' keyword here
//│ ║  l.252: 	trait Foo[type A] { fun foo(x: A): A }
//│ ╙──       	          ^^^^
//│ trait Foo {
//│   fun foo: (x: A,) -> A
//│ }


trait Foo[A] { fun a: A; fun foo(x: A): A }
//│ trait Foo[A] {
//│   fun a: A
//│   fun foo: (x: A,) -> A
//│ }

class Bar[B](a: B) extends Foo { fun foo(x) = x }
//│ class Bar[B](a: B) extends Foo {
//│   fun foo: 'A -> 'A
//│ }
//│ where
//│   'A :> B

let b = Bar(123)
//│ let b: Bar[123]
//│ b
//│   = Bar {}

b : Foo['X]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.279: 	b : Foo['X]
//│ ║         	^
//│ ╟── application of type `Bar[?B]` is not an instance of type `Foo`
//│ ║  l.274: 	let b = Bar(123)
//│ ║         	        ^^^^^^^^
//│ ╟── but it flows into reference with expected type `#Foo`
//│ ║  l.279: 	b : Foo['X]
//│ ║         	^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.279: 	b : Foo['X]
//│ ╙──       	    ^^^^^^^
//│ Foo['X]
//│   where
//│     'X :> 123
//│ res
//│     = Bar {}

b.foo
//│ 'a -> (123 | 'a)
//│ res
//│     = [Function: foo]


// * Note the shadowed type variable `A` in `foo`
trait Foo[A] { fun foo[A](x: A): A }
//│ trait Foo[A] {
//│   fun foo: forall 'A. (x: 'A,) -> 'A
//│ }

:e // FIXME
class B extends Foo { fun foo(x) = x }
//│ ╔══[ERROR] Type error in definition of method foo
//│ ║  l.311: 	class B extends Foo { fun foo(x) = x }
//│ ║         	                          ^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.311: 	class B extends Foo { fun foo(x) = x }
//│ ║         	                                   ^
//│ ╟── back into type variable `A`
//│ ║  l.305: 	trait Foo[A] { fun foo[A](x: A): A }
//│ ║         	                       ^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this reference:
//│ ║  l.311: 	class B extends Foo { fun foo(x) = x }
//│ ╙──       	                                   ^
//│ class B extends Foo {
//│   fun foo: (??A & 'a) -> (??A0 | 'a)
//│ }

:e
class B extends Foo { fun foo(x) = x + 1 }
//│ ╔══[ERROR] Type error in definition of method foo
//│ ║  l.330: 	class B extends Foo { fun foo(x) = x + 1 }
//│ ║         	                          ^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.305: 	trait Foo[A] { fun foo[A](x: A): A }
//│ ║         	                       ^
//│ ╟── into reference of type `Int`
//│ ║  l.330: 	class B extends Foo { fun foo(x) = x + 1 }
//│ ╙──       	                                   ^
//│ ╔══[ERROR] Type error in definition of method foo
//│ ║  l.330: 	class B extends Foo { fun foo(x) = x + 1 }
//│ ║         	                          ^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.330: 	class B extends Foo { fun foo(x) = x + 1 }
//│ ║         	                                   ^^^^^
//│ ╟── adding a type annotation to any of the following terms may help resolve the problem
//│ ╟── • this operator application:
//│ ║  l.330: 	class B extends Foo { fun foo(x) = x + 1 }
//│ ╙──       	                                   ^^^^^
//│ class B extends Foo {
//│   fun foo: Int -> Int
//│ }

