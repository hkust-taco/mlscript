:NewDefs



class Foo[out A](x: A)
//│ class Foo[A](x: A)

fun foo(x: Foo[Int]): Foo[Num] = x
//│ fun foo: (x: Foo[Int],) -> Foo[Num]

:e
fun foo(x: Foo[Num]): Foo[Int] = x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.12: 	fun foo(x: Foo[Num]): Foo[Int] = x
//│ ║        	                                 ^
//│ ╟── type `Num` is not an instance of `Int`
//│ ║  l.12: 	fun foo(x: Foo[Num]): Foo[Int] = x
//│ ║        	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	fun foo(x: Foo[Num]): Foo[Int] = x
//│ ╙──      	                          ^^^
//│ fun foo: (x: Foo[Num],) -> Foo[Int]


class Foo[in A](x: A -> Int)
//│ class Foo[A](x: A -> Int)

fun foo(x: Foo[Num]): Foo[Int] = x
//│ fun foo: (x: Foo[Num],) -> Foo[Int]

:e
fun foo(x: Foo[Int]): Foo[Num] = x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.32: 	fun foo(x: Foo[Int]): Foo[Num] = x
//│ ║        	                                 ^
//│ ╟── type `Num` is not an instance of `Int`
//│ ║  l.32: 	fun foo(x: Foo[Int]): Foo[Num] = x
//│ ║        	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.32: 	fun foo(x: Foo[Int]): Foo[Num] = x
//│ ╙──      	               ^^^
//│ fun foo: (x: Foo[Int],) -> Foo[Num]



// * Note that not checking variance annotations is actually sound in MLscript,
// *  but can be surprising for users, who will find type errors at the use sites.


// :e // TODO check variance annotations!
class Oops0[in A](x: A)
//│ class Oops0[A](x: A)

// :e // TODO check variance annotations!
class Oops0[out A](x: A -> Int)
//│ class Oops0[A](x: A -> Int)

let o = Oops0(id)
//│ let o: Oops0[nothing]
//│ o
//│   = Oops0 {}

// * What happens is `Oops9{ A = nothing..'? }` is inferred for `o` (consistent with `A`'s covariance),
// *  so all negative occurrences of `o.A` are viewed as `nothing` from the outside.
o.x
//│ nothing -> Int
//│ res
//│     = [Function: id]

// * Similarly, `Oops0[Int]` here will expand to the equivalent `Oops0{ A = nothing..Int }`
(o : Oops0[Int]).x
//│ nothing -> Int
//│ res
//│     = [Function: id]

:e
o.x(123)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.77: 	o.x(123)
//│ ║        	^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `nothing`
//│ ║  l.77: 	o.x(123)
//│ ║        	    ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.55: 	class Oops0[out A](x: A -> Int)
//│ ╙──      	                ^
//│ Int | error
//│ res
//│     = 123

:e
(o : Oops0[Int]).x(123)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.92: 	(o : Oops0[Int]).x(123)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `nothing`
//│ ║  l.92: 	(o : Oops0[Int]).x(123)
//│ ║        	                   ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.55: 	class Oops0[out A](x: A -> Int)
//│ ╙──      	                ^
//│ Int | error
//│ res
//│     = 123


class Oops1[out A](x: A -> A, y: A)
//│ class Oops1[A](x: A -> A, y: A)

let o = Oops1(id, 123)
//│ let o: Oops1[123]
//│ o
//│   = Oops1 {}

o.x
//│ nothing -> 123
//│ res
//│     = [Function: id]

:e
o.x(123)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.121: 	o.x(123)
//│ ║         	^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `nothing`
//│ ║  l.121: 	o.x(123)
//│ ║         	    ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.107: 	class Oops1[out A](x: A -> A, y: A)
//│ ╙──       	                ^
//│ 123 | error
//│ res
//│     = 123

:re
o.x(error) + 1
//│ Int
//│ res
//│ Runtime error:
//│   Error: unexpected runtime error


class Oops2[out A](x: A -> A, y: A)
//│ class Oops2[A](x: A -> A, y: A)

let o = Oops2(id, 123)
//│ let o: Oops2[123]
//│ o
//│   = Oops2 {}

o.x
//│ nothing -> 123
//│ res
//│     = [Function: id]

:e
o.x(123)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.157: 	o.x(123)
//│ ║         	^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `nothing`
//│ ║  l.157: 	o.x(123)
//│ ║         	    ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.143: 	class Oops2[out A](x: A -> A, y: A)
//│ ╙──       	                ^
//│ 123 | error
//│ res
//│     = 123

:e // * We will be able to make this work later, through `o.x : o.A -> o.A` and `o.y : o.A`
o.x(o.y)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.172: 	o.x(o.y)
//│ ║         	^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `nothing`
//│ ║  l.146: 	let o = Oops2(id, 123)
//│ ║         	                  ^^^
//│ ╟── but it flows into field selection with expected type `nothing`
//│ ║  l.172: 	o.x(o.y)
//│ ║         	    ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.143: 	class Oops2[out A](x: A -> A, y: A)
//│ ╙──       	                ^
//│ 123 | error
//│ res
//│     = 123

:re
o.x(error) + 1
//│ Int
//│ res
//│ Runtime error:
//│   Error: unexpected runtime error


