:NewDefs


class Test { type T = Int }
//│ class Test {
//│   constructor()
//│ }

1 : Test.T
//│ Int
//│ res
//│     = 1


trait Test { type T = Int }
//│ trait Test

1 : Test.T
//│ Int
//│ res
//│     = 1

// TODO inspect
class Foo[T](x: T) { 
  type T = T
} 
//│ class Foo[T](x: T)

1 : Foo(1).T
//│ 1
//│ res
//│     = 1

:e
false : Foo(1).T
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.35: 	false : Foo(1).T
//│ ║        	^^^^^
//│ ╟── reference of type `false` does not match type `1`
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.35: 	false : Foo(1).T
//│ ║        	            ^
//│ ╟── from type selection:
//│ ║  l.35: 	false : Foo(1).T
//│ ╙──      	              ^^
//│ 1
//│ res
//│     = false

:e
class Foo[type T](x: T) { 
  type T = T
} 
//│ ╔══[ERROR] Class type member 'T' already exists
//│ ║  l.52: 	  type T = T
//│ ╙──      	  ^^^^^^
//│ class Foo[T](x: T)

:e
class Foo[type T](x: Int) { 
  type T = Int
} 
//│ ╔══[ERROR] Class type member 'T' already exists
//│ ║  l.61: 	  type T = Int
//│ ╙──      	  ^^^^^^
//│ class Foo[T](x: Int)

abstract class Foo { type T = Int }
//│ abstract class Foo

:e
class Bar extends Foo { type T = Bool }
//│ ╔══[ERROR] Inherited parameter named 'T' is not virtual and cannot be overridden
//│ ╙── Originally declared here:
//│ class Bar extends Foo {
//│   constructor()
//│ }

abstract class Foo[type T]
//│ abstract class Foo[T]

// TODO
class Bar extends Foo { type T = Bool }
//│ ╔══[ERROR] Inherited parameter named 'T' is not virtual and cannot be overridden
//│ ╟── Originally declared here:
//│ ║  l.79: 	abstract class Foo[type T]
//│ ╙──      	                        ^
//│ class Bar extends Foo {
//│   constructor()
//│ }

// TODO
module Foo { type A = A }
//│ module Foo
