:NewDefs
:NoJS


// * Adapted example from Code reuse through polymorphic variants (FOSE 2000)
// * This time with a List class.

// FIXME:
//  - simplification problem or constraint bug: `'result :> anything <: Num`
//  - constraining loop with unannotated `list_assoc` ascription
//  - still a number of quite ugly types


class List<A> {
  fun match: forall 'res; (ifNil: () => 'res, ifCons: (A, List[A]) => 'res) => 'res
  fun match = error
}
let Nil: () => List<'a>
let Cons: (head: 'a, tail: List<'a>) => List<'a>
//│ class List[A]() {
//│   fun match: forall 'res. (ifNil: () -> 'res, ifCons: (A, List[A],) -> 'res,) -> 'res
//│ }
//│ let Nil: forall 'a. () -> List['a]
//│ let Cons: forall 'a0. (head: 'a0, tail: List['a0],) -> List['a0]

class NotFound
class Success<A>(result: A)
//│ class NotFound()
//│ class Success[A](result: A)

fun eq(l: string, r: string): bool
//│ fun eq: (l: string, r: string,) -> bool

// * Annotation currently needed to avoid later ascription loop (due to excessive TV refreshing?)
// fun list_assoc(s, l) =
fun list_assoc(s, l: List<'a>) =
  l.match(
    ifNil: () => NotFound(),
    ifCons: (h, t) =>
      if eq(s, h._1) then Success(h._2)
      else list_assoc(s, t)
  )
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.40: 	      if eq(s, h._1) then Success(h._2)
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	      else list_assoc(s, t)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `bool` is not an instance of type `Object`
//│ ║  l.31: 	fun eq(l: string, r: string): bool
//│ ║        	                              ^^^^
//│ ╟── but it flows into application with expected type `#Object`
//│ ║  l.40: 	      if eq(s, h._1) then Success(h._2)
//│ ╙──      	         ^^^^^^^^^^^
//│ fun list_assoc: forall 'a 'A. (string, l: List['a],) -> (NotFound | Success['A])
//│   where
//│     'a <: {_1: string, _2: 'A}

list_assoc : (string, List<{ _1: string, _2: 'b }>) => (NotFound | Success['b])
//│ (string, List[{_1: string, _2: 'b}],) -> (NotFound | Success['b])

fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ fun list_assoc: forall 'b. (s: string, l: List[{_1: string, _2: 'b}],) -> (NotFound | Success['b])

class Var(s: string)
//│ class Var(s: string)

mixin EvalVar {
  fun eval(sub, v) =
    if v is Var(s) then
      if list_assoc(s, sub) is
        NotFound then v
        Success(r) then r
}
//│ mixin EvalVar() {
//│   fun eval: forall 'b. (List[{_1: string, _2: 'b}], Var,) -> ('b | Var)
//│ }

class Abs<A>(x: string, t: A)
class App<A>(s: A, t: A)
//│ class Abs[A](x: string, t: A)
//│ class App[A](s: A, t: A)

fun incr(x: {a: int}): unit
//│ fun incr: (x: {a: int},) -> unit

fun gensym(): string
//│ fun gensym: () -> string

fun int_to_string(x: int): string
//│ fun int_to_string: (x: int,) -> string

mixin EvalLambda {
  fun eval(sub, v) =
    if v is
      App(t1, t2) then
        let l1 = this.eval(sub, t1)
        let l2 = this.eval(sub, t2)
        if t1 is
          Abs(x, t) then this.eval(Cons((x, l2), Nil()), t)
        else
          App(l1, l2)
      Abs(x, t) then
        let s = gensym()
        Abs(s, this.eval(Cons((x, Var(s)), sub), t))
    else
      super.eval(sub, v)
}
//│ mixin EvalLambda() {
//│   super: {eval: ('b, 'c,) -> 'd}
//│   this: {eval: ('b, 's,) -> ('e & 'f) & (List[in 'a out 'a | (string, 'f,)], 't,) -> 'd & (List[in 'a0 out 'a0 | 'a1 | (string, Var,)], 't0,) -> 'g}
//│   fun eval: forall 'a2. (List['a2] & 'b, Abs['t0] | App['s & (Abs['t] | #Object & ~#Abs)] | #Object & 'c & ~#Abs & ~#App,) -> (Abs['g] | App['e | 'f] | 'd)
//│ }
//│ where
//│   'a2 :> 'a0 | (string, Var,)
//│       <: 'a1

module Test1 extends EvalVar, EvalLambda
//│ module Test1() {
//│   fun eval: (List[{_1: string, _2: 'b}], 'a,) -> 'b
//│ }
//│ where
//│   'a <: Abs['a] | App['a & (Abs['a] | #Object & ~#Abs)] | Var
//│   'b :> App['b] | Abs['b] | Var

Test1.eval(Nil(), Var("a"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.125: 	Test1.eval(Nil(), Var("a"))
//│ ║         	                  ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.125: 	Test1.eval(Nil(), Var("a"))
//│ ║         	                      ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ 'a
//│   where
//│     'a :> Abs['a] | Var | App['a]

Test1.eval(Nil(), Abs("b", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.139: 	Test1.eval(Nil(), Abs("b", Var("a")))
//│ ║         	                           ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.139: 	Test1.eval(Nil(), Abs("b", Var("a")))
//│ ║         	                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.139: 	Test1.eval(Nil(), Abs("b", Var("a")))
//│ ║         	                  ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"b"` is not an instance of type `string`
//│ ║  l.139: 	Test1.eval(Nil(), Abs("b", Var("a")))
//│ ║         	                      ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Var

Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                      ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                      ^^^^^^^^
//│ ╟── string literal of type `"b"` is not an instance of type `string`
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                             ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"b"` is not an instance of type `string`
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                 ^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                     ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.162: 	Test1.eval(Cons(("c", Var("d")), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ error | 'a
//│   where
//│     'a :> Abs['a] | Var | App['a]

Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                               ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                ^^^^^^^^
//│ ╟── string literal of type `"b"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                       ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"b"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                           ^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                                                                               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.212: 	Test1.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("b", Var("b")), Var("c")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ error | 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var | error] | Var

class Num(n: int)
class Add<A>(l: A, r: A)
class Mul<A>(l: A, r: A)
//│ class Num(n: int)
//│ class Add[A](l: A, r: A)
//│ class Mul[A](l: A, r: A)

fun map_expr(f, v) =
  if v is
    Var then v
    Num then v
    Add(l, r) then Add(f(l), f(r))
    Mul(l, r) then Mul(f(l), f(r))
//│ fun map_expr: forall 'l 'A 'l0 'A0. ('l -> 'A & 'l0 -> 'A0, Add['l] | Mul['l0] | Num | Var,) -> (Add['A] | Mul['A0] | Num | Var)

mixin EvalExpr {
  fun eval(sub, v) =
    fun eta(e) = this.eval(sub, e)
    let vv = map_expr(eta, v)
    if vv is
      Var then super.eval(sub, vv)
      Add(Num(l), Num(r)) then Num(l + r)
      Mul(Num(l), Num(r)) then Num(l * r)
    else v
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ║         	                                   ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.271: 	class Num(n: int)
//│ ║         	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ╙──       	                                   ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ║         	                                   ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.271: 	class Num(n: int)
//│ ║         	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ╙──       	                                       ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ║         	                               ^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.292: 	      Add(Num(l), Num(r)) then Num(l + r)
//│ ║         	                                   ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.271: 	class Num(n: int)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ║         	                                   ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.271: 	class Num(n: int)
//│ ║         	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ╙──       	                                   ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ║         	                                   ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.271: 	class Num(n: int)
//│ ║         	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ╙──       	                                       ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ║         	                               ^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.293: 	      Mul(Num(l), Num(r)) then Num(l * r)
//│ ║         	                                   ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.271: 	class Num(n: int)
//│ ╙──       	             ^^^
//│ mixin EvalExpr() {
//│   super: {eval: ('a, Var,) -> 'b}
//│   this: {eval: ('a, 'c,) -> #Object}
//│   fun eval: forall 'd. ('a, 'd & (Add['c] | Mul['c] | Num | Var),) -> (Num | error | 'd | 'b)
//│ }

module Test2 extends EvalVar, EvalExpr
//│ module Test2() {
//│   fun eval: (List[{_1: string, _2: 'b}], 'a,) -> ('b | Num | Var | error | 'a)
//│ }
//│ where
//│   'a <: Add['c] | Mul['c] | Num | Var
//│   'c <: 'a
//│   'b <: #Object

Test2.eval(Nil(), Var("a"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.365: 	Test2.eval(Nil(), Var("a"))
//│ ║         	                  ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.365: 	Test2.eval(Nil(), Var("a"))
//│ ║         	                      ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ Num | Var | error

Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                               ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                                                   ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                                                       ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.377: 	Test2.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Var("a"))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ Abs[Var | error] | Num | Var | error

Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	                      ^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	                          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.271: 	class Num(n: int)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	                                       ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.416: 	Test2.eval(Cons(("a", Num(1)), Nil()), Var("a"))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ Num | Var | error

Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                               ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                                                       ^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                                                           ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.271: 	class Num(n: int)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                                                               ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                                                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.446: 	Test2.eval(Cons(("a", Abs("d", Var("d"))), Nil()), Add(Num(1), Var("a")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ Abs[Var | error] | Add[Num | Var | error] | Num | Var | error

module Test3 extends EvalVar, EvalExpr, EvalLambda
//│ module Test3() {
//│   fun eval: (List[{_1: string, _2: 'b}], 'a,) -> 'c
//│ }
//│ where
//│   'b :> Var | 'c
//│      <: #Object
//│   'c :> Abs['c] | 'b | Num | Var | error | 'd | App['c]
//│   'd <: Add['e] | Mul['e] | Num | Var
//│   'e <: 'a
//│   'a <: Abs['a] | App['a & (Abs['a] | #Object & ~#Abs)] | #Object & 'd & ~#Abs & ~#App

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                               ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                                                            ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                                                                ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                                                   ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                                                       ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.506: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), Abs("a", Var("a")))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var | error] | Var | Num | error

Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                               ^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                      ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"d"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                          ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                ^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                    ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                       ^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"a"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.78: 	class Abs<A>(x: string, t: A)
//│ ╙──      	                ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                               ^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                                   ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.271: 	class Num(n: int)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                                       ^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                                                                                           ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Var(s: string)
//│ ╙──      	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"c"` is not an instance of type `string`
//│ ║  l.556: 	Test3.eval(Cons(("c", Abs("d", Var("d"))), Nil()), App(Abs("a", Var("a")), Add(Num(1), Var("c"))))
//│ ║         	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.61: 	fun list_assoc(s: string, l: List<{ _1: string, _2: 'b }>): NotFound | Success['b]
//│ ╙──      	                                        ^^^^^^
//│ 'a
//│   where
//│     'a :> App['a] | Abs['a] | Abs[Var | error] | Var | Add[Num | Var | error] | Num | error

module Test3 extends EvalVar, EvalLambda, EvalExpr
//│ module Test3() {
//│   fun eval: (List[{_1: string, _2: 'b}], 'a,) -> ('a | 'c)
//│ }
//│ where
//│   'b :> Var | 'c
//│      <: #Object
//│   'c :> 'b | Abs['c] | App['c] | Var | Num | error | 'a
//│   'a <: Add['d] | Mul['d] | Num | Var
//│   'd <: 'a

