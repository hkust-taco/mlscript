:NewDefs


x => x is 42
//│ Object -> Bool
//│ res
//│     = [Function: res]


fun (|>;) foo(a, b) = [a, b]
//│ fun (|>;) foo: forall 'a 'b. ('a, 'b) -> ['a, 'b]

42 |>; x => x
//│ [42, forall 'a. 'a -> 'a]
//│ res
//│     = [ 42, [Function (anonymous)] ]


fun (>>) compose(f, g) = x => g(f(x))
//│ fun (>>) compose: forall 'a 'b 'c 'd. ('a ->{'c} 'b, 'b ->{'c} 'd) -> 'a ->{'c} 'd

succ >> x => x + 2
//│ Int -> Int
//│ res
//│     = [Function (anonymous)]

:e
x => x + 2 >> succ
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.28: 	x => x + 2 >> succ
//│ ║        	     ^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` is not a function
//│ ║  l.28: 	x => x + 2 >> succ
//│ ║        	     ^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.19: 	fun (>>) compose(f, g) = x => g(f(x))
//│ ║        	                                ^^^^
//│ ╟── from reference:
//│ ║  l.19: 	fun (>>) compose(f, g) = x => g(f(x))
//│ ╙──      	                                ^
//│ Int -> (error | anything -> Int)
//│ res
//│     = [Function: res]

(x => x + 2) >> succ
//│ Int -> Int
//│ res
//│     = [Function (anonymous)]

:e
x => x + 2
  >> succ
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.51: 	x => x + 2
//│ ║        	         ^
//│ ║  l.52: 	  >> succ
//│ ║        	^^^^^^^^^^
//│ ╟── integer literal of type `2` is not a function
//│ ║  l.51: 	x => x + 2
//│ ║        	         ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.19: 	fun (>>) compose(f, g) = x => g(f(x))
//│ ║        	                                ^^^^
//│ ╟── from reference:
//│ ║  l.19: 	fun (>>) compose(f, g) = x => g(f(x))
//│ ╙──      	                                ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.51: 	x => x + 2
//│ ║        	     ^^^^^
//│ ║  l.52: 	  >> succ
//│ ║        	^^^^^^^^^
//│ ╟── function of type `?a ->{(?c | ?d)} ?b` is not an instance of type `Int`
//│ ║  l.19: 	fun (>>) compose(f, g) = x => g(f(x))
//│ ║        	                         ^^^^^^^^^^^^
//│ ╟── but it flows into operator application with expected type `Int`
//│ ║  l.51: 	x => x + 2
//│ ║        	         ^
//│ ║  l.52: 	  >> succ
//│ ╙──      	^^^^^^^^^^
//│ Int -> (Int | error)
//│ res
//│     = [Function: res]


:e
x => x.y => y
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  l.86: 	x => x.y => y
//│ ╙──      	     ^^^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.86: 	x => x.y => y
//│ ╙──      	            ^
//│ anything -> error -> error
//│ Code generation encountered an error:
//│   term Sel(Var(x),Var(y)) is not a valid pattern


