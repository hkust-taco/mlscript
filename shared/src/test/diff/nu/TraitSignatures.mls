:NewDefs


// * Interfaces that are "callable" are important to support for TS/JS interop


declare trait Foo: ((x: Num) => Num) {
  val y: Str
}
//│ declare trait Foo: (x: Num) -> Num {
//│   val y: Str
//│ }

(f: Foo) => [f.y, f(0)]
//│ (f: Foo) -> [Str, Num]
//│ res
//│     = [Function: res]


declare trait FooPoly: forall 'a: (x: 'a) => 'a
//│ declare trait FooPoly: forall 'a. (x: 'a) -> 'a

(f: FooPoly) => [f(0), f(true)]
//│ (f: FooPoly) -> [0, true]
//│ res
//│     = [Function: res]


:e // TODO signatures are currently unchecked
class Oops(y: Str) extends Foo
//│ class Oops(y: Str) extends Foo
//│ TEST CASE FAILURE: There was an unexpected lack of type error

:e // TODO
module Oops extends FooPoly
//│ module Oops extends FooPoly
//│ TEST CASE FAILURE: There was an unexpected lack of type error

:e
Oops(123)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.40: 	Oops(123)
//│ ║        	^^^^^^^^^
//│ ╟── reference of type `Oops` is not a function
//│ ║  l.40: 	Oops(123)
//│ ╙──      	^^^^
//│ error
//│ res
//│ Runtime error:
//│   TypeError: Oops is not a function

:e
(Oops : FooPoly)(123)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.53: 	(Oops : FooPoly)(123)
//│ ║        	 ^^^^
//│ ╟── reference of type `Oops` is not a function
//│ ╟── Note: constraint arises from function type:
//│ ║  l.20: 	declare trait FooPoly: forall 'a: (x: 'a) => 'a
//│ ║        	                                  ^^^^^^^
//│ ╟── from type reference:
//│ ║  l.53: 	(Oops : FooPoly)(123)
//│ ╙──      	        ^^^^^^^
//│ 123
//│ res
//│ Runtime error:
//│   TypeError: Oops is not a function


