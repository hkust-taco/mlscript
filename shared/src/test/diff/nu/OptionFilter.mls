:NewDefs


// * Minimization of code that used to cause a problem:

abstract class Option[T]: (None | ()) {
  virtual fun filter: Option[T]
}
module None extends Option[nothing] {
  fun filter = None
}
//│ abstract class Option[T]: None | () {
//│   fun filter: Option[T]
//│ }
//│ module None extends Option {
//│   fun filter: None
//│ }


// * Original code:

abstract class Option[out T]: (Some[T] | None) {
  virtual fun filter: (p: T -> Bool) -> Option[T]
}
class Some[out T](val value: T) extends Option[T] {
  fun filter(p) = if p of value then Some(value) else None
}
module None extends Option[nothing] {
  fun filter(_) = None
}
//│ abstract class Option[T]: None | Some[T] {
//│   fun filter: (p: T -> Bool) -> Option[T]
//│ }
//│ class Some[T](value: T) extends Option {
//│   fun filter: (T -> Object) -> (None | Some[T])
//│ }
//│ module None extends Option {
//│   fun filter: anything -> None
//│ }


