:NewDefs


// TODO: there is problem when the is SPACE after '?'

// Typing of (a?: Int, b?: Int) is ok, but constraining is not 
:d
fun f1(a?: Int, b?: Int) = a + b
//│ 0. Typing TypingUnit(List(fun f1 = (a: Int?, b: Int?,) => + (a,) (b,)))
//│ | 0. Created lazy type info for fun f1 = (a: Int?, b: Int?,) => + (a,) (b,)
//│ | Completing fun f1 = (a: Int?, b: Int?,) => + (a,) (b,)
//│ | | UNSTASHING... (out)
//│ | | Type params 
//│ | | UNSTASHING... (out)
//│ | | Params 
//│ | | 1. Typing term (a: Int?, b: Int?,) => + (a,) (b,)
//│ | | | 1. Typing pattern a: Int?, b: Int?,
//│ | | | | HERE, good!
//│ | | | | 1. Typing pattern a : Int
//│ | | | | | Typing type TypeName(Int)
//│ | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | 1. type TypeName(Int)
//│ | | | | | | | typename case??
//│ | | | | | | => Int
//│ | | | | | => Int ——— 
//│ | | | | 1. : Int
//│ | | | | opt is => true
//│ | | | | case #2
//│ | | | | 1. Typing pattern b : Int
//│ | | | | | Typing type TypeName(Int)
//│ | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | 1. type TypeName(Int)
//│ | | | | | | | typename case??
//│ | | | | | | => Int
//│ | | | | | => Int ——— 
//│ | | | | 1. : Int
//│ | | | | opt is => true
//│ | | | | case #2
//│ | | | 1. : (a: Int?, b: Int?,)
//│ | | | 1. Typing term + (a,) (b,)
//│ | | | | 1. Typing term + (a,)
//│ | | | | | 1. Typing term +
//│ | | | | | 1. : (Int -> (Int -> Int))
//│ | | | | | 1. Typing term a
//│ | | | | | 1. : Int
//│ | | | | | CONSTRAIN (Int -> (Int -> Int)) <! (Int -> α29')
//│ | | | | |   where 
//│ | | | | | 1. C (Int -> (Int -> Int)) <! (Int -> α29')    (0)
//│ | | | | | | 1. C (Int,) <! (Int,)    (1)
//│ | | | | | | | Already a subtype by <:<
//│ | | | | | | 1. C (Int -> Int) <! α29'    (1)
//│ | | | | | | | NEW α29' LB (0)
//│ | | | | 1. : α29'
//│ | | | | 1. Typing term b
//│ | | | | 1. : Int
//│ | | | | CONSTRAIN α29' <! (Int -> α30')
//│ | | | |   where 
//│ 		α29' :> (Int -> Int)
//│ | | | | 1. C α29' <! (Int -> α30')    (0)
//│ | | | | | NEW α29' UB (1)
//│ | | | | | 1. C (Int -> Int) <! (Int -> α30')    (2)
//│ | | | | | | 1. C (Int,) <! (Int,)    (2)
//│ | | | | | | | Already a subtype by <:<
//│ | | | | | | 1. C Int <! α30'    (2)
//│ | | | | | | | NEW α30' LB (0)
//│ | | | 1. : α30'
//│ | | 1. : ((a: Int?, b: Int?,) -> α30')
//│ | | UNSTASHING... (out)
//│ | | CONSTRAIN ((a: Int?, b: Int?,) -> α30') <! f131'
//│ | |   where 
//│ 		α30' :> Int
//│ | | 1. C ((a: Int?, b: Int?,) -> α30') <! f131'    (0)
//│ | | | NEW f131' LB (1)
//│ | | UNSTASHING... (out)
//│ | Completed TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int?, b: Int?,) -> α30')) where 
//│ 		α30' :> Int
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun f1: ‹∀ 0. ((a: Int?, b: Int?,) -> α30')› where 
//│ |		α30' :> Int
//│ fun f1: (a: Int, b: Int,) -> Int



// using space, creates ASC in AST.
:p
fun f1(a: Int, b: Int) = a + b
//│ |#fun| |f1|(|a|#:| |Int|,| |b|#:| |Int|)| |#=| |a| |+| |b|
//│ AST: TypingUnit(NuFunDef(None, f1, [], Lam(Tup(a: Var(Int), b: Var(Int)), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b))))))
//│ Parsed: fun f1 = (a: Int, b: Int,) => + (a,) (b,);
//│ fun f1: (a: Int, b: Int,) -> Int

f1(1, 2)
//│ Int
//│ res
//│     = 3

:p
fun f1(a, b) = a + b
//│ |#fun| |f1|(|a|,| |b|)| |#=| |a| |+| |b|
//│ AST: TypingUnit(NuFunDef(None, f1, [], Lam(Tup(_: Var(a), _: Var(b)), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b))))))
//│ Parsed: fun f1 = (a, b,) => + (a,) (b,);
//│ fun f1: (Int, Int,) -> Int


:p
f1(1, 2)
//│ |f1|(|1|,| |2|)|
//│ AST: TypingUnit(App(Var(f1), Tup(_: IntLit(1), _: IntLit(2))))
//│ Parsed: f1 (1, 2,);
//│ Int
//│ res
//│     = 3

// checking how typer works.
let x = [1, 2] : [Int, Int]
//│ let x: (Int, Int,)
//│ x
//│   = [ 1, 2 ]

let f = ([a, b]) => a - b
//│ let f: (Int, Int,) -> Int
//│ f
//│   = [Function: f]

f(x)
//│ Int
//│ res
//│     = -1

[1, 2, 3]: [Int, Int, Int]
//│ (Int, Int, Int,)
//│ res
//│     = [ 1, 2, 3 ]

[1]
//│ (1,)
//│ res
//│     = [ 1 ]

class C1
class C2 extends C1
let x = new C2()
let y: C1 = x
//│ class C1
//│ class C2 extends C1
//│ let x: C2
//│ let y: C1
//│ x
//│   = C2 {}
//│ y
//│   = C2 {}

[x, y]: [C1, C1]
//│ (C1, C1,)
//│ res
//│     = [ C2 {}, C2 {} ]


[1, 2, 3]: [Int, Int, Int]
//│ (Int, Int, Int,)
//│ res
//│     = [ 1, 2, 3 ]

// Typing of [Int, Int?] is ok, but constraining is not 
:d
[1, 2]: [Int, Int?]
//│ 0. Typing TypingUnit(List('(' 1, 2, ')' : (Int, Int,)))
//│ | Typing unit statements
//│ | | 0. Typing term '(' 1, 2, ')' : (Int, Int,)
//│ | | | typing-trm-here!!! '(' 1, 2, ')'
//│ | | | 0. Typing term '(' 1, 2, ')'
//│ | | | | 0. Typing term 1, 2,
//│ | | | | | HERE, good!
//│ | | | | | 0. Typing term 1
//│ | | | | | 0. : #1<Int,Num,Object>
//│ | | | | | opt is => false
//│ | | | | | case #2
//│ | | | | | 0. Typing term 2
//│ | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | opt is => false
//│ | | | | | case #2
//│ | | | | 0. : (#1<Int,Num,Object>, #2<Int,Num,Object>,)
//│ | | | 0. : (#1<Int,Num,Object>, #2<Int,Num,Object>,)
//│ | | | typing-ty-here!!! Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))
//│ | | | Typing type Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))
//│ | | | | vars=Map() newDefsInfo=Map()
//│ | | | | 0. type Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))
//│ | | | | | typing tuple!!!
//│ | | | | | 0. type TypeName(Int)
//│ | | | | | | typename case??
//│ | | | | | => Int
//│ | | | | | 0. type TypeName(Int)
//│ | | | | | | typename case??
//│ | | | | | => Int
//│ | | | | => (Int, Int?,)
//│ | | | => (Int, Int?,) ——— 
//│ | | | constraining!!!
//│ | | | CONSTRAIN (#1<Int,Num,Object>, #2<Int,Num,Object>,) <! (Int, Int?,)
//│ | | |   where 
//│ | | | 0. C (#1<Int,Num,Object>, #2<Int,Num,Object>,) <! (Int, Int?,)    (0)
//│ | | | | Already a subtype by <:<
//│ | | 0. : (Int, Int?,)
//│ | : Some((Int, Int?,))
//│ ======== TYPED ========
//│ res: Some((Int, Int?,)) where 
//│ (Int, Int,)
//│ res
//│     = [ 1, 2 ]

:dp
[1, 2]: [Int, Int, Int?]
//│ |[|1|,| |2|]|#:| |[|Int|,| |Int|,| |Int|?|]|
//│ ? block		inspects |[|1|,| |2|]|#:| |[|Int|,| |Int|,| |Int|?|]|    [at l.300]
//│ ? go		inspects |[|1|,| |2|]|#:| |[|Int|,| |Int|,| |Int|?|]|    [at l.269]
//│ ? go		inspects |[|1|,| |2|]|#:| |[|Int|,| |Int|,| |Int|?|]|    [at l.269]
//│ @ exprOrIf(0,false)    [at l.499]
//│ │ ? exprOrIf		inspects |[|1|,| |2|]|#:| |[|Int|,| |Int|,| |Int|?|]|    [at l.561]
//│ │ ! exprOrIf		consumes |[|1|,| |2|]|    [at l.590]
//│ │ > ? maybeIndented		inspects |1|,| |2|    [at l.1005]
//│ │ > @ argsOrIf(List(),List())    [at l.1048]
//│ │ > │ ? argsOrIf		inspects |1|,| |2|    [at l.1049]
//│ │ > │ ? yeetSpaces		inspects |1|,| |2|    [at l.515]
//│ │ > │ ? yeetSpaces		inspects |1|,| |2|    [at l.515]
//│ │ > │ ? yeetSpaces		inspects |1|,| |2|    [at l.515]
//│ │ > │ @ exprOrIf(1,true)    [at l.1092]
//│ │ > │ │ ? exprOrIf		inspects |1|,| |2|    [at l.561]
//│ │ > │ │ ! exprOrIf		consumes |1|    [at l.574]
//│ │ > │ │ @ exprCont(1,`1`,false)    [at l.575]
//│ │ > │ │ │ ? exprCont		inspects |,| |2|    [at l.737]
//│ │ > │ │ = Right(1)
//│ │ > │ = Right(1)
//│ │ > │ ? argsOrIf		inspects |,| |2|    [at l.1093]
//│ │ > │ nexttoken => (COMMA,Loc(2,3,nu/OptionalArgs:+213))
//│ │ > │ ? isOptinoal		inspects |,| |2|    [at l.1098]
//│ │ > │ flags => None None None
//│ │ > │ e => Right(Fld(FldFlags(false,false,false),1))
//│ │ > │ body => 1 IntLit(1)
//│ │ > │ ? argsOrIf		inspects |,| |2|    [at l.1122]
//│ │ > │ ! argsOrIf		consumes |,|    [at l.1128]
//│ │ > │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),1)))),List())    [at l.1048]
//│ │ > │ │ ? argsOrIf		inspects | |2|    [at l.1049]
//│ │ > │ │ ! argsOrIf		consumes | |    [at l.1058]
//│ │ > │ │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),1)))),List())    [at l.1048]
//│ │ > │ │ │ ? argsOrIf		inspects |2|    [at l.1049]
//│ │ > │ │ │ ? yeetSpaces		inspects |2|    [at l.515]
//│ │ > │ │ │ ? yeetSpaces		inspects |2|    [at l.515]
//│ │ > │ │ │ ? yeetSpaces		inspects |2|    [at l.515]
//│ │ > │ │ │ @ exprOrIf(1,true)    [at l.1092]
//│ │ > │ │ │ │ ? exprOrIf		inspects |2|    [at l.561]
//│ │ > │ │ │ │ ! exprOrIf		consumes |2|    [at l.574]
//│ │ > │ │ │ │ @ exprCont(1,`2`,false)    [at l.575]
//│ │ > │ │ │ │ │ ? exprCont		inspects ||    [at l.737]
//│ │ > │ │ │ │ = Right(2)
//│ │ > │ │ │ = Right(2)
//│ │ > │ │ │ ? argsOrIf		inspects ||    [at l.1093]
//│ │ > │ │ │ ? isOptinoal		inspects ||    [at l.1098]
//│ │ > │ │ │ flags => None None None
//│ │ > │ │ │ e => Right(Fld(FldFlags(false,false,false),2))
//│ │ > │ │ │ body => 2 IntLit(2)
//│ │ > │ │ │ ? argsOrIf		inspects ||    [at l.1122]
//│ │ > │ │ = List((None,Right(Fld(FldFlags(false,false,false),1))), (None,Right(Fld(FldFlags(false,false,false),2))))
//│ │ > │ = List((None,Right(Fld(FldFlags(false,false,false),1))), (None,Right(Fld(FldFlags(false,false,false),2))))
//│ │ > = List((None,Right(Fld(FldFlags(false,false,false),1))), (None,Right(Fld(FldFlags(false,false,false),2))))
//│ │ > ? concludeWith		inspects ||    [at l.87]
//│ │ > Concluded with List((None,Fld(FldFlags(false,false,false),1)), (None,Fld(FldFlags(false,false,false),2)))
//│ │ @ exprCont(0,`'(' 1, 2, ')'`,false)    [at l.608]
//│ │ │ ? exprCont		inspects |#:| |[|Int|,| |Int|,| |Int|?|]|    [at l.737]
//│ │ │ ! exprCont		consumes |#:|    [at l.771]
//│ │ │ @ expr(0,true)    [at l.772]
//│ │ │ │ @ exprOrIf(0,true)    [at l.546]
//│ │ │ │ │ ? exprOrIf		inspects | |[|Int|,| |Int|,| |Int|?|]|    [at l.561]
//│ │ │ │ │ ! exprOrIf		consumes | |    [at l.563]
//│ │ │ │ │ @ exprOrIf(0,true)    [at l.564]
//│ │ │ │ │ │ ? exprOrIf		inspects |[|Int|,| |Int|,| |Int|?|]|    [at l.561]
//│ │ │ │ │ │ ! exprOrIf		consumes |[|Int|,| |Int|,| |Int|?|]|    [at l.590]
//│ │ │ │ │ │ > ? maybeIndented		inspects |Int|,| |Int|,|...    [at l.1005]
//│ │ │ │ │ │ > @ argsOrIf(List(),List())    [at l.1048]
//│ │ │ │ │ │ > │ ? argsOrIf		inspects |Int|,| |Int|,|...    [at l.1049]
//│ │ │ │ │ │ > │ ? yeetSpaces		inspects |Int|,| |Int|,|...    [at l.515]
//│ │ │ │ │ │ > │ ? yeetSpaces		inspects |Int|,| |Int|,|...    [at l.515]
//│ │ │ │ │ │ > │ ? yeetSpaces		inspects |Int|,| |Int|,|...    [at l.515]
//│ │ │ │ │ │ > │ @ exprOrIf(1,true)    [at l.1092]
//│ │ │ │ │ │ > │ │ ? exprOrIf		inspects |Int|,| |Int|,|...    [at l.561]
//│ │ │ │ │ │ > │ │ ! exprOrIf		consumes |Int|    [at l.580]
//│ │ │ │ │ │ > │ │ @ exprCont(1,`Int`,false)    [at l.581]
//│ │ │ │ │ │ > │ │ │ ? exprCont		inspects |,| |Int|,| |...    [at l.737]
//│ │ │ │ │ │ > │ │ = Right(Int)
//│ │ │ │ │ │ > │ = Right(Int)
//│ │ │ │ │ │ > │ ? argsOrIf		inspects |,| |Int|,| |...    [at l.1093]
//│ │ │ │ │ │ > │ nexttoken => (COMMA,Loc(12,13,nu/OptionalArgs:+213))
//│ │ │ │ │ │ > │ ? isOptinoal		inspects |,| |Int|,| |...    [at l.1098]
//│ │ │ │ │ │ > │ flags => None None None
//│ │ │ │ │ │ > │ e => Right(Fld(FldFlags(false,false,false),Int))
//│ │ │ │ │ │ > │ body => Int Var(Int)
//│ │ │ │ │ │ > │ ? argsOrIf		inspects |,| |Int|,| |...    [at l.1122]
//│ │ │ │ │ │ > │ ! argsOrIf		consumes |,|    [at l.1128]
//│ │ │ │ │ │ > │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),Int)))),List())    [at l.1048]
//│ │ │ │ │ │ > │ │ ? argsOrIf		inspects | |Int|,| |Int|...    [at l.1049]
//│ │ │ │ │ │ > │ │ ! argsOrIf		consumes | |    [at l.1058]
//│ │ │ │ │ │ > │ │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),Int)))),List())    [at l.1048]
//│ │ │ │ │ │ > │ │ │ ? argsOrIf		inspects |Int|,| |Int|?|    [at l.1049]
//│ │ │ │ │ │ > │ │ │ ? yeetSpaces		inspects |Int|,| |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ ? yeetSpaces		inspects |Int|,| |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ ? yeetSpaces		inspects |Int|,| |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ @ exprOrIf(1,true)    [at l.1092]
//│ │ │ │ │ │ > │ │ │ │ ? exprOrIf		inspects |Int|,| |Int|?|    [at l.561]
//│ │ │ │ │ │ > │ │ │ │ ! exprOrIf		consumes |Int|    [at l.580]
//│ │ │ │ │ │ > │ │ │ │ @ exprCont(1,`Int`,false)    [at l.581]
//│ │ │ │ │ │ > │ │ │ │ │ ? exprCont		inspects |,| |Int|?|    [at l.737]
//│ │ │ │ │ │ > │ │ │ │ = Right(Int)
//│ │ │ │ │ │ > │ │ │ = Right(Int)
//│ │ │ │ │ │ > │ │ │ ? argsOrIf		inspects |,| |Int|?|    [at l.1093]
//│ │ │ │ │ │ > │ │ │ nexttoken => (COMMA,Loc(17,18,nu/OptionalArgs:+213))
//│ │ │ │ │ │ > │ │ │ ? isOptinoal		inspects |,| |Int|?|    [at l.1098]
//│ │ │ │ │ │ > │ │ │ flags => None None None
//│ │ │ │ │ │ > │ │ │ e => Right(Fld(FldFlags(false,false,false),Int))
//│ │ │ │ │ │ > │ │ │ body => Int Var(Int)
//│ │ │ │ │ │ > │ │ │ ? argsOrIf		inspects |,| |Int|?|    [at l.1122]
//│ │ │ │ │ │ > │ │ │ ! argsOrIf		consumes |,|    [at l.1128]
//│ │ │ │ │ │ > │ │ │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int)))),List())    [at l.1048]
//│ │ │ │ │ │ > │ │ │ │ ? argsOrIf		inspects | |Int|?|    [at l.1049]
//│ │ │ │ │ │ > │ │ │ │ ! argsOrIf		consumes | |    [at l.1058]
//│ │ │ │ │ │ > │ │ │ │ @ argsOrIf(List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int)))),List())    [at l.1048]
//│ │ │ │ │ │ > │ │ │ │ │ ? argsOrIf		inspects |Int|?|    [at l.1049]
//│ │ │ │ │ │ > │ │ │ │ │ ? yeetSpaces		inspects |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ │ │ ? yeetSpaces		inspects |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ │ │ ? yeetSpaces		inspects |Int|?|    [at l.515]
//│ │ │ │ │ │ > │ │ │ │ │ @ exprOrIf(1,true)    [at l.1092]
//│ │ │ │ │ │ > │ │ │ │ │ │ ? exprOrIf		inspects |Int|?|    [at l.561]
//│ │ │ │ │ │ > │ │ │ │ │ │ ! exprOrIf		consumes |Int|    [at l.580]
//│ │ │ │ │ │ > │ │ │ │ │ │ @ exprCont(1,`Int`,false)    [at l.581]
//│ │ │ │ │ │ > │ │ │ │ │ │ │ ? exprCont		inspects |?|    [at l.737]
//│ │ │ │ │ │ > │ │ │ │ │ │ = Right(Int)
//│ │ │ │ │ │ > │ │ │ │ │ = Right(Int)
//│ │ │ │ │ │ > │ │ │ │ │ ? argsOrIf		inspects |?|    [at l.1093]
//│ │ │ │ │ │ > │ │ │ │ │ nexttoken => (IDENT(?,true),Loc(22,22,nu/OptionalArgs:+213))
//│ │ │ │ │ │ > │ │ │ │ │ ? isOptinoal		inspects |?|    [at l.1098]
//│ │ │ │ │ │ > │ │ │ │ │ ! isOptinoal		consumes |?|    [at l.1100]
//│ │ │ │ │ │ > │ │ │ │ │ flags => None None None
//│ │ │ │ │ │ > │ │ │ │ │ e => Right(Fld(FldFlags(false,false,true),Int))
//│ │ │ │ │ │ > │ │ │ │ │ body => Int Var(Int)
//│ │ │ │ │ │ > │ │ │ │ │ ? argsOrIf		inspects ||    [at l.1122]
//│ │ │ │ │ │ > │ │ │ │ = List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,true),Int))))
//│ │ │ │ │ │ > │ │ │ = List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,true),Int))))
//│ │ │ │ │ │ > │ │ = List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,true),Int))))
//│ │ │ │ │ │ > │ = List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,true),Int))))
//│ │ │ │ │ │ > = List((None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,false),Int))), (None,Right(Fld(FldFlags(false,false,true),Int))))
//│ │ │ │ │ │ > ? concludeWith		inspects ||    [at l.87]
//│ │ │ │ │ │ > Concluded with List((None,Fld(FldFlags(false,false,false),Int)), (None,Fld(FldFlags(false,false,false),Int)), (None,Fld(FldFlags(false,false,true),Int)))
//│ │ │ │ │ │ @ exprCont(0,`'(' Int, Int, Int?, ')'`,false)    [at l.608]
//│ │ │ │ │ │ │ ? exprCont		inspects ||    [at l.737]
//│ │ │ │ │ │ = Right('(' Int, Int, Int?, ')')
//│ │ │ │ │ = Right('(' Int, Int, Int?, ')')
//│ │ │ │ = Right('(' Int, Int, Int?, ')')
//│ │ │ │ result => '(' Int, Int, Int?, ')' ## Bra(rcd = false, Tup(_: Var(Int), _: Var(Int), _: Var(Int)))
//│ │ │ │ result toType => Right(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ │ │ = '(' Int, Int, Int?, ')'
//│ │ │ asc => '(' 1, 2, ')' : (Int, Int, Int,)
//│ │ = Right('(' 1, 2, ')' : (Int, Int, Int,))
//│ = Right('(' 1, 2, ')' : (Int, Int, Int,))
//│ ? yeetSpaces		inspects ||    [at l.515]
//│ ? parseAll		inspects ||    [at l.76]
//│ Parsed: '(' 1, 2, ')' : (Int, Int, Int,);
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.213: 	[1, 2]: [Int, Int, Int?]
//│ ║         	^^^^^^
//│ ╟── tuple literal of type `(1, 2,)` does not match type `(Int, Int, Int,)`
//│ ║  l.213: 	[1, 2]: [Int, Int, Int?]
//│ ║         	 ^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.213: 	[1, 2]: [Int, Int, Int?]
//│ ╙──       	        ^^^^^^^^^^^^^^^^
//│ (Int, Int, Int,)
//│ res
//│     = [ 1, 2 ]

