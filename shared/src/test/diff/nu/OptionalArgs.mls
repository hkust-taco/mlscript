:NewDefs

// Typing of (a?: Int, b?: Int) is ok, but constraining is not 
// :d
// :ds
:ds
fun f1(a?: Int, b?: Int) = a + b
//│ ⬤ Initial: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: Int?, b: Int?,) -> α29'))
//│ 	None)
//│  where: 
//│ 		α29' :> Int
//│ allVarPols: +α29'
//│ Renewed α29' ~> α29_31'
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: Int?, b: Int?,) -> α29_31'))
//│ 	None)
//│  where: 
//│ 		α29_31' :> Int
//│ allVarPols: +α29_31'
//│ consed: Map((true,Int) -> α29_31')
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: Int?, b: Int?,) -> α29_31'))
//│ 	None)
//│  where: 
//│ 		α29_31' :> Int
//│ analyze1[+] ((a: Int?, b: Int?,) -> α29_31')
//│ | analyze1[+;-] (a: Int?, b: Int?,)
//│ | | analyze1[+;-] Int
//│ | | analyze1[+;-] Int
//│ | analyze1[+] α29_31'
//│ | | analyze1[+;@[+](0)] Int
//│ [inv] 
//│ [nums] +α29_31' 1
//│ analyze2[+] ((a: Int?, b: Int?,) -> α29_31')
//│ | analyze2[+;-] (a: Int?, b: Int?,)
//│ | | analyze2[+;-] Int
//│ | | analyze2[+;-] Int
//│ | analyze2[+] α29_31'
//│ | | >> Processing α29_31' at [+]
//│ | | go α29_31'   ()
//│ | | | go Int   (α29_31')
//│ | | >> Occurrences HashSet(Int, α29_31')
//│ | | >>>> occs[+α29_31'] := HashSet(Int, α29_31')  <~ None
//│ | | analyze2[+] Int
//│ [occs] +α29_31' {Int,α29_31'}
//│ [vars] TreeSet(α29_31')
//│ [rec] Set()
//│ 0[1] α29_31'
//│ 1[!] α29_31'
//│ [sub] α29_31' -> None
//│ [bounds] 
//│ 		α29_31' :> Int
//│ [rec] Set()
//│ transform[+] ((a: Int?, b: Int?,) -> α29_31')   ()  +  None
//│ | transform[-] (a: Int?, b: Int?,)   ()  +;-  None
//│ | | transform[-] Int   ()  +;-  None
//│ | | ~> Int
//│ | | transform[-] Int   ()  +;-  None
//│ | | ~> Int
//│ | ~> (a: Int?, b: Int?,)
//│ | transform[+] α29_31'   ()  +  None
//│ | | -> bound Some(true)
//│ | | transform[+] Int   (α29_31')  +;@[+](0)  None
//│ | | ~> Int
//│ | ~> Int
//│ ~> ((a: Int?, b: Int?,) -> Int)
//│ ⬤ Type after simplification: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: Int?, b: Int?,) -> Int))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ normLike[+] TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: Int?, b: Int?,) -> Int))
//│ 	None)
//│ | norm[+] ((a: Int?, b: Int?,) -> Int)
//│ | | DNF: DNF(0, ((a: Int?, b: Int?,) -> Int){})
//│ | | norm[-] (a: Int?, b: Int?,)
//│ | | | DNF: DNF(0, (a: Int?, b: Int?,){})
//│ | | | norm[-] Int
//│ | | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | | ~> #Int<Object,Num>
//│ | | | norm[-] Int
//│ | | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | | ~> #Int<Object,Num>
//│ | | ~> (a: #Int<Object,Num>?, b: #Int<Object,Num>?,)
//│ | | norm[+] Int
//│ | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | ~> #Int<Object,Num>
//│ | ~> ((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>)
//│ ⬤ Normalized: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ consed: Map()
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ analyze1[+] ((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>)
//│ | analyze1[+;-] (a: #Int<Object,Num>?, b: #Int<Object,Num>?,)
//│ | | analyze1[+;-] #Int<Object,Num>
//│ | | analyze1[+;-] #Int<Object,Num>
//│ | analyze1[+] #Int<Object,Num>
//│ [inv] 
//│ [nums] 
//│ analyze2[+] ((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>)
//│ | analyze2[+;-] (a: #Int<Object,Num>?, b: #Int<Object,Num>?,)
//│ | | analyze2[+;-] #Int<Object,Num>
//│ | | analyze2[+;-] #Int<Object,Num>
//│ | analyze2[+] #Int<Object,Num>
//│ [occs] 
//│ [vars] TreeSet()
//│ [rec] Set()
//│ [sub] 
//│ [bounds] 
//│ [rec] Set()
//│ transform[+] ((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>)   ()  +  None
//│ | transform[-] (a: #Int<Object,Num>?, b: #Int<Object,Num>?,)   ()  +;-  None
//│ | | transform[-] #Int<Object,Num>   ()  +;-  None
//│ | | ~> #Int<Object,Num>
//│ | | transform[-] #Int<Object,Num>   ()  +;-  None
//│ | | ~> #Int<Object,Num>
//│ | ~> (a: #Int<Object,Num>?, b: #Int<Object,Num>?,)
//│ | transform[+] #Int<Object,Num>   ()  +  None
//│ | ~> #Int<Object,Num>
//│ ~> ((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>)
//│ ⬤ Resim: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ [subs] HashMap()
//│ ⬤ Factored: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a, b,),((a: #Int<Object,Num>?, b: #Int<Object,Num>?,) -> #Int<Object,Num>))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun f1: (a: Int?, b: Int?) -> Int)
//│ result => None
//│ fun f1: (a: Int?, b: Int?) -> Int


// using space, creates ASC in AST.
:p
fun f1(a: Int, b: Int) = a + b
//│ |#fun| |f1|(|a|#:| |Int|,| |b|#:| |Int|)| |#=| |a| |+| |b|
//│ AST: TypingUnit(NuFunDef(None, f1, None, [], Lam(Tup(a: Var(Int), b: Var(Int)), App(Var(+), Tup(_: Var(a), _: Var(b))))))
//│ Parsed: fun f1 = (a: Int, b: Int,) => + (a, b,);
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int, b: Int,) => + (a, b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun f1: (a: Int, b: Int) -> Int)
//│ result => None
//│ fun f1: (a: Int, b: Int) -> Int


class C1
class C2 extends C1
let x = new C2()
let y: C1 = x
//│ sim => TypedTypingUnit(
//│ 	TypedNuCls(0, TypeName(C1),
//│ 		List(),
//│ 		List(),
//│ 		this: ⊤, ,
//│ 		: ⊤, Set(), Map())
//│ 	TypedNuCls(0, TypeName(C2),
//│ 		List(),
//│ 		List(),
//│ 		this: ⊤, ,
//│ 		: ⊤, Set(TypeName(C1)), Map())
//│ 	TypedNuFun(0,let x = new C2() {},C2)
//│ 	TypedNuFun(0,let y = x : C1,C1)
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(class C1() {}, class C2(): C1 {}, let x: C2, let y: C1)
//│ result => None
//│ class C1
//│ class C2 extends C1
//│ let x: C2
//│ let y: C1
//│ x
//│   = C2 {}
//│ y
//│   = C2 {}

[x, y]: [C1, C1]
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)))))
//│ [C1, C1]
//│ res
//│     = [ C2 {}, C2 {} ]
[x, y]: [C1, C1, C1?]
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1, C1?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),true)))))
//│ [C1, C1, C1?]
//│ res
//│     = [ C2 {}, C2 {} ]

:e
[x]: [C1, C1, C1?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.218: 	[x]: [C1, C1, C1?]
//│ ║         	^^^
//│ ╟── expression of type `[?a]` does not match type `[C1, C1, C1?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.218: 	[x]: [C1, C1, C1?]
//│ ╙──       	     ^^^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1, C1?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),true)))))
//│ [C1, C1, C1?]
//│ res
//│     = [ C2 {} ]


[1, 2, 3]: [Int, Int, Int]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ [Int, Int, Int]
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ [Int, Int?]
//│ res
//│     = [ 1, 2 ]

[1]: [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ [Int, Int?]
//│ res
//│     = [ 1 ]

:e
[]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.267: 	[]: [Int, Int?]
//│ ║         	^^
//│ ╟── expression of type `[]` does not match type `[Int, Int?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.267: 	[]: [Int, Int?]
//│ ╙──       	    ^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ [Int, Int?]
//│ res
//│     = []

:e
[1, 2, 3]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ║         	^^^^^^^^^
//│ ╟── tuple literal of type `[1, 2, 3]` does not match type `[Int, Int?]`
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ║         	 ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ╙──       	           ^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ [Int, Int?]
//│ res
//│     = [ 1, 2, 3 ]

// FIXME
:ds
[1, 2]: [Int, Int, Int?]
//│ ⬤ Initial: TypedTypingUnit(
//│ 	Some((Int, Int, Int?,)))
//│  where: 
//│ allVarPols: 
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	Some((Int, Int, Int?,)))
//│  where: 
//│ allVarPols: 
//│ consed: Map()
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	Some((Int, Int, Int?,)))
//│  where: 
//│ analyze1[+] (Int, Int, Int?,)
//│ | analyze1[+] Int
//│ | analyze1[+] Int
//│ | analyze1[+] Int
//│ [inv] 
//│ [nums] 
//│ analyze2[+] (Int, Int, Int?,)
//│ | analyze2[+] Int
//│ | analyze2[+] Int
//│ | analyze2[+] Int
//│ [occs] 
//│ [vars] TreeSet()
//│ [rec] Set()
//│ [sub] 
//│ [bounds] 
//│ [rec] Set()
//│ transform[+] (Int, Int, Int?,)   ()  +  None
//│ | transform[+] Int   ()  +  None
//│ | ~> Int
//│ | transform[+] Int   ()  +  None
//│ | ~> Int
//│ | transform[+] Int   ()  +  None
//│ | ~> Int
//│ ~> (Int, Int, Int?,)
//│ ⬤ Type after simplification: TypedTypingUnit(
//│ 	Some((Int, Int, Int?,)))
//│  where: 
//│ allVarPols: 
//│ normLike[+] TypedTypingUnit(
//│ 	Some((Int, Int, Int?,)))
//│ | norm[+] (Int, Int, Int?,)
//│ | | DNF: DNF(0, (Int, Int, Int?,){})
//│ | | norm[+] Int
//│ | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | ~> #Int<Object,Num>
//│ | | norm[+] Int
//│ | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | ~> #Int<Object,Num>
//│ | | norm[+] Int
//│ | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | ~> #Int<Object,Num>
//│ | ~> (#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)
//│ ⬤ Normalized: TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│  where: 
//│ allVarPols: 
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│  where: 
//│ allVarPols: 
//│ consed: Map()
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│  where: 
//│ analyze1[+] (#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)
//│ | analyze1[+] #Int<Object,Num>
//│ | analyze1[+] #Int<Object,Num>
//│ | analyze1[+] #Int<Object,Num>
//│ [inv] 
//│ [nums] 
//│ analyze2[+] (#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)
//│ | analyze2[+] #Int<Object,Num>
//│ | analyze2[+] #Int<Object,Num>
//│ | analyze2[+] #Int<Object,Num>
//│ [occs] 
//│ [vars] TreeSet()
//│ [rec] Set()
//│ [sub] 
//│ [bounds] 
//│ [rec] Set()
//│ transform[+] (#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)   ()  +  None
//│ | transform[+] #Int<Object,Num>   ()  +  None
//│ | ~> #Int<Object,Num>
//│ | transform[+] #Int<Object,Num>   ()  +  None
//│ | ~> #Int<Object,Num>
//│ | transform[+] #Int<Object,Num>   ()  +  None
//│ | ~> #Int<Object,Num>
//│ ~> (#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)
//│ ⬤ Resim: TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│  where: 
//│ allVarPols: 
//│ [subs] HashMap()
//│ ⬤ Factored: TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│  where: 
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>?,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true)))))
//│ [Int, Int, Int?]
//│ res
//│     = [ 1, 2 ]


// * Harder case:

// why xs type is `nothing` ?
:p
fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ |#fun| |foo|(|xs|#:| |[|Int|]| |&| |'a|)| |#=| |xs| |#:| |[|Int|,| |Int|?|]|
//│ AST: TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(xs: App(Var(&), Tup(_: Bra(rcd = false, Tup(_: Var(Int))), _: Var('a)))), Asc(Var(xs), Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))))))
//│ Parsed: fun foo = (xs: & ('(' Int, ')', 'a,),) => xs : [Int, Int?];
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun foo = (xs: & ('(' Int, ')', 'a,),) => xs : [Int, Int?],((xs: (#Int<Object,Num>,),) -> (#Int<Object,Num>, #Int<Object,Num>?,)))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun foo: (xs: [Int]) -> [Int, Int?])
//│ result => None
//│ fun foo: (xs: [Int]) -> [Int, Int?]



// TODO later: update normal form construction

fun foo: [Int] | [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun foo: [Int] | [Int, Int?],(#Int<Object,Num>, #Int<Object,Num>?,))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun foo: [Int, Int?])
//│ result => None
//│ fun foo: [Int, Int?]

fun foo: [Int] & [Int, Int?]
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TyperHelpers.tupleIntersection(TyperHelpers.scala:135)
//│ 	at: mlscript.TyperHelpers$SimpleTypeImpl.$amp(TyperHelpers.scala:434)
//│ 	at: mlscript.TyperHelpers$SimpleTypeImpl.$amp$(TyperHelpers.scala:411)
//│ 	at: mlscript.TyperDatatypes$SimpleType.$amp(TyperDatatypes.scala:155)
//│ 	at: mlscript.Typer.$anonfun$typeType2$17(Typer.scala:462)
//│ 	at: mlscript.Typer.$anonfun$typeType2$11(Typer.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.Typer.rec$1(Typer.scala:621)
//│ 	at: mlscript.Typer.$anonfun$typeType2$2(Typer.scala:622)


