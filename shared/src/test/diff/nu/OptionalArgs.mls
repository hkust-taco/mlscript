:NewDefs
// TODO add check two compatible fields

fun f1(a?: Int, b?: Int) = a + b
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.4: 	fun f1(a?: Int, b?: Int) = a + b
//│ ║       	                           ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.4: 	fun f1(a?: Int, b?: Int) = a + b
//│ ║       	           ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.4: 	fun f1(a?: Int, b?: Int) = a + b
//│ ╙──     	                           ^
//│ fun f1: (a: (Int | undefined)?, b: (Int | undefined)?) -> (Int | error)

fun f1(a: Int, b: Int) = a + b
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.16: 	fun f1(a: Int, b: Int) = a + b
//│ ║        	                         ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.16: 	fun f1(a: Int, b: Int) = a + b
//│ ║        	          ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.16: 	fun f1(a: Int, b: Int) = a + b
//│ ╙──      	                         ^
//│ fun f1: (a: Int | undefined, b: Int | undefined) -> (Int | error)


class C1
class C2 extends C1
let x = new C2()
let y: C1 = x
//│ class C1 {
//│   constructor()
//│ }
//│ class C2 extends C1 {
//│   constructor()
//│ }
//│ let x: C2
//│ let y: C1
//│ x
//│   = C2 {}
//│ y
//│   = C2 {}

[x, y]: [C1, C1]
//│ [C1, C1]
//│ res
//│     = [ C2 {}, C2 {} ]

[x, y]: [C1, C1, C1?]
//│ [C1, C1, (C1)?]
//│ res
//│     = [ C2 {}, C2 {} ]

:e
[x]: [C1, C1, C1?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.57: 	[x]: [C1, C1, C1?]
//│ ║        	^^^
//│ ╟── expression of type `[?a]` does not match type `[C1, C1, (C1)?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.57: 	[x]: [C1, C1, C1?]
//│ ╙──      	     ^^^^^^^^^^^^^
//│ [C1, C1, (C1)?]
//│ res
//│     = [ C2 {} ]


[1, 2, 3]: [Int, Int, Int]
//│ [Int, Int, Int]
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int?]
//│ [Int, (Int)?]
//│ res
//│     = [ 1, 2 ]

[1]: [Int, Int?]
//│ [Int, (Int)?]
//│ res
//│     = [ 1 ]

:e
[]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.86: 	[]: [Int, Int?]
//│ ║        	^^
//│ ╟── expression of type `[]` does not match type `[Int, (Int)?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.86: 	[]: [Int, Int?]
//│ ╙──      	    ^^^^^^^^^^^
//│ [Int, (Int)?]
//│ res
//│     = []

:e
[1, 2, 3]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.99: 	[1, 2, 3]: [Int, Int?]
//│ ║        	^^^^^^^^^
//│ ╟── tuple literal of type `[1, 2, 3]` does not match type `[Int, (Int)?]`
//│ ║  l.99: 	[1, 2, 3]: [Int, Int?]
//│ ║        	 ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.99: 	[1, 2, 3]: [Int, Int?]
//│ ╙──      	           ^^^^^^^^^^^
//│ [Int, (Int)?]
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int, Int?]
//│ [Int, Int, (Int)?]
//│ res
//│     = [ 1, 2 ]


// * Harder case:
:p
fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ |#fun| |foo|(|xs|#:| |[|Int|]| |&| |'a|)| |#=| |xs| |#:| |[|Int|,| |Int|?|]|
//│ AST: TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(xs: App(Var(&), Tup(_: Bra(rcd = false, Tup(_: Var(Int))), _: Var('a)))), Asc(Var(xs), Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))))))
//│ Parsed: fun foo = (xs: &('(' [Int,] ')', 'a,),) => xs : [Int, (Int)?];
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.121: 	fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ ║         	                          ^^
//│ ╟── type `undefined` is not a 2-element tuple
//│ ║  l.121: 	fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ ║         	            ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `[Int, (Int)?]`
//│ ║  l.121: 	fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ ║         	                          ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.121: 	fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ ╙──       	                               ^^^^^^^^^^^
//│ fun foo: (xs: undefined | [Int]) -> [Int, (Int)?]

fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.139: 	fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ ║         	                           ^^
//│ ╟── type `undefined` is not a 2-element tuple
//│ ║  l.139: 	fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ ║         	            ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `[Int, (Int)?]`
//│ ║  l.139: 	fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ ║         	                           ^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.139: 	fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ ╙──       	                                ^^^^^^^^^^^
//│ fun foo: (xs: undefined | [Int]) -> [[Int, (Int)?], undefined]



// TODO later: update normal form construction

fun foo: [Int] | [Int?]
//│ fun foo: [(Int)?]

fun foo: [Int] & [Int?]
//│ fun foo: [Int]

fun foo: [Int] | [Int, Int?]
//│ fun foo: [Int, (Int)?]

fun foo: [Int] & [Int, Int?]
//│ fun foo: [Int]

fun foo: ([Int] & [Int, Int?]) -> Int
//│ fun foo: ([Int]) -> Int


:e
foo([1, true])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.175: 	foo([1, true])
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `[1, true]` does not match type `[Int]`
//│ ║  l.175: 	foo([1, true])
//│ ║         	     ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.170: 	fun foo: ([Int] & [Int, Int?]) -> Int
//│ ╙──       	          ^^^^^
//│ Int | error
//│ res
//│     = <no result>
//│       foo is not implemented


fun foo: ([Int] | [Int, Int?]) -> Int
//│ fun foo: ([Int, (Int)?]) -> Int

:e
foo([1, true])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.195: 	foo([1, true])
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `Int`
//│ ║  l.195: 	foo([1, true])
//│ ╙──       	        ^^^^
//│ Int | error
//│ res
//│     = <no result>
//│       foo is not implemented

// check check check
let x = [1, 2, 3]: [Int, Int, Int]
//│ let x: [Int, Int, Int]
//│ x
//│   = [ 1, 2, 3 ]

fun foo0(x: Int?) = if x is undefined then 0 else x + 1
//│ fun foo0: (x: (Int | undefined)?) -> Int

fun foo1(x?) = if x is undefined then 0 else x + 1
//│ fun foo1: ((Int | undefined)?) -> Int

:e
fun foo0(x: Int?) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.220: 	fun foo0(x: Int?) = x + 1
//│ ║         	                    ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.220: 	fun foo0(x: Int?) = x + 1
//│ ║         	            ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.220: 	fun foo0(x: Int?) = x + 1
//│ ╙──       	                    ^
//│ fun foo0: (x: (Int | undefined)?) -> (Int | error)

:e
fun foo1(x?) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.233: 	fun foo1(x?) = x + 1
//│ ║         	               ^^^^^
//│ ╟── reference of type `undefined` is not an instance of type `Int`
//│ ║  l.233: 	fun foo1(x?) = x + 1
//│ ╙──       	               ^
//│ fun foo1: ((Int | undefined)?) -> (Int | error)

:e
fun ff(x: Int?) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.243: 	fun ff(x: Int?) = x + 1
//│ ║         	                  ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.243: 	fun ff(x: Int?) = x + 1
//│ ║         	          ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.243: 	fun ff(x: Int?) = x + 1
//│ ╙──       	                  ^
//│ fun ff: (x: (Int | undefined)?) -> (Int | error)


fun ff(x: Int | undefined) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.256: 	fun ff(x: Int | undefined) = x + 1
//│ ║         	                             ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.256: 	fun ff(x: Int | undefined) = x + 1
//│ ║         	                ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.256: 	fun ff(x: Int | undefined) = x + 1
//│ ╙──       	                             ^
//│ fun ff: (x: Int | undefined) -> (Int | error)


:e
fun foo1([x, y]?) = x + y
//│ ╔══[ERROR] Error here
//│ ║  l.270: 	fun foo1([x, y]?) = x + y
//│ ╙──       	         ^^^^^^
//│ fun foo1: (([Int, Int])?) -> Int


[123?]
//│ ╔══[ERROR] Error here
//│ ║  l.277: 	[123?]
//│ ╙──       	 ^^^
//│ [(123)?]
//│ res
//│     = [ 123 ]



