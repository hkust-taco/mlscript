:NewDefs

// Typing of (a?: Int, b?: Int) is ok, but constraining is not 
// :d
// :ds
:ds
fun f1(a?: Int, b?: Int) = a + b
//│ ⬤ Initial: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int?, b: Int?,) -> α30'))
//│ 	None)
//│  where: 
//│ 		α30' :> Int
//│ allVarPols: +α30'
//│ Renewed α30' ~> α30_32'
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int, b: Int,) -> α30_32'))
//│ 	None)
//│  where: 
//│ 		α30_32' :> Int
//│ allVarPols: +α30_32'
//│ consed: Map((true,Int) -> α30_32')
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int, b: Int,) -> α30_32'))
//│ 	None)
//│  where: 
//│ 		α30_32' :> Int
//│ analyze1[+] ((a: Int, b: Int,) -> α30_32')
//│ | analyze1[+;-] (a: Int, b: Int,)
//│ | | analyze1[+;-] Int
//│ | | analyze1[+;-] Int
//│ | analyze1[+] α30_32'
//│ | | analyze1[+;@[+](0)] Int
//│ [inv] 
//│ [nums] +α30_32' 1
//│ analyze2[+] ((a: Int, b: Int,) -> α30_32')
//│ | analyze2[+;-] (a: Int, b: Int,)
//│ | | analyze2[+;-] Int
//│ | | analyze2[+;-] Int
//│ | analyze2[+] α30_32'
//│ | | >> Processing α30_32' at [+]
//│ | | go α30_32'   ()
//│ | | | go Int   (α30_32')
//│ | | >> Occurrences HashSet(α30_32', Int)
//│ | | >>>> occs[+α30_32'] := HashSet(α30_32', Int)  <~ None
//│ | | analyze2[+] Int
//│ [occs] +α30_32' {α30_32',Int}
//│ [vars] TreeSet(α30_32')
//│ [rec] Set()
//│ 0[1] α30_32'
//│ 1[!] α30_32'
//│ [sub] α30_32' -> None
//│ [bounds] 
//│ 		α30_32' :> Int
//│ [rec] Set()
//│ transform[+] ((a: Int, b: Int,) -> α30_32')   ()  +  None
//│ | transform[-] (a: Int, b: Int,)   ()  +;-  None
//│ | | transform[-] Int   ()  +;-  None
//│ | | ~> Int
//│ | | transform[-] Int   ()  +;-  None
//│ | | ~> Int
//│ | ~> (a: Int, b: Int,)
//│ | transform[+] α30_32'   ()  +  None
//│ | | -> bound Some(true)
//│ | | transform[+] Int   (α30_32')  +;@[+](0)  None
//│ | | ~> Int
//│ | ~> Int
//│ ~> ((a: Int, b: Int,) -> Int)
//│ ⬤ Type after simplification: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int, b: Int,) -> Int))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ normLike[+] TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: Int, b: Int,) -> Int))
//│ 	None)
//│ | norm[+] ((a: Int, b: Int,) -> Int)
//│ | | DNF: DNF(0, ((a: Int, b: Int,) -> Int){})
//│ | | norm[-] (a: Int, b: Int,)
//│ | | | DNF: DNF(0, (a: Int, b: Int,){})
//│ | | | norm[-] Int
//│ | | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | | ~> #Int<Object,Num>
//│ | | | norm[-] Int
//│ | | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | | ~> #Int<Object,Num>
//│ | | ~> (a: #Int<Object,Num>, b: #Int<Object,Num>,)
//│ | | norm[+] Int
//│ | | | DNF: DNF(0, #Int<Object,Num>{})
//│ | | ~> #Int<Object,Num>
//│ | ~> ((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>)
//│ ⬤ Normalized: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ ⬤ Cleaned up: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ consed: Map()
//│ ⬤ Unskid: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ analyze1[+] ((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>)
//│ | analyze1[+;-] (a: #Int<Object,Num>, b: #Int<Object,Num>,)
//│ | | analyze1[+;-] #Int<Object,Num>
//│ | | analyze1[+;-] #Int<Object,Num>
//│ | analyze1[+] #Int<Object,Num>
//│ [inv] 
//│ [nums] 
//│ analyze2[+] ((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>)
//│ | analyze2[+;-] (a: #Int<Object,Num>, b: #Int<Object,Num>,)
//│ | | analyze2[+;-] #Int<Object,Num>
//│ | | analyze2[+;-] #Int<Object,Num>
//│ | analyze2[+] #Int<Object,Num>
//│ [occs] 
//│ [vars] TreeSet()
//│ [rec] Set()
//│ [sub] 
//│ [bounds] 
//│ [rec] Set()
//│ transform[+] ((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>)   ()  +  None
//│ | transform[-] (a: #Int<Object,Num>, b: #Int<Object,Num>,)   ()  +;-  None
//│ | | transform[-] #Int<Object,Num>   ()  +;-  None
//│ | | ~> #Int<Object,Num>
//│ | | transform[-] #Int<Object,Num>   ()  +;-  None
//│ | | ~> #Int<Object,Num>
//│ | ~> (a: #Int<Object,Num>, b: #Int<Object,Num>,)
//│ | transform[+] #Int<Object,Num>   ()  +  None
//│ | ~> #Int<Object,Num>
//│ ~> ((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>)
//│ ⬤ Resim: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ allVarPols: 
//│ [subs] HashMap()
//│ ⬤ Factored: TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│  where: 
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int?, b: Int?,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun f1: (a: Int, b: Int,) -> Int)
//│ result => None
//│ fun f1: (a: Int, b: Int,) -> Int


// using space, creates ASC in AST.
:p
fun f1(a: Int, b: Int) = a + b
//│ |#fun| |f1|(|a|#:| |Int|,| |b|#:| |Int|)| |#=| |a| |+| |b|
//│ AST: TypingUnit(NuFunDef(None, f1, [], Lam(Tup(a: Var(Int), b: Var(Int)), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b))))))
//│ Parsed: fun f1 = (a: Int, b: Int,) => + (a,) (b,);
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun f1 = (a: Int, b: Int,) => + (a,) (b,),((a: #Int<Object,Num>, b: #Int<Object,Num>,) -> #Int<Object,Num>))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun f1: (a: Int, b: Int,) -> Int)
//│ result => None
//│ fun f1: (a: Int, b: Int,) -> Int


class C1
class C2 extends C1
let x = new C2()
let y: C1 = x
//│ sim => TypedTypingUnit(
//│ 	TypedNuCls(0, TypeName(C1),
//│ 		List(),
//│ 		List(),
//│ 		this: ⊤, ,
//│ 		: ⊤, Set(), Map())
//│ 	TypedNuCls(0, TypeName(C2),
//│ 		List(),
//│ 		List(),
//│ 		this: ⊤, ,
//│ 		: ⊤, Set(TypeName(C1)), Map())
//│ 	TypedNuFun(0,let x = new C2() {},C2)
//│ 	TypedNuFun(0,let y = x : C1,C1)
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(class C1() {}, class C2(): C1 {}, let x: C2, let y: C1)
//│ result => None
//│ class C1
//│ class C2 extends C1
//│ let x: C2
//│ let y: C1
//│ x
//│   = C2 {}
//│ y
//│   = C2 {}

[x, y]: [C1, C1]
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)))))
//│ (C1, C1,)
//│ res
//│     = [ C2 {}, C2 {} ]
[x, y]: [C1, C1, C1?]
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1, C1,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)))))
//│ (C1, C1, C1,)
//│ res
//│     = [ C2 {}, C2 {} ]

:e
[x]: [C1, C1, C1?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.218: 	[x]: [C1, C1, C1?]
//│ ║         	^^^
//│ ╟── expression of type `(?a,)` does not match type `(C1, C1, C1,)`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.218: 	[x]: [C1, C1, C1?]
//│ ╙──       	     ^^^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((C1, C1, C1,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)), (None,Field(None,TypeName(C1),false)))))
//│ (C1, C1, C1,)
//│ res
//│     = [ C2 {} ]


[1, 2, 3]: [Int, Int, Int]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int, Int,)
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int,)
//│ res
//│     = [ 1, 2 ]

[1]: [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int,)
//│ res
//│     = [ 1 ]

:e
[]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.267: 	[]: [Int, Int?]
//│ ║         	^^
//│ ╟── expression of type `()` does not match type `(Int, Int,)`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.267: 	[]: [Int, Int?]
//│ ╙──       	    ^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int,)
//│ res
//│     = []

:e
[1, 2, 3]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ║         	^^^^^^^^^
//│ ╟── tuple literal of type `(1, 2, 3,)` does not match type `(Int, Int,)`
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ║         	 ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.285: 	[1, 2, 3]: [Int, Int?]
//│ ╙──       	           ^^^^^^^^^^^
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int,)
//│ res
//│     = [ 1, 2, 3 ]

// FIXME
[1, 2]: [Int, Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	Some((#Int<Object,Num>, #Int<Object,Num>, #Int<Object,Num>,)))
//│ exp => class mlscript.Signature
//│ members => List()
//│ result => Some(Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),false)))))
//│ (Int, Int, Int,)
//│ res
//│     = [ 1, 2 ]


// * Harder case:

// why xs type is `nothing` ?
:p
fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ |#fun| |foo|(|xs|#:| |[|Int|]| |&| |'a|)| |#=| |xs| |#:| |[|Int|,| |Int|?|]|
//│ AST: TypingUnit(NuFunDef(None, foo, [], Lam(Tup(xs: App(App(Var(&), Tup(_: Var(Int))), Tup(_: Var('a)))), Asc(Var(xs), Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))))))
//│ Parsed: fun foo = (xs: & (Int,) ('a,),) => xs : (Int, Int?,);
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun foo = (xs: & (Int,) ('a,),) => xs : (Int, Int?,),((xs: ⊥,) -> (#Int<Object,Num>, #Int<Object,Num>,)))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun foo: (xs: nothing,) -> (Int, Int,))
//│ result => None
//│ fun foo: (xs: nothing,) -> (Int, Int,)



// TODO later: update normal form construction

fun foo: [Int] | [Int, Int?]
//│ sim => TypedTypingUnit(
//│ 	TypedNuFun(0,fun foo: (Int,) | (Int, Int?,),(Array‹#Int<Object,Num>› & {_1: #Int<Object,Num>}))
//│ 	None)
//│ exp => class mlscript.Signature
//│ members => List(fun foo: Array[Int] & {_1: Int})
//│ result => None
//│ fun foo: Array[Int] & {_1: Int}

fun foo: [Int] & [Int, Int?]
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TyperHelpers.tupleIntersection(TyperHelpers.scala:135)
//│ 	at: mlscript.TyperHelpers$SimpleTypeImpl.$amp(TyperHelpers.scala:434)
//│ 	at: mlscript.TyperHelpers$SimpleTypeImpl.$amp$(TyperHelpers.scala:411)
//│ 	at: mlscript.TyperDatatypes$SimpleType.$amp(TyperDatatypes.scala:155)
//│ 	at: mlscript.Typer.$anonfun$typeType2$17(Typer.scala:445)
//│ 	at: mlscript.Typer.$anonfun$typeType2$11(Typer.scala:447)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)
//│ 	at: mlscript.Typer.rec$1(Typer.scala:604)
//│ 	at: mlscript.Typer.$anonfun$typeType2$2(Typer.scala:605)


