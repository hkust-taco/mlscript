:NewDefs
// TODO add check two compatible fields

fun f1(a?: Int, b?: Int) = a + b
//│ fun f1: (a: (Int)?, b: (Int)?) -> Int

fun f1(a: Int, b: Int) = a + b
//│ fun f1: (a: Int, b: Int) -> Int


class C1
class C2 extends C1
let x = new C2()
let y: C1 = x
//│ class C1 {
//│   constructor()
//│ }
//│ class C2 extends C1 {
//│   constructor()
//│ }
//│ let x: C2
//│ let y: C1
//│ x
//│   = C2 {}
//│ y
//│   = C2 {}

[x, y]: [C1, C1]
//│ [C1, C1]
//│ res
//│     = [ C2 {}, C2 {} ]

[x, y]: [C1, C1, C1?]
//│ [C1, C1, (C1)?]
//│ res
//│     = [ C2 {}, C2 {} ]

:e
[x]: [C1, C1, C1?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.39: 	[x]: [C1, C1, C1?]
//│ ║        	^^^
//│ ╟── expression of type `[?a]` does not match type `[C1, C1, (C1)?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.39: 	[x]: [C1, C1, C1?]
//│ ╙──      	     ^^^^^^^^^^^^^
//│ [C1, C1, (C1)?]
//│ res
//│     = [ C2 {} ]


[1, 2, 3]: [Int, Int, Int]
//│ [Int, Int, Int]
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int?]
//│ [Int, (Int)?]
//│ res
//│     = [ 1, 2 ]

[1]: [Int, Int?]
//│ [Int, (Int)?]
//│ res
//│     = [ 1 ]

:e
[]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.68: 	[]: [Int, Int?]
//│ ║        	^^
//│ ╟── expression of type `[]` does not match type `[Int, (Int)?]`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.68: 	[]: [Int, Int?]
//│ ╙──      	    ^^^^^^^^^^^
//│ [Int, (Int)?]
//│ res
//│     = []

:e
[1, 2, 3]: [Int, Int?]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.81: 	[1, 2, 3]: [Int, Int?]
//│ ║        	^^^^^^^^^
//│ ╟── tuple literal of type `[1, 2, 3]` does not match type `[Int, (Int)?]`
//│ ║  l.81: 	[1, 2, 3]: [Int, Int?]
//│ ║        	 ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.81: 	[1, 2, 3]: [Int, Int?]
//│ ╙──      	           ^^^^^^^^^^^
//│ [Int, (Int)?]
//│ res
//│     = [ 1, 2, 3 ]

[1, 2]: [Int, Int, Int?]
//│ [Int, Int, (Int)?]
//│ res
//│     = [ 1, 2 ]


// * Harder case:
:p
fun foo(xs: [Int] & 'a) = xs : [Int, Int?]
//│ |#fun| |foo|(|xs|#:| |[|Int|]| |&| |'a|)| |#=| |xs| |#:| |[|Int|,| |Int|?|]|
//│ AST: TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(xs: App(Var(&), Tup(_: Bra(rcd = false, Tup(_: Var(Int))), _: Var('a)))), Asc(Var(xs), Tuple(List((None,Field(None,TypeName(Int),false)), (None,Field(None,TypeName(Int),true))))))))
//│ Parsed: fun foo = (xs: &('(' [Int,] ')', 'a,),) => xs : [Int, (Int)?];
//│ fun foo: (xs: [Int]) -> [Int, (Int)?]

fun foo(xs: [Int] & 'a) = [xs : [Int, Int?], xs]
//│ fun foo: forall 'a. (xs: [Int] & 'a) -> [[Int, (Int)?], [Int] & 'a]



// TODO later: update normal form construction

fun foo: [Int] | [Int?]
//│ fun foo: [(Int)?]

fun foo: [Int] & [Int?]
//│ fun foo: [Int]

fun foo: [Int] | [Int, Int?]
//│ fun foo: [Int, (Int)?]

fun foo: [Int] & [Int, Int?]
//│ fun foo: [Int]

fun foo: ([Int] & [Int, Int?]) -> Int
//│ fun foo: ([Int]) -> Int


:e
foo([1, true])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.133: 	foo([1, true])
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `[1, true]` does not match type `[Int]`
//│ ║  l.133: 	foo([1, true])
//│ ║         	     ^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.128: 	fun foo: ([Int] & [Int, Int?]) -> Int
//│ ╙──       	          ^^^^^
//│ Int | error
//│ res
//│     = <no result>
//│       foo is not implemented


fun foo: ([Int] | [Int, Int?]) -> Int
//│ fun foo: ([Int, (Int)?]) -> Int

:e
foo([1, true])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.153: 	foo([1, true])
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `Int`
//│ ║  l.153: 	foo([1, true])
//│ ╙──       	        ^^^^
//│ Int | error
//│ res
//│     = <no result>
//│       foo is not implemented

// check check check
let x = [1, 2, 3]: [Int, Int, Int]
//│ let x: [Int, Int, Int]
//│ x
//│   = [ 1, 2, 3 ]

fun foo0(x: Int?) = if x is undefined then 0 else x + 1
//│ fun foo0: (x: (Int)?) -> Int

fun foo1(x?) = if x is undefined then 0 else x + 1
//│ fun foo1: ((Int | undefined)?) -> Int

:e
fun foo0(x: Int?) = x + 1
//│ fun foo0: (x: (Int)?) -> Int

:e
fun foo1(x?) = x + 1
//│ fun foo1: ((Int)?) -> Int

:e
fun ff(x: Int?) = x + 1
//│ fun ff: (x: (Int)?) -> Int

:e
fun ff(x: Int | undefined) = x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.190: 	fun ff(x: Int | undefined) = x + 1
//│ ║         	                             ^^^^^
//│ ╟── type `undefined` is not an instance of type `Int`
//│ ║  l.190: 	fun ff(x: Int | undefined) = x + 1
//│ ║         	                ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.190: 	fun ff(x: Int | undefined) = x + 1
//│ ╙──       	                             ^
//│ fun ff: (x: Int | undefined) -> (Int | error)
