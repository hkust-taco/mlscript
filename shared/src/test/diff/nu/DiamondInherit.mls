:NewDefs




trait Foo[A] { fun foo: A }
//│ trait Foo[A] {
//│   fun foo: A
//│ }

module Bar extends Foo[int | bool], Foo[int | string] {
  fun foo = 123
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.12: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `bool | int`
//│ ║  l.12: 	  fun foo = 123
//│ ║        	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `bool | int`
//│ ║  l.12: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.11: 	module Bar extends Foo[int | bool], Foo[int | string] {
//│ ║        	                       ^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.6: 	trait Foo[A] { fun foo: A }
//│ ╙──     	                   ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.12: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.12: 	  fun foo = 123
//│ ║        	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `int | string`
//│ ║  l.12: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.11: 	module Bar extends Foo[int | bool], Foo[int | string] {
//│ ║        	                                        ^^^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.6: 	trait Foo[A] { fun foo: A }
//│ ╙──     	                   ^^^^^^
//│ module Bar extends Foo {
//│   fun foo: 123
//│ }

Bar.foo
//│ 123
//│ res
//│     = 123

Bar : Foo['X]
//│ Foo['X]
//│   where
//│     'X := int | string
//│ res
//│     = Bar { class: [class Bar extends Object] }

(Bar : Foo['X]).foo
//│ int | string
//│ res
//│     = 123


trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ trait Foo[A] {
//│   fun bar: A -> A
//│   fun foo: A
//│ }

module Bar extends Foo[int | bool], Foo[int | string] {
  fun foo = 123
  fun bar = id
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.73: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `bool | int`
//│ ║  l.73: 	  fun foo = 123
//│ ║        	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `bool | int`
//│ ║  l.73: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.72: 	module Bar extends Foo[int | bool], Foo[int | string] {
//│ ║        	                       ^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.73: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.73: 	  fun foo = 123
//│ ║        	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `int | string`
//│ ║  l.73: 	  fun foo = 123
//│ ║        	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.72: 	module Bar extends Foo[int | bool], Foo[int | string] {
//│ ║        	                                        ^^^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ module Bar extends Foo {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: 123
//│ }

Bar.bar
//│ forall 'a. 'a -> 'a
//│ res
//│     = [Function: id]

Bar : Foo['X]
//│ Foo['X]
//│   where
//│     'X := int | string
//│ res
//│     = Bar { class: [class Bar extends Object] }


trait T1 extends Foo[int | bool]
//│ trait T1 extends Foo {
//│   fun bar: 'A -> 'A
//│   fun foo: 'A
//│ }
//│ where
//│   'A := bool | int

module Bar extends T1, Foo[int | string] {
  fun foo = 123
  fun bar = id
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.133: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `bool | int`
//│ ║  l.133: 	  fun foo = 123
//│ ║         	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `bool | int`
//│ ║  l.133: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                     ^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.133: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.133: 	  fun foo = 123
//│ ║         	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `int | string`
//│ ║  l.133: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.132: 	module Bar extends T1, Foo[int | string] {
//│ ║         	                           ^^^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ module Bar extends Foo, T1 {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: 123
//│ }

(Bar : Foo['X]).foo
//│ int | string
//│ res
//│     = 123

(Bar : Foo['X]).bar
//│ ('A & (int | string)) -> ('A | int | string)
//│ res
//│     = [Function: id]

(Bar : T1).foo
//│ bool | int
//│ res
//│     = 123

let f = (Bar : T1).bar
f(true)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.187: 	f(true)
//│ ║         	^^^^^^^
//│ ╟── reference of type `True` does not match type `bool | int`
//│ ║  l.187: 	f(true)
//│ ║         	  ^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                     ^^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	          ^
//│ let f: ('A & (bool | int)) -> ('A | bool | int)
//│ bool | error | int
//│ f
//│   = [Function: id]
//│ res
//│     = true

:e
module Bar extends T1, Foo[int | string] {
  fun foo = 123
  fun bar(x) = x + 1
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.209: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `bool | int`
//│ ║  l.209: 	  fun foo = 123
//│ ║         	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `bool | int`
//│ ║  l.209: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                     ^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.209: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.209: 	  fun foo = 123
//│ ║         	            ^^^
//│ ╟── but it flows into definition of method foo with expected type `int | string`
//│ ║  l.209: 	  fun foo = 123
//│ ║         	      ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.208: 	module Bar extends T1, Foo[int | string] {
//│ ║         	                           ^^^^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	                   ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                     ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── type `bool` is not an instance of type `Int`
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                           ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` does not match type `bool | int`
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	               ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.124: 	trait T1 extends Foo[int | bool]
//│ ║         	                     ^^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	          ^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of type `Int`
//│ ║  l.208: 	module Bar extends T1, Foo[int | string] {
//│ ║         	                                 ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	      ^^^^^^^^^^^^^^
//│ ╟── operator application of type `Int` does not match type `int | string`
//│ ║  l.210: 	  fun bar(x) = x + 1
//│ ║         	               ^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.208: 	module Bar extends T1, Foo[int | string] {
//│ ║         	                           ^^^^^^^^^^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.66: 	trait Foo[A] { fun foo: A; fun bar: A -> A }
//│ ╙──      	          ^
//│ module Bar extends Foo, T1 {
//│   fun bar: Int -> Int
//│   fun foo: 123
//│ }


trait Base[A] { fun foo: A; fun bar: A -> A }
trait Derived1[A] extends Base[A]
trait Derived2 extends Base[(int | string, int | string)]
//│ trait Base[A] {
//│   fun bar: A -> A
//│   fun foo: A
//│ }
//│ trait Derived1[A] extends Base {
//│   fun bar: 'A -> 'A
//│   fun foo: 'A
//│ }
//│ trait Derived2 extends Base {
//│   fun bar: 'A0 -> 'A0
//│   fun foo: 'A0
//│ }
//│ where
//│   'A0 := (int | string, int | string,)
//│   'A := A

class Final extends Derived1[(int, int)], Derived2 {
  fun foo = (123, 456)
  fun bar([x, y]) = [error, error]
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` is not an instance of type `int`
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.318: 	class Final extends Derived1[(int, int)], Derived2 {
//│ ╙──       	                              ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `456` is not an instance of type `int`
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.318: 	class Final extends Derived1[(int, int)], Derived2 {
//│ ╙──       	                                   ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.301: 	trait Derived2 extends Base[(int | string, int | string)]
//│ ╙──       	                             ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `456` does not match type `int | string`
//│ ║  l.319: 	  fun foo = (123, 456)
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.301: 	trait Derived2 extends Base[(int | string, int | string)]
//│ ╙──       	                                           ^^^^^^^^^^^^
//│ class Final extends Base, Derived1, Derived2 {
//│   fun bar: (anything, anything,) -> (nothing, nothing,)
//│   fun foo: (123, 456,)
//│ }

:e
class Final extends Derived1[(int, int)], Derived2 {
  fun foo = (123, 456)
  fun bar([x, y]) = [y, x]
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` is not an instance of type `int`
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.364: 	class Final extends Derived1[(int, int)], Derived2 {
//│ ╙──       	                              ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `456` is not an instance of type `int`
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.364: 	class Final extends Derived1[(int, int)], Derived2 {
//│ ╙──       	                                   ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` does not match type `int | string`
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.301: 	trait Derived2 extends Base[(int | string, int | string)]
//│ ╙──       	                             ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	      ^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `456` does not match type `int | string`
//│ ║  l.365: 	  fun foo = (123, 456)
//│ ║         	                  ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.301: 	trait Derived2 extends Base[(int | string, int | string)]
//│ ╙──       	                                           ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.366: 	  fun bar([x, y]) = [y, x]
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.301: 	trait Derived2 extends Base[(int | string, int | string)]
//│ ║         	                                   ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.364: 	class Final extends Derived1[(int, int)], Derived2 {
//│ ║         	                                   ^^^
//│ ╟── from reference:
//│ ║  l.366: 	  fun bar([x, y]) = [y, x]
//│ ╙──       	                        ^
//│ class Final extends Base, Derived1, Derived2 {
//│   fun bar: (int, int,) -> (int | string, int | string,)
//│   fun foo: (123, 456,)
//│ }


