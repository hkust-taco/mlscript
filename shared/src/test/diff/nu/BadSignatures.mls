:NewDefs


:e
trait T {
  fun x : int
  fun x = false
}
//│ ╔══[ERROR] Method implementations in traits are not yet supported
//│ ║  l.7: 	  fun x = false
//│ ╙──     	      ^^^^^^^^^
//│ trait T {
//│   fun x: int
//│ }


class A { fun x = 1 }
//│ class A {
//│   fun x: 1
//│ }

:e
class B() extends A {
  fun x: int
}
//│ ╔══[ERROR] Type mismatch in signature of member `x`:
//│ ║  l.24: 	  fun x: int
//│ ║        	      ^^^^^^
//│ ╟── type `int` does not match type `1`
//│ ║  l.24: 	  fun x: int
//│ ║        	         ^^^
//│ ╟── but it flows into signature of member `x` with expected type `1`
//│ ║  l.24: 	  fun x: int
//│ ║        	      ^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.17: 	class A { fun x = 1 }
//│ ║        	                  ^
//│ ╟── from definition of method x:
//│ ║  l.17: 	class A { fun x = 1 }
//│ ╙──      	              ^^^^^
//│ class B() extends A {
//│   fun x: int
//│ }

B().x
//│ int
//│ res
//│     = 1

(B() : A).x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.50: 	(B() : A).x
//│ ║        	 ^^^
//│ ╟── application of type `B` is not an instance of type `A`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.50: 	(B() : A).x
//│ ╙──      	       ^
//│ 1
//│ res
//│     = 1

class C() extends B { fun x = 0 }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.62: 	class C() extends B { fun x = 0 }
//│ ║        	                          ^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.62: 	class C() extends B { fun x = 0 }
//│ ║        	                              ^
//│ ╟── but it flows into definition of method x with expected type `int`
//│ ║  l.62: 	class C() extends B { fun x = 0 }
//│ ║        	                          ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.24: 	  fun x: int
//│ ║        	         ^^^
//│ ╟── from signature of member `x`:
//│ ║  l.24: 	  fun x: int
//│ ╙──      	      ^^^^^^
//│ class C() extends A, B {
//│   fun x: 0
//│ }

(C() : A).x
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.82: 	(C() : A).x
//│ ║        	 ^^^
//│ ╟── application of type `C` is not an instance of type `A`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.82: 	(C() : A).x
//│ ╙──      	       ^
//│ 1
//│ res
//│     = 0

:e
class B() extends A {
  fun x: int
  fun x = 1
}
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.97: 	  fun x = 1
//│ ║        	      ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.97: 	  fun x = 1
//│ ║        	          ^
//│ ╟── but it flows into definition of method x with expected type `int`
//│ ║  l.97: 	  fun x = 1
//│ ║        	      ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.96: 	  fun x: int
//│ ║        	         ^^^
//│ ╟── from signature of member `x`:
//│ ║  l.96: 	  fun x: int
//│ ╙──      	      ^^^^^^
//│ ╔══[ERROR] Type mismatch in signature of member `x`:
//│ ║  l.96: 	  fun x: int
//│ ║        	      ^^^^^^
//│ ╟── type `int` does not match type `1`
//│ ║  l.96: 	  fun x: int
//│ ║        	         ^^^
//│ ╟── but it flows into signature of member `x` with expected type `1`
//│ ║  l.96: 	  fun x: int
//│ ║        	      ^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.17: 	class A { fun x = 1 }
//│ ║        	                  ^
//│ ╟── from definition of method x:
//│ ║  l.17: 	class A { fun x = 1 }
//│ ╙──      	              ^^^^^
//│ class B() extends A {
//│   fun x: int
//│ }


:e
mixin M { fun x : int }
//│ ╔══[ERROR] Member `x` is declared in parent but not implemented in `M`
//│ ║  l.135: 	mixin M { fun x : int }
//│ ║         	      ^
//│ ╟── Declared here:
//│ ║  l.135: 	mixin M { fun x : int }
//│ ╙──       	              ^^^^^^^
//│ mixin M() {
//│   fun x: int
//│ }

