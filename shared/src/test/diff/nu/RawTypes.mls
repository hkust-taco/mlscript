:NewDefs

// * currently
// Foo => Foo[?] ? is rigid can be uncovered in pattern matching
// * future
// Foo => Foo['a] can place bounds on 'a

class Foo[type A](val a: A)
//│ class Foo[A](a: A)

:e
fun foo(f: Foo): Int = f.a : f.A
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── back into type variable `A`
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                              ^^
//│ ╔══[ERROR] Type error in type ascription
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                       ^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ║        	                              ^^
//│ ╟── into type `Int`
//│ ║  l.12: 	fun foo(f: Foo): Int = f.a : f.A
//│ ╙──      	                 ^^^
//│ fun foo: (f: Foo[anything]) -> Int

// :s
// :ds
fun foo(f: Foo[?]) = f.a
//│ fun foo: (f: Foo[anything]) -> anything

// TODO
fun foo(f: Foo[?]) = f.a : f.A
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.39: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ║        	                     ^^^
//│ ╟── field selection of type `anything` does not match type `nothing`
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.39: 	fun foo(f: Foo[?]) = f.a : f.A
//│ ╙──      	                            ^^
//│ fun foo: (f: Foo[anything]) -> anything

foo(Foo(1))
//│ anything
//│ res
//│     = 1

fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[anything]) -> ??A

fun foo(f: Foo[Int]) = f.a
//│ fun foo: (f: Foo[Int]) -> Int

fun foo(f: Foo[?]) = if f is Foo(a) then a : f.A
//│ fun foo: (f: Foo[anything]) -> ??A

:e
fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╔══[ERROR] Type error in `case` expression
//│ ║  l.64: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                          ^^^^^^^^^^^^^^^^^^
//│ ╟── type variable `A` leaks out of its scope
//│ ║  l.8: 	class Foo[type A](val a: A)
//│ ║       	               ^
//│ ╟── into type `Int | ~??A`
//│ ║  l.64: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ║        	                 ^^^
//│ ╟── Note: constraint arises from type selection:
//│ ║  l.64: 	fun foo(f: Foo): Int = if f is Foo(a) then a : f.A
//│ ╙──      	                                                ^^
//│ fun foo: (f: Foo[anything]) -> (Int | error)

:e
fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.80: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ║        	                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `anything` does not match type `Int | ~??A`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.80: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ║        	                    ^^^
//│ ╟── from type selection:
//│ ║  l.80: 	fun foo(f: Foo[?]): Int = if f is Foo(a) then a : f.A else 0
//│ ║        	                                                   ^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.8: 	class Foo[type A](val a: A)
//│ ╙──     	               ^
//│ fun foo: (f: Foo[anything]) -> Int

fun foo(f: Foo['a]) = f.a : f.A
//│ fun foo: forall 'a. (f: Foo['a]) -> 'a

fun foo(a, f: Foo[a]): Int = f.a : f.A
//│ fun foo: forall 'a. ('a, f: Foo['a]) -> Int
//│   where
//│     'a <: Int

fun bar(f): Int = f.a : f.A
//│ fun bar: forall 'A. {A :> 'A <: Int, a: 'A} -> Int

foo(2, Foo(1))
//│ Int
//│ res
//│     = 1

bar(Foo(1))
//│ Int
//│ res
//│     = 1

class Foo[A](val a: A -> A)
//│ class Foo[A](a: A -> A)

fun foo(f: Foo) = f.a
//│ fun foo: (f: Foo[?]) -> ??A -> ??A0

fun foo(f: Foo) = ()
//│ fun foo: (f: Foo[?]) -> ()

fun foo(f) = f : Foo
//│ fun foo: Foo[?] -> Foo[?]

abstract class Foo[type T]: Bar
class Bar(val b: Int) extends Foo[Int]
//│ abstract class Foo[T]: Bar
//│ class Bar(b: Int) extends Foo

fun foo(x: Foo[?]) = if x is Bar then x.b : x.T
//│ fun foo: (x: Foo[?]) -> Int

foo(Bar(1))
//│ Int
//│ res
//│     = 1

fun foo(x: Foo['a]) = if x is Bar then x.b : x.T
//│ fun foo: forall 'a. (x: Foo['a]) -> (Int & 'a)
