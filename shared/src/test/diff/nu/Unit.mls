:NewDefs


()
//│ []
//│ res
//│     = []

fun x: ()
fun x = ()
//│ fun x: []
//│ fun x: []

x
//│ []
//│ res
//│     = []


// :e // TODO – currently we treat () as an empty array; should in fact be JS's `undefined`
x : Array['a]
//│ Array[nothing]
//│ res
//│     = []

// TODO
x : undefined
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.27: 	x : undefined
//│ ║        	^
//│ ╟── type `[]` does not match type `undefined`
//│ ║  l.9: 	fun x: ()
//│ ║       	       ^^
//│ ╟── but it flows into reference with expected type `undefined`
//│ ║  l.27: 	x : undefined
//│ ║        	^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.27: 	x : undefined
//│ ╙──      	    ^^^^^^^^^
//│ undefined
//│ res
//│     = []

// TODO
fun x: ()
fun x = undefined
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.46: 	fun x = undefined
//│ ║        	    ^^^^^^^^^^^^^
//│ ╟── undefined literal of type `undefined` is not a 0-element tuple
//│ ║  l.46: 	fun x = undefined
//│ ║        	        ^^^^^^^^^
//│ ╟── but it flows into definition of method x with expected type `[]`
//│ ║  l.46: 	fun x = undefined
//│ ║        	    ^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.45: 	fun x: ()
//│ ╙──      	       ^^
//│ fun x: undefined
//│ fun x: []


:e
fun x: ()
fun x = 1
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.65: 	fun x = 1
//│ ║        	    ^^^^^
//│ ╟── integer literal of type `1` is not a 0-element tuple
//│ ║  l.65: 	fun x = 1
//│ ║        	        ^
//│ ╟── but it flows into definition of method x with expected type `[]`
//│ ║  l.65: 	fun x = 1
//│ ║        	    ^^^^^
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.64: 	fun x: ()
//│ ╙──      	       ^^
//│ fun x: 1
//│ fun x: []


