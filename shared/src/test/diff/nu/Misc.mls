:NewDefs


1
//│ 1
//│ res
//│     = 1

2 + 2
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.9: 	2 + 2
//│ ║       	^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.9: 	2 + 2
//│ ╙──     	^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.9: 	2 + 2
//│ ║       	^^^^^
//│ ╟── integer literal of type `2` is not an instance of type `int`
//│ ║  l.9: 	2 + 2
//│ ╙──     	    ^
//│ error | int
//│ res
//│     = 4

let r = { x: 1 }
//│ let r: {x: 1}
//│ r
//│   = { x: 1 }

r.x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	r.x + 1
//│ ║        	^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.26: 	let r = { x: 1 }
//│ ║        	             ^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.31: 	r.x + 1
//│ ╙──      	^^^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.31: 	r.x + 1
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.31: 	r.x + 1
//│ ╙──      	      ^
//│ error | int
//│ res
//│     = 2


x => x + 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.52: 	x => x + 1
//│ ║        	     ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.52: 	x => x + 1
//│ ╙──      	         ^
//│ int -> (error | int)
//│ res
//│     = [Function: res]

{ y } => y
//│ {y: 'a} -> 'a
//│ res
//│     = [Function: res]

fun f({ y }) = y
//│ fun f: forall 'a. {y: 'a} -> 'a

fun f of { y } = y
//│ fun f: forall 'a. {y: 'a} -> 'a

f({y: 1})
//│ 1
//│ res
//│     = 1


let f = (x, y) => x + y
//│ let f: (int, int,) -> int
//│ f
//│   = [Function: f2]

f(1, 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.85: 	f(1, 2)
//│ ║        	^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.85: 	f(1, 2)
//│ ║        	  ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.80: 	let f = (x, y) => x + y
//│ ╙──      	                  ^
//│ error | int
//│ res
//│     = 3

:e
f([1, 2])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.100: 	f([1, 2])
//│ ║         	^^^^^^^^^
//│ ╟── argument of type `((1, 2,),)` does not match type `(?a, ?b,)`
//│ ║  l.100: 	f([1, 2])
//│ ║         	 ^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.80: 	let f = (x, y) => x + y
//│ ╙──      	         ^^^^
//│ error | int
//│ res
//│     = '1,2undefined'



let f = ((x, y)) => x + y
//│ let f: (int, int,) -> int
//│ f
//│   = [Function: f3]

:e
f(1, 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.122: 	f(1, 2)
//│ ║         	^^^^^^^
//│ ╟── argument list of type `(1, 2,)` does not match type `((?a, ?b,),)`
//│ ║  l.122: 	f(1, 2)
//│ ╙──       	 ^^^^^^
//│ error | int
//│ res
//│ Runtime error:
//│   TypeError: number 1 is not iterable (cannot read property Symbol(Symbol.iterator))



f((1, 2))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.136: 	f((1, 2))
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.136: 	f((1, 2))
//│ ║         	   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.116: 	let f = ((x, y)) => x + y
//│ ╙──       	                    ^
//│ error | int
//│ res
//│     = 3

f([1, 2])
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.150: 	f([1, 2])
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.150: 	f([1, 2])
//│ ║         	   ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.116: 	let f = ((x, y)) => x + y
//│ ╙──       	                    ^
//│ error | int
//│ res
//│     = 3

let f = (((x, y))) => x + y
//│ let f: (int, int,) -> int
//│ f
//│   = [Function: f4]

// TODO parse as tuple arg!
let f = [x, y] => x + y
//│ let f: (int, int,) -> int
//│ f
//│   = [Function: f5]

f(1, 2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.175: 	f(1, 2)
//│ ║         	^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.175: 	f(1, 2)
//│ ║         	  ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.170: 	let f = [x, y] => x + y
//│ ╙──       	                  ^
//│ error | int
//│ res
//│     = 3

// TODO...
let f = [[[x, y]]] => x + y
//│ let f: (int, int,) -> int
//│ f
//│   = [Function: f6]


