:NewDefs


class A(val n: Int)
//│ class A(n: Int)

A
//│ (n: Int) -> A
//│ res
//│     = [Function (anonymous)] {
//│         class: [class A],
//│         unapply: [Function: unapply]
//│       }

let a = A(42)
//│ let a: A
//│ a
//│   = A {}

a.n
//│ Int
//│ res
//│     = 42


fun f(x: A) = x.n
//│ fun f: (x: A) -> Int

fun f(x: A) = if x is A then x.n
//│ fun f: (x: A) -> Int

fun f(x: A | 'b) = if x is A then x.n else 0
//│ fun f: (x: Object) -> Int


fun f(x) = x.n
//│ fun f: forall 'n. {n: 'n} -> 'n

f(a)
//│ Int
//│ res
//│     = 42

fun f(x) = if x is A then x.n
//│ fun f: A -> Int

f(a)
//│ Int
//│ res
//│     = 42

fun f(x) = if x is A then x.n else 0
//│ fun f: Object -> Int

f(a)
//│ Int
//│ res
//│     = 42



class C {
  fun id(x) = x
  fun const(x) = id
}
//│ class C {
//│   constructor()
//│   fun const: anything -> (forall 'a. 'a -> 'a)
//│   fun id: forall 'a. 'a -> 'a
//│ }


// TODO
class Base0(val n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.74: 	class Base0(val n) {
//│ ╙──      	                ^
//│ ╔══[ERROR] Indirectly-recursive member should have a type signature
//│ ║  l.78: 	  fun oops = this.my
//│ ╙──      	                 ^^^
//│ class Base0(n: error) {
//│   fun me: Base0 & {n: error}
//│   fun mine: error
//│   fun my: error
//│   fun oops: error
//│ }

// :d
// Base0

let b1 = Base0(42)
//│ let b1: Base0
//│ b1
//│    = Base0 {}

let n1 = b1.n
//│ let n1: error
//│ n1
//│    = 42

// TODO
n1 + 1
//│ Int
//│ res
//│     = 43


let b2 = Base0("hi")
let n2 = b2.n
//│ let b2: Base0
//│ let n2: error
//│ b2
//│    = Base0 {}
//│ n2
//│    = 'hi'



class Base1(val base: Int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1(base: Int) {
//│   fun foo: Int -> Int
//│   fun getBase1: Int
//│   fun getBase2: Int
//│ }

class Base1(val base: Int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1(base: Int) {
//│   fun foo: Int -> Int
//│   fun getBase1: Int
//│   fun me: Base1 & {base: Int}
//│ }

Base1
//│ (base: Int) -> Base1
//│ res
//│     = [Function (anonymous)] {
//│         class: [class Base1],
//│         unapply: [Function: unapply]
//│       }

let b = Base1(1)
//│ let b: Base1
//│ b
//│   = Base1 {}

b.base
//│ Int
//│ res
//│     = 1

b.getBase1
//│ Int
//│ res
//│     = 1

// :d
b.me
//│ Base1 & {base: Int}
//│ res
//│     = Base1 {}

:e
b.getBaseTypo
//│ ╔══[ERROR] Type `Base1` does not contain member `getBaseTypo`
//│ ║  l.176: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ error
//│ res
//│     = undefined


b : Base1
//│ Base1
//│ res
//│     = Base1 {}


class Rec(val n: Int) {
  fun go = Rec(n + 1)
}
//│ class Rec(n: Int) {
//│   fun go: Rec
//│ }

let r = Rec(0)
r.n
//│ let r: Rec
//│ Int
//│ r
//│   = Rec {}
//│ res
//│     = 0

:d
r.go.n
//│ 0. Typing TypingUnit(List(Sel(Sel(Var(r),Var(go)),Var(n))))
//│ | Typing unit statements
//│ | | 0. Typing term Sel(Sel(Var(r),Var(go)),Var(n))
//│ | | | 0. Typing term Sel(Var(r),Var(go))
//│ | | | | 0. Typing term Var(r)
//│ | | | | 0. : α179
//│ | | | | CONSTRAIN α179 <! {go: go184}
//│ | | | |   where 
//│ 		α179 :> Rec <: {n: n181} & r180
//│ 		r180 :> Rec
//│ 		n181 :> Int
//│ | | | | 0. C α179 <! {go: go184}    (0)
//│ | | | | | 0. C α179 <! {go: go184}    (0)
//│ | | | | | | NEW α179 UB (0)
//│ | | | | | | 0. C Rec <! {go: go184}    (2)
//│ | | | | | | | 0. C Rec <! {go: go184}    (2)
//│ | | | | | | | | 0. ARGH  DNF(0, #Rec<Object>{})  <!  DNF(0, {go: go184})
//│ | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | Consider #Rec<Object>{} <: DNF(0, {go: go184})
//│ | | | | | | | | | Possible: List({go: go184})
//│ | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List({go: go184})  %  ⊥
//│ | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  {go:go184}
//│ | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  |{go:go184}
//│ | | | | | | | | | | | | Looking up field go in Some(Rec) & TreeSet() & {...}
//│ | | | | | | | | | | | | | Lookup Rec.go : Some(‹∀ 1. α176''›) where 
//│ 		α176'' :> Rec <: go177''
//│ 		go177'' :> Rec
//│ | | | | | | | | | | | | | Fresh[0] Rec.go : Some(‹∀ 1. α176''›) where Some(
//│ 		α176'' :> Rec <: go177''
//│ 		go177'' :> Rec)
//│ | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | 0. C ‹∀ 1. α176''› <! go184    (2)
//│ | | | | | | | | | | | | | NEW go184 LB (0)
//│ | | | 0. : go184
//│ | | | CONSTRAIN go184 <! {n: n185}
//│ | | |   where 
//│ 		α176'' :> Rec <: go177''
//│ 		go177'' :> Rec
//│ 		go184 :> ‹∀ 1. α176''›
//│ | | | 0. C go184 <! {n: n185}    (0)
//│ | | | | NEW go184 UB (0)
//│ | | | | 0. C ‹∀ 1. α176''› <! {n: n185}    (2)
//│ | | | | | 0. ARGH  DNF(1, α176'')  <!  DNF(0, {n: n185})
//│ | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | 0. C α176_186 <! {n: n185}    (4)
//│ | | | | | | | NEW α176_186 UB (0)
//│ | | | | | | | 0. C Rec <! {n: n185}    (7)
//│ | | | | | | | | 0. C Rec <! {n: n185}    (7)
//│ | | | | | | | | | 0. ARGH  DNF(0, #Rec<Object>{})  <!  DNF(0, {n: n185})
//│ | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | Consider #Rec<Object>{} <: DNF(0, {n: n185})
//│ | | | | | | | | | | Possible: List({n: n185})
//│ | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List({n: n185})  %  ⊥
//│ | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  {n:n185}
//│ | | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  |{n:n185}
//│ | | | | | | | | | | | | | Looking up field n in Some(Rec) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | Lookup Rec.n : Some(Int) where 
//│ | | | | | | | | | | | | | | Fresh[0] Rec.n : Some(Int) where Some()
//│ | | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | | 0. C Int <! n185    (4)
//│ | | | | | | | | | | | | | | NEW n185 LB (0)
//│ | | 0. : n185
//│ | : Some(n185)
//│ ======== TYPED ========
//│ res: Some(n185) where 
//│ 		n185 :> Int
//│ Int
//│ res
//│     = 1




// TODO treat `a: Int` as a signature
class Annots(base: 0 | 1) {
  a: Int
  fun a = base
}
//│ ╔══[WARNING] Expression in statement position should have type `()`.
//│ ╟── Use a comma expression `... , ()` to explicitly discard non-unit values, making your intent clearer.
//│ ╟── Type mismatch in type ascription:
//│ ║  l.284: 	  a: Int
//│ ║         	  ^
//│ ╟── type `Int` does not match type `()`
//│ ║  l.284: 	  a: Int
//│ ║         	     ^^^
//│ ╟── but it flows into expression in statement position with expected type `()`
//│ ║  l.284: 	  a: Int
//│ ╙──       	  ^
//│ class Annots(base: 0 | 1) {
//│   fun a: 0 | 1
//│ }




