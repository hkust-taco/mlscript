:NewDefs


class A(n: int)
//│ class A(n: int)

A
//│ (n: int,) -> A
//│ res
//│     = [Function (anonymous)] { class: [class A] }

let a = A(42)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	let a = A(42)
//│ ║        	        ^^^^^
//│ ╟── integer literal of type `42` is not an instance of type `int`
//│ ║  l.12: 	let a = A(42)
//│ ║        	          ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.4: 	class A(n: int)
//│ ╙──     	           ^^^
//│ let a: A | error
//│ a
//│   = A {}

a.n
//│ error | int
//│ res
//│     = 42


fun f(x: A) = x.n
//│ fun f: (x: A,) -> int

fun f(x: A) = if x is A then x.n
//│ fun f: (x: A,) -> int

fun f(x: A | 'b) = if x is A then x.n else 0
//│ fun f: (x: #Object,) -> (0 | int)


fun f(x) = x.n
//│ fun f: forall 'n. {n: 'n} -> 'n

f(a)
//│ error | int
//│ res
//│     = 42

fun f(x) = if x is A then x.n
//│ fun f: A -> int

f(a)
//│ int
//│ res
//│     = 42

fun f(x) = if x is A then x.n else 0
//│ fun f: #Object -> (0 | int)

f(a)
//│ 0 | int
//│ res
//│     = 42



class C {
  fun id(x) = x
  fun const(x) = id
}
//│ class C() {
//│   fun const: forall 'a. anything -> 'a -> 'a
//│   fun id: forall 'a. 'a -> 'a
//│ }


// TODO
class Base0(n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.79: 	class Base0(n) {
//│ ╙──      	            ^
//│ ╔══[ERROR] Indirectly-recursive member should have type annotation
//│ ║  l.83: 	  fun oops = this.my
//│ ╙──      	                 ^^^
//│ class Base0(n: error) {
//│   fun me: Base0 & {n: error}
//│   fun mine: error
//│   fun my: error
//│   fun oops: error
//│ }

// :d
// Base0

let b1 = Base0(42)
//│ let b1: Base0
//│ b1
//│    = Base0 {}

let n1 = b1.n
//│ let n1: error
//│ n1
//│    = 42

// TODO
n1 + 1
//│ Int
//│ res
//│     = 43


let b2 = Base0("hi")
let n2 = b2.n
//│ let b2: Base0
//│ let n2: error
//│ b2
//│    = Base0 {}
//│ n2
//│    = 'hi'



class Base1(base: int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.132: 	  fun foo(x) = this.base + x
//│ ║         	               ^^^^^^^^^^^
//│ ╟── field selection of type `int` is not an instance of type `Int`
//│ ║  l.132: 	  fun foo(x) = this.base + x
//│ ╙──       	               ^^^^^^^^^
//│ class Base1(base: int) {
//│   fun foo: Int -> (Int | error)
//│   fun getBase1: int
//│   fun getBase2: int
//│ }

class Base1(base: int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.149: 	  fun foo(x) = base + x
//│ ║         	               ^^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.146: 	class Base1(base: int) {
//│ ║         	                  ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.149: 	  fun foo(x) = base + x
//│ ╙──       	               ^^^^
//│ class Base1(base: int) {
//│   fun foo: Int -> (Int | error)
//│   fun getBase1: int
//│   fun me: Base1 & {base: int}
//│ }

Base1
//│ (base: int,) -> Base1
//│ res
//│     = [Function (anonymous)] { class: [class Base1] }

let b = Base1(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.171: 	let b = Base1(1)
//│ ║         	        ^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.171: 	let b = Base1(1)
//│ ║         	              ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.146: 	class Base1(base: int) {
//│ ╙──       	                  ^^^
//│ let b: Base1 | error
//│ b
//│   = Base1 {}

b.base
//│ error | int
//│ res
//│     = 1

b.getBase1
//│ error | int
//│ res
//│     = 1

// :d
b.me
//│ Base1 & {base: int} | error
//│ res
//│     = Base1 {}

:e
b.getBaseTypo
//│ ╔══[ERROR] Class `Base1` does not contain member `getBaseTypo`
//│ ║  l.202: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ error
//│ res
//│     = undefined


b : Base1
//│ Base1
//│ res
//│     = Base1 {}


class Rec(n: int) {
  fun go = Rec(n + 1)
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.218: 	  fun go = Rec(n + 1)
//│ ║         	               ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.217: 	class Rec(n: int) {
//│ ║         	             ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.218: 	  fun go = Rec(n + 1)
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.218: 	  fun go = Rec(n + 1)
//│ ║         	           ^^^^^^^^^^
//│ ╟── operator application of type `Int` is not an instance of type `int`
//│ ║  l.218: 	  fun go = Rec(n + 1)
//│ ║         	               ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.217: 	class Rec(n: int) {
//│ ╙──       	             ^^^
//│ class Rec(n: int) {
//│   fun go: Rec | error
//│ }

let r = Rec(0)
r.n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.242: 	let r = Rec(0)
//│ ║         	        ^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.242: 	let r = Rec(0)
//│ ║         	            ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.217: 	class Rec(n: int) {
//│ ╙──       	             ^^^
//│ let r: Rec | error
//│ error | int
//│ r
//│   = Rec {}
//│ res
//│     = 0

r.go.n
//│ error | int
//│ res
//│     = 1




// TODO treat `a: int` as a signature
class Annots(base: 0 | 1) {
  a: int
  fun a = base
}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.270: 	  a: int
//│ ║         	  ^
//│ ╟── type `0` is not an instance of type `int`
//│ ║  l.269: 	class Annots(base: 0 | 1) {
//│ ║         	                   ^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.270: 	  a: int
//│ ║         	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.270: 	  a: int
//│ ╙──       	     ^^^
//│ class Annots(base: 0 | 1) {
//│   fun a: 0 | 1
//│ }




