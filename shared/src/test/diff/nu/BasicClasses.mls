:NewDefs


class A(val n: Int)
//│ class A(n: Int)

A
//│ (n: Int) -> A
//│ res
//│     = [Function (anonymous)] {
//│         class: [class A],
//│         unapply: [Function: unapply]
//│       }

let a = A(42)
//│ let a: A
//│ a
//│   = A {}

a.n
//│ Int
//│ res
//│     = 42


fun f(x: A) = x.n
//│ fun f: (x: A) -> Int

fun f(x: A) = if x is A then x.n
//│ fun f: (x: A) -> Int

fun f(x: A | 'b) = if x is A then x.n else 0
//│ fun f: (x: Object) -> Int


fun f(x) = x.n
//│ fun f: forall 'n. {n: 'n} -> 'n

f(a)
//│ Int
//│ res
//│     = 42

fun f(x) = if x is A then x.n
//│ fun f: A -> Int

f(a)
//│ Int
//│ res
//│     = 42

fun f(x) = if x is A then x.n else 0
//│ fun f: Object -> Int

f(a)
//│ Int
//│ res
//│     = 42



class C {
  fun id(x) = x
  fun const(x) = id
}
//│ class C {
//│   constructor()
//│   fun const: anything -> (forall 'a. 'a -> 'a)
//│   fun id: forall 'a. 'a -> 'a
//│ }


// TODO
class Base0(val n) {
  fun me = this
  fun my = this.n
  fun mine = my
  fun oops = this.my
}
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.74: 	class Base0(val n) {
//│ ╙──      	                ^
//│ ╔══[ERROR] Indirectly-recursive member should have a type signature
//│ ║  l.78: 	  fun oops = this.my
//│ ╙──      	                 ^^^
//│ class Base0(n: error) {
//│   fun me: Base0 & {n: error}
//│   fun mine: error
//│   fun my: error
//│   fun oops: error
//│ }

// :d
// Base0

let b1 = Base0(42)
//│ let b1: Base0
//│ b1
//│    = Base0 {}

let n1 = b1.n
//│ let n1: error
//│ n1
//│    = 42

// TODO
n1 + 1
//│ Int
//│ res
//│     = 43


let b2 = Base0("hi")
let n2 = b2.n
//│ let b2: Base0
//│ let n2: error
//│ b2
//│    = Base0 {}
//│ n2
//│    = 'hi'



class Base1(val base: Int) {
  fun getBase1 = base
  fun getBase2 = this.base
  fun foo(x) = this.base + x
}
//│ class Base1(base: Int) {
//│   fun foo: Int -> Int
//│   fun getBase1: Int
//│   fun getBase2: Int
//│ }

class Base1(val base: Int) {
  fun getBase1 = base
  fun me = this
  fun foo(x) = base + x
}
//│ class Base1(base: Int) {
//│   fun foo: Int -> Int
//│   fun getBase1: Int
//│   fun me: Base1 & {base: Int}
//│ }

Base1
//│ (base: Int) -> Base1
//│ res
//│     = [Function (anonymous)] {
//│         class: [class Base1],
//│         unapply: [Function: unapply]
//│       }

let b = Base1(1)
//│ let b: Base1
//│ b
//│   = Base1 {}

b.base
//│ Int
//│ res
//│     = 1

b.getBase1
//│ Int
//│ res
//│     = 1

// :d
b.me
//│ Base1 & {base: Int}
//│ res
//│     = Base1 {}

:e
b.getBaseTypo
//│ ╔══[ERROR] Type `Base1` does not contain member `getBaseTypo`
//│ ║  l.176: 	b.getBaseTypo
//│ ╙──       	 ^^^^^^^^^^^^
//│ error
//│ res
//│     = undefined


b : Base1
//│ Base1
//│ res
//│     = Base1 {}


class Rec(val n: Int) {
  fun go = Rec(n + 1)
}
//│ class Rec(n: Int) {
//│   fun go: Rec
//│ }

let r = Rec(0)
r.n
//│ let r: Rec
//│ Int
//│ r
//│   = Rec {}
//│ res
//│     = 0

:d
r.go.n
//│ 0. Typing TypingUnit(List(Sel(Sel(Var(r),Var(go)),Var(n))))
//│ | Typing unit statements
//│ | | 0. Typing term ((r).go).n
//│ | | | 0. Typing term (r).go
//│ | | | | 0. Typing term r
//│ | | | | 0. : α183
//│ | | | | CONSTRAIN α183 <! {go: go188}
//│ | | | |   where 
//│ 		α183 :> Rec <: {n: n185} & r184
//│ 		r184 :> Rec
//│ 		n185 :> Int
//│ | | | | 0. C α183 <! {go: go188}    (0)
//│ | | | | | 0. C α183 <! {go: go188}    (0)
//│ | | | | | | NEW α183 UB (0)
//│ | | | | | | 0. C Rec <! {go: go188}    (2)
//│ | | | | | | | 0. C Rec <! {go: go188}    (2)
//│ | | | | | | | | 0. ARGH  DNF(0, #Rec<Object>{})  <!  DNF(0, {go: go188})
//│ | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | Consider #Rec<Object>{} <: DNF(0, {go: go188})
//│ | | | | | | | | | Possible: List({go: go188})
//│ | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List({go: go188})  %  ⊥
//│ | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  {go:go188}
//│ | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  |{go:go188}
//│ | | | | | | | | | | | | Looking up field go in Some(Rec) & TreeSet() & {...}
//│ | | | | | | | | | | | | | Lookup Rec.go : Some(‹∀ 1. α180''›) where 
//│ 		α180'' :> Rec <: go181''
//│ 		go181'' :> Rec
//│ | | | | | | | | | | | | | Fresh[0] Rec.go : Some(‹∀ 1. α180''›) where Some(
//│ 		α180'' :> Rec <: go181''
//│ 		go181'' :> Rec)
//│ | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | 0. C ‹∀ 1. α180''› <! go188    (2)
//│ | | | | | | | | | | | | | NEW go188 LB (0)
//│ | | | 0. : go188
//│ | | | CONSTRAIN go188 <! {n: n189}
//│ | | |   where 
//│ 		α180'' :> Rec <: go181''
//│ 		go181'' :> Rec
//│ 		go188 :> ‹∀ 1. α180''›
//│ | | | 0. C go188 <! {n: n189}    (0)
//│ | | | | NEW go188 UB (0)
//│ | | | | 0. C ‹∀ 1. α180''› <! {n: n189}    (2)
//│ | | | | | 0. ARGH  DNF(1, α180'')  <!  DNF(0, {n: n189})
//│ | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | 0. C α180_190 <! {n: n189}    (4)
//│ | | | | | | | NEW α180_190 UB (0)
//│ | | | | | | | 0. C Rec <! {n: n189}    (7)
//│ | | | | | | | | 0. C Rec <! {n: n189}    (7)
//│ | | | | | | | | | 0. ARGH  DNF(0, #Rec<Object>{})  <!  DNF(0, {n: n189})
//│ | | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | | Consider #Rec<Object>{} <: DNF(0, {n: n189})
//│ | | | | | | | | | | Possible: List({n: n189})
//│ | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List({n: n189})  %  ⊥
//│ | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  {n:n189}
//│ | | | | | | | | | | | | 0. A  #Rec<Object>{}  %  List()  <!  List()  %  |{n:n189}
//│ | | | | | | | | | | | | | Looking up field n in Some(Rec) & TreeSet() & {...}
//│ | | | | | | | | | | | | | | Lookup Rec.n : Some(Int) where 
//│ | | | | | | | | | | | | | | Fresh[0] Rec.n : Some(Int) where Some()
//│ | | | | | | | | | | | | | |   & None  (from refinement)
//│ | | | | | | | | | | | | | 0. C Int <! n189    (4)
//│ | | | | | | | | | | | | | | NEW n189 LB (0)
//│ | | 0. : n189
//│ | : Some(n189)
//│ ======== TYPED ========
//│ res: Some(n189) where 
//│ 		n189 :> Int
//│ Int
//│ res
//│     = 1




// TODO treat `a: Int` as a signature
class Annots(base: 0 | 1) {
  a: Int
  fun a = base
}
//│ ╔══[WARNING] Expression in statement position should have type `()`.
//│ ╟── Use a comma expression `... , ()` to explicitly discard non-unit values, making your intent clearer.
//│ ╟── Type mismatch in type ascription:
//│ ║  l.284: 	  a: Int
//│ ║         	  ^
//│ ╟── type `Int` does not match type `()`
//│ ║  l.284: 	  a: Int
//│ ║         	     ^^^
//│ ╟── but it flows into expression in statement position with expected type `()`
//│ ║  l.284: 	  a: Int
//│ ╙──       	  ^
//│ class Annots(base: 0 | 1) {
//│   fun a: 0 | 1
//│ }




