:NewDefs


class C1(x: Int)
//│ class C1(x: Int)

:e
class C2(x: Int) extends C1(y) {
  val y = x
}
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.8: 	class C2(x: Int) extends C1(y) {
//│ ╙──     	                            ^
//│ class C2(x: Int) extends C1 {
//│   val y: Int
//│ }
//│ Code generation encountered an error:
//│   unresolved symbol y

:e
abstract class C2 extends C1(y) {
  val y: Int
}
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.21: 	abstract class C2 extends C1(y) {
//│ ╙──      	                             ^
//│ abstract class C2 extends C1 {
//│   val y: Int
//│ }
//│ Code generation encountered an error:
//│   unresolved symbol y

:e
abstract class C2 extends C1(this.y) {
  val y: Int
}
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.34: 	abstract class C2 extends C1(this.y) {
//│ ╙──      	                             ^^^^
//│ abstract class C2 extends C1 {
//│   val y: Int
//│ }


class C1(x: C1)
//│ class C1(x: C1)

:e
class C2 extends C1(this)
//│ ╔══[ERROR] identifier not found: this
//│ ║  l.49: 	class C2 extends C1(this)
//│ ╙──      	                    ^^^^
//│ class C2 extends C1 {
//│   constructor()
//│ }


class Foo { virtual fun x: Int = 1 }
//│ class Foo {
//│   constructor()
//│   fun x: Int
//│ }

:e
class Bar extends Foo { fun x = false }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.65: 	class Bar extends Foo { fun x = false }
//│ ║        	                            ^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `Int`
//│ ║  l.65: 	class Bar extends Foo { fun x = false }
//│ ║        	                                ^^^^^
//│ ╟── but it flows into definition of method x with expected type `Int`
//│ ║  l.65: 	class Bar extends Foo { fun x = false }
//│ ║        	                            ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ║        	                           ^^^
//│ ╟── from definition of method x:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ╙──      	                        ^^^^^^^^^^
//│ class Bar extends Foo {
//│   constructor()
//│   fun x: false
//│ }

:e
class Bar extends Foo {
  fun x: Bool
  fun x = false
}
//│ ╔══[ERROR] Type mismatch in signature of member `x`:
//│ ║  l.88: 	  fun x: Bool
//│ ║        	      ^^^^^^^
<<<<<<< HEAD
//│ ╟── type `Bool` is not an instance of type `Int`
//│ ║  l.94: 	  fun x: Bool
//│ ║        	         ^^^^
//│ ╟── but it flows into signature of member `x` with expected type `Int`
//│ ║  l.94: 	  fun x: Bool
//│ ║        	      ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.64: 	class Foo { virtual fun x: Int = 1 }
//│ ║        	                           ^^^
//│ ╟── from definition of method x:
//│ ║  l.64: 	class Foo { virtual fun x: Int = 1 }
//│ ╙──      	                        ^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in signature of member `x`:
//│ ║  l.94: 	  fun x: Bool
//│ ║        	      ^^^^^^^
//│ ╟── type `Bool` is not an instance of type `Int`
//│ ║  l.94: 	  fun x: Bool
||||||| b14bd8d83
//│ ╟── type `Bool` is not an instance of `Int`
//│ ║  l.94: 	  fun x: Bool
=======
//│ ╟── type `Bool` is not an instance of `Int`
//│ ║  l.88: 	  fun x: Bool
>>>>>>> new-definition-typing
//│ ║        	         ^^^^
//│ ╟── but it flows into signature of member `x` with expected type `Int`
//│ ║  l.88: 	  fun x: Bool
//│ ║        	      ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ║        	                           ^^^
//│ ╟── from definition of method x:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ╙──      	                        ^^^^^^^^^^
//│ class Bar extends Foo {
//│   constructor()
//│   fun x: Bool
//│ }

mixin M { fun x = false }
//│ mixin M() {
//│   fun x: false
//│ }

:e
class Bar extends Foo, M
//│ ╔══[ERROR] Type mismatch in definition of method x:
<<<<<<< HEAD
//│ ║  l.132: 	mixin M { fun x = false }
||||||| b14bd8d83
//│ ║  l.117: 	mixin M { fun x = false }
=======
//│ ║  l.111: 	mixin M { fun x = false }
>>>>>>> new-definition-typing
//│ ║         	              ^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `Int`
<<<<<<< HEAD
//│ ║  l.132: 	mixin M { fun x = false }
||||||| b14bd8d83
//│ ║  l.117: 	mixin M { fun x = false }
=======
//│ ║  l.111: 	mixin M { fun x = false }
>>>>>>> new-definition-typing
//│ ║         	                  ^^^^^
//│ ╟── but it flows into definition of method x with expected type `Int`
<<<<<<< HEAD
//│ ║  l.132: 	mixin M { fun x = false }
||||||| b14bd8d83
//│ ║  l.117: 	mixin M { fun x = false }
=======
//│ ║  l.111: 	mixin M { fun x = false }
>>>>>>> new-definition-typing
//│ ║         	              ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ║        	                           ^^^
//│ ╟── from definition of method x:
//│ ║  l.58: 	class Foo { virtual fun x: Int = 1 }
//│ ╙──      	                        ^^^^^^^^^^
//│ class Bar extends Foo {
//│   constructor()
//│   fun x: false
//│ }



class A { class X { fun f = 1 } }
trait B { class X { fun g = 1 } }
//│ class A {
//│   constructor()
//│   class X {
//│     constructor()
//│     fun f: 1
//│   }
//│ }
//│ trait B {
//│   class X {
//│     constructor()
//│     fun g: 1
//│   }
//│ }

:e
class C extends A, B
//│ ╔══[ERROR] Class member `X` cannot override class member of the same name declared in parent
<<<<<<< HEAD
//│ ║  l.178: 	class C extends A, B
||||||| b14bd8d83
//│ ║  l.163: 	class C extends A, B
=======
//│ ║  l.157: 	class C extends A, B
>>>>>>> new-definition-typing
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── Originally declared here:
<<<<<<< HEAD
//│ ║  l.162: 	trait B { class X { fun g = 1 } }
||||||| b14bd8d83
//│ ║  l.147: 	trait B { class X { fun g = 1 } }
=======
//│ ║  l.141: 	trait B { class X { fun g = 1 } }
>>>>>>> new-definition-typing
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Intersection of class member and class members currently unsupported
<<<<<<< HEAD
//│ ║  l.178: 	class C extends A, B
||||||| b14bd8d83
//│ ║  l.163: 	class C extends A, B
=======
//│ ║  l.157: 	class C extends A, B
>>>>>>> new-definition-typing
//│ ║         	^^^^^^^^^^^^^^^^^^^^
//│ ╟── The class member is defined here:
<<<<<<< HEAD
//│ ║  l.161: 	class A { class X { fun f = 1 } }
||||||| b14bd8d83
//│ ║  l.146: 	class A { class X { fun f = 1 } }
=======
//│ ║  l.140: 	class A { class X { fun f = 1 } }
>>>>>>> new-definition-typing
//│ ║         	          ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── The class member is defined here:
<<<<<<< HEAD
//│ ║  l.162: 	trait B { class X { fun g = 1 } }
||||||| b14bd8d83
//│ ║  l.147: 	trait B { class X { fun g = 1 } }
=======
//│ ║  l.141: 	trait B { class X { fun g = 1 } }
>>>>>>> new-definition-typing
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^
//│ class C extends A, B {
//│   constructor()
//│   class X {
//│     constructor()
//│     fun f: 1
//│   }
//│ }

:e
class C extends A {
  class X { fun g = 1 }
}
//│ ╔══[ERROR] Class member `X` cannot override class member of the same name declared in parent
<<<<<<< HEAD
//│ ║  l.203: 	class C extends A {
||||||| b14bd8d83
//│ ║  l.188: 	class C extends A {
=======
//│ ║  l.182: 	class C extends A {
>>>>>>> new-definition-typing
//│ ║         	^^^^^^^^^^^^^^^^^^^
<<<<<<< HEAD
//│ ║  l.204: 	  class X { fun g = 1 }
||||||| b14bd8d83
//│ ║  l.189: 	  class X { fun g = 1 }
=======
//│ ║  l.183: 	  class X { fun g = 1 }
>>>>>>> new-definition-typing
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^
<<<<<<< HEAD
//│ ║  l.205: 	}
||||||| b14bd8d83
//│ ║  l.190: 	}
=======
//│ ║  l.184: 	}
>>>>>>> new-definition-typing
//│ ║         	^
//│ ╟── Originally declared here:
<<<<<<< HEAD
//│ ║  l.161: 	class A { class X { fun f = 1 } }
||||||| b14bd8d83
//│ ║  l.146: 	class A { class X { fun f = 1 } }
=======
//│ ║  l.140: 	class A { class X { fun f = 1 } }
>>>>>>> new-definition-typing
//│ ╙──       	          ^^^^^^^^^^^^^^^^^^^^^
//│ class C extends A {
//│   constructor()
//│   class X {
//│     constructor()
//│     fun g: 1
//│   }
//│ }



:e
class Foo2 extends Foo2
//│ ╔══[ERROR] Unhandled cyclic definition
<<<<<<< HEAD
//│ ║  l.227: 	class Foo2 extends Foo2
||||||| b14bd8d83
//│ ║  l.212: 	class Foo2 extends Foo2
=======
//│ ║  l.206: 	class Foo2 extends Foo2
>>>>>>> new-definition-typing
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^
//│ class Foo2 extends Foo2 {
//│   constructor()
//│ }
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded



