:NewDefs


let x: Eql[int]
//│ let x: Eql[int]
//│ x
//│   = <missing implementation>

x === 1
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.9: 	x === 1
//│ ║       	^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.9: 	x === 1
//│ ║       	      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.4: 	let x: Eql[int]
//│ ╙──     	           ^^^
//│ Bool | error
//│ res
//│     = <no result>
//│       x is not implemented

:e
1 === x
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.25: 	1 === x
//│ ║        	^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ║  l.25: 	1 === x
//│ ╙──      	^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.25: 	1 === x
//│ ║        	^^^^^^^
//│ ╟── type `#Eql & {Eql#A :> int}` is not an instance of type `number`
//│ ║  l.4: 	let x: Eql[int]
//│ ║       	       ^^^^^^^^
//│ ╟── but it flows into reference with expected type `number`
//│ ║  l.25: 	1 === x
//│ ╙──      	      ^
//│ Bool | error
//│ res
//│     = <no result>
//│       x is not implemented

:e
x === x
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.47: 	x === x
//│ ║        	^^^^^^^
//│ ╟── type `#Eql & {Eql#A :> int}` is not an instance of type `int`
//│ ║  l.4: 	let x: Eql[int]
//│ ║       	       ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.47: 	x === x
//│ ║        	      ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.4: 	let x: Eql[int]
//│ ╙──     	           ^^^
//│ Bool | error
//│ res
//│     = <no result>
//│       x is not implemented


fun test1(x) =
  x === x
//│ fun test1: forall 'a. (Eql['a] & 'a) -> Bool

fun test2(x, y) =
  x === y
//│ fun test2: forall 'a. (Eql['a], 'a,) -> Bool


1 : Eql['a]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.75: 	1 : Eql['a]
//│ ║        	^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.75: 	1 : Eql['a]
//│ ╙──      	    ^^^^^^^
//│ Eql[number]
//│ res
//│     = 1

1 : Eql[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.87: 	1 : Eql[int]
//│ ║        	^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.87: 	1 : Eql[int]
//│ ╙──      	    ^^^^^^^^
//│ Eql[int]
//│ res
//│     = 1

1 : Eql[1]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.99: 	1 : Eql[1]
//│ ║        	^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.99: 	1 : Eql[1]
//│ ╙──      	    ^^^^^^
//│ Eql[1]
//│ res
//│     = 1

test1(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.111: 	test1(1)
//│ ║         	^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ║  l.111: 	test1(1)
//│ ║         	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.67: 	  x === x
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = true


let n: int = 1
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.126: 	let n: int = 1
//│ ║         	             ^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.126: 	let n: int = 1
//│ ╙──       	       ^^^
//│ let n: int
//│ n
//│   = 1

n : Eql['a]
//│ Eql[number]
//│ res
//│     = 1

test1(n)
//│ Bool
//│ res
//│     = true


let n: number
//│ let n: number
//│ n
//│   = <missing implementation>

test1(n)
//│ Bool
//│ res
//│     = <no result>
//│       n is not implemented

let d = 1/2
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.160: 	let d = 1/2
//│ ║         	        ^^
//│ ╟── integer literal of type `1` is not an instance of type `number`
//│ ║  l.160: 	let d = 1/2
//│ ╙──       	        ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.160: 	let d = 1/2
//│ ║         	        ^^^
//│ ╟── integer literal of type `2` is not an instance of type `number`
//│ ║  l.160: 	let d = 1/2
//│ ╙──       	          ^
//│ let d: error | number
//│ d
//│   = 0.5

test1(d)
//│ Bool
//│ res
//│     = true

test1("hello")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.182: 	test1("hello")
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hello"` is not an instance of type `Eql`
//│ ║  l.182: 	test1("hello")
//│ ║         	      ^^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.67: 	  x === x
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = true


test2(0, 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.197: 	test2(0, 1)
//│ ║         	^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `Eql`
//│ ║  l.197: 	test2(0, 1)
//│ ║         	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

test2(0, d)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.211: 	test2(0, d)
//│ ║         	^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `Eql`
//│ ║  l.211: 	test2(0, d)
//│ ║         	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

x => test2(0, x)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.225: 	x => test2(0, x)
//│ ║         	     ^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `Eql`
//│ ║  l.225: 	x => test2(0, x)
//│ ║         	           ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ number -> (Bool | error)
//│ res
//│     = [Function: res]

x => test2(x, 0)
//│ Eql[0] -> Bool
//│ res
//│     = [Function: res]

x => test2(d, x)
//│ number -> Bool
//│ res
//│     = [Function: res]

x => test2(x, d)
//│ Eql[error | number] -> Bool
//│ res
//│     = [Function: res]


:e
test2(1, "oops")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.256: 	test2(1, "oops")
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ║  l.256: 	test2(1, "oops")
//│ ║         	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

:e
test2("oops", 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.271: 	test2("oops", 1)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"oops"` is not an instance of type `Eql`
//│ ║  l.271: 	test2("oops", 1)
//│ ║         	      ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

:e
test2(1, {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.286: 	test2(1, {})
//│ ║         	^^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `Eql`
//│ ║  l.286: 	test2(1, {})
//│ ║         	      ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

:e
test2({}, 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.301: 	test2({}, 1)
//│ ║         	^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false

:e
test2({}, {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.314: 	test2({}, {})
//│ ║         	^^^^^^^^^^^^^
//│ ╟── record literal of type `anything` is not an instance of type `Eql`
//│ ╟── Note: constraint arises from reference:
//│ ║  l.71: 	  x === y
//│ ╙──      	  ^
//│ Bool | error
//│ res
//│     = false


