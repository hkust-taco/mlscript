:NewDefs


class A
//â”‚ class A {
//â”‚   constructor()
//â”‚ }

class B(m: Int) extends A
//â”‚ class B(m: Int) extends A


class A(n: Int)
//â”‚ class A(n: Int)

class B(m: Int) extends A(m + 1)
//â”‚ class B(m: Int) extends A


class A {
  fun a1: Int
  fun a1 = 1
  fun a2 = 2
}
//â”‚ class A {
//â”‚   constructor()
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

class B extends A
//â”‚ class B extends A {
//â”‚   constructor()
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }


// * Interestingly, we can currently inherit from modules...

module C { fun test = 0 }
//â”‚ module C {
//â”‚   fun test: 0
//â”‚ }

class D() extends C
//â”‚ class D() extends C {
//â”‚   fun test: 0
//â”‚ }

D().test
//â”‚ 0
//â”‚ res
//â”‚     = 0


class E(val m: Int) extends A {
  constructor(a: Int, b: Int) {
    m = a + b
    log of concat("Here's m: ")(toString of m)
  }
}
//â”‚ class E(m: Int) extends A {
//â”‚   constructor(a: Int, b: Int)
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

// * FIXME codegen
E(1).m
//â”‚ Int
//â”‚ res
//â”‚     = NaN
//â”‚ // Output
//â”‚ Here's m: NaN

(new E(1, 2)).m
//â”‚ Int
//â”‚ res
//â”‚     = 3
//â”‚ // Output
//â”‚ Here's m: 3

if new E(1, 2) is E(x) then x
//â”‚ Int
//â”‚ res
//â”‚     = 3
//â”‚ // Output
//â”‚ Here's m: 3

:e
module F extends E
//â”‚ â•”â•â•[ERROR] class E expects 2 parameter(s); got 0
//â”‚ â•‘  l.92: 	module F extends E
//â”‚ â•™â”€â”€      	                 ^
//â”‚ module F extends A, E {
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

:e
module F extends E(123)
//â”‚ â•”â•â•[ERROR] class E expects 2 parameter(s); got 1
//â”‚ â•‘  l.102: 	module F extends E(123)
//â”‚ â•™â”€â”€       	                 ^^^^^
//â”‚ module F extends A, E {
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

module F extends E(123, 456)
//â”‚ module F extends A, E {
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

// * Note: strangely, we see here the ctor output from the previous definitions of the F module ğŸ¤”
F.m
//â”‚ Int
//â”‚ res
//â”‚     = 579
//â”‚ // Output
//â”‚ Here's m: NaN
//â”‚ Here's m: NaN
//â”‚ Here's m: 579


class G(x: Int) extends E(x, x + 1)
//â”‚ class G(x: Int) extends A, E {
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

G(123).m
//â”‚ Int
//â”‚ res
//â”‚     = 247
//â”‚ // Output
//â”‚ Here's m: 247


:e // TODO support
class H extends E {
  constructor(a: Int, b: Int) {
    super(a, b)
  }
}
//â”‚ â•”â•â•[ERROR] class E expects 2 parameter(s); got 0
//â”‚ â•‘  l.143: 	class H extends E {
//â”‚ â•™â”€â”€       	                ^
//â”‚ â•”â•â•[ERROR] Illegal use of `super`
//â”‚ â•‘  l.145: 	    super(a, b)
//â”‚ â•™â”€â”€       	    ^^^^^
//â”‚ â•”â•â•[ERROR] identifier not found: super
//â”‚ â•‘  l.145: 	    super(a, b)
//â”‚ â•™â”€â”€       	    ^^^^^
//â”‚ class H extends A, E {
//â”‚   constructor(a: Int, b: Int)
//â”‚   fun a1: Int
//â”‚   fun a2: 2
//â”‚ }

:re
new H(111, 222)
//â”‚ H
//â”‚ res
//â”‚     Runtime error:
//â”‚       ReferenceError: Super constructor may only be called once
//â”‚ // Output
//â”‚ Here's m: NaN
//â”‚ Here's m: 333


