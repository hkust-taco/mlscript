:NewDefs

fun test(x: 'a) = if x is undefined then 0 else x + 1
//│ fun test: (x: Int | undefined) -> Int

test(x: 0)
//│ Int
//│ res
//│     = 1

:e
test(x: 0, 1)
//│ ╔══[ERROR] Unnamed arguments should appear first when using named arguments
//│ ║  l.12: 	test(x: 0, 1)
//│ ╙──      	    ^^^^^^^^^
//│ error
//│ res
//│     = 1

:e
test(y: 0)
//│ ╔══[ERROR] Argument named x is missing from this function call
//│ ║  l.21: 	test(y: 0)
//│ ╙──      	    ^^^^^^
//│ Int
//│ res
//│ Runtime error:
//│   Error: an error was thrown

fun test(x: 'a, y: 'b) = [x, y]
//│ fun test: forall 'a 'b. (x: 'a, y: 'b) -> ['a, 'b]

:e
test(y: 0)
//│ ╔══[ERROR] Number of arguments dosen't match with the function signature
//│ ║  l.34: 	test(y: 0)
//│ ╙──      	    ^^^^^^
//│ error
//│ res
//│     = [ 0, undefined ]

:e
test(1, x: 0)
//│ ╔══[ERROR] Argument for parameter x is duplicated
//│ ║  l.43: 	test(1, x: 0)
//│ ╙──      	    ^^^^^^^^^
//│ ╔══[ERROR] Argument named y is missing from this function call
//│ ║  l.43: 	test(1, x: 0)
//│ ╙──      	    ^^^^^^^^^
//│ [0, nothing]
//│ res
//│ Runtime error:
//│   Error: an error was thrown

// * Notice no let binding is generated for the first argument
:js
test(0, y: 1)
//│ [0, 1]
//│ // Prelude
//│ class TypingUnit7 {}
//│ const typing_unit7 = new TypingUnit7;
//│ // Query 1
//│ res = test1(0, 1);
//│ // End of generated code
//│ res
//│     = [ 0, 1 ]

id(test)(0, y: 1)
//│ [0, 1]
//│ res
//│     = [ 0, 1 ]

id(if true then test else error)(0, y: 1)
//│ [0, 1]
//│ res
//│     = [ 0, 1 ]

:e
id(if true then test else id)(0, y: 1)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.79: 	id(if true then test else id)(0, y: 1)
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 id(if (true) then test else id,) class mlscript.TyperDatatypes$TypeVariable List() List((‹∀ 0. ((x: 'a48', y: 'b49',) -> ('a48', 'b49',))› | ‹∀ 0. (α6' -> α6')›)) List()
//│ ║  l.79: 	id(if true then test else id)(0, y: 1)
//│ ╙──      	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ res
//│     = [ 0, 1 ]

// * No let binding in that value of argument is a var or literal
:js
let tmp = 2
test(0, y: tmp)
test(0, y: 200)
//│ let tmp: 2
//│ [0, 200]
//│ // Prelude
//│ class TypingUnit11 {}
//│ const typing_unit11 = new TypingUnit11;
//│ // Query 1
//│ globalThis.tmp = 2;
//│ // Query 2
//│ res = test1(0, tmp);
//│ // Query 3
//│ res = test1(0, 200);
//│ // End of generated code
//│ tmp
//│     = 2
//│ res
//│     = [ 0, 2 ]
//│ res
//│     = [ 0, 200 ]


:js
test(0, y: 1 + 2)
//│ [0, Int]
//│ // Prelude
//│ class TypingUnit12 {}
//│ const typing_unit12 = new TypingUnit12;
//│ // Query 1
//│ res = ((y_1) => test1(0, y_1))(1 + 2);
//│ // End of generated code
//│ res
//│     = [ 0, 3 ]



fun fff(x: Int, y: Int, z: Int) = (x - y) * z
//│ fun fff: (x: Int, y: Int, z: Int) -> Int

// * Testing renaming
:e
fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╔══[ERROR] identifier not found: y_1
//│ ║  l.134: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] identifier not found: z_1
//│ ║  l.134: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	                         ^^^
//│ Int
//│ Code generation encountered an error:
//│   unresolved symbol z_1

:js
let y_1 = 2
let z_1 = 3
fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ let y_1: 2
//│ let z_1: 3
//│ Int
//│ // Prelude
//│ class TypingUnit15 {}
//│ const typing_unit15 = new TypingUnit15;
//│ // Query 1
//│ globalThis["y_1"] = 2;
//│ // Query 2
//│ globalThis["z_1"] = 3;
//│ // Query 3
//│ res = ((z_2) => ((x_1) => fff(x_1, 2, z_2))(z_1 - 2))(y_1 + 1);
//│ // End of generated code
//│ y_1
//│     = 2
//│ z_1
//│     = 3
//│ res
//│     = -3


class A() {
  fun ma(x: Int, y: Int) = x - y
  fun mma(x: Int, y: Int) = y - x
} 
//│ class A() {
//│   fun ma: (x: Int, y: Int) -> Int
//│   fun mma: (x: Int, y: Int) -> Int
//│ }

let x = A()
x.ma(y: 2, x: 1)
//│ let x: A
//│ Int
//│ x
//│   = A {}
//│ res
//│     = -1

A().ma(x: 1, y: 2)
//│ Int
//│ res
//│     = -1

id(x).ma(y: 2, x: 1)
//│ Int
//│ res
//│     = -1


fun print(x: Int) = (y: Int, z: Int) => log([x, y, z])
let p = print(0)
//│ fun print: (x: Int) -> (y: Int, z: Int) -> undefined
//│ let p: (y: Int, z: Int) -> undefined
//│ p
//│   = [Function: print]

p(z: 1, y: 2)
//│ undefined
//│ res
//│     = undefined
//│ // Output
//│ [ 0, 2, 1 ]

:e
fun print(x) = (y, z) => log([x, y, z])
let p = print(0)
p(z: 1, y: 2)
//│ ╔══[ERROR] Cannot use named arguments as the function type has untyped arguments
//│ ║  l.216: 	p(z: 1, y: 2)
//│ ╙──       	 ^^^^^^^^^^^^
//│ fun print: anything -> (anything, anything) -> undefined
//│ let p: (anything, anything) -> undefined
//│ error
//│ p
//│   = [Function: print1]
//│ res
//│     = [Function (anonymous)]


class Baz() {
  fun f(x: Int, y: Int) = log([x, y])
}
Baz().f(y: 1, x: 2)
//│ class Baz() {
//│   fun f: (x: Int, y: Int) -> undefined
//│ }
//│ undefined
//│ res
//│     = undefined
//│ // Output
//│ [ 2, 1 ]

let b = Baz()
b.f(y: 1, x: 2)
//│ let b: Baz
//│ undefined
//│ b
//│   = Baz {}
//│ res
//│     = undefined
//│ // Output
//│ [ 2, 1 ]


class A(val x: Int, val y: Int)
//│ class A(x: Int, y: Int)

let z = A(y: 2, x: 1)
z.x
z.y
//│ let z: A
//│ Int
//│ z
//│   = A {}
//│ res
//│     = 1
//│ res
//│     = 2

:e
(f => f(x: a))
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 f class mlscript.TyperDatatypes$ProvType List() List() List()
//│ ║  l.270: 	(f => f(x: a))
//│ ╙──       	      ^
//│ anything -> error
//│ Code generation encountered an error:
//│   unresolved symbol a

:e
(f => f)(error)(x: a)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 '(' (f::4,) => f ')'(error,) class mlscript.TyperDatatypes$TypeVariable List() List() List()
//│ ║  l.279: 	(f => f)(error)(x: a)
//│ ╙──       	^^^^^^^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol a

:e
(f => f)(42)(x: a)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 '(' (f::5,) => f ')'(42,) class mlscript.TyperDatatypes$TypeVariable List() List(#42<Int,Num,Object>) List()
//│ ║  l.288: 	(f => f)(42)(x: a)
//│ ╙──       	^^^^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol a

//FIXME double error
:e
(f => f)(if true then 123 else false)(x: a)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.298: 	(f => f)(if true then 123 else false)(x: a)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 '(' (f::6,) => f ')'(if (true) then 123 else false,) class mlscript.TyperDatatypes$TypeVariable List() List((#123<Int,Num,Object> | #false<Bool,Object>)) List()
//│ ║  l.298: 	(f => f)(if true then 123 else false)(x: a)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol a

(f => f)(if true then (x: Int) => x + 1 else error)(x: 123)
//│ Int
//│ res
//│     = 124

:e
(f => if true then f else id)(if true then (x: Int) => x + 1 else id)(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.315: 	(f => if true then f else id)(if true then (x: Int) => x + 1 else id)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 '(' (f::9,) => if (true) then f else id ')'(if (true) then (x: Int,) => +(x, 1,) else id,) class mlscript.TyperDatatypes$TypeVariable List() List((α234 | ‹∀ 0. (α6' -> α6')›)) List()
//│ ║  l.315: 	(f => if true then f else id)(if true then (x: Int) => x + 1 else id)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ res
//│     = 124

// FIXME
:e
(f => if true then f else id)(if true then (x: Int) => x + 1 else (x: Int) => x + 1)(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.328: 	(f => if true then f else id)(if true then (x: Int) => x + 1 else (x: Int) => x + 1)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 '(' (f::10,) => if (true) then f else id ')'(if (true) then (x: Int,) => +(x, 1,) else (x: Int,) => +(x, 1,),) class mlscript.TyperDatatypes$TypeVariable List() List((α239 | ‹∀ 0. (α6' -> α6')›)) List()
//│ ║  l.328: 	(f => if true then f else id)(if true then (x: Int) => x + 1 else (x: Int) => x + 1)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ res
//│     = 124


fun foo(f: (x: Int) => Int) = f(x: 123)
//│ fun foo: (f: (x: Int) -> Int) -> Int

// upperbound and lowerbound are empty?
:d
fun foo(f: ((x: Int) => Int) & 'a) = [f(x: 123), f]
//│ 0. Typing ‹fun foo = (f: &('(' (x: Int,) => Int ')', 'a,),) => '(' [f(x: 123,), f,] ')'›
//│ | 0. Created lazy type info for fun foo = (f: &('(' (x: Int,) => Int ')', 'a,),) => '(' [f(x: 123,), f,] ')'
//│ | Completing fun foo = (f: &('(' (x: Int,) => Int ')', 'a,),) => '(' [f(x: 123,), f,] ')'
//│ | | Type params 
//│ | | Params 
//│ | | 1. Typing term (f: &('(' (x: Int,) => Int ')', 'a,),) => '(' [f(x: 123,), f,] ')'
//│ | | | 1. Typing pattern [f: &('(' (x: Int,) => Int ')', 'a,),]
//│ | | | | 1. Typing pattern f : (x: Int) -> Int & 'a
//│ | | | | | Typing type Inter(Function(Tuple(List((Some(x),Field(None,TypeName(Int))))),TypeName(Int)),'a)
//│ | | | | | | vars=Map() newDefsInfo=Map()
//│ | | | | | | 1. type Inter(Function(Tuple(List((Some(x),Field(None,TypeName(Int))))),TypeName(Int)),'a)
//│ | | | | | | | 1. type Function(Tuple(List((Some(x),Field(None,TypeName(Int))))),TypeName(Int))
//│ | | | | | | | | 1. type Tuple(List((Some(x),Field(None,TypeName(Int)))))
//│ | | | | | | | | | 1. type TypeName(Int)
//│ | | | | | | | | | => Int
//│ | | | | | | | | => (x: Int,)
//│ | | | | | | | | 1. type TypeName(Int)
//│ | | | | | | | | => Int
//│ | | | | | | | => ((x: Int,) -> Int)
//│ | | | | | | | 1. type 'a
//│ | | | | | | | => 'a248'
//│ | | | | | | => (((x: Int,) -> Int) & 'a248')
//│ | | | | | => (((x: Int,) -> Int) & 'a248') ——— 'a248'
//│ | | | | 1. : (((x: Int,) -> Int) & 'a248')
//│ | | | 1. : (f: (((x: Int,) -> Int) & 'a248'),)
//│ | | | 1. Typing term '(' [f(x: 123,), f,] ')'
//│ | | | | 1. Typing term [f(x: 123,), f,]
//│ | | | | | 1. Typing term f(x: 123,)
//│ | | | | | | 1. Typing term f
//│ | | | | | | 1. : (((x: Int,) -> Int) & 'a248')
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 f class mlscript.TyperDatatypes$TypeVariable List() List() List()
//│ ║  l.345: 	fun foo(f: ((x: Int) => Int) & 'a) = [f(x: 123), f]
//│ ╙──       	                                      ^
//│ | | | | | | Desugared is here => f(123,)
//│ | | | | | | 1. Typing term f(123,)
//│ | | | | | | | 1. Typing term f
//│ | | | | | | | 1. : (((x: Int,) -> Int) & 'a248')
//│ | | | | | | | 1. Typing term 123
//│ | | | | | | | 1. : #123<Int,Num,Object>
//│ | | | | | | | CONSTRAIN (((x: Int,) -> Int) & 'a248') <! (#123<Int,Num,Object> -> α249')
//│ | | | | | | |   where 
//│ | | | | | | | 1. C (((x: Int,) -> Int) & 'a248') <! (#123<Int,Num,Object> -> α249')    (0)
//│ | | | | | | | | 1. ARGH  DNF(1, ((x: #Int<Object,Num>,) -> #Int<Object,Num>){}∧'a248')  <!  DNF(1, (#123<Int,Num,Object> -> α249'){})
//│ | | | | | | | | | DNF DISCHARGE CONSTRAINTS
//│ | | | | | | | | | 1. C 'a248' <! ((#123<Int,Num,Object> -> α249') | ~(((x: #Int<Object,Num>,) -> #Int<Object,Num>)))    (2)
//│ | | | | | | | | | | NEW 'a248' UB (1)
//│ | | | | | | 1. : α249'
//│ | | | | | 1. : α249'
//│ | | | | | 1. Typing term f
//│ | | | | | 1. : (((x: Int,) -> Int) & 'a248')
//│ | | | | 1. : (α249', (((x: Int,) -> Int) & 'a248'),)
//│ | | | 1. : (α249', (((x: Int,) -> Int) & 'a248'),)
//│ | | 1. : ((f: (((x: Int,) -> Int) & 'a248'),) -> (α249', (((x: Int,) -> Int) & 'a248'),))
//│ | | CONSTRAIN ((f: (((x: Int,) -> Int) & 'a248'),) -> (α249', (((x: Int,) -> Int) & 'a248'),)) <! foo250'
//│ | |   where 
//│ 		'a248' <: ((#123<Int,Num,Object> -> α249') | ~(((x: #Int<Object,Num>,) -> #Int<Object,Num>)))
//│ | | 1. C ((f: (((x: Int,) -> Int) & 'a248'),) -> (α249', (((x: Int,) -> Int) & 'a248'),)) <! foo250'    (0)
//│ | | | NEW foo250' LB (1)
//│ | Completed TypedNuFun(0,fun foo = (f: &('(' (x: Int,) => Int ')', 'a,),) => '(' [f(x: 123,), f,] ')',((f: (((x: Int,) -> Int) & 'a248'),) -> (α249', (((x: Int,) -> Int) & 'a248'),))) where 
//│ 		'a248' <: ((#123<Int,Num,Object> -> α249') | ~(((x: #Int<Object,Num>,) -> #Int<Object,Num>)))
//│ | Typing unit statements
//│ | : None
//│ ======== TYPED ========
//│ fun foo: ‹∀ 0. ((f: (((x: Int,) -> Int) & 'a248'),) -> (α249', (((x: Int,) -> Int) & 'a248'),))› where 
//│ |		'a248' <: ((#123<Int,Num,Object> -> α249') | ~(((x: #Int<Object,Num>,) -> #Int<Object,Num>)))
//│ fun foo: forall 'a 'b. (f: (x: Int) -> Int & 123 -> 'b & 'a) -> ['b, (x: Int) -> Int & 'a]

foo((x: Int) => 1)
//│ [1, (x: Int) -> 1]
//│ res
//│     = [ 1, [Function (anonymous)] ]

fun foo(f: ((x: Int) => Int) | 'a) = f(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.418: 	fun foo(f: ((x: Int) => Int) | 'a) = f(x: 123)
//│ ╙──       	                                     ^
//│ fun foo: (f: anything) -> error

// * the result of the if-then-else is a TV with two LBs: the type of x and the function type
fun foo(x) = (if true then (x: Int) => x + 1 else x)(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #3
//│ ║  l.425: 	fun foo(x) = (if true then (x: Int) => x + 1 else x)(x: 123)
//│ ╙──       	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ fun foo: anything -> error

foo((y: Int) => y)
//│ error
//│ res
//│     = 124

fun foo(x) = if true then (x: Int) => x + 1 else x
//│ fun foo: forall 'a. 'a -> ((x: Int) -> Int | 'a)

:e
foo((y: Int) => y)(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 foo((y: Int,) => y,) class mlscript.TyperDatatypes$TypeVariable List() List(‹∀ 1. (((x: Int,) -> α275_285'') | α274_284)›) List()
//│ ║  l.440: 	foo((y: Int) => y)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^
//│ error
//│ res
//│     = 124

:e
foo((x: Int) => x - 1)(x: 123)
//│ ╔══[ERROR] Cannot retrieve any function type for applying named arguments #1 foo((x: Int,) => -(x, 1,),) class mlscript.TyperDatatypes$TypeVariable List() List(‹∀ 1. (((x: Int,) -> α275_290'') | α274_289)›) List()
//│ ║  l.449: 	foo((x: Int) => x - 1)(x: 123)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ res
//│     = 124

fun foo1(x) = [x + 1, x]
//│ fun foo1: forall 'a. (Int & 'a) -> [Int, 'a]

:e
foo1(x: 123)
//│ ╔══[ERROR] Cannot use named arguments as the function type has untyped arguments
//│ ║  l.461: 	foo1(x: 123)
//│ ╙──       	    ^^^^^^^^
//│ error
//│ res
//│     = [ 124, 123 ]

fun foo1(x: Int & 'a) = [x + 1, x]
//│ fun foo1: forall 'a. (x: Int & 'a) -> [Int, Int & 'a]

foo1(x: 123)
//│ [Int, 123]
//│ res
//│     = [ 124, 123 ]
