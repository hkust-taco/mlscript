:NewDefs

fun test(x: 'a) = if x is undefined then 0 else x + 1
//│ fun test: (x: Int | undefined,) -> Int

test(10)
//│ Int
//│ res
//│     = 11

test(x: 0, 1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.11: 	test(x: 0, 1)
//│ ║        	^^^^^^^^^^^^^
//│ ╟── argument list of type `(x: 0, 1,)` does not match type `(x: 'a,)`
//│ ║  l.11: 	test(x: 0, 1)
//│ ║        	    ^^^^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.3: 	fun test(x: 'a) = if x is undefined then 0 else x + 1
//│ ╙──     	        ^^^^^^^
//│ ╔══[ERROR] the unnamed args should appear first when using named args!
//│ ║  l.11: 	test(x: 0, 1)
//│ ╙──      	    ^^^^^^^^^
//│ error
//│ res
//│     = 1

fun test(x: 'a, y: 'b) = [x, y]
//│ fun test: forall 'a 'b. (x: 'a, y: 'b,) -> ('a, 'b,)

test(x: 0, 1)
//│ ╔══[ERROR] the unnamed args should appear first when using named args!
//│ ║  l.31: 	test(x: 0, 1)
//│ ╙──      	    ^^^^^^^^^
//│ error
//│ res
//│     = [ 0, 1 ]

test(1, x: 0)
//│ ╔══[ERROR] Wrong tuple field name: found 'x' instead of 'y'
//│ ║  l.39: 	test(1, x: 0)
//│ ╙──      	    ^^^^^^^^^
//│ ╔══[ERROR] number of parameters dosen't match with the function signature!
//│ ║  l.39: 	test(1, x: 0)
//│ ╙──      	    ^^^^^^^^^
//│ error
//│ res
//│     = [ 1, 0 ]

test(y: 0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.50: 	test(y: 0)
//│ ║        	^^^^^^^^^^
//│ ╟── argument list of type `(y: 0,)` does not match type `(x: 'a, y: 'b,)`
//│ ║  l.50: 	test(y: 0)
//│ ║        	    ^^^^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.28: 	fun test(x: 'a, y: 'b) = [x, y]
//│ ╙──      	        ^^^^^^^^^^^^^^
//│ ╔══[ERROR] number of parameters dosen't match with the function signature!
//│ ║  l.50: 	test(y: 0)
//│ ╙──      	    ^^^^^^
//│ error
//│ res
//│     = [ 0, undefined ]

fun test(x) = x + 1
//│ fun test: Int -> Int

test(y: 0)
//│ ╔══[ERROR] number of parameters dosen't match with the function signature!
//│ ║  l.70: 	test(y: 0)
//│ ╙──      	    ^^^^^^
//│ error
//│ res
//│     = 1

fun fff(x: Int, y: Int, z: Int) = (x - y) * z
//│ fun fff: (x: Int, y: Int, z: Int,) -> Int

fff(1, 2, 3)
//│ Int
//│ res
//│     = -3

// ???? 5 - 4 in debug mode shows some errors, 1 dosen't
:d
fff(1, z: 3, y:2)
//│ 0. Typing TypingUnit(List(fff (1, z: 3, y: 2,)))
//│ | Typing unit statements
//│ | | 0. Typing term fff (1, z: 3, y: 2,)
//│ | | | 0. Typing term fff
//│ | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | 0. Typing term 1
//│ | | | 0. : #1<Int,Num,Object>
//│ | | | 0. Typing term 3
//│ | | | 0. : #3<Int,Num,Object>
//│ | | | 0. Typing term 2
//│ | | | 0. : #2<Int,Num,Object>
//│ | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | a and a_ty => Tup(_: IntLit(1), z: IntLit(3), y: IntLit(2)) (#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,)
//│ | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,) -> α99)
//│ | | |   where 
//│ 		α93' :> Int
//│ | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,) -> α99)    (0)
//│ | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,) -> α99)    (2)
//│ | | | | | 0. C (#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | 0. C ‹∀ 0. α93'› <! α99    (2)
//│ | | | | | | NEW α99 LB (0)
//│ | | | f => fff
//│ | | | args_ty => (#1<Int,Num,Object>, z: #3<Int,Num,Object>, y: #2<Int,Num,Object>,) class mlscript.TyperDatatypes$TupleType
//│ | | | fun_ty => ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› class mlscript.TyperDatatypes$PolymorphicType
//│ | | | argsList => List(x, y, z)
//│ | | | a is => 1, z: 3, y: 2,
//│ | | | final acc => Map(x -> Right(1), z -> Left(z_1), y -> Left(y_1))
//│ | | | Desugared is here => let z_1 = 3 in let y_1 = 2 in fff (1, y_1, z_1,)
//│ | | | 0. Typing term let z_1 = 3 in let y_1 = 2 in fff (1, y_1, z_1,)
//│ | | | | 0. Typing term 3
//│ | | | | 0. : #3<Int,Num,Object>
//│ | | | | 0. Typing term let y_1 = 2 in fff (1, y_1, z_1,)
//│ | | | | | 0. Typing term 2
//│ | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | 0. Typing term fff (1, y_1, z_1,)
//│ | | | | | | 0. Typing term fff
//│ | | | | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | 0. Typing term 1
//│ | | | | | | 0. : #1<Int,Num,Object>
//│ | | | | | | 0. Typing term y_1
//│ | | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | | 0. Typing term z_1
//│ | | | | | | 0. : #3<Int,Num,Object>
//│ | | | | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | a and a_ty => Tup(_: IntLit(1), _: Var(y_1), _: Var(z_1)) (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,)
//│ | | | | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α100)
//│ | | | | | |   where 
//│ 		α93' :> Int
//│ | | | | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α100)    (0)
//│ | | | | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α100)    (2)
//│ | | | | | | | | 0. C (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | | | | 0. C ‹∀ 0. α93'› <! α100    (2)
//│ | | | | | | | | | NEW α100 LB (0)
//│ | | | | | 0. : α100
//│ | | | | 0. : α100
//│ | | | 0. : α100
//│ | | 0. : α100
//│ | : Some(α100)
//│ ======== TYPED ========
//│ res: Some(α100) where 
//│ 		α93' :> Int
//│ 		α100 :> ‹∀ 0. α93'›
//│ Int
//│ res
//│     = -3

:d
fff(y: 2, z: 3, x: 1)
//│ 0. Typing TypingUnit(List(fff (y: 2, z: 3, x: 1,)))
//│ | Typing unit statements
//│ | | 0. Typing term fff (y: 2, z: 3, x: 1,)
//│ | | | 0. Typing term fff
//│ | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | 0. Typing term 2
//│ | | | 0. : #2<Int,Num,Object>
//│ | | | 0. Typing term 3
//│ | | | 0. : #3<Int,Num,Object>
//│ | | | 0. Typing term 1
//│ | | | 0. : #1<Int,Num,Object>
//│ | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | a and a_ty => Tup(y: IntLit(2), z: IntLit(3), x: IntLit(1)) (y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,)
//│ | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,) -> α103)
//│ | | |   where 
//│ 		α93' :> Int
//│ | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,) -> α103)    (0)
//│ | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,) -> α103)    (2)
//│ | | | | | 0. C (y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | 0. C ‹∀ 0. α93'› <! α103    (2)
//│ | | | | | | NEW α103 LB (0)
//│ | | | f => fff
//│ | | | args_ty => (y: #2<Int,Num,Object>, z: #3<Int,Num,Object>, x: #1<Int,Num,Object>,) class mlscript.TyperDatatypes$TupleType
//│ | | | fun_ty => ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› class mlscript.TyperDatatypes$PolymorphicType
//│ | | | argsList => List(x, y, z)
//│ | | | a is => y: 2, z: 3, x: 1,
//│ | | | final acc => Map(y -> Left(y_1), z -> Left(z_1), x -> Left(x_1))
//│ | | | Desugared is here => let y_1 = 2 in let z_1 = 3 in let x_1 = 1 in fff (x_1, y_1, z_1,)
//│ | | | 0. Typing term let y_1 = 2 in let z_1 = 3 in let x_1 = 1 in fff (x_1, y_1, z_1,)
//│ | | | | 0. Typing term 2
//│ | | | | 0. : #2<Int,Num,Object>
//│ | | | | 0. Typing term let z_1 = 3 in let x_1 = 1 in fff (x_1, y_1, z_1,)
//│ | | | | | 0. Typing term 3
//│ | | | | | 0. : #3<Int,Num,Object>
//│ | | | | | 0. Typing term let x_1 = 1 in fff (x_1, y_1, z_1,)
//│ | | | | | | 0. Typing term 1
//│ | | | | | | 0. : #1<Int,Num,Object>
//│ | | | | | | 0. Typing term fff (x_1, y_1, z_1,)
//│ | | | | | | | 0. Typing term fff
//│ | | | | | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | | 0. Typing term x_1
//│ | | | | | | | 0. : #1<Int,Num,Object>
//│ | | | | | | | 0. Typing term y_1
//│ | | | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | | | 0. Typing term z_1
//│ | | | | | | | 0. : #3<Int,Num,Object>
//│ | | | | | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | | a and a_ty => Tup(_: Var(x_1), _: Var(y_1), _: Var(z_1)) (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,)
//│ | | | | | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α104)
//│ | | | | | | |   where 
//│ 		α93' :> Int
//│ | | | | | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α104)    (0)
//│ | | | | | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) -> α104)    (2)
//│ | | | | | | | | | 0. C (#1<Int,Num,Object>, #2<Int,Num,Object>, #3<Int,Num,Object>,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | | | | | 0. C ‹∀ 0. α93'› <! α104    (2)
//│ | | | | | | | | | | NEW α104 LB (0)
//│ | | | | | | 0. : α104
//│ | | | | | 0. : α104
//│ | | | | 0. : α104
//│ | | | 0. : α104
//│ | | 0. : α104
//│ | : Some(α104)
//│ ======== TYPED ========
//│ res: Some(α104) where 
//│ 		α93' :> Int
//│ 		α104 :> ‹∀ 0. α93'›
//│ Int
//│ res
//│     = -3

fff(1, 2, y:2)
//│ ╔══[ERROR] number of parameters dosen't match with the function signature!
//│ ║  l.231: 	fff(1, 2, y:2)
//│ ╙──       	   ^^^^^^^^^^^
//│ error
//│ res
//│     = -2

//testing renaming
fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╔══[ERROR] identifier not found: y_1
//│ ║  l.240: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	             ^^^
//│ ╔══[ERROR] identifier not found: z_1
//│ ║  l.240: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	                         ^^^
//│ ╔══[ERROR] Wrong tuple field name: found 'y' instead of 'x'
//│ ║  l.240: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] number of parameters dosen't match with the function signature!
//│ ║  l.240: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ error
//│ Code generation encountered an error:
//│   unresolved symbol y_1

:d
let y_1 = 2
let z_1 = 3
fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ 0. Typing TypingUnit(List(let y_1 = 2, let z_1 = 3, fff (y: 2, z: + (y_1,) (1,), x: - (z_1,) (2,),)))
//│ | 0. Created lazy type info for let y_1 = 2
//│ | 0. Created lazy type info for let z_1 = 3
//│ | Completing let y_1 = 2
//│ | | UNSTASHING... (out)
//│ | | Type params 
//│ | | UNSTASHING... (out)
//│ | | Params 
//│ | | 0. Typing term 2
//│ | | 0. : #2<Int,Num,Object>
//│ | | CONSTRAIN #2<Int,Num,Object> <! y_1113'
//│ | |   where 
//│ | | 1. C #2<Int,Num,Object> <! y_1113'    (0)
//│ | | | NEW y_1113' LB (0)
//│ | | UNSTASHING... (out)
//│ | Completed TypedNuFun(0,let y_1 = 2,#2<Int,Num,Object>) where 
//│ | Completing let z_1 = 3
//│ | | UNSTASHING... (out)
//│ | | Type params 
//│ | | UNSTASHING... (out)
//│ | | Params 
//│ | | 0. Typing term 3
//│ | | 0. : #3<Int,Num,Object>
//│ | | CONSTRAIN #3<Int,Num,Object> <! z_1114'
//│ | |   where 
//│ | | 1. C #3<Int,Num,Object> <! z_1114'    (0)
//│ | | | NEW z_1114' LB (0)
//│ | | UNSTASHING... (out)
//│ | Completed TypedNuFun(0,let z_1 = 3,#3<Int,Num,Object>) where 
//│ | Typing unit statements
//│ | | 0. Typing term fff (y: 2, z: + (y_1,) (1,), x: - (z_1,) (2,),)
//│ | | | 0. Typing term fff
//│ | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | 0. Typing term 2
//│ | | | 0. : #2<Int,Num,Object>
//│ | | | 0. Typing term + (y_1,) (1,)
//│ | | | | 0. Typing term + (y_1,)
//│ | | | | | 0. Typing term +
//│ | | | | | 0. : (Int -> (Int -> Int))
//│ | | | | | 0. Typing term y_1
//│ | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | f and f_ty => Var(+) (Int -> (Int -> Int))
//│ | | | | | a and a_ty => Tup(_: Var(y_1)) (#2<Int,Num,Object>,)
//│ | | | | | CONSTRAIN (Int -> (Int -> Int)) <! (#2<Int,Num,Object> -> α115)
//│ | | | | |   where 
//│ | | | | | 0. C (Int -> (Int -> Int)) <! (#2<Int,Num,Object> -> α115)    (0)
//│ | | | | | | 0. C (#2<Int,Num,Object>,) <! (Int,)    (1)
//│ | | | | | | 0. C (Int -> Int) <! α115    (1)
//│ | | | | | | | NEW α115 LB (0)
//│ | | | | 0. : α115
//│ | | | | 0. Typing term 1
//│ | | | | 0. : #1<Int,Num,Object>
//│ | | | | f and f_ty => App(Var(+), Tup(_: Var(y_1))) α115
//│ | | | | a and a_ty => Tup(_: IntLit(1)) (#1<Int,Num,Object>,)
//│ | | | | CONSTRAIN α115 <! (#1<Int,Num,Object> -> α116)
//│ | | | |   where 
//│ 		α115 :> (Int -> Int)
//│ | | | | 0. C α115 <! (#1<Int,Num,Object> -> α116)    (0)
//│ | | | | | NEW α115 UB (0)
//│ | | | | | 0. C (Int -> Int) <! (#1<Int,Num,Object> -> α116)    (2)
//│ | | | | | | 0. C (#1<Int,Num,Object>,) <! (Int,)    (2)
//│ | | | | | | 0. C Int <! α116    (2)
//│ | | | | | | | NEW α116 LB (0)
//│ | | | 0. : α116
//│ | | | 0. Typing term - (z_1,) (2,)
//│ | | | | 0. Typing term - (z_1,)
//│ | | | | | 0. Typing term -
//│ | | | | | 0. : (Int -> (Int -> Int))
//│ | | | | | 0. Typing term z_1
//│ | | | | | 0. : #3<Int,Num,Object>
//│ | | | | | f and f_ty => Var(-) (Int -> (Int -> Int))
//│ | | | | | a and a_ty => Tup(_: Var(z_1)) (#3<Int,Num,Object>,)
//│ | | | | | CONSTRAIN (Int -> (Int -> Int)) <! (#3<Int,Num,Object> -> α117)
//│ | | | | |   where 
//│ | | | | | 0. C (Int -> (Int -> Int)) <! (#3<Int,Num,Object> -> α117)    (0)
//│ | | | | | | 0. C (#3<Int,Num,Object>,) <! (Int,)    (1)
//│ | | | | | | 0. C (Int -> Int) <! α117    (1)
//│ | | | | | | | NEW α117 LB (0)
//│ | | | | 0. : α117
//│ | | | | 0. Typing term 2
//│ | | | | 0. : #2<Int,Num,Object>
//│ | | | | f and f_ty => App(Var(-), Tup(_: Var(z_1))) α117
//│ | | | | a and a_ty => Tup(_: IntLit(2)) (#2<Int,Num,Object>,)
//│ | | | | CONSTRAIN α117 <! (#2<Int,Num,Object> -> α118)
//│ | | | |   where 
//│ 		α117 :> (Int -> Int)
//│ | | | | 0. C α117 <! (#2<Int,Num,Object> -> α118)    (0)
//│ | | | | | NEW α117 UB (0)
//│ | | | | | 0. C (Int -> Int) <! (#2<Int,Num,Object> -> α118)    (2)
//│ | | | | | | 0. C (#2<Int,Num,Object>,) <! (Int,)    (2)
//│ | | | | | | 0. C Int <! α118    (2)
//│ | | | | | | | NEW α118 LB (0)
//│ | | | 0. : α118
//│ | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | a and a_ty => Tup(y: IntLit(2), z: App(App(Var(+), Tup(_: Var(y_1))), Tup(_: IntLit(1))), x: App(App(Var(-), Tup(_: Var(z_1))), Tup(_: IntLit(2)))) (y: #2<Int,Num,Object>, z: α116, x: α118,)
//│ | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((y: #2<Int,Num,Object>, z: α116, x: α118,) -> α119)
//│ | | |   where 
//│ 		α93' :> Int
//│ 		α116 :> Int
//│ 		α118 :> Int
//│ | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((y: #2<Int,Num,Object>, z: α116, x: α118,) -> α119)    (0)
//│ | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((y: #2<Int,Num,Object>, z: α116, x: α118,) -> α119)    (2)
//│ | | | | | 0. C (y: #2<Int,Num,Object>, z: α116, x: α118,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | | CONSTRAIN #error<> <! α119
//│ | | | | | |   where 
//│ | | | | | | 0. C #error<> <! α119    (0)
//│ | | | | | | | NEW α119 LB (0)
//│ ╔══[ERROR] Wrong tuple field name: found 'y' instead of 'x'
//│ ║  l.260: 	fff(y: 2, z: y_1 + 1, x: z_1 - 2)
//│ ╙──       	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ | | | | | | 0. C #2<Int,Num,Object> <! Int    (3)
//│ | | | | | | 0. C α116 <! Int    (3)
//│ | | | | | | | NEW α116 UB (0)
//│ | | | | | | | 0. C Int <! Int    (5)
//│ | | | | | | 0. C α118 <! Int    (3)
//│ | | | | | | | NEW α118 UB (0)
//│ | | | | | | | 0. C Int <! Int    (5)
//│ | | | | | 0. C ‹∀ 0. α93'› <! α119    (2)
//│ | | | | | | NEW α119 LB (0)
//│ | | | f => fff
//│ | | | args_ty => (y: #2<Int,Num,Object>, z: α116, x: α118,) class mlscript.TyperDatatypes$TupleType
//│ | | | fun_ty => ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› class mlscript.TyperDatatypes$PolymorphicType
//│ | | | argsList => List(x, y, z)
//│ | | | a is => y: 2, z: + (y_1,) (1,), x: - (z_1,) (2,),
//│ | | | final acc => Map(y -> Left(y_2), z -> Left(z_2), x -> Left(x_1))
//│ | | | Desugared is here => let y_2 = 2 in let z_2 = + (y_1,) (1,) in let x_1 = - (z_1,) (2,) in fff (x_1, y_2, z_2,)
//│ | | | 0. Typing term let y_2 = 2 in let z_2 = + (y_1,) (1,) in let x_1 = - (z_1,) (2,) in fff (x_1, y_2, z_2,)
//│ | | | | 0. Typing term 2
//│ | | | | 0. : #2<Int,Num,Object>
//│ | | | | 0. Typing term let z_2 = + (y_1,) (1,) in let x_1 = - (z_1,) (2,) in fff (x_1, y_2, z_2,)
//│ | | | | | 0. Typing term + (y_1,) (1,)
//│ | | | | | | 0. Typing term + (y_1,)
//│ | | | | | | | 0. Typing term +
//│ | | | | | | | 0. : (Int -> (Int -> Int))
//│ | | | | | | | 0. Typing term y_1
//│ | | | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | | | f and f_ty => Var(+) (Int -> (Int -> Int))
//│ | | | | | | | a and a_ty => Tup(_: Var(y_1)) (#2<Int,Num,Object>,)
//│ | | | | | | | CONSTRAIN (Int -> (Int -> Int)) <! (#2<Int,Num,Object> -> α120)
//│ | | | | | | |   where 
//│ | | | | | | | 0. C (Int -> (Int -> Int)) <! (#2<Int,Num,Object> -> α120)    (0)
//│ | | | | | | | | 0. C (#2<Int,Num,Object>,) <! (Int,)    (1)
//│ | | | | | | | | 0. C (Int -> Int) <! α120    (1)
//│ | | | | | | | | | NEW α120 LB (0)
//│ | | | | | | 0. : α120
//│ | | | | | | 0. Typing term 1
//│ | | | | | | 0. : #1<Int,Num,Object>
//│ | | | | | | f and f_ty => App(Var(+), Tup(_: Var(y_1))) α120
//│ | | | | | | a and a_ty => Tup(_: IntLit(1)) (#1<Int,Num,Object>,)
//│ | | | | | | CONSTRAIN α120 <! (#1<Int,Num,Object> -> α121)
//│ | | | | | |   where 
//│ 		α120 :> (Int -> Int)
//│ | | | | | | 0. C α120 <! (#1<Int,Num,Object> -> α121)    (0)
//│ | | | | | | | NEW α120 UB (0)
//│ | | | | | | | 0. C (Int -> Int) <! (#1<Int,Num,Object> -> α121)    (2)
//│ | | | | | | | | 0. C (#1<Int,Num,Object>,) <! (Int,)    (2)
//│ | | | | | | | | 0. C Int <! α121    (2)
//│ | | | | | | | | | NEW α121 LB (0)
//│ | | | | | 0. : α121
//│ | | | | | 0. Typing term let x_1 = - (z_1,) (2,) in fff (x_1, y_2, z_2,)
//│ | | | | | | 0. Typing term - (z_1,) (2,)
//│ | | | | | | | 0. Typing term - (z_1,)
//│ | | | | | | | | 0. Typing term -
//│ | | | | | | | | 0. : (Int -> (Int -> Int))
//│ | | | | | | | | 0. Typing term z_1
//│ | | | | | | | | 0. : #3<Int,Num,Object>
//│ | | | | | | | | f and f_ty => Var(-) (Int -> (Int -> Int))
//│ | | | | | | | | a and a_ty => Tup(_: Var(z_1)) (#3<Int,Num,Object>,)
//│ | | | | | | | | CONSTRAIN (Int -> (Int -> Int)) <! (#3<Int,Num,Object> -> α122)
//│ | | | | | | | |   where 
//│ | | | | | | | | 0. C (Int -> (Int -> Int)) <! (#3<Int,Num,Object> -> α122)    (0)
//│ | | | | | | | | | 0. C (#3<Int,Num,Object>,) <! (Int,)    (1)
//│ | | | | | | | | | 0. C (Int -> Int) <! α122    (1)
//│ | | | | | | | | | | NEW α122 LB (0)
//│ | | | | | | | 0. : α122
//│ | | | | | | | 0. Typing term 2
//│ | | | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | | | f and f_ty => App(Var(-), Tup(_: Var(z_1))) α122
//│ | | | | | | | a and a_ty => Tup(_: IntLit(2)) (#2<Int,Num,Object>,)
//│ | | | | | | | CONSTRAIN α122 <! (#2<Int,Num,Object> -> α123)
//│ | | | | | | |   where 
//│ 		α122 :> (Int -> Int)
//│ | | | | | | | 0. C α122 <! (#2<Int,Num,Object> -> α123)    (0)
//│ | | | | | | | | NEW α122 UB (0)
//│ | | | | | | | | 0. C (Int -> Int) <! (#2<Int,Num,Object> -> α123)    (2)
//│ | | | | | | | | | 0. C (#2<Int,Num,Object>,) <! (Int,)    (2)
//│ | | | | | | | | | 0. C Int <! α123    (2)
//│ | | | | | | | | | | NEW α123 LB (0)
//│ | | | | | | 0. : α123
//│ | | | | | | 0. Typing term fff (x_1, y_2, z_2,)
//│ | | | | | | | 0. Typing term fff
//│ | | | | | | | 0. : ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | | 0. Typing term x_1
//│ | | | | | | | 0. : α123
//│ | | | | | | | 0. Typing term y_2
//│ | | | | | | | 0. : #2<Int,Num,Object>
//│ | | | | | | | 0. Typing term z_2
//│ | | | | | | | 0. : α121
//│ | | | | | | | f and f_ty => Var(fff) ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')›
//│ | | | | | | | a and a_ty => Tup(_: Var(x_1), _: Var(y_2), _: Var(z_2)) (α123, #2<Int,Num,Object>, α121,)
//│ | | | | | | | CONSTRAIN ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((α123, #2<Int,Num,Object>, α121,) -> α124)
//│ | | | | | | |   where 
//│ 		α93' :> Int
//│ 		α121 :> Int
//│ 		α123 :> Int
//│ | | | | | | | 0. C ‹∀ 0. ((x: Int, y: Int, z: Int,) -> α93')› <! ((α123, #2<Int,Num,Object>, α121,) -> α124)    (0)
//│ | | | | | | | | DISTRIB-L  ~>  ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›)
//│ | | | | | | | | 0. C ((x: Int, y: Int, z: Int,) -> ‹∀ 0. α93'›) <! ((α123, #2<Int,Num,Object>, α121,) -> α124)    (2)
//│ | | | | | | | | | 0. C (α123, #2<Int,Num,Object>, α121,) <! (x: Int, y: Int, z: Int,)    (2)
//│ | | | | | | | | | | 0. C α123 <! Int    (3)
//│ | | | | | | | | | | | NEW α123 UB (0)
//│ | | | | | | | | | | | 0. C Int <! Int    (5)
//│ | | | | | | | | | | 0. C #2<Int,Num,Object> <! Int    (3)
//│ | | | | | | | | | | 0. C α121 <! Int    (3)
//│ | | | | | | | | | | | NEW α121 UB (0)
//│ | | | | | | | | | | | 0. C Int <! Int    (5)
//│ | | | | | | | | | 0. C ‹∀ 0. α93'› <! α124    (2)
//│ | | | | | | | | | | NEW α124 LB (0)
//│ | | | | | | 0. : α124
//│ | | | | | 0. : α124
//│ | | | | 0. : α124
//│ | | | 0. : α124
//│ | | 0. : α124
//│ | : Some(α124)
//│ ======== TYPED ========
//│ let y_1: #2<Int,Num,Object> where 
//│ let z_1: #3<Int,Num,Object> where 
//│ res: Some(α124) where 
//│ 		α93' :> Int
//│ 		α124 :> ‹∀ 0. α93'›
//│ let y_1: 2
//│ let z_1: 3
//│ Int
//│ y_1
//│     = 2
//│ z_1
//│     = 3
//│ res
//│     = -3
