:NewDefs
:NoJS

trait Showable {
    fun toString: string
}
//│ trait Showable {
//│   fun toString: string
//│ }

:e
trait What0 extends woooo
//│ ╔══[ERROR] Could not find definition `woooo`
//│ ║  l.12: 	trait What0 extends woooo
//│ ╙──      	                    ^^^^^
//│ trait What0

class Point(x: int, y: int) extends Showable {
    fun mlen = x + y
    fun toString = "I'm a point"
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.19: 	    fun mlen = x + y
//│ ║        	               ^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.18: 	class Point(x: int, y: int) extends Showable {
//│ ║        	               ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.19: 	    fun mlen = x + y
//│ ╙──      	               ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.19: 	    fun mlen = x + y
//│ ║        	               ^^^^^
//│ ╟── type `int` is not an instance of type `Int`
//│ ║  l.18: 	class Point(x: int, y: int) extends Showable {
//│ ║        	                       ^^^
//│ ╟── but it flows into reference with expected type `Int`
//│ ║  l.19: 	    fun mlen = x + y
//│ ╙──      	                   ^
//│ ╔══[ERROR] Type mismatch in definition of method toString:
//│ ║  l.20: 	    fun toString = "I'm a point"
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"I'm a point"` is not an instance of type `string`
//│ ║  l.20: 	    fun toString = "I'm a point"
//│ ║        	                   ^^^^^^^^^^^^^
//│ ╟── but it flows into definition of method toString with expected type `string`
//│ ║  l.20: 	    fun toString = "I'm a point"
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	    fun toString: string
//│ ║       	                  ^^^^^^
//│ ╟── from signature of member `toString`:
//│ ║  l.5: 	    fun toString: string
//│ ╙──     	        ^^^^^^^^^^^^^^^^
//│ class Point(x: int, y: int) extends Showable {
//│   fun mlen: Int | error
//│   fun toString: "I'm a point"
//│ }

class What1(toString: string) extends Showable
//│ class What1(toString: string) extends Showable

:e
trait NoShow extends What1("hi")
//│ ╔══[ERROR] Type mismatch in type declaration:
//│ ║  l.64: 	trait NoShow extends What1("hi")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hi"` is not an instance of type `string`
//│ ║  l.64: 	trait NoShow extends What1("hi")
//│ ║        	                           ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.60: 	class What1(toString: string) extends Showable
//│ ╙──      	                      ^^^^^^
//│ ╔══[ERROR] A trait can only inherit from other traits
//│ ║  l.64: 	trait NoShow extends What1("hi")
//│ ╙──      	                     ^^^^^^^^^^^
//│ trait NoShow extends Showable, What1

:e
class ErrC1 extends Showable
class ErrC2 extends Showable {
    fun toString = 114
}
class ErrC3(toString: string -> string) extends Showable
//│ ╔══[ERROR] Member `toString` is declared in parent but not implemented in `ErrC1`
//│ ║  l.80: 	class ErrC1 extends Showable
//│ ║        	      ^^^^^
//│ ╟── Declared here:
//│ ║  l.5: 	    fun toString: string
//│ ╙──     	        ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method toString:
//│ ║  l.82: 	    fun toString = 114
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── integer literal of type `114` is not an instance of type `string`
//│ ║  l.82: 	    fun toString = 114
//│ ║        	                   ^^^
//│ ╟── but it flows into definition of method toString with expected type `string`
//│ ║  l.82: 	    fun toString = 114
//│ ║        	        ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	    fun toString: string
//│ ║       	                  ^^^^^^
//│ ╟── from signature of member `toString`:
//│ ║  l.5: 	    fun toString: string
//│ ╙──     	        ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in function type:
//│ ║  l.84: 	class ErrC3(toString: string -> string) extends Showable
//│ ║        	                      ^^^^^^^^^^^^^^^^
//│ ╟── type `string -> string` is not an instance of type `string`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.5: 	    fun toString: string
//│ ║       	                  ^^^^^^
//│ ╟── from signature of member `toString`:
//│ ║  l.5: 	    fun toString: string
//│ ╙──     	        ^^^^^^^^^^^^^^^^
//│ class ErrC1 extends Showable {
//│   fun toString: string
//│ }
//│ class ErrC2 extends Showable {
//│   fun toString: 114
//│ }
//│ class ErrC3(toString: string -> string) extends Showable

trait Stadt {
    let name: string
}
//│ trait Stadt {
//│   let name: string
//│ }

trait RefinedStadt extends Stadt {
    let size: int
    fun foo: bool -> int
}
//│ trait RefinedStadt extends Stadt {
//│   fun foo: bool -> int
//│   let name: string
//│   let size: int
//│ }

trait SizedStadt extends RefinedStadt {
    let size: 1 | 2 | 3
    fun bar: int -> int
}
//│ ╔══[ERROR] Type mismatch in signature of member `size`:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── type `1` is not an instance of type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^
//│ ╟── but it flows into union type with expected type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in signature of member `size`:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── type `2` is not an instance of type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	                  ^
//│ ╟── but it flows into union type with expected type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in signature of member `size`:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── type `3` is not an instance of type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	                      ^
//│ ╟── but it flows into union type with expected type `int`
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ trait SizedStadt extends RefinedStadt, Stadt {
//│   fun bar: int -> int
//│   fun foo: bool -> int
//│   let name: string
//│   let size: 1 | 2 | 3
//│ }

class Goodstatt(size: 1 | 2) extends RefinedStadt {
    let name = "good"
    fun bar(x) = x
    fun foo(t) = if t && true then this.size else 0
}
//│ ╔══[ERROR] Type mismatch in string literal:
//│ ║  l.198: 	    let name = "good"
//│ ║         	               ^^^^^^
//│ ╟── string literal of type `"good"` is not an instance of type `string`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.125: 	    let name: string
//│ ║         	              ^^^^^^
//│ ╟── from signature of member `name`:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `bool` is not an instance of type `Bool`
//│ ║  l.133: 	    fun foo: bool -> int
//│ ║         	             ^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ╙──       	                    ^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `1` is not an instance of type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	                                   ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `2` is not an instance of type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                          ^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	                                   ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.200: 	    fun foo(t) = if t && true then this.size else 0
//│ ║         	                                                  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Type mismatch in union type:
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^^^^^
//│ ╟── type `1` is not an instance of type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^
//│ ╟── but it flows into union type with expected type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in union type:
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^^^^^
//│ ╟── type `2` is not an instance of type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                          ^
//│ ╟── but it flows into union type with expected type `int`
//│ ║  l.197: 	class Goodstatt(size: 1 | 2) extends RefinedStadt {
//│ ║         	                      ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ class Goodstatt(size: 1 | 2) extends RefinedStadt, Stadt {
//│   fun bar: 'a -> 'a
//│   fun foo: Bool -> (0 | 1 | 2)
//│   let name: "good"
//│ }

:e
class Errcity(size: int) extends SizedStadt {
    fun bar = "hahaha"
}
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.292: 	    fun bar = "hahaha"
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hahaha"` is not a function
//│ ║  l.292: 	    fun bar = "hahaha"
//│ ║         	              ^^^^^^^^
//│ ╟── but it flows into definition of method bar with expected type `int -> int`
//│ ║  l.292: 	    fun bar = "hahaha"
//│ ║         	        ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.143: 	    fun bar: int -> int
//│ ║         	             ^^^^^^^^^^
//│ ╟── from signature of member `bar`:
//│ ║  l.143: 	    fun bar: int -> int
//│ ╙──       	        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.291: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	                    ^^^
//│ ╟── type `int` does not match type `1 | 2 | 3`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^^^^^^^^^
//│ ╟── from signature of member `size`:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ╙──       	        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Member `name` is declared in parent but not implemented in `Errcity`
//│ ║  l.291: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	      ^^^^^^^
//│ ╟── Declared here:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ ╔══[ERROR] Member `foo` is declared in parent but not implemented in `Errcity`
//│ ║  l.291: 	class Errcity(size: int) extends SizedStadt {
//│ ║         	      ^^^^^^^
//│ ╟── Declared here:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	        ^^^^^^^^^^^^^^^^
//│ class Errcity(size: int) extends RefinedStadt, SizedStadt, Stadt {
//│   fun bar: "hahaha"
//│   fun foo: bool -> int
//│   let name: string
//│ }

module Omg extends Stadt {
    fun name = "omg!!!"
    fun cool(x) = x + x
}
//│ ╔══[ERROR] Type mismatch in definition of method name:
//│ ║  l.338: 	    fun name = "omg!!!"
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"omg!!!"` is not an instance of type `string`
//│ ║  l.338: 	    fun name = "omg!!!"
//│ ║         	               ^^^^^^^^
//│ ╟── but it flows into definition of method name with expected type `string`
//│ ║  l.338: 	    fun name = "omg!!!"
//│ ║         	        ^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.125: 	    let name: string
//│ ║         	              ^^^^^^
//│ ╟── from signature of member `name`:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ module Omg extends Stadt {
//│   fun cool: Int -> Int
//│   fun name: "omg!!!"
//│ }

mixin More {
    fun more(x) = x == 1
    fun size = 1
    fun bar(x) = x
}
//│ mixin More() {
//│   fun bar: 'a -> 'a
//│   fun more: #Num -> Bool
//│   fun size: 1
//│ }

mixin Fooo {
    fun foo(x) = 0
}
//│ mixin Fooo() {
//│   fun foo: anything -> 0
//│ }

class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	        ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Type mismatch in union type:
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                      ^^^^^^^^^^^^^^^^^
//│ ╟── type `"grass"` is not an instance of type `string`
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                      ^^^^^^^
//│ ╟── but it flows into union type with expected type `string`
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                      ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.125: 	    let name: string
//│ ║         	              ^^^^^^
//│ ╟── from signature of member `name`:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in union type:
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                      ^^^^^^^^^^^^^^^^^
//│ ╟── type `"GRASS"` is not an instance of type `string`
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                                ^^^^^^^
//│ ╟── but it flows into union type with expected type `string`
//│ ║  l.379: 	class Grassberg(name: "grass" | "GRASS") extends More, SizedStadt, Fooo
//│ ║         	                      ^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.125: 	    let name: string
//│ ║         	              ^^^^^^
//│ ╟── from signature of member `name`:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ class Grassberg(name: "GRASS" | "grass") extends RefinedStadt, SizedStadt, Stadt {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: anything -> 0
//│   fun more: #Num -> Bool
//│   fun size: 1
//│ }

:e
class Dirtberg extends More, SizedStadt, Fooo {
    let name = "dirt"
    fun size = 4    // this should not check
}
//│ ╔══[ERROR] Type mismatch in string literal:
//│ ║  l.428: 	    let name = "dirt"
//│ ║         	               ^^^^^^
//│ ╟── string literal of type `"dirt"` is not an instance of type `string`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.125: 	    let name: string
//│ ║         	              ^^^^^^
//│ ╟── from signature of member `name`:
//│ ║  l.125: 	    let name: string
//│ ╙──       	        ^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method size:
//│ ║  l.429: 	    fun size = 4    // this should not check
//│ ║         	        ^^^^^^^^
//│ ╟── integer literal of type `4` does not match type `1 | 2 | 3`
//│ ║  l.429: 	    fun size = 4    // this should not check
//│ ║         	               ^
//│ ╟── but it flows into definition of method size with expected type `1 | 2 | 3`
//│ ║  l.429: 	    fun size = 4    // this should not check
//│ ║         	        ^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ║         	              ^^^^^^^^^
//│ ╟── from signature of member `size`:
//│ ║  l.142: 	    let size: 1 | 2 | 3
//│ ╙──       	        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	        ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ class Dirtberg extends RefinedStadt, SizedStadt, Stadt {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: anything -> 0
//│   fun more: #Num -> Bool
//│   let name: "dirt"
//│   fun size: 4
//│ }

class Iceburg(name: string) extends RefinedStadt, More, Fooo
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	        ^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `int`
//│ ║  l.373: 	    fun foo(x) = 0
//│ ║         	                 ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.133: 	    fun foo: bool -> int
//│ ╙──       	                     ^^^
//│ ╔══[ERROR] Type mismatch in definition of method size:
//│ ║  l.363: 	    fun size = 1
//│ ║         	        ^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.363: 	    fun size = 1
//│ ║         	               ^
//│ ╟── but it flows into definition of method size with expected type `int`
//│ ║  l.363: 	    fun size = 1
//│ ║         	        ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.132: 	    let size: int
//│ ║         	              ^^^
//│ ╟── from signature of member `size`:
//│ ║  l.132: 	    let size: int
//│ ╙──       	        ^^^^^^^^^
//│ class Iceburg(name: string) extends RefinedStadt, Stadt {
//│   fun bar: forall 'a. 'a -> 'a
//│   fun foo: anything -> 0
//│   fun more: #Num -> Bool
//│   fun size: 1
//│ }

class A { fun x: int = 1 }
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.505: 	class A { fun x: int = 1 }
//│ ║         	                       ^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.505: 	class A { fun x: int = 1 }
//│ ╙──       	                 ^^^
//│ class A {
//│   fun x: int
//│ }

:e
class B extends A { fun x = "A" }
//│ ╔══[ERROR] Type mismatch in definition of method x:
//│ ║  l.518: 	class B extends A { fun x = "A" }
//│ ║         	                        ^^^^^^^
//│ ╟── string literal of type `"A"` is not an instance of type `int`
//│ ║  l.518: 	class B extends A { fun x = "A" }
//│ ║         	                            ^^^
//│ ╟── but it flows into definition of method x with expected type `int`
//│ ║  l.518: 	class B extends A { fun x = "A" }
//│ ║         	                        ^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.505: 	class A { fun x: int = 1 }
//│ ║         	                 ^^^
//│ ╟── from definition of method x:
//│ ║  l.505: 	class A { fun x: int = 1 }
//│ ╙──       	              ^^^^^^^^^^
//│ class B extends A {
//│   fun x: "A"
//│ }

class C1[A] { fun a: A = a }
//│ class C1[A] {
//│   fun a: A
//│ }

class C2 extends C1[int] { fun a = 1 }
//│ ╔══[ERROR] Type mismatch in definition of method a:
//│ ║  l.543: 	class C2 extends C1[int] { fun a = 1 }
//│ ║         	                               ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.543: 	class C2 extends C1[int] { fun a = 1 }
//│ ║         	                                   ^
//│ ╟── but it flows into definition of method a with expected type `int`
//│ ║  l.543: 	class C2 extends C1[int] { fun a = 1 }
//│ ║         	                               ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.543: 	class C2 extends C1[int] { fun a = 1 }
//│ ║         	                    ^^^
//│ ╟── from definition of method a:
//│ ║  l.538: 	class C1[A] { fun a: A = a }
//│ ╙──       	                  ^^^^^^^^
//│ class C2 extends C1 {
//│   fun a: 1
//│ }

// trait MyTrait[A] { type MyTrait#A = A; fun a: A = a }
// freshen/subst
// trait MyTrait[int] { type MyTrait#A = int; fun a: int = a }

trait MyTrait[A] { fun a: A }
//│ trait MyTrait[A] {
//│   fun a: A
//│ }

// :ns
// :d
// :ds
class C extends MyTrait[int] { fun a = 1 }
//│ ╔══[ERROR] Type mismatch in definition of method a:
//│ ║  l.575: 	class C extends MyTrait[int] { fun a = 1 }
//│ ║         	                                   ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.575: 	class C extends MyTrait[int] { fun a = 1 }
//│ ║         	                                       ^
//│ ╟── but it flows into definition of method a with expected type `int`
//│ ║  l.575: 	class C extends MyTrait[int] { fun a = 1 }
//│ ║         	                                   ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.575: 	class C extends MyTrait[int] { fun a = 1 }
//│ ║         	                        ^^^
//│ ╟── from signature of member `a`:
//│ ║  l.567: 	trait MyTrait[A] { fun a: A }
//│ ╙──       	                       ^^^^
//│ class C extends MyTrait {
//│   fun a: 1
//│ }

:e
class C extends MyTrait[int] { fun a = false }
//│ ╔══[ERROR] Type mismatch in definition of method a:
//│ ║  l.596: 	class C extends MyTrait[int] { fun a = false }
//│ ║         	                                   ^^^^^^^^^
//│ ╟── reference of type `False` is not an instance of type `int`
//│ ║  l.596: 	class C extends MyTrait[int] { fun a = false }
//│ ║         	                                       ^^^^^
//│ ╟── but it flows into definition of method a with expected type `int`
//│ ║  l.596: 	class C extends MyTrait[int] { fun a = false }
//│ ║         	                                   ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.596: 	class C extends MyTrait[int] { fun a = false }
//│ ║         	                        ^^^
//│ ╟── from signature of member `a`:
//│ ║  l.567: 	trait MyTrait[A] { fun a: A }
//│ ╙──       	                       ^^^^
//│ class C extends MyTrait {
//│   fun a: False
//│ }


trait T1 { 
    let foo : 1 | 2 | 3 
    fun bar : string | bool
}
trait T2 { 
    let foo : 2 | 3 | 4
    let bar : int | bool
}
//│ trait T1 {
//│   fun bar: bool | string
//│   let foo: 1 | 2 | 3
//│ }
//│ trait T2 {
//│   let bar: bool | int
//│   let foo: 2 | 3 | 4
//│ }

trait T4 extends T1, T2 {
    fun foo: 2
}
//│ trait T4 extends T1, T2 {
//│   fun bar: bool
//│   fun foo: 2
//│ }

class C1(foo: 2, bar: true) extends T4
//│ class C1(foo: 2, bar: true) extends T1, T2, T4

:e
class C3 extends T4{
    fun foo = 3
    fun bar = false
}
//│ ╔══[ERROR] Type mismatch in definition of method foo:
//│ ║  l.647: 	    fun foo = 3
//│ ║         	        ^^^^^^^
//│ ╟── integer literal of type `3` does not match type `2`
//│ ║  l.647: 	    fun foo = 3
//│ ║         	              ^
//│ ╟── but it flows into definition of method foo with expected type `2`
//│ ║  l.647: 	    fun foo = 3
//│ ║         	        ^^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.635: 	    fun foo: 2
//│ ║         	             ^
//│ ╟── from signature of member `foo`:
//│ ║  l.635: 	    fun foo: 2
//│ ╙──       	        ^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.648: 	    fun bar = false
//│ ║         	        ^^^^^^^^^^^
//│ ╟── reference of type `False` does not match type `bool | string`
//│ ║  l.648: 	    fun bar = false
//│ ║         	              ^^^^^
//│ ╟── but it flows into definition of method bar with expected type `bool | string`
//│ ║  l.648: 	    fun bar = false
//│ ║         	        ^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.619: 	    fun bar : string | bool
//│ ║         	              ^^^^^^^^^^^^^
//│ ╟── from signature of member `bar`:
//│ ║  l.619: 	    fun bar : string | bool
//│ ╙──       	        ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in definition of method bar:
//│ ║  l.648: 	    fun bar = false
//│ ║         	        ^^^^^^^^^^^
//│ ╟── reference of type `False` does not match type `bool | int`
//│ ║  l.648: 	    fun bar = false
//│ ║         	              ^^^^^
//│ ╟── but it flows into definition of method bar with expected type `bool | int`
//│ ║  l.648: 	    fun bar = false
//│ ║         	        ^^^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.623: 	    let bar : int | bool
//│ ║         	              ^^^^^^^^^^
//│ ╟── from signature of member `bar`:
//│ ║  l.623: 	    let bar : int | bool
//│ ╙──       	        ^^^^^^^^^^^^^^^^
//│ class C3 extends T1, T2, T4 {
//│   fun bar: False
//│   fun foo: 3
//│ }

:e
class C2(foo: int, bar: string) extends T4
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.701: 	class C2(foo: int, bar: string) extends T4
//│ ║         	              ^^^
//│ ╟── type `int` does not match type `2`
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.635: 	    fun foo: 2
//│ ║         	             ^
//│ ╟── from signature of member `foo`:
//│ ║  l.635: 	    fun foo: 2
//│ ╙──       	        ^^^^^^
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.701: 	class C2(foo: int, bar: string) extends T4
//│ ║         	                        ^^^^^^
//│ ╟── type `string` does not match type `bool | int`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.623: 	    let bar : int | bool
//│ ║         	              ^^^^^^^^^^
//│ ╟── from signature of member `bar`:
//│ ║  l.623: 	    let bar : int | bool
//│ ╙──       	        ^^^^^^^^^^^^^^^^
//│ class C2(foo: int, bar: string) extends T1, T2, T4

:e
trait T5 extends T4 {
    let foo: 4
}
//│ ╔══[ERROR] Type mismatch in signature of member `foo`:
//│ ║  l.726: 	    let foo: 4
//│ ║         	        ^^^^^^
//│ ╟── type `4` does not match type `2`
//│ ║  l.726: 	    let foo: 4
//│ ║         	             ^
//│ ╟── but it flows into signature of member `foo` with expected type `2`
//│ ║  l.726: 	    let foo: 4
//│ ║         	        ^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.635: 	    fun foo: 2
//│ ║         	             ^
//│ ╟── from signature of member `foo`:
//│ ║  l.635: 	    fun foo: 2
//│ ╙──       	        ^^^^^^
//│ trait T5 extends T1, T2, T4 {
//│   fun bar: bool
//│   let foo: 4
//│ }

:e
trait T3 extends T1, T2 {
    let foo: true
}
//│ ╔══[ERROR] Type mismatch in signature of member `foo`:
//│ ║  l.750: 	    let foo: true
//│ ║         	        ^^^^^^^^^
//│ ╟── type `true` does not match type `1 | 2 | 3`
//│ ║  l.750: 	    let foo: true
//│ ║         	             ^^^^
//│ ╟── but it flows into signature of member `foo` with expected type `1 | 2 | 3`
//│ ║  l.750: 	    let foo: true
//│ ║         	        ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.618: 	    let foo : 1 | 2 | 3 
//│ ║         	              ^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.618: 	    let foo : 1 | 2 | 3 
//│ ╙──       	        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in signature of member `foo`:
//│ ║  l.750: 	    let foo: true
//│ ║         	        ^^^^^^^^^
//│ ╟── type `true` does not match type `2 | 3 | 4`
//│ ║  l.750: 	    let foo: true
//│ ║         	             ^^^^
//│ ╟── but it flows into signature of member `foo` with expected type `2 | 3 | 4`
//│ ║  l.750: 	    let foo: true
//│ ║         	        ^^^^^^^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.622: 	    let foo : 2 | 3 | 4
//│ ║         	              ^^^^^^^^^
//│ ╟── from signature of member `foo`:
//│ ║  l.622: 	    let foo : 2 | 3 | 4
//│ ╙──       	        ^^^^^^^^^^^^^^^
//│ trait T3 extends T1, T2 {
//│   fun bar: bool
//│   let foo: true
//│ }
