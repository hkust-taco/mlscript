:NewDefs


class C<A>
//│ class C[A]()

fun f(x) = if x is C then x
//│ fun f: forall 'A. C['A] -> C['A]

// * TODO parse class tags?
// f(C : #C)


class C<A>(a: A)
//│ class C[A](a: A)

let c = C(1)
//│ let c: C[1]
//│ c
//│   = C {}

c.a
//│ 1
//│ res
//│     = 1

fun f(x) = if x is C(a) then a
//│ fun f: forall 'a. C['a] -> 'a

f(c)
//│ 1
//│ res
//│     = 1


class C[A](n: A) {
  fun f = this.n
  fun g = C(12).n
}
//│ class C[A](n: A) {
//│   fun f: A
//│   fun g: 12
//│ }


class Some<A>(value: A) {
  fun get = value
  fun toArray = [value]
  fun map(f) = Some(f(value))
  fun map_A(f : A => 'b) = Some(f(value))
}
//│ class Some[A](value: A) {
//│   fun get: A
//│   fun map: forall 'A. (A -> 'A) -> Some['A]
//│   fun map_A: forall 'A0. (A -> 'A0) -> Some['A0]
//│   fun toArray: (A,)
//│ }


let s = Some(1)
//│ let s: Some[1]
//│ s
//│   = Some {}


s.value
//│ 1
//│ res
//│     = 1

s.get
//│ 1
//│ res
//│     = 1

s.toArray
//│ (1,)
//│ res
//│     = [ 1 ]


s.map
//│ forall 'A. (1 -> 'A) -> Some['A]
//│ res
//│     = [Function: map]

s.map(succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.87: 	s.map(succ)
//│ ║        	^^^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.60: 	let s = Some(1)
//│ ╙──      	             ^
//│ Some[int] | error
//│ res
//│     = Some {}


s.map_A
//│ forall 'A. (1 -> 'A) -> Some['A]
//│ res
//│     = [Function: map_A]

s.map_A(succ)
//│ Some[int]
//│ res
//│     = Some {}



module None {
  fun get = error
  fun toArray = []
  fun map(f) = None
  fun map_A(f: nothing -> anything) = None
}
//│ module None() {
//│   fun get: nothing
//│   fun map: anything -> None
//│   fun map_A: (f: nothing -> anything,) -> None
//│   fun toArray: ()
//│ }


None.toArray
//│ ()
//│ res
//│     = []


type Option<A> = Some<A> | None
//│ type Option[A] = Some[A] | None



let opt = if true then Some(123) else None
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ║         	             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` is not an instance of type `Object`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ╙──       	             ^^^^
//│ let opt: None | Some[123]
//│ opt
//│     = Some {}

opt.toArray
//│ Array[123]
//│ res
//│     = [ 123 ]


opt.map(succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.153: 	opt.map(succ)
//│ ║         	^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` is not an instance of type `int`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ╙──       	                            ^^^
//│ None | Some[int] | error
//│ res
//│     = Some {}

opt.map_A(succ)
//│ None | Some[int]
//│ res
//│     = Some {}

opt.map(x => x > 0)
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.169: 	opt.map(x => x > 0)
//│ ║         	             ^^^^^
//│ ╟── integer literal of type `0` is not an instance of type `number`
//│ ║  l.169: 	opt.map(x => x > 0)
//│ ╙──       	                 ^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.169: 	opt.map(x => x > 0)
//│ ║         	^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `123` is not an instance of type `number`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ║         	                            ^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.169: 	opt.map(x => x > 0)
//│ ╙──       	             ^
//│ None | Some[bool | error] | error
//│ res
//│     = Some {}



if opt is Some then opt.value else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.191: 	if opt is Some then opt.value else 0
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `None` is not an instance of type `Object`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ║         	                                      ^^^^
//│ ╟── but it flows into reference with expected type `#Object`
//│ ║  l.191: 	if opt is Some then opt.value else 0
//│ ╙──       	   ^^^
//│ 0 | 123
//│ res
//│     = 123

if opt is Some(v) then v else 0
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.205: 	if opt is Some(v) then v else 0
//│ ║         	   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `None` is not an instance of type `Object`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ║         	                                      ^^^^
//│ ╟── but it flows into reference with expected type `#Object`
//│ ║  l.205: 	if opt is Some(v) then v else 0
//│ ╙──       	   ^^^
//│ 0 | 123
//│ res
//│     = 123


fun map(x, f) = if x is
  None then None
  Some(v) then Some(f(v))
//│ fun map: forall 'value 'A. (None | Some['value], 'value -> 'A,) -> (None | Some['A])

let mo = map(opt, succ)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.225: 	let mo = map(opt, succ)
//│ ║         	         ^^^^^^^^^^^^^^
//│ ╟── reference of type `None` is not an instance of type `Object`
//│ ║  l.136: 	let opt = if true then Some(123) else None
//│ ║         	                                      ^^^^
//│ ╟── but it flows into reference with expected type `#Object`
//│ ║  l.225: 	let mo = map(opt, succ)
//│ ║         	             ^^^
//│ ╟── Note: constraint arises from `case` expression:
//│ ║  l.220: 	fun map(x, f) = if x is
//│ ║         	                   ^^^^
//│ ║  l.221: 	  None then None
//│ ║         	^^^^^^^^^^^^^^^^
//│ ║  l.222: 	  Some(v) then Some(f(v))
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.220: 	fun map(x, f) = if x is
//│ ╙──       	                   ^
//│ let mo: None | Some[int] | error
//│ mo
//│    = Some {}

mo.toArray
//│ Array[int] | error
//│ res
//│     = [ 124 ]



// TODO
class Test(n) {
  fun foo = n + 1
  fun bar = n
}
//│ ╔══[ERROR] Class parameters currently need type annotations
//│ ║  l.257: 	class Test(n) {
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.258: 	  fun foo = n + 1
//│ ║         	            ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.258: 	  fun foo = n + 1
//│ ╙──       	                ^
//│ class Test(n: error) {
//│   fun bar: error
//│   fun foo: error | int
//│ }

Test(1)
//│ Test
//│ res
//│     = Test {}

// :e
Test(true)
//│ Test
//│ res
//│     = Test {}


:e
class Test<A>(n: A) {
  fun foo = n + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.289: 	  fun foo = n + 1
//│ ║         	            ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.289: 	  fun foo = n + 1
//│ ║         	            ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.288: 	class Test<A>(n: A) {
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.289: 	  fun foo = n + 1
//│ ║         	            ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.289: 	  fun foo = n + 1
//│ ╙──       	                ^
//│ class Test[A](n: A) {
//│   fun foo: error | int
//│ }

Test(1)
//│ Test[1]
//│ res
//│     = Test {}

Test(true)
//│ Test[true]
//│ res
//│     = Test {}


class Test<A>(n: A) {
  fun foo: A = n
  fun foo1(x: A) = x
  fun id(x) = x
}
//│ class Test[A](n: A) {
//│   fun foo: A
//│   fun foo1: (x: A,) -> A
//│   fun id: forall 'a. 'a -> 'a
//│ }

Test(1)
//│ Test[1]
//│ res
//│     = Test {}

Test(1).foo
//│ 1
//│ res
//│     = 1

Test("ok").foo
//│ "ok"
//│ res
//│     = 'ok'

let t = Test(1)
//│ let t: Test[1]
//│ t
//│   = Test {}

t.foo1(true)
//│ 1 | true
//│ res
//│     = true

t : Test<'a>
//│ Test['a]
//│   where
//│     'a :> 1 | true
//│ res
//│     = Test {}

t.id
//│ forall 'a. 'a -> 'a
//│ res
//│     = [Function: id]

[t.id(1), t.id(true)]
//│ (1, true,)
//│ res
//│     = [ 1, true ]


:e
class TestBad<A> {
  fun foo1(x: A) = x
  fun foo2(x: A) = x + 1
}
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.378: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^
//│ ╟── reference of type `A` is not an instance of type `int`
//│ ║  l.378: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.376: 	class TestBad<A> {
//│ ╙──       	              ^
//│ ╔══[ERROR] Type mismatch in operator application:
//│ ║  l.378: 	  fun foo2(x: A) = x + 1
//│ ║         	                   ^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.378: 	  fun foo2(x: A) = x + 1
//│ ╙──       	                       ^
//│ class TestBad[A]() {
//│   fun foo1: (x: A,) -> A
//│   fun foo2: (x: A,) -> (error | int)
//│ }

TestBad().foo1
//│ (x: 'A,) -> 'A
//│ res
//│     = [Function: foo1]

TestBad().foo1(1)
//│ 1
//│ res
//│     = 1

x => TestBad().foo1(x)
//│ 'a -> 'a
//│ res
//│     = [Function: res]

// :d
let t = TestBad()
//│ let t: forall 'A. TestBad['A]
//│ t
//│   = TestBad {}

t.foo1
//│ (x: 'A,) -> 'A
//│ res
//│     = [Function: foo1]

[t.foo1(0), t.foo1(true)]
//│ (0, true,)
//│ res
//│     = [ 0, true ]

t.foo1(0)
//│ 0
//│ res
//│     = 0

t
//│ forall 'A. TestBad['A]
//│ res
//│     = TestBad {}


fun foo(x: TestBad<int>) = x.foo1
//│ fun foo: (x: TestBad[int],) -> (x: int,) -> int

foo(t)
//│ (x: int,) -> int
//│ res
//│     = [Function: foo1]

foo(t)(1)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.450: 	foo(t)(1)
//│ ║         	^^^^^^^^^
//│ ╟── integer literal of type `1` is not an instance of type `int`
//│ ║  l.450: 	foo(t)(1)
//│ ║         	       ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.442: 	fun foo(x: TestBad<int>) = x.foo1
//│ ║         	                   ^^^
//│ ╟── Note: type parameter A is defined at:
//│ ║  l.376: 	class TestBad<A> {
//│ ╙──       	              ^
//│ error | int
//│ res
//│     = 1


TestBad().foo2
//│ (x: anything,) -> (error | int)
//│ res
//│     = [Function: foo2]



class Weird(x: C<'a>)
//│ class Weird(x: C['a])

let w = Weird(c)
//│ let w: Weird
//│ w
//│   = Weird {}

w.x
//│ C['a]
//│ res
//│     = C {}

not(w.x.n)
//│ bool
//│ res
//│     = true

:e
not(w.x.a)
//│ ╔══[ERROR] Class `C` does not contain member `a`
//│ ║  l.494: 	not(w.x.a)
//│ ╙──       	       ^^
//│ bool
//│ res
//│     = false



