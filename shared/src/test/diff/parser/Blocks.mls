:AllowParseErrors


a
b
//│ |a|↵|b|
//│ Parsed: {a; b}

a,
b
//│ |a|,|↵|b|
//│ ╔══[PARSE ERROR] Expected end of input; found comma instead
//│ ║  l.9: 	a,
//│ ╙──     	 ^
//│ Parsed: {a}

a,
b,
//│ |a|,|↵|b|,|
//│ ╔══[PARSE ERROR] Expected end of input; found comma instead
//│ ║  l.17: 	a,
//│ ╙──      	 ^
//│ Parsed: {a}

a,
b,
c
//│ /!!!\ Uncaught error: java.lang.ArrayIndexOutOfBoundsException: 7
//│ 	at: mlscript.NewLexer.isQuasiquoteKeyword$1(NewLexer.scala:81)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:91)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:140)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:90)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:150)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:140)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:90)

foo
  a
  b
//│ |foo|→|a|↵|b|←|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.40: 	foo
//│ ║        	^^^
//│ ║  l.41: 	  a
//│ ║        	^^^
//│ ║  l.42: 	  b
//│ ╙──      	^^^
//│ Parsed: {foo ({a; b},)}

foo(
  a,
  b
)
//│ |foo|(|→|a|,|↵|b|←|↵|)|
//│ Parsed: {foo (a, b,)}

foo(
  a,
  b,
)
//│ |foo|(|→|a|,|↵|b|,|←|↵|)|
//│ Parsed: {foo (a, b,)}

foo(
  a
  b
)
//│ |foo|(|→|a|↵|b|←|↵|)|
//│ Parsed: {foo ({a; b},)}

foo(
    a
  b
)
//│ |foo|(|→|a|←|→|b|←|↵|)|
//│ ╔══[PARSE ERROR] Unexpected indented block here
//│ ║  l.76: 	  b
//│ ║        	^^^
//│ ║  l.77: 	)
//│ ╙──      	^
//│ Parsed: {foo (a,)}

// TODO
foo of
  a
  fun f = 1
  b
//│ |foo| |#of|→|a|↵|#fun| |f| |#=| |1|↵|b|←|
//│ ╔══[PARSE ERROR] Unexpected 'fun' keyword in expression position
//│ ║  l.89: 	  fun f = 1
//│ ╙──      	  ^^^
//│ ╔══[PARSE ERROR] Unexpected '=' keyword here
//│ ║  l.89: 	  fun f = 1
//│ ╙──      	        ^
//│ Parsed: {foo ({a; f},)}

foo +
  a
  b
//│ |foo| |+|→|a|↵|b|←|
//│ Parsed: {+ (foo,) ({a; b},)}


foo(a, b, c)
foo of a, b, c
//│ /!!!\ Uncaught error: java.lang.ArrayIndexOutOfBoundsException: 27
//│ 	at: mlscript.NewLexer.isQuasiquoteKeyword$1(NewLexer.scala:81)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:91)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:87)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:90)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:150)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:87)

foo of
  aaaaa,
  bbbbb,
  ccccc
//│ |foo| |#of|→|aaaaa|,|↵|bbbbb|,|↵|ccccc|←|
//│ Parsed: {foo (aaaaa, bbbbb, ccccc,)}

foo of
  a
  boo
    x
    y
  c
//│ /!!!\ Uncaught error: java.lang.ArrayIndexOutOfBoundsException: 32
//│ 	at: mlscript.NewLexer.isQuasiquoteKeyword$1(NewLexer.scala:81)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:91)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:140)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:150)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:140)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:150)
//│ 	at: mlscript.NewLexer.lex(NewLexer.scala:130)
//│ 	at: mlscript.NewLexer.go$1(NewLexer.scala:82)


fun foo =
  print("ok")
  print("ko")
//│ |#fun| |foo| |#=|→|print|(|"ok"|)|↵|print|(|"ko"|)|←|
//│ Parsed: {fun foo = {print ("ok",); print ("ko",)}}

fun foo =
  
  print("ok")
  
  print("ko")
  
//│ |#fun| |foo| |#=|→|print|(|"ok"|)|↵|print|(|"ko"|)|↵|←|
//│ Parsed: {fun foo = {print ("ok",); print ("ko",)}}

fun foo =
  fun local(x) = x + 1
  print(local(1))
  class Foo
//│ |#fun| |foo| |#=|→|#fun| |local|(|x|)| |#=| |x| |+| |1|↵|print|(|local|(|1|)|)|↵|#class| |Foo|←|
//│ Parsed: {fun foo = {fun local = x, => + (x,) (1,); print (local (1,),); class Foo() {}}}

fun foo =
  fun local(x) =
    class Foo {
      fun bar = x + 1
    }
    Foo().bar
  print of local(0) + local(1)
  print of (local of 0) + local of 1
  fun tmp = 1
  print of local of 0 + local of 1
  fun tmp = 2
//│ |#fun| |foo| |#=|→|#fun| |local|(|x|)| |#=|→|#class| |Foo| |{|→|#fun| |bar| |#=| |x| |+| |1|←|↵|}|↵|Foo|(||)|.bar|←|↵|print| |#of| |local|(|0|)| |+| |local|(|1|)|↵|print| |#of| |(|local| |#of| |0|)| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |1|↵|print| |#of| |local| |#of| |0| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |2|←|
//│ Parsed: {fun foo = {fun local = x, => {class Foo() {fun bar = + (x,) (1,)}; (Foo ()).bar}; print (+ (local (0,),) (local (1,),),); print (+ (local (0,),) (local (1,),),); fun tmp = 1; print (local (+ (0,) (local (1,),),),); fun tmp = 2}}


