def t1 : (int, ...Array[int], bool)
//│ t1: (int, ...Array[int], bool)
//│   = <missing implementation>

def t2 : (int, ...(bool, int))
//│ t2: (int, ...(bool, int,))
//│   = <missing implementation>

:e
def t3 : (int, ...bool, mut int)
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.10: 	def t3 : (int, ...bool, mut int)
//│ ║        	                  ^^^^
//│ ╙── type `bool` does not match type `Array[?a]`
//│ ╔══[ERROR] Mutable splice field
//│ ║  l.10: 	def t3 : (int, ...bool, mut int)
//│ ╙──      	         ^^^^^^^^^^^^^^^^^^^^^^^
//│ t3: (int, ...bool, error)
//│   = <missing implementation>

:e
def t4 : (int, ...int, bool)
//│ ╔══[ERROR] Type mismatch in type reference:
//│ ║  l.22: 	def t4 : (int, ...int, bool)
//│ ║        	                  ^^^
//│ ╙── type `int` does not match type `Array[?a]`
//│ t4: (int, ...int, bool)
//│   = <missing implementation>

:d
def f1 : ('a, ...Array[int]) -> 'a
//│ 1. Typing type Function(Tuple(List((None,Field(None,Splice(List(Right(('a,false)), Left(AppliedType(TypeName(Array),List(TypeName(int)))))))))),'a)
//│ | vars=Map() newDefsInfo=Map()
//│ | CONSTRAIN Array[Int] <! Array[None..α1']
//│ |   where 
//│ | C Array[Int] <! Array[None..α1']
//│ | | C Array[None..Int] <! Array[None..α1']
//│ | | | C Int <! α1'
//│ => ((None..SpliceType(List(Right(['a0']), Left(Array[Int]))),) -> ['a0']) | 'a0'
//│ Typed as: ((None..SpliceType(List(Right(['a0']), Left(Array[Int]))),) -> ['a0'])
//│  where: 
//│ f1: ('a, ...Array[int]) -> 'a
//│   = <missing implementation>

:d
def f1 (x, ...y) = x
//│ 1. Typing term (((x, ...y),) => x)
//│ | 1. Typing pattern ((x, ...y),)
//│ | | 1. Typing pattern (x, ...y)
//│ | | | 1. Typing pattern x
//│ | | | 1. : α0'
//│ | | | 1. Typing pattern y
//│ | | | 1. : α1'
//│ | | | CONSTRAIN α1' <! Array[None..α2']
//│ | | |   where 
//│ | | | C α1' <! Array[None..α2']
//│ | | 1. : SpliceType(List(Right(α0'), Left(α1')))
//│ | 1. : (None..SpliceType(List(Right(α0'), Left(α1'))),)
//│ | 1. Typing term x
//│ | 1. : [α0']
//│ 1. : ((None..SpliceType(List(Right(α0'), Left(α1'))),) -> [α0'])
//│ Typed as: ((None..SpliceType(List(Right(α0'), Left(α1'))),) -> [α0'])
//│  where: α1' <: [[Array[None..α2']]]
//│ Typed as: ((None..SpliceType(List(Right(['a0']), Left(Array[Int]))),) -> ['a0'])
//│  where: 
//│ ('a, ...Array[anything]) -> 'a
//│   <:  f1:
//│ ('a, ...Array[int]) -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.46: 	def f1 (x, ...y) = x
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `('a, ...Array[int])` does not match type `(?a, ...?b)`
//│ ║  l.31: 	def f1 : ('a, ...Array[int]) -> 'a
//│ ║        	         ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from splice:
//│ ║  l.46: 	def f1 (x, ...y) = x
//│ ╙──      	       ^^^^^^^^^
//│ Code generation crashed:
//│   scala.MatchError: (x, ...y) (of class mlscript.Splc)

:e
errt = (1, ...2, 3)
//│ ╔══[ERROR] Type mismatch in splice:
//│ ║  l.82: 	errt = (1, ...2, 3)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── integer literal of type `2` does not match type `Array[?a]`
//│ ║  l.82: 	errt = (1, ...2, 3)
//│ ╙──      	              ^
//│ errt: (1, ...2, 3)
//│ Code generation crashed:
//│   scala.MatchError: (1, ...2, 3) (of class mlscript.Splc)

:e
wrerr = (1, ...true, mut 3)
//│ ╔══[ERROR] Type mismatch in splice:
//│ ║  l.94: 	wrerr = (1, ...true, mut 3)
//│ ║        	        ^^^^^^^^^^^^^^^^^^^
//│ ╟── reference of type `true` does not match type `Array[?a]`
//│ ║  l.94: 	wrerr = (1, ...true, mut 3)
//│ ╙──      	               ^^^^
//│ ╔══[ERROR] mutable splice not supported
//│ ║  l.94: 	wrerr = (1, ...true, mut 3)
//│ ╙──      	        ^^^^^^^^^^^^^^^^^^^
//│ wrerr: (1, ...true, error)
//│ Code generation crashed:
//│   scala.MatchError: (1, ...true, mut 3) (of class mlscript.Splc)

gt1 = (1, ...(1,2,3), 2)
//│ gt1: (1, ...(1, 2, 3,), 2)
//│ Code generation crashed:
//│   scala.MatchError: (1, ...(1, 2, 3,), 2) (of class mlscript.Splc)

gt1[0]
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.113: 	gt1[0]
//│ ║         	^^^^^^
//│ ╟── splice of type `(1, ...(1, 2, 3,), 2)` does not match type `Array[?a]`
//│ ║  l.108: 	gt1 = (1, ...(1,2,3), 2)
//│ ║         	      ^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Array[?a]`
//│ ║  l.113: 	gt1[0]
//│ ╙──       	^^^
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol gt1

def arr1: Array[int]
gt2 = (...arr1)
//│ arr1: Array[int]
//│ gt2: (...Array[int])
//│ Code generation crashed:
//│   scala.MatchError: (...arr1) (of class mlscript.Splc)
