:NoJS

class A: { x: int }
//│ Defined class A

def muta1: MutArray[int]
//│ muta1: MutArray[int .. int]

def a1: Array[int]
//│ a1: Array[int]

muta1 : Array[int]
//│ res: Array[int]

:e
a1: MutArray[int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.16: 	a1: MutArray[int]
//│ ║        	^^
//│ ╟── type `Array[int]` does not match type `MutArray[int .. int]`
//│ ║  l.9: 	def a1: Array[int]
//│ ║       	        ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `MutArray[int .. int]`
//│ ║  l.16: 	a1: MutArray[int]
//│ ║        	^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.16: 	a1: MutArray[int]
//│ ╙──      	    ^^^^^^^^^^^^^
//│ res: MutArray[int .. int]

a2 = A {x=3}
//│ a2: A & {x: 3}

def rc1 : { mut x : int}
rc1 = {mut x = 1}
//│ rc1: {x: int .. int}
//│ {x: 'a .. 1 | 'a}
//│   <:  rc1:
//│ {x: int .. int}

rc1.x <- 3

:e
rc1.x <- true
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.44: 	rc1.x <- true
//│ ║        	^^^^^^^^^^^^^
//│ ╟── reference of type `true` does not match type `int`
//│ ║  l.44: 	rc1.x <- true
//│ ║        	         ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.34: 	def rc1 : { mut x : int}
//│ ║        	                    ^^^
//│ ╟── from assigned selection:
//│ ║  l.44: 	rc1.x <- true
//│ ╙──      	^^^^^


immrcd = { x = 1: int }
immtpl = (1: int,)
//│ immrcd: {x: int}
//│ immtpl: (int,)

immrcd.x
immtpl._1
immtpl[0]
//│ res: int
//│ res: int
//│ res: int

:e
immrcd.x <- 0
immtpl._1 <- 0
immtpl[0] <- 0
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.72: 	immrcd.x <- 0
//│ ║        	^^^^^^^^^^^^^
//│ ╟── record field of type `int` is not mutable
//│ ║  l.59: 	immrcd = { x = 1: int }
//│ ║        	           ^^^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.72: 	immrcd.x <- 0
//│ ╙──      	       ^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.73: 	immtpl._1 <- 0
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── tuple field of type `int` is not mutable
//│ ║  l.60: 	immtpl = (1: int,)
//│ ║        	          ^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.73: 	immtpl._1 <- 0
//│ ╙──      	       ^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.74: 	immtpl[0] <- 0
//│ ║        	^^^^^^^^^^^^^^
//│ ╟── tuple field of type `int` is not mutable
//│ ║  l.60: 	immtpl = (1: int,)
//│ ║        	          ^
//│ ╟── but it flows into assigned array element with expected type `?a`
//│ ║  l.74: 	immtpl[0] <- 0
//│ ╙──      	^^^^^^^^^


//FIXME
rc2 = {mut x = 1}
rc2.x <- true
rc2.x <- "hello"
//│ rc2: {x: 'a .. 1 | 'a}

def g r = (fun x -> r) (r.x <- 3)
//│ g: ({x: 3 | 'a .. 'a} & 'b) -> 'b

g rc1
//│ res: {x: int .. int}

g rc2
//│ res: {x: 'a .. 1 | 3 | 'a}

trait T
//│ Defined trait T

def t1 : T & {mut x : int; y : bool}
t1 = T {mut x = 2; y = false}
t2 = T {x = 2}
//│ t1: {x: int .. int, y: bool} & t
//│ {x: 'a .. 2 | 'a, y: false} & t
//│   <:  t1:
//│ {x: int .. int, y: bool} & t
//│ t2: {x: 2} & t

t1.x <- 4

:e
t1.y <- true
t2.x <- 3
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.134: 	t1.y <- true
//│ ║         	^^^^^^^^^^^^
//│ ╟── record field of type `bool` is not mutable
//│ ║  l.122: 	def t1 : T & {mut x : int; y : bool}
//│ ║         	                           ^^^^^^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.134: 	t1.y <- true
//│ ╙──       	   ^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.135: 	t2.x <- 3
//│ ║         	^^^^^^^^^
//│ ╟── record field of type `2` is not mutable
//│ ║  l.124: 	t2 = T {x = 2}
//│ ║         	        ^^^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.135: 	t2.x <- 3
//│ ╙──       	   ^

class B: { mut x: int; y: bool }
  method Foo = this.x
//│ Defined class B
//│ Defined B.Foo: B -> int

def b1 : B
b1 = B { mut x = 2; y = true }
b2 = B { mut x = 1; y = false}
//│ b1: B
//│ B with {x: int & 'x .. 2 | 'x, y: true}
//│   <:  b1:
//│ B
//│ b2: B with {x: int & 'x .. 1 | 'x, y: false}

b1.Foo
//│ res: int

:e
b1.Foo <- 0
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.172: 	b1.Foo <- 0
//│ ║         	^^^^^^^^^^^
//│ ╟── type `B` does not have field 'Foo'
//│ ║  l.160: 	def b1 : B
//│ ║         	         ^
//│ ╟── but it flows into reference with expected type `{Foo = ?a}`
//│ ║  l.172: 	b1.Foo <- 0
//│ ║         	^^
//│ ╟── Note: constraint arises from assigned selection:
//│ ║  l.172: 	b1.Foo <- 0
//│ ╙──       	^^^^^^

:e
b3 = B {x = 6; y = false}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.176: 	b3 = B {x = 6; y = false}
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^
//│ ╟── record field of type `6` is not mutable
//│ ║  l.176: 	b3 = B {x = 6; y = false}
//│ ╙──       	        ^^^^^
//│ b3: (B with {x: int & 'x .. 6 | 'x, y: false}) | error

:e
b2.y <- b1.y
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.186: 	b2.y <- b1.y
//│ ║         	^^^^^^^^^^^^
//│ ╟── record field of type `?y` is not mutable
//│ ║  l.155: 	class B: { mut x: int; y: bool }
//│ ║         	                       ^^^^^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.186: 	b2.y <- b1.y
//│ ╙──       	   ^

:e
b2.x <- b1.y
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.198: 	b2.x <- b1.y
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `bool` does not match type `int`
//│ ║  l.155: 	class B: { mut x: int; y: bool }
//│ ║         	                          ^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.198: 	b2.x <- b1.y
//│ ║         	        ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.155: 	class B: { mut x: int; y: bool }
//│ ║         	                  ^^^
//│ ╟── from assigned selection:
//│ ║  l.198: 	b2.x <- b1.y
//│ ╙──       	^^^^

b2.x <- b1.x
b1.x <- a2.x

def h : B -> int -> int
def h b i = (fun _ -> b.x) (b.x <- i) 
//│ h: B -> int -> int
//│ {x: 'a .. 'a & 'b} -> 'a -> 'b
//│   <:  h:
//│ B -> int -> int

h b1 2
//│ res: int

:e
h {mut x = 4} 2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.229: 	h {mut x = 4} 2
//│ ║         	^^^^^^^^^^^^^
//│ ╟── record literal of type `{x: ?a .. ?a}` is not an instance of type B
//│ ║  l.229: 	h {mut x = 4} 2
//│ ║         	  ^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.218: 	def h : B -> int -> int
//│ ╙──       	        ^
//│ res: error | int

def mt1: (mut int, mut bool)
def mt2: (int, int)
def mt3: (mut int, mut int)
def mt4: (mut bool, bool, bool)
mt4 = (mut true, false, false)
//│ mt1: (int .. int, bool .. bool,)
//│ mt2: (int, int,)
//│ mt3: (int .. int, int .. int,)
//│ mt4: (bool .. bool, bool, bool,)
//│ ('a .. true | 'a, false, false,)
//│   <:  mt4:
//│ (bool .. bool, bool, bool,)

mt1 : (int, bool)
//│ res: (int, bool,)

def emt: (mut int)
//│ emt: (int .. int,)

emt._1
//│ res: int

k1 = (mut 233, "hello", mut true)
k1._1 <- k1._1 + 1
//│ k1: ('a .. 233 | 'a, "hello", 'b .. true | 'b,)

:e
k1._2 <- 233
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.268: 	k1._2 <- 233
//│ ║         	^^^^^^^^^^^^
//│ ╟── tuple field of type `"hello"` is not mutable
//│ ║  l.263: 	k1 = (mut 233, "hello", mut true)
//│ ║         	               ^^^^^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.268: 	k1._2 <- 233
//│ ╙──       	   ^^

muta1[0] <- 1

mt1 = (mut 3, mut false)
//│ ('a .. 3 | 'a, 'b .. false | 'b,)
//│   <:  mt1:
//│ (int .. int, bool .. bool,)

def amf : MutArray['a] -> 'a
//│ amf: MutArray['a .. 'a] -> 'a

amf mt3
//│ res: int

:e
amf mt4
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.293: 	amf mt4
//│ ║         	^^^^^^^
//│ ╟── type `(bool .. bool, bool, bool,)` does not match type `MutArray[?a .. ?a]`
//│ ║  l.244: 	def mt4: (mut bool, bool, bool)
//│ ║         	         ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `MutArray[?a .. ?a]`
//│ ║  l.293: 	amf mt4
//│ ║         	    ^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.286: 	def amf : MutArray['a] -> 'a
//│ ╙──       	          ^^^^^^^^^^^^
//│ res: bool | error

:e
muta1[1] <- false
a1[0] <- 1
mt1[0] <- mt2._1
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.310: 	a1[0] <- 1
//│ ║         	^^^^^^^^^^
//│ ╟── type `Array[int]` does not match type `MutArray[?a .. ?a]`
//│ ║  l.9: 	def a1: Array[int]
//│ ║       	        ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `MutArray[?a .. ?a]`
//│ ║  l.310: 	a1[0] <- 1
//│ ╙──       	^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.311: 	mt1[0] <- mt2._1
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `bool`
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	                       ^^^^
//│ ╟── from assigned array element:
//│ ║  l.311: 	mt1[0] <- mt2._1
//│ ╙──       	^^^^^^

mt1._1 <- mt2._1
mt1._1 <- mt1._1 * 2
mt1._2 <- false
mt3[0] <- mt3[1]
mt3[1] <- mt1._1

:e
mt1._1 <- mt1._2
mt1._2 <- 1
mt1._1 <- (b1.t <- 4)
(mt1._1 <- b1.t) <- 4
b1.x <- 1 + 2 <- 4
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.341: 	mt1._1 <- mt1._2
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── type `bool` does not match type `int`
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	                       ^^^^
//│ ╟── but it flows into field selection with expected type `int`
//│ ║  l.341: 	mt1._1 <- mt1._2
//│ ║         	          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	              ^^^
//│ ╟── from assigned selection:
//│ ║  l.341: 	mt1._1 <- mt1._2
//│ ╙──       	^^^^^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.342: 	mt1._2 <- 1
//│ ║         	^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `bool`
//│ ║  l.342: 	mt1._2 <- 1
//│ ║         	          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	                       ^^^^
//│ ╟── from assigned selection:
//│ ║  l.342: 	mt1._2 <- 1
//│ ╙──       	^^^^^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ║         	           ^^^^^^^^^
//│ ╟── type `B` does not have field 't'
//│ ║  l.160: 	def b1 : B
//│ ║         	         ^
//│ ╟── but it flows into reference with expected type `{t: ?a .. ?a}`
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ║         	           ^^
//│ ╟── Note: constraint arises from assigned selection:
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ╙──       	           ^^^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── assignment of type `unit` does not match type `int`
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.241: 	def mt1: (mut int, mut bool)
//│ ║         	              ^^^
//│ ╟── from assigned selection:
//│ ║  l.343: 	mt1._1 <- (b1.t <- 4)
//│ ╙──       	^^^^^^
//│ ╔══[ERROR] Illegal assignment
//│ ║  l.344: 	(mt1._1 <- b1.t) <- 4
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── cannot assign to assignment
//│ ║  l.344: 	(mt1._1 <- b1.t) <- 4
//│ ╙──       	^^^^^^^^^^^^^^^^
//│ res: error
//│ ╔══[ERROR] Illegal assignment
//│ ║  l.345: 	b1.x <- 1 + 2 <- 4
//│ ║         	            ^^^^^^
//│ ╟── cannot assign to integer literal
//│ ║  l.345: 	b1.x <- 1 + 2 <- 4
//│ ╙──       	            ^

def f : {mut _1 : int} -> int -> unit
def g : (mut int, bool) -> int -> unit
//│ f: {_1: int .. int} -> int -> unit
//│ g: (int .. int, bool,) -> int -> unit

def f a n = a._1 <- n
//│ {_1: 'a .. 'a} -> 'a -> unit
//│   <:  f:
//│ {_1: int .. int} -> int -> unit

f mt1 1

:e
f mt2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.424: 	f mt2
//│ ║         	^^^^^
//│ ╟── tuple field of type `int` is not mutable
//│ ║  l.242: 	def mt2: (int, int)
//│ ╙──       	          ^^^
//│ res: int -> unit | error

:e
g (1, true) 2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.434: 	g (1, true) 2
//│ ║         	^^^^^^^^^^^
//│ ╟── tuple field of type `1` is not mutable
//│ ║  l.434: 	g (1, true) 2
//│ ╙──       	   ^
//│ res: error | unit

w1 = 3 with {mut x = 4}
w1.x <- 3
//│ w1: 3 & {x: 'a .. 4 | 'a}

w1.x
//│ res: 4

def st1 : (int, )
def st2 : (mut int, )
//│ st1: (int,)
//│ st2: (int .. int,)

st1 = (3,)
st2 = (mut 4,)
//│ (3,)
//│   <:  st1:
//│ (int,)
//│ ('a .. 4 | 'a,)
//│   <:  st2:
//│ (int .. int,)

st2._1 <- 8

:e
st1._1 <- 9
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.467: 	st1._1 <- 9
//│ ║         	^^^^^^^^^^^
//│ ╟── tuple field of type `int` is not mutable
//│ ║  l.450: 	def st1 : (int, )
//│ ║         	           ^^^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.467: 	st1._1 <- 9
//│ ╙──       	    ^^

def am1 : Array[(mut int)]
//│ am1: Array[(int .. int,)]

def foreach : Array['a] -> ('a -> unit) -> Array['a]
//│ foreach: Array['a] -> ('a -> unit) -> Array['a]

foreach am1 (fun x -> x[0] <- 1)
foreach am1 (fun y -> y._1 <- 2)
//│ res: Array[(int .. int,)]
//│ res: Array[(int .. int,)]

:e
(1,2,3)[0] <- true
(1,2,3)._1 <- "hello"
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.490: 	(1,2,3)[0] <- true
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── tuple literal of type `(1, 2, 3,)` does not match type `MutArray[?a .. ?a]`
//│ ║  l.490: 	(1,2,3)[0] <- true
//│ ╙──       	^^^^^^^
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.491: 	(1,2,3)._1 <- "hello"
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── tuple field of type `1` is not mutable
//│ ║  l.491: 	(1,2,3)._1 <- "hello"
//│ ║         	 ^
//│ ╟── but it flows into assigned field with expected type `?a`
//│ ║  l.491: 	(1,2,3)._1 <- "hello"
//│ ╙──       	        ^^

:e
(0,)["oops"]
(mut 0,)["oops"] <- 1
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.509: 	(0,)["oops"]
//│ ║         	^^^^^^^^^^^^
//│ ╟── string literal of type `"oops"` does not match type `int`
//│ ║  l.509: 	(0,)["oops"]
//│ ╙──       	     ^^^^^^
//│ res: 0
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.510: 	(mut 0,)["oops"] <- 1
//│ ║         	^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"oops"` does not match type `int`
//│ ║  l.510: 	(mut 0,)["oops"] <- 1
//│ ╙──       	         ^^^^^^

oops = "oops"
arr = (mut 0,)
//│ oops: "oops"
//│ arr: ('a .. 0 | 'a,)

:e
arr[oops]
arr[oops] <- 1
//│ ╔══[ERROR] Type mismatch in array access:
//│ ║  l.531: 	arr[oops]
//│ ║         	^^^^^^^^^
//│ ╟── string literal of type `"oops"` does not match type `int`
//│ ║  l.525: 	oops = "oops"
//│ ║         	       ^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.531: 	arr[oops]
//│ ╙──       	    ^^^^
//│ res: 0
//│ ╔══[ERROR] Type mismatch in assignment:
//│ ║  l.532: 	arr[oops] <- 1
//│ ║         	^^^^^^^^^^^^^^
//│ ╟── string literal of type `"oops"` does not match type `int`
//│ ║  l.525: 	oops = "oops"
//│ ║         	       ^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.532: 	arr[oops] <- 1
//│ ╙──       	    ^^^^

