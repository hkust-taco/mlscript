
class Monoid[A]
  method Empty: A
  method Add: A -> A -> A
//│ Defined class Monoid
//│ Declared Monoid.Empty: Monoid['A] -> 'A
//│ Declared Monoid.Add: Monoid['A] -> 'A -> 'A -> 'A

class IntMonoid: Monoid[int]
  method Empty = 0
  method Add = add
def IntMonoid = IntMonoid {}
//│ Defined class IntMonoid
//│ Defined IntMonoid.Empty: IntMonoid -> 0
//│ Defined IntMonoid.Add: IntMonoid -> int -> int -> int
//│ IntMonoid: IntMonoid
//│          = IntMonoid {}

class Num: { val: int }
//│ Defined class Num

class NumMonoid: Monoid[Num]
  method Empty = Num { val = 1 }
  method Add this that = Num { val = this.val * that.val }
//│ Defined class NumMonoid
//│ Defined NumMonoid.Empty: NumMonoid -> (Num & {val: 1})
//│ Defined NumMonoid.Add: NumMonoid -> {val: int} -> {val: int} -> Num

class Complex[A]: { real: A; imaginary: A }
  method Map f = Complex { real = f this.real; imaginary = f this.imaginary }
def Complex real imaginary = Complex { real; imaginary }
//│ Defined class Complex
//│ Defined Complex.Map: Complex['A] -> ('A -> ('a & 'A0)) -> (Complex['A0] with {imaginary: 'a, real: 'a})
//│ Complex: ('real & 'A) -> ('A & 'imaginary) -> (Complex['A] with {imaginary: 'imaginary, real: 'real})
//│        = [Function: Complex1]

class ComplexMonoid[A]: Monoid[Complex[A]] & { base: Monoid[A] }
  method Empty = Complex this.base.Empty this.base.Empty
  method Add self that =
    Complex (this.base.Add self.real that.real) (this.base.Add self.imaginary that.imaginary)
//│ Defined class ComplexMonoid
//│ Defined ComplexMonoid.Empty: ComplexMonoid['A] -> (Complex['a] with {imaginary: 'A, real: 'A})
//│   where
//│     'a :> 'A
//│ Defined ComplexMonoid.Add: ComplexMonoid['A] -> {imaginary: 'A, real: 'A} -> {imaginary: 'A, real: 'A} -> (Complex['a] with {imaginary: 'A, real: 'A})
//│   where
//│     'a :> 'A

cmi = ComplexMonoid { base = IntMonoid }
//│ cmi: ComplexMonoid[int] with {base: IntMonoid}
//│    = ComplexMonoid { base: IntMonoid {} }

def ComplexMonoid base = ComplexMonoid { base }
//│ ComplexMonoid: (Monoid['A] & 'base) -> (ComplexMonoid['A] with {base: 'base})
//│              = [Function: ComplexMonoid1]

cmi = ComplexMonoid IntMonoid
//│ cmi: ComplexMonoid[int] with {base: IntMonoid}
//│    = ComplexMonoid { base: IntMonoid {} }

cmi.Empty
//│ res: Complex[int]
//│    = Complex { real: 0, imaginary: 0 }

cmi.Empty.real
//│ res: int
//│    = 0

cmi.Add (Complex 1 2) (Complex 3 4)
//│ res: Complex[int]
//│    = Complex { real: 4, imaginary: 6 }



// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors



cmi = ComplexMonoid { base = IntMonoid }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	cmi = ComplexMonoid { base = IntMonoid }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{base: ?a}` is not an instance of type Monoid
//│ ║  l.+1: 	cmi = ComplexMonoid { base = IntMonoid }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.37: 	class ComplexMonoid[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	                                                     ^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.53: 	def ComplexMonoid base = ComplexMonoid { base }
//│ ╙──      	                                         ^^^^
//│ cmi: (ComplexMonoid['A] with {base: {base: IntMonoid}}) | error



class ComplexMonoid_bad_0[A]: Monoid[Complex[A]] & { base: Monoid[A] }
  method Empty = Complex { real = this.base }
  method Add this that = error
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type Complex
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Complex[?]`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.+1: 	class ComplexMonoid_bad_0[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	                                     ^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not a record (expected a record with fields: real, imaginary)
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `{real: A, imaginary: A}`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.29: 	class Complex[A]: { real: A; imaginary: A }
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not have field 'Complex#A'
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `{Complex#A = A}`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.+1: 	class ComplexMonoid_bad_0[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	                                     ^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ Defined class ComplexMonoid_bad_0
//│ Defined ComplexMonoid_bad_0.Empty: ComplexMonoid_bad_0['A] -> ('a & 'b) -> (Complex['b] with {imaginary: 'a, real: {real: Monoid['A]}})
//│ Defined ComplexMonoid_bad_0.Add: ComplexMonoid_bad_0['A] -> anything -> anything -> nothing


class ComplexMonoid_bad_1[A]: Monoid[Complex[A]] & { base: Monoid[A] }
  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
  method Add this that = error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	                                                               ^^^^^^^^^^^^^^
//│ ╟── type definition of type `ComplexMonoid_bad_1[A]` does not have field 'imaginary'
//│ ║  l.+1: 	class ComplexMonoid_bad_1[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{imaginary: ?a}`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ╙──      	                                                               ^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not an instance of type Complex
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `Complex[?]`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.+1: 	class ComplexMonoid_bad_1[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	                                     ^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` is not a record (expected a record with fields: real, imaginary)
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `{real: A, imaginary: A}`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.29: 	class Complex[A]: { real: A; imaginary: A }
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b` does not have field 'Complex#A'
//│ ║  l.31: 	def Complex real imaginary = Complex { real; imaginary }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into application with expected type `{Complex#A = A}`
//│ ║  l.+2: 	  method Empty = Complex { real = this.base.Empty; imaginary = this.imaginary.Empty }
//│ ║        	                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.+1: 	class ComplexMonoid_bad_1[A]: Monoid[Complex[A]] & { base: Monoid[A] }
//│ ║        	                                     ^^^^^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.3: 	  method Empty: A
//│ ╙──     	         ^^^^^^^^
//│ Defined class ComplexMonoid_bad_1
//│ Defined ComplexMonoid_bad_1.Empty: ComplexMonoid_bad_1['A] -> ('a & 'b) -> (Complex['b] with {imaginary: 'a, real: {imaginary: error, real: 'A}})
//│ Defined ComplexMonoid_bad_1.Add: ComplexMonoid_bad_1['A] -> anything -> anything -> nothing

