
class Parent: { name: string }
//│ Defined class Parent

class Child: Parent & { age: int }
//│ Defined class Child

def p = Parent{ name = "Bob" }
//│ p: parent & {name: string}

p: Parent
//│ res: Parent

:e
def c = Child(Parent { name = "Bob" })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	def c = Child(Parent { name = "Bob" })
//│ ║        	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `parent & {name: string}` does not match type `{age: int}`
//│ ║  l.15: 	def c = Child(Parent { name = "Bob" })
//│ ║        	              ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.5: 	class Child: Parent & { age: int }
//│ ╙──     	                      ^^^^^^^^^^^^
//│ c: (child & (Parent & {age: int})) | error

def c = Child(Parent { name = "Bob" } with { age = 123 })
//│ c: child & (Parent & {age: int})

c: Parent
//│ res: Parent

:d
c.name
//│ 0. Typing term c.name
//│  0. Typing term c
//│  0. : [α0]
//│  CONSTRAIN [[α0]] <! {name: α1}
//│    where α0 :> (child & (Parent & {age: int}))
//│  C [[α0]] <! {name: α1}
//│   C [α0] <! {name: α1}
//│    C α0 <! {name: α1}
//│     C (child & (Parent & {age: int})) <! {name: α1}
//│      A  LhsTop  %  List(child, (Parent & {age: int}))  <!  List({name: α1})  %  RhsBot
//│       A  LhsRefined(Some(child),{})  %  List((Parent & {age: int}))  <!  List({name: α1})  %  RhsBot
//│        A  LhsRefined(Some(child),{})  %  List(Parent, {age: int})  <!  List({name: α1})  %  RhsBot
//│         A  LhsRefined(Some(child),{})  %  List((parent & {name: string}), {age: int})  <!  List({name: α1})  %  RhsBot
//│          A  LhsRefined(Some(child),{})  %  List(parent, {name: string}, {age: int})  <!  List({name: α1})  %  RhsBot
//│ 0. : α1
//│ Typed as: α1
//│  where: 
//│ Compact type before simplification: CompactTypeScheme(‹α1›,TreeMap())
//│ [occ] LinkedHashMap((true,α1) -> LinkedHashSet(α1))
//│ [rec] TreeSet()
//│ [!] α1
//│ [sub] α1 -> None
//│ Compact type after simplification: CompactTypeScheme(‹›,Map())
//│ res: nothing

// FIXME!
c: { name: 'a }
//│ res: {name: nothing}

c: { name: string }
//│ res: {name: string}


def f x = case x of {
  | Parent -> x.name
  }
//│ f: parent & {name: 'a} -> 'a

// FIXME
// :d
f c
//│ res: nothing


def f x = case x of {
  | Child -> x.name
  }
//│ f: child & {name: 'a} -> 'a

f c
//│ res: nothing


def f x = case x of {
  | Parent -> x.name
  | _ -> ""
  }
//│ f: ((parent & {name: 'a}) | (anything & ~parent)) -> 'a | ""

f c
//│ res: nothing | ""


def f x = case x of {
  | Parent -> x.name
  | Child -> x.name
  }
//│ f: ((parent & {name: 'a}) | ((child & {name: 'b}) & ~parent)) -> 'a | 'b

f c
//│ res: nothing | nothing

