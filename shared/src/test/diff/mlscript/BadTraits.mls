class A
class B
//│ Defined class A
//│ Defined class B

// Okay to define, but impossible to instantiate:
trait T: A & B
//│ Defined trait T

:e
T {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.11: 	T {}
//│ ║        	^^^^
//│ ╟── record literal of type `anything` is not an instance of type `A`
//│ ║  l.11: 	T {}
//│ ║        	  ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^
//│ ╟── from intersection type:
//│ ║  l.7: 	trait T: A & B
//│ ╙──     	         ^^^^^
//│ res: error | #T
//│    = {}

a = A{}
//│ a: A
//│  = A {}

:e
T a
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	T a
//│ ║        	^^^
//│ ╟── application of type `A` is not an instance of type `B`
//│ ║  l.27: 	a = A{}
//│ ║        	    ^^^
//│ ╟── but it flows into reference with expected type `B`
//│ ║  l.32: 	T a
//│ ║        	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	trait T: A & B
//│ ║       	             ^
//│ ╟── from intersection type:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^^^^^
//│ ╟── Note: class A is defined at:
//│ ║  l.1: 	class A
//│ ╙──     	      ^
//│ res: A & #T | error
//│    = A {}

:e
:js
T A
//│ // Query 1
//│ res = T.build((x) => new A(x));
//│ // End of generated code
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.56: 	T A
//│ ║        	^^^
//│ ╟── reference of type `anything -> A` is not an instance of type `A`
//│ ║  l.56: 	T A
//│ ║        	  ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^
//│ ╟── from intersection type:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^^^^^
//│ ╟── Note: class constructor A is defined at:
//│ ║  l.1: 	class A
//│ ╙──     	      ^
//│ res: anything -> A & #T | error
//│    = [Function (anonymous)]

:e
T (B {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	T (B {})
//│ ║        	^^^^^^^^
//│ ╟── application of type `B` is not an instance of type `A`
//│ ║  l.79: 	T (B {})
//│ ║        	   ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^
//│ ╟── from intersection type:
//│ ║  l.7: 	trait T: A & B
//│ ║       	         ^^^^^
//│ ╟── Note: class B is defined at:
//│ ║  l.2: 	class B
//│ ╙──     	      ^
//│ res: B & #T | error
//│    = B {}

:re
t = T error
//│ t: nothing
//│ Runtime error:
//│   Error: unexpected runtime error

:re
t: nothing
//│ res: nothing
//│ Runtime error:
//│   ReferenceError: t is not defined

type Als = A & B
//│ Defined type alias Als

:re
t: Als
//│ res: Als
//│ Runtime error:
//│   ReferenceError: t is not defined


:e
class D0: T
//│ ╔══[ERROR] class D0 cannot inherit from class B as it already inherits from class A
//│ ║  l.121: 	class D0: T
//│ ╙──       	      ^^^^^

:e
class D1: B & T
//│ ╔══[ERROR] class D1 cannot inherit from class A as it already inherits from class B
//│ ║  l.127: 	class D1: B & T
//│ ╙──       	      ^^^^^^^^^


trait S: { x: int }
//│ Defined trait S

s = S{ x = 1 }
//│ s: {x: 1} & #S
//│  = { x: 1 }

t = s: s
//│ t: #S
//│  = { x: 1 }

:e
t.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.145: 	t.x
//│ ║         	^^^
//│ ╟── type `#S` does not have field 'x'
//│ ║  l.140: 	t = s: s
//│ ║         	       ^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.145: 	t.x
//│ ╙──       	^
//│ res: error
//│    = 1

t = s: S
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

t.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.171: 	t.x
//│ ║         	^^^
//│ ╟── type `#S` does not have field 'x'
//│ ║  l.140: 	t = s: s
//│ ║         	       ^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.171: 	t.x
//│ ╙──       	^
//│ res: error
//│    = 1


trait Lol
  method Foo = 1
class Hey
  method Foo = "oops"
//│ Defined trait Lol
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

:e
class H: Lol & Hey
//│ ╔══[ERROR] An overriding method definition must be given when inheriting from multiple method definitions
//│ ║  l.203: 	class H: Lol & Hey
//│ ║         	      ^
//│ ╟── Definitions of method Foo inherited from:
//│ ╟── • Lol
//│ ║  l.186: 	  method Foo = 1
//│ ║         	         ^^^^^^^
//│ ╟── • Hey
//│ ║  l.188: 	  method Foo = "oops"
//│ ╙──       	         ^^^^^^^^^^^^
//│ Defined class H
//│ Code generation encountered an error:
//│   undeclared type name Lol when resolving base classes


// Forbid trait constructors when the trait contains method defs as well:

h = Hey{}
//│ h: Hey
//│ Code generation encountered an error:
//│   unresolved symbol Hey

:e
l = Lol h
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.227: 	l = Lol h
//│ ║         	    ^^^
//│ ╟── Note that traits with methods are always considered abstract
//│ ║  l.185: 	trait Lol
//│ ╙──       	      ^^^
//│ l: error
//│ Code generation encountered an error:
//│   unresolved symbol Lol

:e
e = Lol
e
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.239: 	e = Lol
//│ ║         	    ^^^
//│ ╟── Note that traits with methods are always considered abstract
//│ ║  l.185: 	trait Lol
//│ ╙──       	      ^^^
//│ e: error
//│ res: error
//│ Code generation encountered an error:
//│   unresolved symbol Lol

l.(Lol.Foo)
//│ res: 1
//│ Code generation encountered an error:
//│   unresolved symbol l

l.(Hey.Foo)
//│ res: "oops"
//│ Code generation encountered an error:
//│   unresolved symbol l


trait Lol2: Lol
//│ Defined trait Lol2

:e
Lol2
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.267: 	Lol2
//│ ║         	^^^^
//│ ╟── Note that traits with methods are always considered abstract
//│ ║  l.263: 	trait Lol2: Lol
//│ ╙──       	      ^^^^^^^^^
//│ res: error
//│    = [Function: build]

