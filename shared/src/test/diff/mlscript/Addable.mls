
class Addable[A]
  method Add: A -> A
//│ Defined class Addable
//│ Declared Addable.Add: Addable['A] -> 'A -> 'A

class Num: Addable[Num] & { val: int }
  method Add that = Num { val = this.val + that.val }
//│ Defined class Num
//│ Defined Num.Add: Num -> {val: int} -> Num

class Str: Addable[Str] & { val: string }
  method Add that = Str { val = concat this.val that.val }
//│ Defined class Str
//│ Defined Str.Add: Str -> {val: string} -> Str

n = Num { val = 1 }
//│ n: Num & {val: 1}
//│  = Num { val: 1 }

n.Add n
//│ res: Num & {val: 1}
//│    = Num { val: 2 }


def addTwo a0 a1 = a0.Add a1
//│ addTwo: Addable['A | Num .. Num & 'A] -> (Num & 'a) -> (Num | 'a)
//│       = [Function: addTwo]

addTwo n n
//│ res: Num
//│    = Num { val: 2 }

s = Str { val = "hey" }
//│ s: Str & {val: "hey"}
//│  = Str { val: 'hey' }

s.Add s
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.38: 	s.Add s
//│ ║        	^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                   ^^^
//│ res: error
//│    = Str { val: 'heyhey' }

addTwo s s
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.51: 	addTwo s s
//│ ║        	^^^^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                   ^^^
//│ res: error
//│    = Str { val: 'heyhey' }



def addSame a = a.Add a
//│ addSame: nothing -> Num
//│        = [Function: addSame]

addSame n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.70: 	addSame n
//│ ║        	^^^^^^^^^
//│ ╟── application of type `Num & {val: ?val}` is not an instance of type Str
//│ ║  l.17: 	n = Num { val = 1 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Str`
//│ ║  l.70: 	addSame n
//│ ║        	        ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from reference:
//│ ║  l.66: 	def addSame a = a.Add a
//│ ╙──      	                      ^
//│ res: error
//│    = Num { val: 2 }


rec def addNTimes a n =
  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.90: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── but it flows into application with expected type `Str`
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║        	                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from application:
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ╙──      	                               ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.90: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Str` is not an instance of type Num
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                   ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.90: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` does not match type `int`
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                                 ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                                 ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.90: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `string`
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                                 ^^^^^^
//│ addNTimes: nothing -> int -> Num
//│          = [Function: addNTimes]

addNTimes n 12
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.145: 	addNTimes n 12
//│ ║         	^^^^^^^^^^^
//│ ╟── application of type `Num & {val: ?val}` is not an instance of type Str
//│ ║  l.17: 	n = Num { val = 1 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Str`
//│ ║  l.145: 	addNTimes n 12
//│ ║         	          ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from reference:
//│ ║  l.91: 	  if n <= 1 then a else a.Add (addNTimes a (n - 1))
//│ ╙──      	                 ^
//│ res: error
//│    = Num { val: 12 }

addNTimes s 5
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.164: 	addNTimes s 5
//│ ║         	^^^^^^^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                   ^^^
//│ res: error
//│    = Str { val: 'heyheyheyheyhey' }




// === === === ERROR CASES === === === //


:ShowRelativeLineNums
:AllowTypeErrors


rec def addNTimes a n =
  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
addNTimes n 12
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type Str
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `Str`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type Addable
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `Addable[?]`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'Addable#A'
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `{Addable#A = Str}`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'val'
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `{val: string}`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                          ^^^^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type Num
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `Num`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` is not an instance of type Addable
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `Addable[?]`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	           ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'Addable#A'
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `{Addable#A = Num}`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	           ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `0` does not have field 'val'
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                ^
//│ ╟── but it flows into application with expected type `{val: int}`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                          ^^^^^^^^^^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── but it flows into application with expected type `Str`
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from application:
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ╙──      	                              ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Str` is not an instance of type Num
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                   ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` does not match type `int`
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                                 ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ╙──     	                                 ^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n < 0 then 0 else a.Add (addNTimes a (n - 1))
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` does not match type `string`
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                                 ^^^^^^
//│ addNTimes: Addable[Num .. nothing] -> int -> (0 | Num)
//│ res: 0 | Num

rec def addNTimes a n =
  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
addNTimes n 12
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	                        ^^^^^^^^^^^^^^^^^
//│ ╟── type `Num` is not a function
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── but it flows into application with expected type `?a -> ?b`
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                        ^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type Str
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type Addable
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` does not have field 'Addable#A'
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	           ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` does not have field 'val'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                          ^^^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type Num
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` is not an instance of type Addable
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	           ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` does not have field 'Addable#A'
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	           ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in binding of lambda expression:
//│ ║  l.+1: 	rec def addNTimes a n =
//│ ║        	                  ^^^^^
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> ?b -> ?c` does not have field 'val'
//│ ╟── Note: constraint arises from record type:
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                          ^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.+2: 	  if n <= 0 then 0 else a.Add addNTimes a (n - 1)
//│ ╙──      	                              ^^^^^^^^^
//│ addNTimes: Addable[Num .. nothing] -> int -> (0 | error)
//│ res: 0 | error

addSame n n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	addSame n n
//│ ║        	^^^^^^^^^
//│ ╟── application of type `Num & {val: ?val}` is not an instance of type Str
//│ ║  l.17: 	n = Num { val = 1 }
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `Str`
//│ ║  l.+1: 	addSame n n
//│ ║        	        ^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ║        	                   ^^^
//│ ╟── from reference:
//│ ║  l.66: 	def addSame a = a.Add a
//│ ╙──      	                      ^
//│ res: error

addTwo s n
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	addTwo s n
//│ ║        	^^^^^^^^
//│ ╟── type `Num` is not an instance of type Str
//│ ║  l.7: 	class Num: Addable[Num] & { val: int }
//│ ║       	                   ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.12: 	class Str: Addable[Str] & { val: string }
//│ ╙──      	                   ^^^
//│ res: error

class Str_bad_0: Addable[Str_bad_0] & { val: string }
  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── operator application of type `int` does not match type `string`
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	                                      ^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ╙──      	                                             ^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ║        	         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` does not match type `int`
//│ ║  l.+1: 	class Str_bad_0: Addable[Str_bad_0] & { val: string }
//│ ║        	                                             ^^^^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.+2: 	  method Add that = Str_bad_0 { val = this.val + that.val }
//│ ╙──      	                                                 ^^^^^^^^
//│ Defined class Str_bad_0
//│ Defined Str_bad_0.Add: (Str_bad_0 & {val: nothing}) -> {val: int} -> (error | (Str_bad_0 with {val: int}))

