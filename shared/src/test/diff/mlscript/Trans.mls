
class A
class B: A
class C: B
c = C{}
//│ Defined class A
//│ Defined class B
//│ Defined class C
//│ c: C
//│  = C {}

c: C
//│ res: C
//│    = C {}

c: B
//│ res: B
//│    = C {}

res: A
//│ res: A
//│    = Uncaught ReferenceError: res is not defined

c: A
//│ res: A
//│    = C {}

a = res
//│ a: A
//│  = Uncaught ReferenceError: res is not defined

:e
a: B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.33: 	a: B
//│ ║        	^
//│ ╟── expression of type `A` does not match type `B`
//│ ║  l.24: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `B`
//│ ║  l.33: 	a: B
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.33: 	a: B
//│ ╙──      	   ^
//│ res: B

:e
a: C
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.49: 	a: C
//│ ║        	^
//│ ╟── expression of type `A` does not match type `C`
//│ ║  l.24: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.49: 	a: C
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.49: 	a: C
//│ ╙──      	   ^
//│ res: C


// Transitivity is currently broken for primitive literals:

42: int
res: number
//│ res: int
//│    = 42
//│ res: number
//│    = Uncaught ReferenceError: res is not defined

// FIXME
42: number
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.75: 	42: number
//│ ║        	^^
//│ ╟── expression of type `42` does not match type `number`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.75: 	42: number
//│ ╙──      	    ^^^^^^
//│ res: number
//│    = 42

