
class A
class B: A
class C: B
c = C{}
//│ Defined class A
//│ Defined class B
//│ Defined class C
//│ c: C

c: C
//│ res: C

c: B
//│ res: B

res: A
//│ res: A

c: A
//│ res: A

a = res
//│ a: A

:e
a: B
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.27: 	a: B
//│ ║        	^
//│ ╟── expression of type `A` does not match type `B`
//│ ║  l.20: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `B`
//│ ║  l.27: 	a: B
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.27: 	a: B
//│ ╙──      	   ^
//│ res: B

:e
a: C
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.43: 	a: C
//│ ║        	^
//│ ╟── expression of type `A` does not match type `C`
//│ ║  l.20: 	c: A
//│ ║        	   ^
//│ ╟── but it flows into reference with expected type `C`
//│ ║  l.43: 	a: C
//│ ║        	^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.43: 	a: C
//│ ╙──      	   ^
//│ res: C


// Transitivity is currently broken for primitive literals:

42: int
res: number
//│ res: int
//│ res: number

// FIXME
42: number
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.67: 	42: number
//│ ║        	^^
//│ ╟── expression of type `42` does not match type `number`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.67: 	42: number
//│ ╙──      	    ^^^^^^
//│ res: number

