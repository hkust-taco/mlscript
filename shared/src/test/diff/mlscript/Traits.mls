trait A: { x: int }
trait B: { y: string }
class C: { x: 0 | 1 }
//│ Defined trait A
//│ Defined trait B
//│ Defined class C


A { x = 1 }
//│ res: {x: 1} & #A
//│    = { x: 1 }

:e
A {}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.14: 	A {}
//│ ║        	^^^^
//│ ╟── record literal of type `anything` does not have field 'x'
//│ ║  l.14: 	A {}
//│ ║        	  ^^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.1: 	trait A: { x: int }
//│ ╙──     	         ^^^^^^^^^^
//│ res: error | #A
//│    = {}


class D: C & A & B
//│ Defined class D

D
//│ res: {x: 'x & (0 | 1), y: string & 'y} -> (D with {x: 'x, y: 'y})
//│    = [Function: res]

:re
error: A & B
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:698)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)

:e
dv = D{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.50: 	dv = D{}
//│ ║        	     ^^^
//│ ╟── record literal of type `anything` is not a record (expected a record with fields: y, x)
//│ ║  l.50: 	dv = D{}
//│ ╙──      	      ^^
//│ dv: D & {x: nothing, y: nothing} | error
//│   = D { x: undefined, y: undefined }

dv = D { x = 0; y = "hello" }
//│ dv: D & {x: 0, y: "hello"}
//│   = D { x: 0, y: 'hello' }

:e
dv: nothing
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.65: 	dv: nothing
//│ ║        	^^
//│ ╟── application of type `D with {x: ?x, y: ?y}` does not match type `nothing`
//│ ║  l.60: 	dv = D { x = 0; y = "hello" }
//│ ║        	     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing`
//│ ║  l.65: 	dv: nothing
//│ ║        	^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.65: 	dv: nothing
//│ ╙──      	    ^^^^^^^
//│ res: nothing
//│    = D { x: 0, y: 'hello' }

dv: A & B
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:698)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)

:e
dv: A & B: nothing
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:698)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)


trait Indirect: C
//│ Defined trait Indirect

class E: Indirect
//│ Defined class E

:e
E{}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.116: 	E{}
//│ ║         	^^^
//│ ╟── record literal of type `anything` does not have field 'x'
//│ ║  l.116: 	E{}
//│ ╙──       	 ^^
//│ res: E & {x: nothing} | error
//│    = E {}

ev = E { x = 1 }
ev: C
//│ ev: E & {x: 1}
//│   = E {}
//│ res: C
//│    = E {}


trait T1: C & A
//│ Defined trait T1

:e
def t = T1 (A { x = 1 })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.138: 	def t = T1 (A { x = 1 })
//│ ║         	        ^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{x: 1}` does not match type `C | ~#A`
//│ ║  l.138: 	def t = T1 (A { x = 1 })
//│ ║         	              ^^^^^^^^^
//│ ╟── but it flows into application with expected type `C | ~#A`
//│ ║  l.138: 	def t = T1 (A { x = 1 })
//│ ║         	            ^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.134: 	trait T1: C & A
//│ ║         	          ^
//│ ╟── from intersection type:
//│ ║  l.134: 	trait T1: C & A
//│ ╙──       	          ^^^^^
//│ t: error | {x: 1} & #A & #T1
//│  = [Function: t]

t = T1 (A (C { x = 1 }))
//│ t: C & {x: 1} & #A & #T1
//│  = C { x: 1 }

class CA: C & A
//│ Defined class CA

t = T1 (CA { x = 1 })
//│ t: CA & {x: 1} & #T1
//│  = CA { x: 1 }


class C1: B & T1 & { y: "hi" | "hello" }
//│ Defined class C1

:e
c1 = C1 { }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.173: 	c1 = C1 { }
//│ ║         	     ^^^^^^
//│ ╟── record literal of type `anything` is not a record (expected a record with fields: y, x)
//│ ║  l.173: 	c1 = C1 { }
//│ ╙──       	        ^^^
//│ c1: C1 & {x: nothing, y: nothing} | error
//│   = C1 { y: undefined, x: undefined }

c1 = C1 { x = 1; y = "hi" }
//│ c1: C1 & {x: 1, y: "hi"}
//│   = C1 { y: 'hi', x: 1 }

c1: T1
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

c1: A
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

c1.x
c1.y
//│ res: 1
//│    = 1
//│ res: "hi"
//│    = 'hi'

