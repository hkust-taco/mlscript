:NoJS

:GeneralizeCurriedFunctions


// ============ Dummy classes to represent the types in the examples ============

class List[A]
  method Get: A // to make List covariant
//│ Defined class List[+A]
//│ Declared List.Get: List['A] -> 'A

class ST[S, A]
  method Inv_S: S -> S
  method Cov_A: A
//│ Defined class ST[=S, +A]
//│ Declared ST.Inv_S: ST['S, ?] -> 'S -> 'S
//│ Declared ST.Cov_A: ST['S, 'A] -> 'A


// ============ Type signatures for functions used in the examples ============

def head: List['a] -> 'a
//│ head: List['a] -> 'a

def tail: List['a] -> List['a]
//│ tail: List['a] -> List['a]

// Used to represent `[]` in the papers
def nil: List['a]
//│ nil: List[nothing]

def choose: 'a -> 'a -> 'a
//│ choose: 'a -> 'a -> 'a

def poly: (forall 'a. 'a -> 'a) -> (int, bool)
//│ poly: (forall 'a. 'a -> 'a) -> (int, bool,)

def auto : (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)
//│ auto: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)

def auto' : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ auto': (forall 'a. 'a -> 'a) -> 'b -> 'b

def ids: List[forall 'a. 'a -> 'a]
//│ ids: List[forall 'a. 'a -> 'a]

def id: 'a -> 'a
//│ id: 'a -> 'a

def length: List['a] -> int
//│ length: List[?] -> int

def single: 'a -> List['a]
//│ single: 'a -> List['a]

def cons: 'a -> List['a] -> List['a]
//│ cons: 'a -> List['a] -> List['a]

def append: List['a] -> List['a] -> List['a]
//│ append: List['a] -> List['a] -> List['a]

def inc: int -> int
//│ inc: int -> int

def map: ('a -> 'b) -> List['a] -> List['b]
//│ map: ('a -> 'b) -> List['a] -> List['b]

def app: ('a -> 'b) -> 'a -> 'b
//│ app: ('a -> 'b) -> 'a -> 'b

def revapp: 'a -> ('a -> 'b) -> 'b
//│ revapp: 'a -> ('a -> 'b) -> 'b

def flip: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
//│ flip: ('a -> 'b -> 'c) -> 'b -> 'a -> 'c

def runST: (forall 's. ST['s, 'v]) -> 'v
//│ runST: (forall 's. ST['s, 'v]) -> 'v

def argST: ST['s, int]
//│ argST: ST['s, int]


// ============ A. polymorphic instantiation ============

// A1
const2 x y = y
//│ const2: anything -> 'a -> 'a

// A2
choose id
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)

// A3
choose nil ids
//│ res: List[forall 'a. 'a -> 'a]

// A4
fun (x: forall 'a. 'a -> 'a) -> x x
//│ res: (forall 'a. 'a -> 'a) -> (forall 'a. 'a -> 'a)

// A4'
fun x -> x x
//│ res: ('a -> 'b & 'a) -> 'b

// A5
id auto
//│ res: (forall 'a. 'a -> 'a) -> (forall 'b. 'b -> 'b)

// A6
id auto'
//│ res: (forall 'a. 'a -> 'a) -> 'b -> 'b

// A7
choose id auto
//│ res: (forall 'a. 'a -> 'a & 'a0) -> (forall 'b. 'a0 | 'b -> 'b)

// A8
:ns
choose id auto'
//│ res: forall 'b. 'c
//│   where
//│     'c :> (forall 'a. 'a -> 'a) | (forall 'b. (forall 'a0. 'a0 -> 'a0) -> 'b -> 'b)

// A9
def f: ('a -> 'a) -> List['a] -> 'a
f (choose id) ids
//│ f: ('a -> 'a) -> List['a] -> 'a
//│ res: 'a -> 'a

// A10
poly id
//│ res: (int, bool,)

// A11
poly (fun x -> x)
//│ res: (int, bool,)

// A12
id poly (fun x -> x)
//│ res: (int, bool,)


// ============ B. inference of polymorphic arguments ============

// B1
fun f -> (f 1, f true)
//│ res: (true -> 'a & 1 -> 'b) -> ('b, 'a,)

// B2
fun xs -> poly (head xs)
//│ res: List[forall 'a. 'a -> 'a] -> (int, bool,)


// ============ C. functions on polymorphic lists ============

// C1
length ids
//│ res: int

// C2
tail ids
//│ res: List[forall 'a. 'a -> 'a]

// C3
head ids
//│ res: 'a -> 'a

// C4
single id
//│ res: List[forall 'a. 'a -> 'a]

// C5
cons id ids
//│ res: List[forall 'a. 'a -> 'a]

// C6
cons (fun x -> x) ids
//│ res: List[forall 'a. 'a -> 'a]

// C7
append (single inc) (single id)
//│ res: List[int -> int]

// C8
def g: List['a] -> List['a] -> 'a
g (single id) ids
//│ g: List['a] -> List['a] -> 'a
//│ res: 'a -> 'a

// C9
map poly (single id)
//│ res: List[(int, bool,)]

// C10
map head (single ids)
//│ res: List[forall 'a. 'a -> 'a]


// ============ D. application functions ============

// D1
app poly id
//│ res: (int, bool,)

// D2
revapp id poly
//│ res: (int, bool,)

// D3
runST argST
//│ res: int

// D4
app runST argST
//│ res: int

// D5
revapp argST runST
//│ res: int


// ============ E. η-expansion ============

def h: int -> (forall 'a. 'a -> 'a)
def k: 'a -> List['a] -> 'a
def lst: List[forall 'a. int -> 'a -> 'a]
//│ h: int -> (forall 'a. 'a -> 'a)
//│ k: 'a -> List['a] -> 'a
//│ lst: List[forall 'a. int -> 'a -> 'a]

// E1
k h lst
//│ res: int -> 'a -> 'a

// E2
k (fun x -> h x) lst
//│ res: int -> 'a -> 'a

// E3
def r: (forall 'a. 'a -> (forall 'b. 'b -> 'b)) -> int
//│ r: (nothing -> (forall 'b. 'b -> 'b)) -> int
r (fun x -> fun y -> y)
//│ res: int

:ns
r
//│ res: (forall 'a. 'a -> (forall 'b. 'b -> 'b)) -> int


// ============ F. FreezeML Programs ============

// F5
auto id
//│ res: 'b -> 'b

// F6
cons (head ids) ids
//│ res: List[forall 'a. 'a -> 'a]

// F7
(head ids) 3
//│ res: 3

// F8
choose (head ids)
//│ res: 'a -> (forall 'a0. 'a | 'a0 -> 'a0)

// F9
let f = revapp id in f poly
//│ res: (int, bool,)

// F10
a = choose id (fun (x: (forall 'a. 'a -> 'a)) -> auto' x)
//│ a: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)

a id
//│ res: 'a -> 'a

choose id (fun x -> auto' x)
//│ res: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)

a = choose id auto'
//│ a: (forall 'a. 'a -> 'a & 'a0) -> ('a0 | 'b -> 'b)

a id
//│ res: 'a -> 'a






// ============ Expected error cases (useful for regression-testing error messages) ============

:e
choose id (fun (x: ('a -> 'a)) -> auto' x)  // Note: the type of argument x is not polymorphic enough
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.298: 	choose id (fun (x: ('a -> 'a)) -> auto' x)  // Note: the type of argument x is not polymorphic enough
//│ ║         	                                  ^^^^^^^
//│ ╟── type `anything` does not match type `nothing`
//│ ║  l.42: 	def auto' : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ║        	                    ^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	def auto' : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ╙──      	                    ^^
//│ res: (anything -> nothing & 'a) -> ('a | 'b -> 'b | error)

:e
a (fun x -> { u = x })
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.311: 	a (fun x -> { u = x })
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── record literal of type `{u: ?a}` is not an instance of type `'a`
//│ ║  l.311: 	a (fun x -> { u = x })
//│ ║         	            ^^^^^^^^^
//│ ╟── Note: constraint arises from quantified type variable:
//│ ║  l.42: 	def auto' : (forall 'a. 'a -> 'a) -> 'b -> 'b
//│ ╙──      	                    ^^
//│ res: ('b & 'a) -> ('b | {u: 'a}) | error


