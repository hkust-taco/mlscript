


def access0 arr = arr[0]
//│ access0: Array['a & ~undefined] -> (undefined | 'a)
//│        = [Function: access0]

def set0 arr x = arr[0] <- x
//│ set0: MutArray['a] -> 'a -> unit
//│     = [Function: set0]


access0((1,))
access0((mut 1,))
//│ res: 1 | undefined
//│    = 1
//│ res: 1 | undefined
//│    = 1

set0((mut 1,))
//│ res: anything -> unit
//│    = [Function (anonymous)]

:e
set0((1,))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.25: 	set0((1,))
//│ ║        	^^^^^^^^^^
//│ ╟── tuple field of type `1` is not mutable
//│ ║  l.25: 	set0((1,))
//│ ╙──      	      ^
//│ res: anything -> unit | error
//│    = [Function (anonymous)]


access0 emptyArray
//│ res: undefined
//│    = undefined

set0 emptyArray 42
//│ = []



def update0 i arr = arr[i] <- arr[i]
//│ update0: int -> MutArray[in undefined | 'a out 'a & ~undefined] -> unit
//│        = [Function: update0]

def update1 i arr = arr[i] <- let a = arr[i] in case a of undefined -> error, _ -> a
//│ update1: int -> MutArray[in 'a out 'a & ~undefined] -> unit
//│        = [Function: update1]

def update2 i arr = let a = arr[i] in arr[i] <- case a of undefined -> error, _ -> a
//│ update2: int -> MutArray[in 'a out 'a & ~undefined] -> unit
//│        = [Function: update2]


// * Strange that it's reported here
:e
update0 0 ((mut 1,))
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.60: 	update0 0 ((mut 1,))
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── possibly-undefined array access of type `undefined` does not match type `~undefined`
//│ ║  l.45: 	def update0 i arr = arr[i] <- arr[i]
//│ ║        	                              ^^^^^^
//│ ╟── Note: constraint arises from prohibited undefined element:
//│ ║  l.45: 	def update0 i arr = arr[i] <- arr[i]
//│ ║        	                              ^^^^^^
//│ ╟── from mutable tuple field:
//│ ║  l.60: 	update0 0 ((mut 1,))
//│ ╙──      	                ^
//│ res: error | unit
//│    = []

update1 0 ((mut 1,))
//│ = []

:re // FIXME
update2 0 ((mut 1,))
//│ Runtime error:
//│   TypeError: ((intermediate value) , []) is not a function




// * Weird stuff:


def foo: MutArray[int] & MutArray[string]
//│ foo: MutArray[in int | string out nothing]
//│    = <missing implementation>

:e
foo = emptyArray
//│ MutArray['a]
//│   <:  foo:
//│ MutArray[in int | string out nothing]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.95: 	foo = emptyArray
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.90: 	def foo: MutArray[int] & MutArray[string]
//│ ║        	                                  ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.90: 	def foo: MutArray[int] & MutArray[string]
//│ ╙──      	                  ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.95: 	foo = emptyArray
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.90: 	def foo: MutArray[int] & MutArray[string]
//│ ║        	                  ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.90: 	def foo: MutArray[int] & MutArray[string]
//│ ╙──      	                                  ^^^^^^
//│    = [Function: emptyArray] { '0': 42 }

:e
def bar x = (mut x,) : MutArray[int] & MutArray[string]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.120: 	def bar x = (mut x,) : MutArray[int] & MutArray[string]
//│ ║         	            ^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.120: 	def bar x = (mut x,) : MutArray[int] & MutArray[string]
//│ ║         	                                                ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.120: 	def bar x = (mut x,) : MutArray[int] & MutArray[string]
//│ ║         	                                ^^^
//│ ╟── from mutable tuple field:
//│ ║  l.120: 	def bar x = (mut x,) : MutArray[int] & MutArray[string]
//│ ╙──       	                 ^
//│ bar: nothing -> MutArray[in int | string out nothing]
//│    = [Function: bar]

foo[0]
//│ res: undefined
//│    = 42

fun x -> foo[0] <- x
//│ res: (int | string) -> unit
//│    = [Function: res]

access0 foo
set0 foo "ok"
//│ res: undefined
//│    = 42
//│ = []

update1 0 foo
//│ = []

foo: MutArray['a]
//│ res: MutArray['a]
//│   where
//│     'a <: int | string
//│    = [Function: emptyArray] { '0': 'ok' }

foo: MutArray['a] & MutArray['b]
//│ res: MutArray[in (int | string) & 'a | (int | string) & 'b out 'a & 'b]
//│    = [Function: emptyArray] { '0': 'ok' }

foo[0]
//│ res: undefined
//│    = 'ok'

foo: MutArray['a] | MutArray['b]
//│ res: MutArray[in 'b & (int | string | ~'b) out 'b]
//│    = [Function: emptyArray] { '0': 'ok' }

foo[0]
//│ res: undefined
//│    = 'ok'


