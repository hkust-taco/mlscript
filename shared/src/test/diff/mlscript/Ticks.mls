:js
f' = 2
//│ // Prelude
//│ let res;
//│ // Query 1
//│ globalThis.f$ = 2;
//│ // End of generated code
//│ f': 2
//│   = 2

:js
f'
//│ // Query 1
//│ res = f$;
//│ // End of generated code
//│ res: 2
//│    = 2

:js
f' + 2
//│ // Query 1
//│ res = f$ + 2;
//│ // End of generated code
//│ res: int
//│    = 4

:js
trait Foo'[T']
  method Bar': T' -> T'
//│ Defined trait Foo'[=T']
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

:js
class A'[B'] : {x': B'}
  method C' = this.x'
//│ Defined class A'[+B']
//│ Defined A'.C': A'['B'] -> 'B'
//│ // Prelude
//│ class A$ {
//│   constructor(fields) {
//│     this["x'"] = fields["x'"];
//│   }
//│   get "C'"() {
//│     const self = this;
//│     return self["x'"];
//│   }
//│ }
//│ // End of generated code

:js
class M : {x': int}
  method N' = this.x'
  method P' y' = this.x' + y'
mm = M{ x' = 2 }
mm.N'
mm.P' f'
//│ Defined class M
//│ Defined M.N': M -> int
//│ Defined M.P': M -> int -> int
//│ // Prelude
//│ class M {
//│   constructor(fields) {
//│     this["x'"] = fields["x'"];
//│   }
//│   get "N'"() {
//│     const self = this;
//│     return self["x'"];
//│   }
//│   "P'"(y$) {
//│     const self = this;
//│     return self["x'"] + y$;
//│   }
//│ }
//│ // Query 1
//│ globalThis.mm = new M({ "x'": 2 });
//│ // Query 2
//│ res = mm["N'"];
//│ // Query 3
//│ res = mm["P'"](f$);
//│ // End of generated code
//│ mm: M & {x': 2}
//│   = M { "x'": 2 }
//│ res: int
//│    = 2
//│ res: int
//│    = 4

:js
class D'[B'] : A'[B']
//│ Defined class D'[+B']
//│ // Prelude
//│ class D$ extends A$ {
//│   constructor(fields) {
//│     super(fields);
//│   }
//│ }
//│ // End of generated code

:js
type E' = D'[int] | A'[int]
//│ Defined type alias E'
//│ // End of generated code

:js
class None': {}
//│ Defined class None'
//│ // Prelude
//│ class None$ {}
//│ // End of generated code

:js
class CC': None' & Foo'[anything]
//│ Defined class CC'
//│ Code generation encountered an error:
//│   undeclared type name Foo' when resolving base classes

:js
class TT' : { a': int }
//│ Defined class TT'
//│ // Prelude
//│ class TT$ {
//│   constructor(fields) {
//│     this["a'"] = fields["a'"];
//│   }
//│ }
//│ // End of generated code

:js
tt' = TT'{a'=4}
tt'.a'
//│ // Query 1
//│ globalThis.tt$ = new TT$({ "a'": 4 });
//│ // Query 2
//│ res = tt$["a'"];
//│ // End of generated code
//│ tt': TT' & {a': 4}
//│    = TT$ { "a'": 4 }
//│ res: 4
//│    = 4

:js
a' = {b' = 42}
//│ // Query 1
//│ globalThis.a$ = { "b'": 42 };
//│ // End of generated code
//│ a': {b': 42}
//│   = { "b'": 42 }

:js
a'.b'
//│ // Query 1
//│ res = a$["b'"];
//│ // End of generated code
//│ res: 42
//│    = 42

:js
def g' x' = x' with { c' = 24 }
//│ // Prelude
//│ function withConstruct(target, fields) {
//│   if (typeof target === "string" || typeof target === "number" || typeof target === "boolean" || typeof target === "bigint" || typeof target === "symbol") {
//│     return Object.assign(target, fields);
//│   }
//│   if (target instanceof String || target instanceof Number || target instanceof Boolean || target instanceof BigInt) {
//│     return Object.assign(target.valueOf(), target, fields);
//│   }
//│   if (Array.isArray(target)) {
//│     const clone = Array.from(target);
//│     for (const key in target){
//│       clone[key] = target[key];
//│     }
//│     for (const key in fields){
//│       clone[key] = fields[key];
//│     }
//│     return clone;
//│   }
//│   if (target == null) {
//│     return Object.assign({}, {}, fields);
//│   }
//│   const copy = Object.assign({}, target, fields);
//│   Object.setPrototypeOf(copy, Object.getPrototypeOf(target));
//│   return copy;
//│ }
//│ // Query 1
//│ globalThis.g$ = function g$(x$) {
//│   return withConstruct(x$, { "c'": 24 });
//│ };
//│ // End of generated code
//│ g': 'a -> ('a\c' & {c': 24})
//│   = [Function: g$]

:js
gg' = let w' = 2 in w' + w'
//│ // Query 1
//│ globalThis.gg$ = ((w$) => w$ + w$)(2);
//│ // End of generated code
//│ gg': int
//│    = 4

:js
rcd' = { x' = 1 }
rcd'.x'
//│ // Query 1
//│ globalThis.rcd$ = { "x'": 1 };
//│ // Query 2
//│ res = rcd$["x'"];
//│ // End of generated code
//│ rcd': {x': 1}
//│     = { "x'": 1 }
//│ res: 1
//│    = 1

:js
foo { x' } = x'
//│ // Query 1
//│ globalThis.foo = function foo({ "x'": x$ }) {
//│   return x$;
//│ };
//│ // End of generated code
//│ foo: {x': 'a} -> 'a
//│    = [Function: foo]

:js
foo { x' = y' } = y'
//│ // Query 1
//│ globalThis.foo1 = function foo1({ "x'": y$ }) {
//│   return y$;
//│ };
//│ // End of generated code
//│ foo: {x': 'a} -> 'a
//│    = [Function: foo1]

:js
trait T : {x': int}
  method N' = this.x'
  method P' y' = this.x' + y'
  method Q ((y', {z'})) = this.x' + y' + z'
//│ Defined trait T
//│ /!!!\ Uncaught error: java.lang.IllegalArgumentException: requirement failed
//│ 	at: scala.Predef$.require(Predef.scala:324)
//│ 	at: mlscript.TypeDefs.clsNameToNomTag(TypeDefs.scala:122)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.$anonfun$mkTag$1(TyperHelpers.scala:1093)
//│ 	at: scala.Option.getOrElse(Option.scala:201)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperHelpers$TypeRefImpl.mkTag$(TyperHelpers.scala:1091)
//│ 	at: mlscript.TyperDatatypes$TypeRef.mkTag(TyperDatatypes.scala:363)
//│ 	at: mlscript.NormalForms$DNF$.mk(NormalForms.scala:707)
//│ 	at: mlscript.TypeSimplifier.$anonfun$normalizeTypes_$bang$106(TypeSimplifier.scala:464)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:32)

:js
let f' = fun x -> x + 1 in f' 2
//│ // Query 1
//│ res = ((f$) => f$(2))((x) => x + 1);
//│ // End of generated code
//│ res: int
//│    = 3

:js
foo { return } = return
//│ // Query 1
//│ globalThis.foo2 = function foo2({ "return": return$ }) {
//│   return return$;
//│ };
//│ // End of generated code
//│ foo: {return: 'a} -> 'a
//│    = [Function: foo2]

foo { return = 1 }
//│ res: 1
//│    = 1
