class Foo[A]: { x: A }
    method Map[B]: (A -> B) -> A
class Bar[A]: Foo[A]
    method Map[B]: B -> A
    rec method Map f = f Map (fun x -> Map)
class Derp: Bar[bool]
    method Map f = true
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `_α26` is not a function
//│ ╟── Note: constraint arises from application:
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ╙──     	                       ^^^^^
//│ Defined class Foo
//│ Defined class Bar
//│ Defined class Derp

Foo.Map
Bar.Map
Derp.Map
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.19: 	Foo.Map
//│ ║        	^^^
//│ ╙── expression of type `{x: ?a} -> foo & {x: ?a}` does not have field 'Map'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.20: 	Bar.Map
//│ ║        	^^^
//│ ╙── expression of type `{x: ?a} -> bar & {x: ?a}` does not have field 'Map'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.21: 	Derp.Map
//│ ║        	^^^^
//│ ╙── expression of type `{x: bool & ?a} -> derp & {x: ?a}` does not have field 'Map'
//│ res: error

def a = Foo { x = 1 }
a.(Foo.Map)(fun x -> x)
//│ a: foo & {x: 1}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.39: 	a.(Foo.Map)(fun x -> x)
//│ ║        	^
//│ ╟── expression of type `foo & {x: ?a | 1}` does not match type `{Foo.Map: ?b}`
//│ ║  l.38: 	def a = Foo { x = 1 }
//│ ║        	        ^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{Foo.Map: ?c}`
//│ ║  l.39: 	a.(Foo.Map)(fun x -> x)
//│ ╙──      	^
//│ res: error

class bar[A, B]: Foo[A] & { Y: B; z: int }
    method identity z = z
    method identity z = z
//│ ╔══[ERROR] Type names must start with a capital letter
//│ ║  l.52: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	      ^^^
//│ ╔══[ERROR] Field identifiers must start with a small letter
//│ ║  l.52: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	                            ^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.54: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ Defined class bar

class Fooo[A, B]: { x: A; y: B }
    method Fun[C]: (A -> B -> C) -> (A -> B -> C)
//│ Defined class Fooo

class Barr: Fooo[int, bool]
    method Fun[C] f = f
//│ Defined class Barr

// Fooo -> PolymorphicType(0,({x: α8', y: α9'} -> ((fooo<> & {x: α6', y: α7'}) & {x: α8', y: α9'})))
// Fooo.Fun -> PolymorphicType(1,((α3' -> (α4' -> α10'')) -> (α3' -> (α4' -> α10''))))
// Barr -> PolymorphicType(0,({x: α2', y: α3'} -> ((barr<fooo> & Fooo[int,bool]) & {x: α2', y: α3'})))
// Barr.Fun -> PolymorphicType(1,(α4'' -> [α4'']))

Fooo.Fun
Barr.Fun
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.79: 	Fooo.Fun
//│ ║        	^^^^
//│ ╙── expression of type `{x: ?a, y: ?b} -> fooo & {y: ?b, x: ?a}` does not have field 'Fun'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.80: 	Barr.Fun
//│ ║        	^^^^
//│ ╙── expression of type `{x: int & ?a, y: bool & ?b} -> barr & {y: ?b, x: ?a}` does not have field 'Fun'
//│ res: error

//TODO: - apply targs in ss (long map chain?)
//      - references between methods (shodowing)
//      - this
//      - calls
//      - bounds on rigidified variables?
//      - ConstraintSolver.constrain.annoyingImpl missing cases?

class Fo[A, B]: { x: A; y: B }
    method Left = { x = x; y = y } : { x: A }
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.100: 	    method Left = { x = x; y = y } : { x: A }
//│ ╙──       	                        ^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.100: 	    method Left = { x = x; y = y } : { x: A }
//│ ╙──       	                               ^
//│ Defined class Fo
