class Foo[A]: { x: A }
    method Map[B]: (A -> B) -> A
class Bar[A]: Foo[A]
    // method Map[B]: B -> A
    rec method Map f = f Map (fun x -> Map)
class Derp: Bar[bool]
    method Map f = true
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `(?b & (?c | ?a -> ((?d -> ?c | ?a) -> ?e) & ?f) & ?g -> ?e) as ?a` does not match type `_α23`
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ╙──     	                   ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `_α24` is not a function
//│ ╟── Note: constraint arises from application:
//│ ║  l.5: 	    rec method Map f = f Map (fun x -> Map)
//│ ╙──     	                       ^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.7: 	    method Map f = true
//│ ║       	           ^^^^^^^^^^^^
//│ ╟── expression of type `true` does not match type `_α39`
//│ ║  l.7: 	    method Map f = true
//│ ║       	                   ^^^^
//│ ╟── but it flows into function of type `?a -> true`
//│ ║  l.7: 	    method Map f = true
//│ ║       	               ^^^^^^^^
//│ ╟── which does not match type `(_α39 -> _α40) -> _α39`
//│ ╟── Note: constraint arises from function type:
//│ ║  l.2: 	    method Map[B]: (A -> B) -> A
//│ ╙──     	                    ^^^^^^^^^^^^
//│ Defined class Foo
//│ Defined class Bar
//│ Defined class Derp

Foo.Map
Bar.Map
Derp.Map
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.38: 	Foo.Map
//│ ║        	^^^
//│ ╙── expression of type `{x: ?a} -> foo & {x: ?a}` does not have field 'Map'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.39: 	Bar.Map
//│ ║        	^^^
//│ ╙── expression of type `{x: ?a} -> bar & {x: ?a}` does not have field 'Map'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.40: 	Derp.Map
//│ ║        	^^^^
//│ ╙── expression of type `{x: bool & ?a} -> derp & {x: ?a}` does not have field 'Map'
//│ res: error

def a = Foo { x = 1 }
a.(Foo.Map)(fun x -> x)
//│ a: foo & {x: 1}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.58: 	a.(Foo.Map)(fun x -> x)
//│ ║        	^
//│ ╟── expression of type `foo & {x: ?a | 1}` does not match type `{Foo.Map: ?b}`
//│ ║  l.57: 	def a = Foo { x = 1 }
//│ ║        	        ^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{Foo.Map: ?c}`
//│ ║  l.58: 	a.(Foo.Map)(fun x -> x)
//│ ╙──      	^
//│ res: error

class bar[A, B]: Foo[A] & { Y: B; z: int }
    method identity z = z
    method identity z = z
//│ ╔══[ERROR] Type names must start with a capital letter
//│ ║  l.71: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	      ^^^
//│ ╔══[ERROR] Field identifiers must start with a small letter
//│ ║  l.71: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	                               ^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.73: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ Defined class bar

class Fooo[A, B]: { x: A; y: B }
    method Fun[C]: (A -> B -> C) -> (A -> B -> C)
//│ Defined class Fooo

class Barr: Fooo[int, bool]
    method Fun[C] f = f
//│ Defined class Barr

// Fooo -> PolymorphicType(0,({x: α8', y: α9'} -> ((fooo<> & {x: α6', y: α7'}) & {x: α8', y: α9'})))
// Fooo.Fun -> PolymorphicType(1,((α3' -> (α4' -> α10'')) -> (α3' -> (α4' -> α10''))))
// Barr -> PolymorphicType(0,({x: α2', y: α3'} -> ((barr<fooo> & Fooo[int,bool]) & {x: α2', y: α3'})))
// Barr.Fun -> PolymorphicType(1,(α4'' -> [α4'']))

Fooo.Fun
Barr.Fun
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.98: 	Fooo.Fun
//│ ║        	^^^^
//│ ╙── expression of type `{x: ?a, y: ?b} -> fooo & {x: ?a, y: ?b}` does not have field 'Fun'
//│ res: error
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.99: 	Barr.Fun
//│ ║        	^^^^
//│ ╙── expression of type `{x: int & ?a, y: bool & ?b} -> barr & {x: ?a, y: ?b}` does not have field 'Fun'
//│ res: error

//TODO: - apply targs in ss (long map chain?)
//      - references between methods (shodowing)
//      - this
//      - calls
//      - bounds on rigidified variables?
//      - ConstraintSolver.constrain.annoyingImpl missing cases?

class Fo[A, B]: { x: A; y: B }
    method Left = { x = x; y = y } : { x: A }
//│ ╔══[ERROR] identifier not found: x
//│ ║  l.119: 	    method Left = { x = x; y = y } : { x: A }
//│ ╙──       	                        ^
//│ ╔══[ERROR] identifier not found: y
//│ ║  l.119: 	    method Left = { x = x; y = y } : { x: A }
//│ ╙──       	                               ^
//│ ╔══[ERROR] type identifier not found: A
//│ ║  l.119: 	    method Left = { x = x; y = y } : { x: A }
//│ ╙──       	                                          ^
//│ Defined class Fo
