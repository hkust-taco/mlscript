//TODO: - references between methods (shodowing)
//      - implicit calls
//      - ConstraintSolver.extrude TypeRef polarity
//      - ConstraintSolver.constrain.annoyingImpl missing cases?


class Foo[A, B]: { x: A; y: B }
    method Fun[C]: (A -> B -> C) -> (A -> B -> C)
//│ Defined class Foo
//│ Declared Foo.Fun: foo & {y: 'a, x: 'b} -> ('b -> 'a -> 'c) -> 'b -> 'a -> 'c

class Bar: Foo[int, bool]
    method Fun f = f
//│ Defined class Bar
//│ Defined Bar.Fun: bar & {y: bool, x: int} -> 'a -> 'a

Foo.Fun
Bar.Fun
//│ res: foo & {y: 'a, x: 'b} -> ('b -> 'a -> 'c) -> 'b -> 'a -> 'c
//│ res: bar & {y: bool, x: int} -> 'a -> 'a

f = Foo { x = 1; y = 2 }
//│ f: foo & {y: 2, x: 1}

f.(Foo.Fun)
//│ res: ('a | 1 -> 'b | 2 -> 'c) -> 'a -> 'b -> 'c

Foo.Fun f
//│ res: ('a | 1 -> 'b | 2 -> 'c) -> 'a -> 'b -> 'c

// TODO impl
:e
f.Fun
//│ ╔══[ERROR] Method Fun not found
//│ ║  l.33: 	f.Fun
//│ ╙──      	^^^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.33: 	f.Fun
//│ ║        	^^^^^
//│ ╟── expression of type `foo & {y: ?a | 2, x: ?b | 1}` does not match type `{Fun: ?c}`
//│ ║  l.22: 	f = Foo { x = 1; y = 2 }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{Fun: ?d}`
//│ ║  l.33: 	f.Fun
//│ ╙──      	^
//│ res: error




class Asc[A, B]: { x: A; y: B }
    method Left = { x = this.x; y = this.y } : { x: A }
    method Right2 = this : { y: B }
//│ Defined class Asc
//│ Defined Asc.Left: asc & {y: anything, x: 'a} -> {x: 'a}
//│ Defined Asc.Right2: asc & {y: 'a, x: anything} -> {y: 'a}




class Simple[A]
    method Get: A
//│ Defined class Simple
//│ Declared Simple.Get: simple -> nothing

class Simple2[A]: { a: A }
    method Get: A
//│ Defined class Simple2
//│ Declared Simple2.Get: simple2 & {a: 'a} -> 'a




class AbstractPair[A, B]: { x: A; y: B }
    method Test: (A -> B -> bool) -> bool
    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ Defined class AbstractPair
//│ Declared AbstractPair.Test: abstractPair & {y: 'a, x: 'b} -> ('b -> 'a -> bool) -> bool
//│ Declared AbstractPair.Map: abstractPair & {y: 'a, x: 'b} -> ('b -> 'c) -> ('a -> 'd) -> abstractPair & {y: 'd, x: 'c}

class Pair[A, B]: AbstractPair[A, B]
    method Test(f: A -> B -> bool) = f this.x this.y
    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ Defined class Pair
//│ Defined Pair.Test: pair & {y: 'a, x: 'b} -> ('b -> 'a -> bool & 'c) -> 'c
//│ Defined Pair.Map: pair & {y: 'a, x: 'b} -> ('b -> 'c) -> ('a -> 'd) -> pair & {y: 'd, x: 'c}

class True[A, B]: Pair[A, B]
    method Test f = true
//│ Defined class True
//│ Defined True.Test: true & {y: anything, x: anything} -> anything -> true
