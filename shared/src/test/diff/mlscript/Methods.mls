class Foo[A, B]: { x: A; y: B }
    method Fun[C]: (A -> B -> C) -> (A -> B -> C)
    method Fun[C, D] (f: C -> D) = f
//│ Defined class Foo
//│ Declared Foo.Fun: (foo & {Foo#A = 'A, Foo#B = 'B, x: 'A, y: 'B}) -> ('A -> 'B -> 'C) -> 'A -> 'B -> 'C
//│ Defined Foo.Fun: (foo & {Foo#A = 'A, Foo#B = 'B, x: 'A, y: 'B}) -> (nothing -> anything & 'a) -> 'a

class Bar: Foo[int, bool]
    method Fun f = f
//│ Defined class Bar
//│ Defined Bar.Fun: (bar & {Foo#A = int, Foo#B = bool, x: int, y: bool}) -> 'a -> 'a

Foo.Fun
Bar.Fun
//│ res: (foo & {Foo#A = 'A, Foo#B = 'B, x: 'A, y: 'B}) -> ('A -> 'B -> 'C) -> 'A -> 'B -> 'C
//│ res: (bar & {Foo#A = int, Foo#B = bool, x: int, y: bool}) -> (int -> bool -> 'C) -> int -> bool -> 'C

f = Foo { x = 1; y = 2 }
//│ f: foo & {Foo#A :> 'A <: 1 | 'A, Foo#B :> 'B <: 2 | 'B, x: 1, y: 2}

f.(Foo.Fun)
//│ res: ((1 | 'A) -> (2 | 'B) -> 'C) -> 'A -> 'B -> 'C

Foo.Fun f
//│ res: ((1 | 'A) -> (2 | 'B) -> 'C) -> 'A -> 'B -> 'C

f.Fun
//│ res: ((1 | 'A) -> (2 | 'B) -> 'C) -> 'A -> 'B -> 'C

// :d
Bar
//│ res: {x: int & 'x, y: bool & 'y} -> (bar & {Foo#A = int, Foo#B = bool, x: 'x, y: 'y})

g = Bar { x = 42; y = true }
//│ g: bar & {Foo#A = int, Foo#B = bool, x: 42, y: true}

g.(Foo.Fun)
g.(Bar.Fun)
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C

Foo.Fun g
Bar.Fun g
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C

g.Fun
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C

h = Bar { x = 43; y = true }
h.Fun
//│ h: bar & {Foo#A = int, Foo#B = bool, x: 43, y: true}
//│ res: (int -> bool -> 'C) -> int -> bool -> 'C




class Wrapper[A]: { x: A }
    method Apply f = Wrapper { x = f this.x }
    method Apply[B]: (A -> B) -> Wrapper[B]
    // method Apply f = Wrapper { x = f this.x }
//│ Defined class Wrapper
//│ Declared Wrapper.Apply: (wrapper & {Wrapper#A = 'A, x: 'A}) -> ('A -> 'B) -> (wrapper & {Wrapper#A = 'B, x: 'B})
//│ Defined Wrapper.Apply: (wrapper & {Wrapper#A = 'A, x: 'A}) -> ('A -> ('a & 'A0)) -> (wrapper & {Wrapper#A = 'A0, x: 'a})

class IntWrapper: Wrapper[int]
    method Apply f = Wrapper { x = f this.x }
//│ Defined class IntWrapper
//│ Defined IntWrapper.Apply: (intWrapper & {Wrapper#A = int, x: int}) -> (int -> ('a & 'A)) -> (wrapper & {Wrapper#A = 'A, x: 'a})

class Psyduck[B]: Wrapper[B]
    method Apply[A]: (B -> A) -> Psyduck[A]
    method Apply f = Psyduck { x = f this.x }
//│ Defined class Psyduck
//│ Declared Psyduck.Apply: (psyduck & {Psyduck#B = 'B, Wrapper#A = 'B, x: 'B}) -> ('B -> 'A) -> (psyduck & {Psyduck#B = 'A, Wrapper#A = 'A, x: 'A})
//│ Defined Psyduck.Apply: (psyduck & {Psyduck#B = 'B, Wrapper#A = 'B, x: 'B}) -> ('B -> ('a & 'B0)) -> (psyduck & {Psyduck#B = 'B0, Wrapper#A = 'B0, x: 'a})

class WrapperWrapper[A]: Wrapper[Wrapper[A]]
    method Apply2[B]: (A -> B) -> WrapperWrapper[B]
    method Apply2 f = WrapperWrapper { x = this.x.Apply f }
//│ Defined class WrapperWrapper
//│ Declared WrapperWrapper.Apply2: (wrapperWrapper & {Wrapper#A = wrapper & {Wrapper#A = 'A, x: 'A}, WrapperWrapper#A = 'A, x: wrapper & {Wrapper#A = 'A, x: 'A}}) -> ('A -> 'B) -> (wrapperWrapper & {Wrapper#A = wrapper & {Wrapper#A = 'B, x: 'B}, WrapperWrapper#A = 'B, x: wrapper & {Wrapper#A = 'B, x: 'B}})
//│ Defined WrapperWrapper.Apply2: (wrapperWrapper & {Wrapper#A = wrapper & {Wrapper#A = 'A, x: 'A}, WrapperWrapper#A = 'A, x: wrapper & {Wrapper#A = 'A, x: 'A}}) -> ('A -> 'a) -> (wrapperWrapper & {Wrapper#A = wrapper & {Wrapper#A = 'a, x: 'a}, WrapperWrapper#A = 'a, x: wrapper & {Wrapper#A = 'a, x: 'a}})

WrapperWrapper { x = Psyduck { x = 0 } }
//│ res: wrapperWrapper & {Wrapper#A :> wrapper & {Wrapper#A :> 0 | 'A <: 'A, x: 'A} <: wrapper & {Wrapper#A :> 'A <: 0 | 'A, x: 0 | 'A}, WrapperWrapper#A :> 'A <: 0 | 'A, x: psyduck & {Psyduck#B :> 'A <: 0 | 'A, Wrapper#A :> 'A <: 0 | 'A, x: 0}}

res.Apply2 (fun x -> mul x 2)
//│ res: wrapperWrapper & {Wrapper#A :> wrapper & {Wrapper#A :> 'B | int <: 'B, x: 'B} <: wrapper & {Wrapper#A :> 'B <: 'B | int, x: 'B | int}, WrapperWrapper#A :> 'B <: 'B | int, x: wrapper & {Wrapper#A :> 'B <: 'B | int, x: 'B | int}}

Wrapper
//│ res: {x: 'x & 'A} -> (wrapper & {Wrapper#A = 'A, x: 'x})




class Asc[A, B]: { x: A; y: B }
    method Left = { x = this.x; y = this.y } : { x: A }
    method Right2 = this : { y: B }
//│ Defined class Asc
//│ Defined Asc.Left: (asc & {Asc#A = 'A, Asc#B = 'B, x: 'A, y: 'B}) -> {x: 'A}
//│ Defined Asc.Right2: (asc & {Asc#A = 'A, Asc#B = 'B, x: 'A, y: 'B}) -> {y: 'B}




class Simple[A]
    method Get: A
//│ Defined class Simple
//│ Declared Simple.Get: (simple & {Simple#A = 'A}) -> 'A

class Simple2[A]: { a: A }
    method Get: A
//│ Defined class Simple2
//│ Declared Simple2.Get: (simple2 & {Simple2#A = 'A, a: 'A}) -> 'A




class AbstractPair[A, B]: { x: A; y: B }
    method Test: (A -> B -> bool) -> bool
    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ Defined class AbstractPair
//│ Declared AbstractPair.Test: (abstractPair & {AbstractPair#A = 'A, AbstractPair#B = 'B, x: 'A, y: 'B}) -> ('A -> 'B -> bool) -> bool
//│ Declared AbstractPair.Map: (abstractPair & {AbstractPair#A = 'A, AbstractPair#B = 'B, x: 'A, y: 'B}) -> ('A -> 'C) -> ('B -> 'D) -> (abstractPair & {AbstractPair#A = 'C, AbstractPair#B = 'D, x: 'C, y: 'D})

class Pair[A, B]: AbstractPair[A, B]
    method Test(f: A -> B -> bool) = f this.x this.y
    method Map fx fy = Pair { x = fx this.x; y = fy this.y }
//│ Defined class Pair
//│ Defined Pair.Test: (pair & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, x: 'A, y: 'B}) -> ('A -> 'B -> (bool & 'a)) -> 'a
//│ Defined Pair.Map: (pair & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, x: 'A, y: 'B}) -> ('A -> ('a & 'A0)) -> ('B -> ('b & 'B0)) -> (pair & {AbstractPair#A = 'A0, AbstractPair#B = 'B0, Pair#A = 'A0, Pair#B = 'B0, x: 'a, y: 'b})

class True[A, B]: Pair[A, B]
    method Test f = true
    method True = this.Test (fun x -> error)
//│ Defined class True
//│ Defined True.Test: (true & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, True#A = 'A, True#B = 'B, x: 'A, y: 'B}) -> anything -> true
//│ Defined True.True: (true & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, True#A = 'A, True#B = 'B, x: 'A, y: 'B}) -> true

class True2[A, B]: Pair[A, B]
    method Test: anything -> bool
    method True = this.Test (fun x -> error)
    method Test f = true
//│ Defined class True2
//│ Declared True2.Test: (true2 & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, True2#A = 'A, True2#B = 'B, x: 'A, y: 'B}) -> anything -> bool
//│ Defined True2.True: (true2 & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, True2#A = 'A, True2#B = 'B, x: 'A, y: 'B}) -> bool
//│ Defined True2.Test: (true2 & {AbstractPair#A = 'A, AbstractPair#B = 'B, Pair#A = 'A, Pair#B = 'B, True2#A = 'A, True2#B = 'B, x: 'A, y: 'B}) -> anything -> true

p = Pair { x = 42; y = true }
fx = fun x -> mul x 2
fy = fun x -> not x
ft = fun x -> fun y -> if (y) then gt x 0 else y
//│ p: pair & {AbstractPair#A :> 'A <: 42 | 'A, AbstractPair#B :> 'B <: 'B | true, Pair#A :> 'A <: 42 | 'A, Pair#B :> 'B <: 'B | true, x: 42, y: true}
//│ fx: int -> int
//│ fy: bool -> bool
//│ ft: int -> bool -> bool

p.Map fx fy
p.Test ft
(p.Map fx fy).Test ft
//│ res: abstractPair & {AbstractPair#A :> 'C <: 'C | int, AbstractPair#B :> 'D <: 'D | bool, x: 'C | int, y: 'D | bool}
//│ res: bool
//│ res: bool

t = True { x = "foo"; y = false }
t.(True.True)
//│ t: true & {AbstractPair#A :> 'A <: "foo" | 'A, AbstractPair#B :> 'B <: 'B | false, Pair#A :> 'A <: "foo" | 'A, Pair#B :> 'B <: 'B | false, True#A :> 'A <: "foo" | 'A, True#B :> 'B <: 'B | false, x: "foo", y: false}
//│ res: true

t = True2 { x = "bar"; y = false }
t.(True2.True)
//│ t: true2 & {AbstractPair#A :> 'A <: "bar" | 'A, AbstractPair#B :> 'B <: 'B | false, Pair#A :> 'A <: "bar" | 'A, Pair#B :> 'B <: 'B | false, True2#A :> 'A <: "bar" | 'A, True2#B :> 'B <: 'B | false, x: "bar", y: false}
//│ res: bool


class Class1A[A]
    method MtdA: A
trait Trait1A[B]
    method MtdA: B
class Class1B: Class1A["a" | "b"] & Trait1A["b" | "c"]
    method MtdA = "b"
//│ Defined class Class1A
//│ Declared Class1A.MtdA: (class1A & {Class1A#A = 'A}) -> 'A
//│ Defined trait Trait1A
//│ Declared Trait1A.MtdA: ({Trait1A#B = 'B} & trait1A) -> 'B
//│ Defined class Class1B
//│ Defined Class1B.MtdA: (class1B & {Class1A#A = "a" | "b", Trait1A#B = "b" | "c"} & trait1A) -> "b"


trait Trait2A[A]
    method MtdB: A
class Class2B[A, B]: Class1A[A] & Trait2A[B]
    method MtdA: A
    method MtdB: B
class Class2C: Class2B[int, bool]
    method MtdA = 42
    method MtdB = true
//│ Defined trait Trait2A
//│ Declared Trait2A.MtdB: ({Trait2A#A = 'A} & trait2A) -> 'A
//│ Defined class Class2B
//│ Declared Class2B.MtdA: (class2B & {Class1A#A = 'A, Class2B#A = 'A, Class2B#B = 'B, Trait2A#A = 'B} & trait2A) -> 'A
//│ Declared Class2B.MtdB: (class2B & {Class1A#A = 'A, Class2B#A = 'A, Class2B#B = 'B, Trait2A#A = 'B} & trait2A) -> 'B
//│ Defined class Class2C
//│ Defined Class2C.MtdA: (class2C & {Class1A#A = int, Class2B#A = int, Class2B#B = bool, Trait2A#A = bool} & trait2A) -> 42
//│ Defined Class2C.MtdB: (class2C & {Class1A#A = int, Class2B#A = int, Class2B#B = bool, Trait2A#A = bool} & trait2A) -> true


:e
class Class3C: Class2C
    method MtdA = 42
    method MtdB = 42
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.212: 	    method MtdB = 42
//│ ║         	           ^^^^^^^^^
//│ ╟── expression of type `42` does not match type `bool`
//│ ║  l.212: 	    method MtdB = 42
//│ ║         	                  ^^
//│ ╟── but it flows into method definition with expected type `bool`
//│ ║  l.212: 	    method MtdB = 42
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.196: 	class Class2C: Class2B[int, bool]
//│ ║         	                            ^^^^
//│ ╟── from method declaration:
//│ ║  l.195: 	    method MtdB: B
//│ ╙──       	           ^^^^^^^
//│ Defined class Class3C
//│ Defined Class3C.MtdA: (class3C & {Class1A#A = int, Class2B#A = int, Class2B#B = bool, Trait2A#A = bool} & trait2A) -> 42
//│ Defined Class3C.MtdB: (class3C & {Class1A#A = int, Class2B#A = int, Class2B#B = bool, Trait2A#A = bool} & trait2A) -> 42

type Id[T] = T
class Test1[A]: { x: A }
    method F: A
class Test2[B]: Test1[Id[B]] & { x: B }
    method F = this.x
//│ Defined type alias Id
//│ Defined class Test1
//│ Declared Test1.F: (test1 & {Test1#A = 'A, x: 'A}) -> 'A
//│ Defined class Test2
//│ Defined Test2.F: (test2 & {Test1#A = 'B, Test2#B = 'B, x: 'B}) -> 'B


class Test3A: Test1['a -> 'a]
Test3A.F
//│ Defined class Test3A
//│ res: (test3A & {Test1#A = 'a -> 'a, x: 'a -> 'a}) -> 'a0 -> 'a0

class Test3B: Test1['a -> 'a] & { x: 'a }
Test3B.F
//│ Defined class Test3B
//│ res: (test3B & {Test1#A = 'a -> 'a, x: 'a -> 'a & 'a}) -> 'a0 -> 'a0




:w
class Test4A[A]: { x: A }
    method Mth4A[A]: A
//│ ╔══[WARNING] Method type parameter A
//│ ║  l.258: 	class Test4A[A]: { x: A }
//│ ║         	             ^
//│ ╟── shadows class type parameter A
//│ ║  l.259: 	    method Mth4A[A]: A
//│ ╙──       	                 ^
//│ Defined class Test4A
//│ Declared Test4A.Mth4A: (test4A & {Test4A#A = 'A, x: 'A}) -> nothing
