
class Test: { value: int }
//│ Defined class Test

def foo x = case x of
  { Test -> x.value
  | _ -> 1
  }
//│ foo: ((test & {value: 'a}) | (anything & ~test)) -> 'a | 1

// Q: why type of `value` widened?
def t = Test { value = 0 }
//│ t: test & {value: int}

foo Test
//│ res: nothing | 1

foo t
//│ res: int | 1


class Toast: { name: string }
//│ Defined class Toast

def bar x = case x of
  { Test -> x.value
  | Toast -> x.name
  }
//│ bar: ((test & {value: 'a}) | ((toast & {name: 'b}) & ~test)) -> 'a | 'b

:e
bar Test
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:130)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:259)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)

:e
bar "ops"
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:130)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:259)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)


def baz x = case x of
  { Test -> x
  | Toast -> x
  }
//│ baz: ((test & 'a) | ((toast & 'b) & ~test)) -> 'a | 'b

:e
baz "oops"
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:130)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:259)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)

