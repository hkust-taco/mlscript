:NoProvs

// ExprProb.mls


class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
//│ Defined class Lit
//│ Defined class Add

// :s
// :ds
rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> int) -> 'b -> int
//│   where
//│     'b <: (Add[?] with {lhs: 'b, rhs: 'b}) | 'a & ~add
//│           = [Function: eval1_stub]


// –––––––––––––––––

// // def eval1_eta k e = eval1_stub k e
// def eval1_eta k e = (fun f -> f k e) eval1_stub

// if true then eval1_stub else error

:ns
rec def f x = f
//│ f: 'a
//│   where
//│     'a :> 'b -> 'a
//│  = [Function: f]

f
//│ res: 'a
//│   where
//│     'a :> anything -> 'a
//│    = [Function: f]

:ns
g y = f y
//│ g: 'a -> 'b
//│   where
//│     'b :> 'c -> 'd
//│     'd :> 'c -> 'd
//│        <: 'b & 'a -> 'b
//│     'a <: 'c
//│  = [Function: g]

// :ds
// :s
g
//│ res: anything -> anything -> 'a
//│   where
//│     'a :> anything -> 'a
//│    = [Function: g]


:ns
h y = (f y, y)
//│ h: 'a -> ('b, 'a,)
//│   where
//│     'b :> 'c -> 'd
//│     'd :> 'c -> 'd
//│        <: 'b & 'a -> 'b
//│     'a <: 'c
//│  = [Function: h]

h
//│ res: 'a -> (anything -> 'b, 'a,)
//│   where
//│     'b :> anything -> 'b
//│    = [Function: h]



