:NoJS


// TODO use RecType immediately for all TVs in canon?


// :stdout
// :s
// :d
// :ds
def f: { x: 'a } as 'a
//│ f: {x: 'a} as 'a


// :stdout
// :s
// :d
// :ds
rec def l a = l
//│ l: anything -> 'a as 'a


// TODO-simplif
// :ds
fun a -> a a
//│ res: ('b & 'a) -> 'c as 'a


// :stdout
// :s
// :d
// :ds
:e
rec def f a = a a
//│ ('b & 'a) -> 'c as 'a
//│   <:  f:
//│ {x: 'a} as 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.34: 	rec def f a = a a
//│ ║        	^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?b -> ?c` does not match type `{x: ?a} | 'a`
//│ ║  l.34: 	rec def f a = a a
//│ ║        	          ^^^^^^^
//│ ╟── Note: constraint arises from local type binding:
//│ ║  l.11: 	def f: { x: 'a } as 'a
//│ ╙──      	       ^^^^^^^^^

// :stdout
// :s
// :d
// :ds
rec def g a = a a
//│ g: ('b & 'a) -> 'c as 'a



class Some[A]: { v: A }
//│ Defined class Some

// :ds
def Some v = Some{v}
//│ Some: ('v & 'A) -> (Some['A] & {v: 'v})


def foo(x: Some['a]) =
  let _ = x.v : Some[?]
  in x: Some['a & some]
//│ foo: Some['a] -> Some[in Some[?] & 'a0 out Some[?] & 'a0]
//│   where
//│     'a :> Some[?] & 'a0
//│        <: Some[?] & 'a0

// :ds
def f: Some['a]
//│ f: Some['a]



// TODO MV

def foo(x: 'a) = (x + 1, x)
//│ foo: ('a & int) -> (int, 'a,)

// NOTE: currently each parameter type is typed independently – so these 'a are different!
def foo(x: 'a, y: 'a) = (x + 1, y)
//│ foo: (int, 'a,) -> (int, 'a,)

// def foo(x: 'a) =
def foo(f: 'a -> 'a, x: 'a) =
  let _ = x + 1
  in error: Some['a & some]
//│ foo: ('a -> 'a, int,) -> Some[Some[?] & 'a0]
