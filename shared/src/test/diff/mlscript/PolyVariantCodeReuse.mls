class NotFound
class Tuple[A, B]: { _1: A; _2: B }
//│ Defined class NotFound
//│ Defined class Tuple[+A, +B]

def Tuple l r = Tuple { _1 = l; _2 = r }
//│ Tuple: '_1 -> '_2 -> Tuple['_1, '_2]
//│      = [Function: Tuple1]

class Nil
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons[+A]
//│ Defined type alias List[+A]

def Nil = Nil {}
//│ Nil: Nil
//│    = Nil {}

def Cons head tail = Cons { head; tail }
//│ Cons: ('head & 'A) -> (List['A] & 'tail) -> (Cons['A] with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]

rec def list_assoc s l = case l of {
  | Cons -> if l.head._1 == s then l.head._2
              else list_assoc s l.tail
  | Nil -> NotFound {}
  }
//│ list_assoc: number -> 'a -> (NotFound | 'b)
//│   where
//│     'a <: (Cons[?] with {head: {_1: number, _2: 'b}, tail: 'a}) | Nil
//│           = [Function: list_assoc]

list_assoc 2 (Cons (Tuple 2 1) Nil )
//│ res: 1 | NotFound
//│    = 1

trait Lambda
trait Expr
class Var: Lambda & Expr & { s: string }
//│ Defined trait Lambda
//│ Defined trait Expr
//│ Defined class Var

def eval_var: List[Tuple[string, 'a]] -> Var -> 'a
//│ eval_var: List[Tuple[string, 'a]] -> Var -> 'a
//│         = <missing implementation>

class Abs[a]: Lambda & { abs: Tuple[string, a] }
class App[a]: Lambda & { app: Tuple[a, a] }
//│ Defined class Abs[+a]
//│ Defined class App[+a]

def eval_lambda eval_rec subst v = case v of {
  | Var -> eval_var subst v
  | App -> let l2' = eval_rec subst v.app._2 in
            let l1' = eval_rec subst v.app._1 in
            case l1' of {
            | Abs -> eval_rec (Cons (Tuple l1'.abs._1 l2') Nil) l1'.abs._2
            | _ -> App { app = Tuple l1' l2' }
            }
  | Abs -> v
  }
//│ eval_lambda: (((Cons[Tuple['_1, '_2]] with {tail: Nil}) | 'a) -> 'b -> ('_2 & 'c & ('_10 & ~abs | (Abs[?] with {abs: {_1: '_1, _2: 'b}})))) -> (List[Tuple[string, 'c]] & 'a) -> (Abs[?] & 'c | (App[?] with {app: {_1: 'b, _2: 'b}}) | Var) -> ((App['_2] with {app: Tuple['_10, '_2]}) | 'c)
//│            = <no result>
//│              eval_var is not implemented

rec def eval1 subst = eval_lambda eval1 subst
//│ eval1: List[Tuple[string, 'B]] -> 'a -> 'B
//│   where
//│     'B :> App['_1] with {app: Tuple['_1, 'B]}
//│        <: ('_1 & ~abs | Abs[?] & {abs: {_1: string, _2: 'a}}) & '_1
//│     'a <: Abs[?] & 'B | (App[?] with {app: {_1: 'a, _2: 'a}}) | Var
//│     '_1 :> 'B
//│      = <no result>
//│        eval_lambda and eval_var are not implemented

class Num: Expr & { num: int }
class Add[a]: Expr & { add: Tuple[a, a] }
class Mul[a]: Expr & { mul: Tuple[a, a] }
//│ Defined class Num
//│ Defined class Add[+a]
//│ Defined class Mul[+a]

def map_expr f v = case v of {
  | Var -> v
  | Num -> v
  | Add -> Add { add = Tuple (f v.add._1) (f v.add._2) }
  | Mul -> Mul { mul = Tuple (f v.mul._1) (f v.mul._2) }
  }
//│ map_expr: ('a -> '_2) -> ((Add[?] with {add: {_1: 'a, _2: 'a}}) | (Mul[?] with {mul: {_1: 'a, _2: 'a}}) | 'b & (Num | Var)) -> (Add['_2] | Mul['_2] | 'b)
//│         = [Function: map_expr]

rec def eval_expr eval_rec subst v =
  let vv = map_expr (eval_rec subst) v in
  case vv of {
    | Var -> eval_var subst vv
    | Add -> let vv1 = vv.add._1 in
              let vv2 = vv.add._2 in
              case vv1 of {
              | Num -> case vv2 of {
                | Num -> Num { num = vv1.num + vv2.num }
                | _ -> vv
                }
              | _ -> vv
              }
    | Mul -> let vv1 = vv.mul._1 in
              let vv2 = vv.mul._2 in
              case vv1 of {
              | Num -> case vv2 of {
                | Num -> Num { num = vv1.num * vv2.num }
                | _ -> vv
                }
              | _ -> vv
              }
    | _ -> vv
    }
//│ eval_expr: ('a -> 'b -> ('_1 & (~num | Num))) -> (List[Tuple[string, {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & 'c]] & 'a) -> ((Add[?] with {add: {_1: 'b, _2: 'b}}) | (Mul[?] with {mul: {_1: 'b, _2: 'b}}) | Num & {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & 'c | Var) -> (Add['_1] | Mul['_1] | Num | 'c)
//│          = <no result>
//│            eval_var is not implemented

rec def eval2 subst = eval_expr eval2 subst
//│ eval2: List[Tuple[string, 'B]] -> 'a -> 'B
//│   where
//│     'a <: (Add[?] with {add: {_1: 'a, _2: 'a}}) | (Mul[?] with {mul: {_1: 'a, _2: 'a}}) | Num & 'B | Var
//│     'B :> Add['B] | Mul['B] | Num
//│        <: (Num & {add: {_1: anything, _2: anything}} | {add: {_1: anything, _2: anything}} & ~num) & (Num & {mul: {_1: anything, _2: anything}} | {mul: {_1: anything, _2: anything}} & ~num)
//│      = <no result>
//│        eval_expr and eval_var are not implemented

def eval_lexpr eval_rec subst v = case v of {
  | Lambda -> eval_lambda eval_rec subst v
  | Expr -> eval_expr eval_rec subst v
  }
//│ eval_lexpr: (((Cons[Tuple['_1, '_10]] with {tail: Nil}) | 'a) -> 'b -> ('c & '_10 & ((Abs[?] with {abs: {_1: '_1, _2: 'b}, add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}}) | '_11 & (Num & {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} | {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & ~abs & ~num)))) -> (List[Tuple[string, {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & 'c]] & 'a) -> (lambda & (Abs[?] & {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & 'c | (App[?] with {app: {_1: 'b, _2: 'b}}) | Var) | ~lambda & expr & ((Add[?] with {add: {_1: 'b, _2: 'b}}) | (Mul[?] with {mul: {_1: 'b, _2: 'b}}) | Num & {add: {_1: anything, _2: anything}, mul: {_1: anything, _2: anything}} & 'c | Var)) -> (Add['_10] | (App['_10] with {app: Tuple['_11, '_10]}) | Mul['_10] | Num | 'c)
//│           = <no result>
//│             eval_lambda and eval_var are not implemented

rec def eval3 subst = eval_lexpr eval3 subst
//│ eval3: List[Tuple[string, 'a]] -> 'b -> 'a
//│   where
//│     'a :> (App['_1] with {app: Tuple['_1, 'a]}) | Num | (Add['a] with {add: 'add}) | (Mul['a] with {mul: 'add})
//│        <: (Abs[?] & 'c | '_1 & (~abs & ~num | Num)) & (Abs[?] & {add: {_1: anything, _2: anything}} & 'c | '_1 & (Num & {add: {_1: anything, _2: anything}} | {add: {_1: anything, _2: anything}} & ~abs & ~num)) & (Abs[?] & {mul: {_1: anything, _2: anything}} & 'c | '_1 & (Num & {mul: {_1: anything, _2: anything}} | {mul: {_1: anything, _2: anything}} & ~abs & ~num))
//│     'c <: {abs: {_1: string, _2: 'b}}
//│     'b <: lambda & (Abs[?] & 'a | (App[?] with {app: {_1: 'b, _2: 'b}}) | Var) | ~lambda & expr & ((Add[?] with {add: {_1: 'b, _2: 'b}}) | (Mul[?] with {mul: {_1: 'b, _2: 'b}}) | (Var | 'a & (Add[?] | Mul[?] | ~add & ~mul & ~var)) & (Num | Var))
//│     '_1 :> (Add['a] with {add: 'add}) | (Mul['a] with {mul: 'add}) | Num | 'a
//│     'add :> Tuple['a, 'a]
//│      = <no result>
//│        eval_lexpr, eval_lambda and eval_var are not implemented

eval3 Nil (Var { s = "s" })
//│ res: 'A
//│   where
//│     'A :> Mul['A] | (App['A | Num] with {app: Tuple['A, 'A]}) | Add['A] | Num
//│    = <no result>
//│      eval3, eval_lexpr, eval_lambda and eval_var are not implemented
