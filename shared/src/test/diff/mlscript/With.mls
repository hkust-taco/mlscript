
def rcd = { x = 1 }
//│ rcd: {x: 1}

rcd.x
//│ res: 1

rcd with { y = 2 }
//│ res: {x: 1} with {y: 2}

add res.x res.y
//│ res: int

rcd with { x = "oops" }
//│ res: {x: 1} with {x: "oops"}

res.x
//│ res: "oops"

id rcd with { x = "oops" }
//│ res: {x: 1} with {x: "oops"}

res.x
//│ res: "oops"


def rcd = { }
//│ rcd: anything

id rcd with { x = "oops" }
//│ res: anything with {x: "oops"}

res.x
//│ res: "oops"


def f r = r with { x = "oops" }
//│ f: 'a -> ('a with {x: "oops"})

f rcd
//│ res: anything with {x: "oops"}

f (rcd with { y = 2 })
//│ res: anything with {y: 2} with {x: "oops"}


def f a b = if true then a else b
//│ f: 'a -> 'a -> 'a

def f a b = (if true then a else b) with { x = "oops" }
//│ f: 'a -> 'a -> ('a with {x: "oops"})

def f a b = let tmp = a.x in (if true then a else b) with { x = "oops" }
//│ f: 'a & {x: anything} -> 'a -> ('a with {x: "oops"})


({ name = "Bob" } with { age = 123 }).age
//│ res: 123

({ name = "Bob" } with { age = 123 }).name
//│ res: "Bob"

({ name = "Bob" } with { name = 123 }).name
//│ res: 123


def getf { f } = f
//│ getf: {f: 'a} -> 'a

def foo x =
  let xf = x with { f = 42 }
  in getf xf
//│ foo: anything -> 42

foo 123
//│ res: 42

def foo x =
  let xf = x with { f = 42 }
  in add (getf xf) (getf x)
//│ foo: {f: int} -> int

def foo x =
  let xf = x with { f = 42 }
  in { l = getf xf; r = getf x; s = x }
//│ foo: 'a & {f: 'b} -> {l: 42, r: 'b, s: 'a}

:e
foo 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.89: 	foo 42
//│ ║        	^^^^^^
//│ ╟── expression of type `42` does not have field 'f'
//│ ║  l.89: 	foo 42
//│ ║        	    ^^
//│ ╟── Note: constraint arises from record literal:
//│ ║  l.67: 	def getf { f } = f
//│ ║        	         ^^^^^
//│ ╟── from argument:
//│ ║  l.85: 	  in { l = getf xf; r = getf x; s = x }
//│ ╙──      	                             ^
//│ res: error | {l: 42, r: nothing, s: 42}

def r = foo (42 with { f = 1 })
//│ r: {l: 42, r: 1, s: 42 & {f: 1}}

r.s.f
//│ res: 1

add r.s 1
//│ res: int

