class None: {}
class Some[A]: { v: A }
//│ Defined class None
//│ Defined class Some

def Some v = Some{v}
def None = None{}
//│ Some: 'a -> (some & {Some#A: 'A | 'a .. 'A, v: 'a})
//│ None: none

def flatMap = fun f -> fun opt ->
  case opt of { Some -> f opt.v | _ -> opt }
//│ flatMap: ('a -> 'b) -> (some & {v: 'a} | 'b & ~some) -> 'b

f x = Some x
flatMap f (Some 1)
flatMap f None
flatMap f "oops"
//│ f: 'a -> (some & {Some#A: 'A | 'a .. 'A, v: 'a})
//│ res: some & {Some#A: 'A | 1 .. 'A, v: 1}
//│ res: some & {Some#A: 'A, v: nothing} | none
//│ res: some & {Some#A: 'A, v: nothing} | "oops"

class NoneBecause: { reason: string }
flatMap f (NoneBecause { reason = "uh uh" })
//│ Defined class NoneBecause
//│ res: some & {Some#A: 'A, v: nothing} | noneBecause & {reason: "uh uh"}

type Expr = Lit | Neg | Var | Plus
class Lit: {v: int}
class Neg: {sub: Expr}
class Var: {nme: string}
class Plus: {lhs: Expr; rhs: Expr}
//│ Defined type alias Expr
//│ Defined class Lit
//│ Defined class Neg
//│ Defined class Var
//│ Defined class Plus

rec def evalOpt x = case x of {
  | Lit ->
      Some x.v
  | Neg ->
      // flatMap (fun s -> Some (neg x.sub)) (evalOpt x.sub)
      flatMap (fun s -> Some (0 - s)) (evalOpt x.sub)
  | Var ->
      // None with {err = concat "free var: " x.nme}
      NoneBecause {reason = concat "free var: " x.nme}
      // None
  | Plus ->
      flatMap (fun l -> flatMap (fun r ->
        // Some (add x.lhs x.rhs)
        Some (l + r)
      ) (evalOpt x.rhs)) (evalOpt x.lhs)
  }
//│ evalOpt: (lit & {v: int & 'b} | neg & {sub: 'a} | var & {nme: string} | plus & {lhs: 'a, rhs: 'a} as 'a) -> (some & {Some#A: 'A | 'b .. 'A, v: 'b} | some & {Some#A: 'A0 | int .. 'A0, v: int} | noneBecause & {reason: string} | some & {Some#A: 'A1 | int .. 'A1, v: int})

evalOpt (Plus{lhs = Lit{v=2}; rhs = Lit{v=3}})
//│ res: some & {Some#A: 'A | 3 | 2 .. 'A, v: 3 | 2} | some & {Some#A: 'A0 | int .. 'A0, v: int} | noneBecause & {reason: string} | some & {Some#A: 'A1 | int .. 'A1, v: int}
