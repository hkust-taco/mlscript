class Some[A]: { value: A }
class None: {}
//│ Defined class Some
//│ Defined class None



def flatMap3 = fun f -> fun opt -> case opt of { Some -> f opt | _ -> opt }
//│ flatMap3: ('a -> 'b) -> some & 'a | 'b & ~some -> 'b


def arg = if true then Some{value = 42} with {payload = 23} else None {}
//│ arg: some & {payload: 23, value: 42} | none

flatMap3 (fun x -> add x.value x.payload) arg
//│ res: int | none


def arg = if true then Some{value = 42} else None {}
//│ arg: some & {value: 42} | none

flatMap3 (fun x -> x.value) arg
//│ res: 42 | none


def foo = flatMap3 (fun x -> x.value)
//│ foo: some & {value: 'a} | 'a & ~some -> 'a

foo arg
//│ res: 42 | none

foo 1
//│ res: 1

def fn = foo None
//│ fn: anything -> none

// :d
fn{} // foo None {}
//│ res: none

// :d
foo (None{})
//│ res: none


fun f -> flatMap3 f arg
//│ res: (none & ~'a | some & {value: 42} -> 'a) -> 'a | none




def foo = flatMap3 (fun x -> x)
//│ foo: some & 'a | 'a & ~some -> 'a

foo 1
//│ res: 1




def simpler = fun f -> case None{} of { Some -> f 1 | _ -> None{} }
//│ simpler: (1 -> 'a) -> 'a | none

def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ simpler: ('a -> 'b) -> some & 'a | none & 'b -> 'b

simpler (fun x -> x.value)
//│ res: some & {value: 'a} | none & 'a -> 'a

:e
res 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.72: 	res 1
//│ ║        	^^^^^
//│ ╟── expression of type `1` does not match type `some & {value: ?a} & ?b | none & ?c`
//│ ║  l.72: 	res 1
//│ ║        	    ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.65: 	def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ ╙──      	                                       ^^^
//│ res: 1 | error


def funny = fun f -> case f of { Some -> f f }
//│ funny: nothing -> nothing

:p
class Foo[A]: { x: A }
    method Map[B]: (A -> B) -> B
class Bar[A]: Foo[A]
    method Map f = Bar Foo { x = f this.x }
//│ Parsed: class Foo[A]: {x: A}; class Bar[A]: Foo[A];
//│ Desugared: class Foo[A]: {x: A}
//│ Desugared: class Bar[A]: Foo[A]
//│ Defined class Foo
//│ Defined class Bar

:e
:p
def a = Bar { x = 1 }
a.(Foo.Map)(fun x -> x)
//│ Parsed: def a: (Bar {x: 1}); (a.Foo.Map (x => x));
//│ Desugared: def a: (Bar {x: 1})
//│ Desugared: (a.Foo.Map (x => x))
//│ a: bar & {x: 1}
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.100: 	a.(Foo.Map)(fun x -> x)
//│ ║         	^
//│ ╟── expression of type `bar & {x: ?a | 1}` does not match type `{Foo.Map: ?b}`
//│ ║  l.99: 	def a = Bar { x = 1 }
//│ ║        	        ^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{Foo.Map: ?c}`
//│ ║  l.100: 	a.(Foo.Map)(fun x -> x)
//│ ╙──       	^
//│ res: error

