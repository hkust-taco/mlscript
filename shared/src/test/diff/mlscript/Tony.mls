class Some[A]: { value: A }
class None: {}
//│ Defined class Some
//│ Defined class None



def flatMap3 = fun f -> fun opt -> case opt of { Some -> f opt | _ -> opt }
//│ flatMap3: ('a -> 'b) -> (some & 'a | 'b & ~some) -> 'b


def arg = if true then Some{value = 42} with {payload = 23} else None {}
//│ arg: some & {Some#A: 'A | 42 .. 'A, payload: 23, value: 42} | none

flatMap3 (fun x -> add x.value x.payload) arg
//│ res: int | none


def arg = if true then Some{value = 42} else None {}
//│ arg: some & {Some#A: 'A | 42 .. 'A, value: 42} | none

flatMap3 (fun x -> x.value) arg
//│ res: 42 | none


def foo = flatMap3 (fun x -> x.value)
//│ foo: (some & {value: 'a} | 'a & ~some) -> 'a

foo arg
//│ res: 42 | none

foo 1
//│ res: 1

def fn = foo None
//│ fn: anything -> none

// :d
fn{} // foo None {}
//│ res: none

// :d
foo (None{})
//│ res: none


fun f -> flatMap3 f arg
//│ res: ((none & ~'a | some & {Some#A: 'A | 42 .. 'A, value: 42}) -> 'a) -> ('a | none)




def foo = flatMap3 (fun x -> x)
//│ foo: (some & 'a | 'a & ~some) -> 'a

foo 1
//│ res: 1




def simpler = fun f -> case None{} of { Some -> f 1 | _ -> None{} }
//│ simpler: (1 -> 'a) -> ('a | none)

def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ simpler: ('a -> 'b) -> (some & 'a | none & 'b) -> 'b

simpler (fun x -> x.value)
//│ res: (some & {value: 'a} | none & 'a) -> 'a

:e
res 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.72: 	res 1
//│ ║        	^^^^^
//│ ╟── expression of type `1` does not match type `some & {value: ?a} & ?b | none & ?c`
//│ ║  l.72: 	res 1
//│ ║        	    ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.65: 	def simpler = fun f -> fun opt -> case opt of { Some -> f opt | None -> opt }
//│ ╙──      	                                       ^^^
//│ res: 1 | error


def funny = fun f -> case f of { Some -> f f }
//│ funny: nothing -> nothing
