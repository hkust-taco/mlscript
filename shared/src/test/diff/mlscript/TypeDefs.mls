
class Test1: { x: int }
//│ Defined class Test1

Test1
//│ res: {x: int & 'x} -> (test1 & {x: 'x})

Test1 { x = 123 }
//│ res: test1 & {x: 123}

:e
Test1 { x = "oops" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `"oops"` does not match type `int`
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	            ^^^^^^
//│ ╟── but it flows into record literal with expected type `{x: int & ?x}`
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	      ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.2: 	class Test1: { x: int }
//│ ╙──     	                  ^^^
//│ res: test1 & {x: "oops"} | error

def Test1 = fun x -> Test1 { x = x }
//│ Test1: (int & 'a) -> (test1 & {x: 'a})

class Test11: { x: int }
def Test11 x = Test11 { x }
//│ Defined class Test11
//│ Test11: (int & 'a) -> (test11 & {x: 'a})


:e
type Test1 = { x: int }
//│ ╔══[ERROR] Type 'Test1' is already defined.
//│ ║  l.37: 	type Test1 = { x: int }
//│ ╙──      	     ^^^^^

// FIXME
type Test2 = { x: int }
//│ Defined type alias Test2

:pe
class Test = { x: int }
//│ /!\ Parse error: Expected end-of-input:1:12, found "= { x: int" at l.47:12: class Test = { x: int }

:pe
type Test: { x: int }
//│ /!\ Parse error: Expected "=":1:10, found ": { x: int" at l.51:10: type Test: { x: int }

// FIXME
type Test3 = int -> int
//│ Defined type alias Test3

// FIXME
type Test4 = int -> int -> int
//│ Defined type alias Test4

// FIXME
type Test5 = (int -> int) -> int
//│ Defined type alias Test5


type T = int
//│ Defined type alias T

:e
type T = int
type T = int
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.71: 	type T = int
//│ ╙──      	     ^
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.72: 	type T = int
//│ ╙──      	     ^

:e
type TypeA = int
foo 42
def foo = 1
foo 42
//│ Defined type alias TypeA
//│ ╔══[ERROR] identifier not found: foo
//│ ║  l.82: 	foo 42
//│ ╙──      	^^^
//│ res: error
//│ foo: 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.84: 	foo 42
//│ ║        	^^^^^^
//│ ╟── expression of type `1` is not a function
//│ ║  l.83: 	def foo = 1
//│ ║        	          ^
//│ ╟── but it flows into reference with expected type `42 -> ?a`
//│ ║  l.84: 	foo 42
//│ ╙──      	^^^
//│ res: error

42: TypeA
//│ res: int

:e
type TypeOops = TypeOops
type TypeB = TypeC
def test = fun x -> (x: TypeB)
test 42
type TypeC = TypeA
//│ ╔══[ERROR] illegal cycle involving type TypeOops
//│ ║  l.106: 	type TypeOops = TypeOops
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^
//│ Defined type alias TypeB
//│ Defined type alias TypeC
//│ test: int -> int
//│ res: int


// FIXME? maybe x's type should be upcasted in the body
def test = fun (x: TypeB) -> x
//│ test: (int & 'a) -> 'a



// Note: type alias definitions can contain type variables,
//   which are refreshed on every use (every expansion) of the alias
type Lol = { x: 'a -> 'a }
//│ Defined type alias Lol

error: Lol -> Lol
//│ res: {x: 'a -> 'a} -> {x: 'a0 -> 'a0}

{ x = id } : Lol
//│ res: {x: 'a -> 'a}


:e
type Runaway[A] = Runaway['a]
//│ ╔══[ERROR] illegal cycle involving type Runaway
//│ ║  l.139: 	type Runaway[A] = Runaway['a]
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^^^^

:e
type Runaway[A] = 'a -> Runaway['a]
//│ ╔══[ERROR] Type definition is not regular: it occurs within itself as Runaway['a], but is defined as Runaway['A]
//│ ║  l.145: 	type Runaway[A] = 'a -> Runaway['a]
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


type Runaway2 = Lol -> Runaway2
//│ Defined type alias Runaway2

:e
id: Runaway2
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.155: 	id: Runaway2
//│ ║         	^^
//│ ╟── expression of type `{x: ?a -> ?a}` is not a function
//│ ║  l.128: 	type Lol = { x: 'a -> 'a }
//│ ║         	           ^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference of type `({x: ?a0 -> ?a0} -> ({x: ?a1 -> ?a1} -> ?b as ?b) & ?c) -> (?c | {x: ?a2 -> ?a2})`
//│ ║  l.155: 	id: Runaway2
//│ ║         	^^
//│ ╟── which does not match type `{x: ?a3 -> ?a3} -> ?d as ?d`
//│ ╟── Note: constraint arises from function type:
//│ ║  l.151: 	type Runaway2 = Lol -> Runaway2
//│ ║         	                ^^^^^^^^^^^^^^^
//│ ╟── from type reference:
//│ ║  l.155: 	id: Runaway2
//│ ╙──       	    ^^^^^^^^
//│ res: {x: 'a -> 'a} -> 'b as 'b

error: Runaway2
//│ res: {x: 'a -> 'a} -> 'b as 'b

:e
error: {x: int} -> nothing : Runaway2
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.178: 	error: {x: int} -> nothing : Runaway2
//│ ║         	^^^^^
//│ ╟── expression of type `?a -> ?a` does not match type `int`
//│ ║  l.128: 	type Lol = { x: 'a -> 'a }
//│ ║         	                ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.178: 	error: {x: int} -> nothing : Runaway2
//│ ╙──       	           ^^^
//│ res: {x: 'a -> 'a} -> 'b as 'b

error: {x: 'x -> 'x} -> nothing : Runaway2
//│ res: {x: 'a -> 'a} -> 'b as 'b

