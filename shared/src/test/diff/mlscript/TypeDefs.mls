
class Test1: { x: int }
//│ Defined class Test1

Test1
//│ res: {x: int & 'a} -> test1 & {x: 'a}

Test1 { x = 123 }
//│ res: test1 & {x: 123}

:e
Test1 { x = "oops" }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `"oops"` does not match type `int`
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	            ^^^^^^
//│ ╟── but it flows into record literal with expected type `{x: int & ?a}`
//│ ║  l.12: 	Test1 { x = "oops" }
//│ ║        	      ^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.2: 	class Test1: { x: int }
//│ ╙──     	                  ^^^
//│ res: test1 & {x: "oops"} | error

def Test1 = fun x -> Test1 { x = x }
//│ Test1: int & 'a -> test1 & {x: 'a}

class Test11: { x: int }
def Test11 x = Test11 { x }
//│ Defined class Test11
//│ Test11: int & 'a -> test11 & {x: 'a}


:e
type Test1 = { x: int }
//│ ╔══[ERROR] Type 'Test1' is already defined.
//│ ║  l.37: 	type Test1 = { x: int }
//│ ╙──      	     ^^^^^

// FIXME
type Test2 = { x: int }
//│ Defined type Test2

:pe
class Test = { x: int }
//│ /!\ Parse error: Expected end-of-input:1:12, found "= { x: int" at l.47:12: class Test = { x: int }

:pe
type Test: { x: int }
//│ /!\ Parse error: Expected "=":1:10, found ": { x: int" at l.51:10: type Test: { x: int }

// FIXME
type Test3 = int -> int
//│ Defined type Test3

// FIXME
type Test4 = int -> int -> int
//│ Defined type Test4

// FIXME
type Test5 = (int -> int) -> int
//│ Defined type Test5


type T = int
//│ Defined type T

:e
type T = int
type T = int
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.71: 	type T = int
//│ ╙──      	     ^
//│ ╔══[ERROR] Type 'T' is already defined.
//│ ║  l.72: 	type T = int
//│ ╙──      	     ^

:e
type TypeA = int
foo 42
def foo = 1
foo 42
//│ Defined type TypeA
//│ ╔══[ERROR] identifier not found: foo
//│ ║  l.82: 	foo 42
//│ ╙──      	^^^
//│ res: error
//│ foo: 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.84: 	foo 42
//│ ║        	^^^^^^
//│ ╟── expression of type `1` is not a function
//│ ║  l.83: 	def foo = 1
//│ ║        	          ^
//│ ╟── but it flows into reference with expected type `42 -> ?a`
//│ ║  l.84: 	foo 42
//│ ╙──      	^^^
//│ res: error

42: TypeA
//│ res: int

:e
type TypeOops = TypeOops
type TypeB = TypeC
def test = fun x -> (x: TypeB)
test 42
type TypeC = TypeA
//│ ╔══[ERROR] illegal cycle involving type TypeOops
//│ ║  l.106: 	type TypeOops = TypeOops
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^
//│ Defined type TypeB
//│ Defined type TypeC
//│ test: int -> int
//│ res: int


// FIXME? maybe x's type should be upcasted in the body
def test = fun (x: TypeB) -> x
//│ test: int & 'a -> 'a

