
t = (1, 2, 3)
//│ t: (1, 2, 3,)

tx = t with { x = 1 }
//│ tx: (1, 2, 3,) & {x: 1}

tx.x
//│ res: 1

trait Hey: { x: int }
//│ Defined trait Hey

:e
Hey t
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.15: 	Hey t
//│ ║        	^^^^^
//│ ╟── expression of type `{_1: 1, _2: 2, _3: 3}` does not have field 'x'
//│ ║  l.2: 	t = (1, 2, 3)
//│ ║       	     ^^^^^^^
//│ ╟── but it flows into reference with expected type `{x: int}`
//│ ║  l.15: 	Hey t
//│ ║        	    ^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.11: 	trait Hey: { x: int }
//│ ╙──      	           ^^^^^^^^^^
//│ res: (1, 2, 3,) & hey | error

htx = Hey tx
//│ htx: (1, 2, 3,) & {x: 1} & hey

htx.x
//│ res: 1

f ((a, b, c)) = { a; b; c }
//│ f: ('a, 'b, 'c,) -> {a: 'a, b: 'b, c: 'c}

f t
//│ res: {a: 1, b: 2, c: 3}

f tx
//│ res: {a: 1, b: 2, c: 3}

f htx
//│ res: {a: 1, b: 2, c: 3}

f ((a, b)) = add a b
//│ f: (int, int,) -> int

:e
f t
f tx
f htx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.52: 	f t
//│ ║        	^^^
//│ ╟── expression of type `(1, 2, 3,)` does not match type `(?a, ?b,)`
//│ ║  l.2: 	t = (1, 2, 3)
//│ ║       	     ^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.52: 	f t
//│ ║        	  ^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.48: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.53: 	f tx
//│ ║        	^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1}` does not match type `(?a, ?b,)`
//│ ║  l.5: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.53: 	f tx
//│ ║        	  ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.48: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.54: 	f htx
//│ ║        	^^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1}` does not match type `~hey | (?a, ?b,)`
//│ ║  l.5: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.54: 	f htx
//│ ║        	  ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.48: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int


g arg = case arg of { Hey -> arg.x | _ -> () }
//│ g: ({x: 'a} & hey | ~hey) -> (() | 'a)

g htx
g tx
//│ res: () | 1
//│ res: () | 1

g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ g: ({x: 'a} & hey | {y: 'a} & ~hey) -> 'a

g htx
g (tx with { y = 2 })
//│ res: 1
//│ res: 1 | 2

:e
g tx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.113: 	g tx
//│ ║         	^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1} & ~hey` does not match type `{y: ?a}`
//│ ║  l.5: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `hey & ?b | ?c & ~hey`
//│ ║  l.113: 	g tx
//│ ║         	  ^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.104: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ║         	                                          ^^^^^
//│ ╟── from reference:
//│ ║  l.104: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ╙──       	             ^^^
//│ res: 1 | error

