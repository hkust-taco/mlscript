
t = (1, 2, 3)
//│ t: (1, 2, 3,)
//│  = [ 1, 2, 3 ]

:js
tx = t with { x = 1 }
//│ // Prelude
//│ function withConstruct(target, fields) {
//│   if (typeof target === "string" || typeof target === "number" || typeof target === "boolean" || typeof target === "bigint" || typeof target === "symbol") {
//│     return Object.assign(target, fields);
//│   }else {
//│     const copy = Object.assign({}, target, fields);
//│     Object.setPrototypeOf(copy, Object.getPrototypeOf(target));
//│     return copy;
//│   }
//│ }
//│ // Query 0
//│ const tx = withConstruct(t, {  x: 1  }); res = tx;
//│ // End of generated code
//│ tx: (1, 2, 3,) & {x: 1}
//│   = Array { '0': 1, '1': 2, '2': 3, x: 1 }

tx.x
//│ res: 1
//│    = 1

trait Hey: { x: int }
//│ Defined trait Hey

:e
Hey t
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.32: 	Hey t
//│ ║        	^^^^^
//│ ╟── expression of type `{_1: 1, _2: 2, _3: 3}` does not have field 'x'
//│ ║  l.2: 	t = (1, 2, 3)
//│ ║       	     ^^^^^^^
//│ ╟── but it flows into reference with expected type `{x: int}`
//│ ║  l.32: 	Hey t
//│ ║        	    ^
//│ ╟── Note: constraint arises from record type:
//│ ║  l.28: 	trait Hey: { x: int }
//│ ╙──      	           ^^^^^^^^^^
//│ res: (1, 2, 3,) & hey | error

htx = Hey tx
//│ htx: (1, 2, 3,) & {x: 1} & hey
//│    = Uncaught ReferenceError: Hey is not defined

htx.x
//│ res: 1
//│    = Uncaught ReferenceError: htx is not defined

f ((a, b, c)) = { a; b; c }
//│ f: ('a, 'b, 'c,) -> {a: 'a, b: 'b, c: 'c}
//│  = const f = ([   a,   b,   c ]) => {   a: a,   b: b,   c: c }; res = f;
//│                                                  ^
//│    
//│    Uncaught SyntaxError: Unexpected token ':'

f t
//│ res: {a: 1, b: 2, c: 3}
//│    = Uncaught ReferenceError: f is not defined

f tx
//│ res: {a: 1, b: 2, c: 3}
//│    = Uncaught ReferenceError: f is not defined

f htx
//│ res: {a: 1, b: 2, c: 3}
//│    = Uncaught ReferenceError: f is not defined

f ((a, b)) = add a b
//│ f: (int, int,) -> int
//│  = [Function: f1]

:e
f t
f tx
f htx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.79: 	f t
//│ ║        	^^^
//│ ╟── expression of type `(1, 2, 3,)` does not match type `(?a, ?b,)`
//│ ║  l.2: 	t = (1, 2, 3)
//│ ║       	     ^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.79: 	f t
//│ ║        	  ^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.74: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.80: 	f tx
//│ ║        	^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1}` does not match type `(?a, ?b,)`
//│ ║  l.7: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.80: 	f tx
//│ ║        	  ^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.74: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.81: 	f htx
//│ ║        	^^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1}` does not match type `~hey | (?a, ?b,)`
//│ ║  l.7: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(?c, ?d,)`
//│ ║  l.81: 	f htx
//│ ║        	  ^^^
//│ ╟── Note: constraint arises from tuple literal:
//│ ║  l.74: 	f ((a, b)) = add a b
//│ ╙──      	    ^^^^
//│ res: error | int


g arg = case arg of { Hey -> arg.x | _ -> () }
//│ g: ({x: 'a} & hey | ~hey) -> (() | 'a)
//│  = [Function: g]

g htx
g tx
//│ res: () | 1
//│    = Uncaught ReferenceError: htx is not defined
//│ res: () | 1
//│    = Uncaught ReferenceError: Hey is not defined
//│          at g (REPL13:1:36)

g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ g: ({x: 'a} & hey | {y: 'a} & ~hey) -> 'a
//│  = [Function: g1]

g htx
g (tx with { y = 2 })
//│ res: 1
//│    = Uncaught ReferenceError: htx is not defined
//│ res: 1 | 2
//│    = Uncaught ReferenceError: Hey is not defined
//│          at g1 (REPL16:1:37)

:e
g tx
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.148: 	g tx
//│ ║         	^^^^
//│ ╟── expression of type `(1, 2, 3,) & {x: 1} & ~hey` does not match type `{y: ?a}`
//│ ║  l.7: 	tx = t with { x = 1 }
//│ ║       	     ^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `hey & ?b | ?c & ~hey`
//│ ║  l.148: 	g tx
//│ ║         	  ^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.135: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ║         	                                          ^^^^^
//│ ╟── from reference:
//│ ║  l.135: 	g arg = case arg of { Hey -> arg.x | _ -> arg.y }
//│ ╙──       	             ^^^
//│ res: 1 | error


if bool then (1,) else (2,)
//│ res: (1 | 2,)
//│    = Uncaught ReferenceError: bool is not defined

if bool then (1,) else (2, 3)
//│ res: anything
//│    = Uncaught ReferenceError: bool is not defined

if bool then (1,) with { a = 1; b = 2 } else (2, 3) with { b = 3; c = 4 }
//│ res: {b: 2 | 3}
//│    = Uncaught ReferenceError: bool is not defined

if bool then (1,) else fun x -> x
//│ res: anything
//│    = Uncaught ReferenceError: bool is not defined

