

// ———


trait S0[A]
  method Foo0: A
trait T0[B]: S0[B]
//│ Defined trait S0[+A]
//│ Declared S0.Foo0: S0['A] -> 'A
//│ Defined trait T0[+B]

:e
class A0: S0[int] & T0[string]
(A0{}).Foo0
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	                       ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	                       ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	             ^^^
//│ Defined class A0
//│ ╔══[ERROR] Instantiation of an abstract type is forbidden
//│ ║  l.15: 	(A0{}).Foo0
//│ ║        	 ^^
//│ ╟── Note that class A0 is abstract:
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Hint: method Foo0 is abstract
//│ ║  l.14: 	class A0: S0[int] & T0[string]
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: error
//│    = undefined

:e
class A0_2: S0[int] & T0[string]
  method Foo0 = 1
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ║        	               ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	                         ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ║        	                         ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ╙──      	               ^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.49: 	  method Foo0 = 1
//│ ║        	         ^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `string`
//│ ║  l.49: 	  method Foo0 = 1
//│ ║        	                ^
//│ ╟── but it flows into method definition with expected type `string`
//│ ║  l.49: 	  method Foo0 = 1
//│ ║        	         ^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.48: 	class A0_2: S0[int] & T0[string]
//│ ║        	                         ^^^^^^
//│ ╟── from inherited method declaration:
//│ ║  l.7: 	  method Foo0: A
//│ ╙──     	         ^^^^^^^
//│ Defined class A0_2
//│ Defined A0_2.Foo0: A0_2 -> 1

(A0_2{}).Foo0
//│ res: nothing
//│    = 1


// ———


trait R1[A]
  method Foo1: A
//│ Defined trait R1[+A]
//│ Declared R1.Foo1: R1['A] -> 'A

trait S1: R1[int]
  method Foo1 = 1
trait T1: R1[string]
  method Foo1 = "a"
//│ Defined trait S1
//│ Defined S1.Foo1: S1 -> 1
//│ Defined trait T1
//│ Defined T1.Foo1: T1 -> "a"

:e
class A1: S1 & T1
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.109: 	class A1: S1 & T1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.99: 	trait S1: R1[int]
//│ ║        	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.101: 	trait T1: R1[string]
//│ ╙──       	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.109: 	class A1: S1 & T1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.101: 	trait T1: R1[string]
//│ ║         	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.99: 	trait S1: R1[int]
//│ ╙──      	             ^^^
//│ ╔══[ERROR] An overriding method definition must be given when inheriting from multiple method definitions
//│ ║  l.109: 	class A1: S1 & T1
//│ ║         	      ^^
//│ ╟── Definitions of method Foo1 inherited from:
//│ ╟── • S1
//│ ║  l.100: 	  method Foo1 = 1
//│ ║         	         ^^^^^^^^
//│ ╟── • T1
//│ ║  l.102: 	  method Foo1 = "a"
//│ ╙──       	         ^^^^^^^^^^
//│ Defined class A1

a1 = A1{}
//│ a1: A1
//│   = A1 {}

a1.Foo1
//│ res: nothing
//│    = 1

a1: S1
a1: R1[int]
a1: R1[string]
a1: R1['_]
//│ res: S1
//│    = A1 {}
//│ res: R1[int]
//│    = A1 {}
//│ res: R1[string]
//│    = A1 {}
//│ res: R1[nothing]
//│    = A1 {}

:ns
a1: R1['_]
//│ res: R1['_]
//│   where
//│     '_ :> int & string
//│        <: int | string
//│    = A1 {}


:e
:js
class A1_2: S1 & T1
  method Foo1 = error
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.172: 	class A1_2: S1 & T1
//│ ║         	      ^^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.99: 	trait S1: R1[int]
//│ ║        	             ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.101: 	trait T1: R1[string]
//│ ╙──       	             ^^^^^^
//│ ╔══[ERROR] Type mismatch in type definition:
//│ ║  l.172: 	class A1_2: S1 & T1
//│ ║         	      ^^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.101: 	trait T1: R1[string]
//│ ║         	             ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.99: 	trait S1: R1[int]
//│ ╙──      	             ^^^
//│ Defined class A1_2
//│ Defined A1_2.Foo1: A1_2 -> nothing
//│ // Prelude
//│ function error() {
//│   throw new Error("unexpected runtime error");
//│ }
//│ class A1_2 {
//│   constructor(fields) {
//│     S1.implement(this);
//│     T1.implement(this);
//│   }
//│   get Foo1() {
//│     return error();
//│   }
//│ }
//│ // End of generated code

:re
(A1_2{}).Foo1
//│ res: nothing
//│ Runtime error:
//│   Error: unexpected runtime error


def f = 0
//│ f: 0
//│  = 0

def f' = 1
//│ f': 1
//│   = 0

f'
//│ res: 1
//│    = 0

