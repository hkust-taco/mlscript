:AllowTypeErrors

succ false
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.3: 	succ false
//│ ║       	^^^^^^^^^^
//│ ╟── reference of type `false` is not an instance of type `int`
//│ ║  l.3: 	succ false
//│ ╙──     	     ^^^^^
//│ res: error | int



x = "oops"
//│ x: "oops"

f y = succ y
//│ f: int -> int

:e
f x
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.21: 	f x
//│ ║        	^^^
//│ ╟── string literal of type `"oops"` is not an instance of type `int`
//│ ║  l.14: 	x = "oops"
//│ ║        	    ^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.21: 	f x
//│ ║        	  ^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.17: 	f y = succ y
//│ ╙──      	           ^
//│ res: error | int







trait MyTrait: { value: anything }
//│ Defined trait MyTrait

def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ test1: ({value: 'value} & #MyTrait | ~#MyTrait) -> (0 | 'value)

:e
test1 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.49: 	test1 1
//│ ║        	^^^^^^^
//│ ╟── expression of type `1 & #MyTrait | 1 & ~?a` does not have field 'value'
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.45: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ║        	                                     ^^^^^^^
//│ ╟── from refined scrutinee:
//│ ║  l.45: 	def test1 x = case x of { MyTrait -> x.value | _ -> 0 }
//│ ╙──      	                   ^
//│ res: 0 | error





def map: 'a -> 'a
def map f = f map (fun x -> map)
//│ map: 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.67: 	def map f = f map (fun x -> map)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `'a` is not a function
//│ ║  l.66: 	def map: 'a -> 'a
//│ ║        	         ^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.67: 	def map f = f map (fun x -> map)
//│ ║        	            ^^^^^
//│ ╟── from reference:
//│ ║  l.67: 	def map f = f map (fun x -> map)
//│ ╙──      	            ^
//│ (('a -> 'a) -> (anything -> 'a0 -> 'a0) -> 'b) -> 'b
//│   <:  map:
//│ 'a -> 'a






class Bar
    method Map[B]: B -> B
    rec method Map f = f 1
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.92: 	    rec method Map f = f 1
//│ ║        	               ^^^^^^^^^^^
//│ ╟── type `B` is not a function
//│ ║  l.91: 	    method Map[B]: B -> B
//│ ║        	               ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.92: 	    rec method Map f = f 1
//│ ║        	                       ^^^
//│ ╟── from reference:
//│ ║  l.92: 	    rec method Map f = f 1
//│ ╙──      	                       ^
//│ Defined class Bar
//│ Declared Bar.Map: Bar -> 'B -> 'B
//│ Defined Bar.Map: Bar -> (1 -> 'a) -> 'a






def boom: anything
//│ boom: anything

// :d
:e
add boom 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.119: 	add boom 1
//│ ║         	^^^^^^^^
//│ ╟── type `anything` is not an instance of type `int`
//│ ║  l.114: 	def boom: anything
//│ ║         	          ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.119: 	add boom 1
//│ ╙──       	    ^^^^
//│ res: error | int





