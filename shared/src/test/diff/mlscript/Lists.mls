
class Nil: {}
class Cons[A]: { head: A; tail: List[A] }
type List[A] = Nil | Cons[A]
//│ Defined class Nil
//│ Defined class Cons
//│ Defined type alias List

def originalCons = Cons  // Note: type still seems over-complicated because we push 'b inside the union, killing a hash-consing opportunity at the outer level...
//│ originalCons: {head: 'head & 'A, tail: List['A] & 'tail} -> (Cons['A] with {head: 'head, tail: 'tail})
//│             = [Function: originalCons]

def Nil = Nil {}
//│ Nil: Nil
//│    = Nil {}

def Cons head tail = Cons { head; tail }
//│ Cons: ('head & 'A) -> (List['A] & 'tail) -> (Cons['A] with {head: 'head, tail: 'tail})
//│     = [Function: Cons1]


Cons 2
//│ res: (List['A] & 'tail) -> (Cons['A] with {head: 2, tail: 'tail})
//│   where
//│     'A :> 2
//│    = [Function (anonymous)]

def c = Cons 2 Nil
//│ c: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 2
//│  = Cons { head: 2, tail: Nil {} }

def d = Cons 1 c
//│ d: Cons['A] with {head: 1, tail: Cons['A] with {head: 2, tail: Nil}}
//│   where
//│     'A :> 1 | 2
//│  = Cons { head: 1, tail: Cons { head: 2, tail: Nil {} } }

d.head
//│ res: 1
//│    = 1

res: 1
//│ res: 1
//│    = 1

d.tail
//│ res: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 2, tail: Nil {} }

Cons 1 res
//│ res: Cons['A] with {head: 1, tail: Cons['A] with {head: 2, tail: Nil}}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 1, tail: Cons { head: 2, tail: Nil {} } }

res.tail
//│ res: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 2, tail: Nil {} }

Cons 1 (Cons 2 Nil)
//│ res: Cons['A] with {head: 1, tail: Cons['A] with {head: 2, tail: Nil}}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 1, tail: Cons { head: 2, tail: Nil {} } }

res.tail
//│ res: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 2, tail: Nil {} }

// We can now access the tail's tail, thanks to the refined type
res.tail
//│ res: Nil
//│    = Nil {}

:e
res.tail.head
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.84: 	res.tail.head
//│ ║        	^^^^^^^^
//│ ╟── application of type `Nil` does not have field 'tail'
//│ ║  l.13: 	def Nil = Nil {}
//│ ║        	          ^^^^^^
//│ ╟── but it flows into reference with expected type `{tail: ?a}`
//│ ║  l.84: 	res.tail.head
//│ ║        	^^^
//│ ╟── Note: class Nil is defined at:
//│ ║  l.2: 	class Nil: {}
//│ ╙──     	      ^^^
//│ res: error
//│ Runtime error:
//│   TypeError: Cannot read properties of undefined (reading 'head')



// This used to yield a more precise Cons constructor, but it's no longer necessary in the new class semantics
:ds
def Cons head tail = originalCons { head; tail } with { head; tail }
//│ ⬤ Typed as: (α0' -> (α1' -> (α5'\head-tail & {head: [α0'], tail: [α1']})))
//│  where: 
//│ 		α0' <: [[head2']]
//│ 		α1' <: [[tail4']]
//│ 		head2' <: A3'
//│ 		tail4' <: List[A3']
//│ 		α5' :> [(cons<> & {head: head2', tail: tail4', Cons#A: A3'..A3'})]
//│ Pols TreeMap(α0' -> None, α1' -> None, head2' -> None, A3' -> None, tail4' -> None, α5' -> Some(true))
//│ Renewed α0' ~> α6'
//│ Renewed head2' ~> head7'
//│ Renewed A3' ~> A8'
//│ Renewed α1' ~> α9'
//│ Renewed tail4' ~> tail10'
//│ Renewed α5' ~> α11'
//│ ⬤ Cleaned up: (α6' -> (α9' -> (α11'\head-tail & {head: α6', tail: α9'})))
//│  where: 
//│ 		α6' <: head7'
//│ 		head7' <: A8'
//│ 		α9' <: tail10'
//│ 		tail10' <: List[A8']
//│ 		α11' :> (cons<> & {head: head7', tail: tail10', Cons#A: A8'..A8'})
//│ analyze0[+] (α6' -> (α9' -> (α11'\head-tail & {head: α6', tail: α9'})))
//│ | analyze0[-] (α6',)
//│ | | analyze0[-] α6'
//│ | | | analyze0[-] head7'
//│ | | | | analyze0[-] A8'
//│ | analyze0[+] (α9' -> (α11'\head-tail & {head: α6', tail: α9'}))
//│ | | analyze0[-] (α9',)
//│ | | | analyze0[-] α9'
//│ | | | | analyze0[-] tail10'
//│ | | | | | analyze0[-] List[A8']
//│ | | | | | | analyze0[=] A8'
//│ | | analyze0[+] (α11'\head-tail & {head: α6', tail: α9'})
//│ | | | analyze0[+] α11'\head-tail
//│ | | | | analyze0[+] α11'
//│ | | | | | analyze0[+] (cons<> & {head: head7', tail: tail10', Cons#A: A8'..A8'})
//│ | | | | | | analyze0[+] cons<>
//│ | | | | | | analyze0[+] {head: head7', tail: tail10', Cons#A: A8'..A8'}
//│ | | | | | | | analyze0[+] head7'
//│ | | | | | | | analyze0[+] tail10'
//│ | | | | | | | analyze0[-] A8'
//│ | | | | | | | analyze0[+] A8'
//│ | | | analyze0[+] {head: α6', tail: α9'}
//│ | | | | analyze0[+] α6'
//│ | | | | analyze0[+] α9'
//│ [inv] A8'
//│ [nums] -α6' 1 ; -head7' 1 ; -A8' 3 ; -α9' 1 ; -tail10' 1 ; +A8' 2 ; +α11' 1 ; +head7' 1 ; +tail10' 1 ; +α6' 1 ; +α9' 1
//│ analyze[+] (α6' -> (α9' -> (α11'\head-tail & {head: α6', tail: α9'})))
//│ | analyze[-] (α6',)
//│ | | analyze[-] α6'
//│ | | | go α6'   ()
//│ | | | | go head7'   (α6')
//│ | | | | | go A8'   (α6', head7')
//│ | | | >>>> α6' HashSet(α6', head7', A8') None
//│ | | | >>>> head7' HashSet(α6', head7', A8') None
//│ | | | >>>> A8' HashSet(α6', head7', A8') None
//│ | analyze[+] (α9' -> (α11'\head-tail & {head: α6', tail: α9'}))
//│ | | analyze[-] (α9',)
//│ | | | analyze[-] α9'
//│ | | | | go α9'   ()
//│ | | | | | go tail10'   (α9')
//│ | | | | | | go List[A8']   (α9', tail10')
//│ | | | | | | | analyze[-] List[A8']
//│ | | | | | | | | analyze[+] A8'
//│ | | | | | | | | | go A8'   ()
//│ | | | | | | | | | >>>> A8' HashSet(A8') None
//│ | | | | | | | | analyze[-] A8'
//│ | | | | | | | | | go A8'   ()
//│ | | | | | | | | | >>>> A8' HashSet(A8') Some(HashSet(α6', head7', A8'))
//│ | | | | >>>> α9' HashSet(List[A8'], α9', tail10') None
//│ | | | | >>>> tail10' HashSet(List[A8'], α9', tail10') None
//│ | | analyze[+] (α11'\head-tail & {head: α6', tail: α9'})
//│ | | | go (α11'\head-tail & {head: α6', tail: α9'})   ()
//│ | | | | analyze[+] α11'\head-tail
//│ | | | | | analyze[+] α11'
//│ | | | | | | go α11'   ()
//│ | | | | | | | go (cons<> & {head: head7', tail: tail10', Cons#A: A8'..A8'})   (α11')
//│ | | | | | | | | analyze[+] cons<>
//│ | | | | | | | | analyze[+] {head: head7', tail: tail10', Cons#A: A8'..A8'}
//│ | | | | | | | | | analyze[+] head7'
//│ | | | | | | | | | | go head7'   ()
//│ | | | | | | | | | | >>>> head7' HashSet(head7') None
//│ | | | | | | | | | analyze[+] tail10'
//│ | | | | | | | | | | go tail10'   ()
//│ | | | | | | | | | | >>>> tail10' HashSet(tail10') None
//│ | | | | | | | | | analyze[-] A8'
//│ | | | | | | | | | analyze[+] A8'
//│ | | | | | | >>>> α11' HashSet(α11') None
//│ | | | | analyze[+] {head: α6', tail: α9'}
//│ | | | | | analyze[+] α6'
//│ | | | | | | go α6'   ()
//│ | | | | | | >>>> α6' HashSet(α6') None
//│ | | | | | analyze[+] α9'
//│ | | | | | | go α9'   ()
//│ | | | | | | >>>> α9' HashSet(α9') None
//│ [occs] -α6' {α6',head7',A8'} ; -head7' {α6',head7',A8'} ; -A8' {A8'} ; +A8' {A8'} ; -α9' {List[A8'],α9',tail10'} ; -tail10' {List[A8'],α9',tail10'} ; +head7' {head7'} ; +tail10' {tail10'} ; +α11' {α11'} ; +α6' {α6'} ; +α9' {α9'}
//│ isBadlyRecursive(α6') = None None
//│ isBadlyRecursive(head7') = None None
//│ isBadlyRecursive(A8') = None None
//│ isBadlyRecursive(α9') = None None
//│ isBadlyRecursive(tail10') = None None
//│ isBadlyRecursive(α11') = None None
//│ [vars] TreeSet(α6', head7', A8', α9', tail10', α11')
//│ [rec] HashSet()
//│ [1] α11'
//│ [!] α11'
//│ [v] α6' Some(HashSet(α6')) Some(HashSet(α6', head7', A8'))
//│ [v] head7' Some(HashSet(head7')) Some(HashSet(α6', head7', A8'))
//│ [w] α6' Some(HashSet(α6', head7', A8'))
//│ [U] α6' := head7'
//│ [w] A8' Some(HashSet(A8'))
//│ [v] A8' Some(HashSet(A8')) Some(HashSet(A8'))
//│ [v] α9' Some(HashSet(α9')) Some(HashSet(List[A8'], α9', tail10'))
//│ [v] tail10' Some(HashSet(tail10')) Some(HashSet(List[A8'], α9', tail10'))
//│ [w] α9' Some(HashSet(List[A8'], α9', tail10'))
//│ [U] α9' := tail10'
//│ [sub] α6' -> Some(head7'), α9' -> Some(tail10'), α11' -> None
//│ [bounds] 
//│ 		α6' <: head7'
//│ 		head7' <: head7' & A8'
//│ 		α9' <: tail10'
//│ 		tail10' <: tail10' & List[A8']
//│ 		α11' :> (cons<> & {head: head7', tail: tail10', Cons#A: A8'..A8'})
//│ isBadlyRecursive(α6') = None None
//│ isBadlyRecursive(head7') = None Some(Some(false))
//│ isBadlyRecursive(A8') = None None
//│ isBadlyRecursive(α9') = None None
//│ isBadlyRecursive(tail10') = None Some(Some(false))
//│ isBadlyRecursive(α11') = None None
//│ [rec] HashSet(head7', tail10')
//│ transform[+] (α6' -> (α9' -> (α11'\head-tail & {head: α6', tail: α9'})))
//│ | transform[-] (α6',)
//│ | | transform[-] α6'
//│ | | | -> head7'
//│ | | | transform[-] head7'
//│ | | | | Renewed head7' ~> head12'
//│ | | | | Setting bounds of head12'
//│ | | | | transform[-] head7'
//│ | | | | ~> ⊤
//│ | | | | transform[-] A8'
//│ | | | | | Renewed A8' ~> A13'
//│ | | | | | Setting bounds of A13'
//│ | | | | ~> A13'
//│ | | | ~> head12'
//│ | | ~> head12'
//│ | ~> (head12',)
//│ | transform[+] (α9' -> (α11'\head-tail & {head: α6', tail: α9'}))
//│ | | transform[-] (α9',)
//│ | | | transform[-] α9'
//│ | | | | -> tail10'
//│ | | | | transform[-] tail10'
//│ | | | | | Renewed tail10' ~> tail14'
//│ | | | | | Setting bounds of tail14'
//│ | | | | | transform[-] tail10'
//│ | | | | | ~> ⊤
//│ | | | | | transform[-] List[A8']
//│ | | | | | | transform[=] A8'
//│ | | | | | | ~> A13'
//│ | | | | | ~> List[A13']
//│ | | | | ~> tail14'
//│ | | | ~> tail14'
//│ | | ~> (tail14',)
//│ | | transform[+] (α11'\head-tail & {head: α6', tail: α9'})
//│ | | | transform[+] α11'\head-tail
//│ | | | | transform[+] α11'
//│ | | | | | -> bound
//│ | | | | | transform[+] (cons<> & {head: head7', tail: tail10', Cons#A: A8'..A8'})
//│ | | | | | | transform[+] cons<>
//│ | | | | | | ~> cons<>
//│ | | | | | | transform[+] {head: head7', tail: tail10', Cons#A: A8'..A8'}
//│ | | | | | | | transform[+] head7'
//│ | | | | | | | ~> head12'
//│ | | | | | | | transform[+] tail10'
//│ | | | | | | | ~> tail14'
//│ | | | | | | | transform[=] A8'
//│ | | | | | | | ~> A13'
//│ | | | | | | ~> {head: head12', tail: tail14', Cons#A: A13'..A13'}
//│ | | | | | ~> (cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})
//│ | | | | ~> (cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})
//│ | | | ~> (cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail
//│ | | | transform[+] {head: α6', tail: α9'}
//│ | | | | transform[+] α6'
//│ | | | | | -> head7'
//│ | | | | | transform[+] head7'
//│ | | | | | ~> head12'
//│ | | | | ~> head12'
//│ | | | | transform[+] α9'
//│ | | | | | -> tail10'
//│ | | | | | transform[+] tail10'
//│ | | | | | ~> tail14'
//│ | | | | ~> tail14'
//│ | | | ~> {head: head12', tail: tail14'}
//│ | | ~> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})
//│ | ~> (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'}))
//│ ~> (head12' -> (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})))
//│ ⬤ Type after simplification: (head12' -> (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})))
//│  where: 
//│ 		head12' <: ⊤ & A13'
//│ 		tail14' <: ⊤ & List[A13']
//│ allVarPols: =head12', =A13', =tail14'
//│ isBadlyRecursive(head12') = None None
//│ isBadlyRecursive(A13') = None None
//│ isBadlyRecursive(tail14') = None None
//│ recVars: HashSet()
//│ coal[+] (head12' -> (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})))
//│ | dnf = DNF((head12' -> (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'}))){})
//│ | coal[-] (head12',)
//│ | | dnf = DNF((head12',){})
//│ | | coal[-] head12'
//│ | | | dnf = DNF(head12')
//│ | | | coal[-] ⊤
//│ | | | | dnf = DNF()
//│ | | | ~> ⊤
//│ | | | coal[-] A13'
//│ | | | | dnf = DNF(A13')
//│ | | | ~> A13'
//│ | | ~> head12'
//│ | ~> (head12',)
//│ | coal[+] (tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'}))
//│ | | dnf = DNF((tail14' -> ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})){})
//│ | | coal[-] (tail14',)
//│ | | | dnf = DNF((tail14',){})
//│ | | | coal[-] tail14'
//│ | | | | dnf = DNF(tail14')
//│ | | | | coal[-] ⊤
//│ | | | | | dnf = DNF()
//│ | | | | ~> ⊤
//│ | | | | coal[-] List[A13']
//│ | | | | | dnf = DNF({}∧List[A13'])
//│ | | | | | coal[=] A13'
//│ | | | | | ~> A13'
//│ | | | | ~> List[A13']
//│ | | | ~> tail14'
//│ | | ~> (tail14',)
//│ | | coal[+] ((cons<> & {head: head12', tail: tail14', Cons#A: A13'..A13'})\head-tail & {head: head12', tail: tail14'})
//│ | | | dnf = DNF(cons<>{Cons#A: A13'..A13', head: head12', tail: tail14'})
//│ | | | coal[+] cons<>
//│ | | | | dnf = DNF(cons<>{})
//│ | | | ~> cons<>
//│ | | | coal[+] {Cons#A: A13'..A13', head: head12', tail: tail14'}
//│ | | | | dnf = DNF({Cons#A: A13'..A13', head: head12', tail: tail14'})
//│ | | | | coal[-] A13'
//│ | | | | | dnf = DNF(A13')
//│ | | | | ~> A13'
//│ | | | | coal[+] A13'
//│ | | | | | dnf = DNF(A13')
//│ | | | | ~> A13'
//│ | | | | coal[+] head12'
//│ | | | | | dnf = DNF(head12')
//│ | | | | ~> head12'
//│ | | | | coal[+] tail14'
//│ | | | | | dnf = DNF(tail14')
//│ | | | | ~> tail14'
//│ | | | ~> {Cons#A: A13'..A13', head: head12', tail: tail14'}
//│ | | ~> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'})
//│ | ~> (tail14' -> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'}))
//│ ~> (head12' -> (tail14' -> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'})))
//│ ⬤ Coalesced: (head12' -> (tail14' -> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'})))
//│  where: 
//│ 		head12' <: ⊤ & A13'
//│ 		tail14' <: ⊤ & List[A13']
//│ allVarPols: =head12', =A13', =tail14'
//│ recons[+] (head12' -> (tail14' -> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'})))  (FunctionType)
//│ | recons[-] (head12',)  (TupleType)
//│ | | recons[-] head12'  (TypeVariable)
//│ | | | recons[-] ⊤  (ExtrType)
//│ | | | => ⊤
//│ | | | recons[-] A13'  (TypeVariable)
//│ | | | => A13'
//│ | | => head15'
//│ | => (head15',)
//│ | recons[+] (tail14' -> (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'}))  (FunctionType)
//│ | | recons[-] (tail14',)  (TupleType)
//│ | | | recons[-] tail14'  (TypeVariable)
//│ | | | | recons[-] ⊤  (ExtrType)
//│ | | | | => ⊤
//│ | | | | recons[-] List[A13']  (TypeRef)
//│ | | | | | recons[=] A13'  (TypeVariable)
//│ | | | | | => A13'
//│ | | | | => List[A13']
//│ | | | => tail16'
//│ | | => (tail16',)
//│ | | recons[+] (cons<> & {Cons#A: A13'..A13', head: head12', tail: tail14'})  (ComposedType)
//│ | | | DNF: DNF(cons<>{Cons#A: A13'..A13', head: head12', tail: tail14'})
//│ | | | recons[-] A13'  (TypeVariable)
//│ | | | => A13'
//│ | | | recons[+] A13'  (TypeVariable)
//│ | | | => A13'
//│ | | | recons[+] head12'  (TypeVariable)
//│ | | | => head15'
//│ | | | recons[+] tail14'  (TypeVariable)
//│ | | | => tail16'
//│ | | => (Cons[A13'] & {head: head15', tail: tail16'})
//│ | => (tail16' -> (Cons[A13'] & {head: head15', tail: tail16'}))
//│ => (head15' -> (tail16' -> (Cons[A13'] & {head: head15', tail: tail16'})))
//│ ⬤ Recons: (head15' -> (tail16' -> (Cons[A13'] & {head: head15', tail: tail16'})))
//│  where: 
//│ 		head15' <: ⊤ & A13'
//│ 		tail16' <: ⊤ & List[A13']
//│ Pols TreeMap(A13' -> None, head15' -> None, tail16' -> None)
//│ Renewed head15' ~> head17'
//│ Renewed A13' ~> A18'
//│ Renewed tail16' ~> tail19'
//│ ⬤ Cleaned up: (head17' -> (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'})))
//│  where: 
//│ 		head17' <: A18'
//│ 		tail19' <: List[A18']
//│ analyze0[+] (head17' -> (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'})))
//│ | analyze0[-] (head17',)
//│ | | analyze0[-] head17'
//│ | | | analyze0[-] A18'
//│ | analyze0[+] (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'}))
//│ | | analyze0[-] (tail19',)
//│ | | | analyze0[-] tail19'
//│ | | | | analyze0[-] List[A18']
//│ | | | | | analyze0[=] A18'
//│ | | analyze0[+] (Cons[A18'] & {head: head17', tail: tail19'})
//│ | | | analyze0[+] Cons[A18']
//│ | | | | analyze0[=] A18'
//│ | | | analyze0[+] {head: head17', tail: tail19'}
//│ | | | | analyze0[+] head17'
//│ | | | | analyze0[+] tail19'
//│ [inv] A18'
//│ [nums] -head17' 1 ; -A18' 3 ; -tail19' 1 ; +A18' 2 ; +head17' 1 ; +tail19' 1
//│ analyze[+] (head17' -> (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'})))
//│ | analyze[-] (head17',)
//│ | | analyze[-] head17'
//│ | | | go head17'   ()
//│ | | | | go A18'   (head17')
//│ | | | >>>> head17' HashSet(head17', A18') None
//│ | | | >>>> A18' HashSet(head17', A18') None
//│ | analyze[+] (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'}))
//│ | | analyze[-] (tail19',)
//│ | | | analyze[-] tail19'
//│ | | | | go tail19'   ()
//│ | | | | | go List[A18']   (tail19')
//│ | | | | | | analyze[-] List[A18']
//│ | | | | | | | analyze[+] A18'
//│ | | | | | | | | go A18'   ()
//│ | | | | | | | | >>>> A18' HashSet(A18') None
//│ | | | | | | | analyze[-] A18'
//│ | | | | | | | | go A18'   ()
//│ | | | | | | | | >>>> A18' HashSet(A18') Some(HashSet(head17', A18'))
//│ | | | | >>>> tail19' HashSet(tail19', List[A18']) None
//│ | | analyze[+] (Cons[A18'] & {head: head17', tail: tail19'})
//│ | | | go (Cons[A18'] & {head: head17', tail: tail19'})   ()
//│ | | | | analyze[+] Cons[A18']
//│ | | | | | analyze[+] A18'
//│ | | | | | analyze[-] A18'
//│ | | | | analyze[+] {head: head17', tail: tail19'}
//│ | | | | | analyze[+] head17'
//│ | | | | | | go head17'   ()
//│ | | | | | | >>>> head17' HashSet(head17') None
//│ | | | | | analyze[+] tail19'
//│ | | | | | | go tail19'   ()
//│ | | | | | | >>>> tail19' HashSet(tail19') None
//│ [occs] -head17' {head17',A18'} ; -A18' {A18'} ; +A18' {A18'} ; -tail19' {tail19',List[A18']} ; +head17' {head17'} ; +tail19' {tail19'}
//│ isBadlyRecursive(head17') = None None
//│ isBadlyRecursive(A18') = None None
//│ isBadlyRecursive(tail19') = None None
//│ [vars] TreeSet(head17', A18', tail19')
//│ [rec] HashSet()
//│ [v] head17' Some(HashSet(head17')) Some(HashSet(head17', A18'))
//│ [w] A18' Some(HashSet(A18'))
//│ [v] A18' Some(HashSet(A18')) Some(HashSet(A18'))
//│ [v] tail19' Some(HashSet(tail19')) Some(HashSet(tail19', List[A18']))
//│ [sub] 
//│ [bounds] 
//│ 		head17' <: A18'
//│ 		tail19' <: List[A18']
//│ isBadlyRecursive(head17') = None None
//│ isBadlyRecursive(A18') = None None
//│ isBadlyRecursive(tail19') = None None
//│ [rec] HashSet()
//│ transform[+] (head17' -> (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'})))
//│ | transform[-] (head17',)
//│ | | transform[-] head17'
//│ | | | Renewed head17' ~> head20'
//│ | | | Inlining bounds of head17' (~> head20')
//│ | | | transform[-] A18'
//│ | | | | Renewed A18' ~> A21'
//│ | | | | Setting bounds of A21'
//│ | | | ~> A21'
//│ | | ~> (A21' & head20')
//│ | ~> ((A21' & head20'),)
//│ | transform[+] (tail19' -> (Cons[A18'] & {head: head17', tail: tail19'}))
//│ | | transform[-] (tail19',)
//│ | | | transform[-] tail19'
//│ | | | | Renewed tail19' ~> tail22'
//│ | | | | Inlining bounds of tail19' (~> tail22')
//│ | | | | transform[-] List[A18']
//│ | | | | | transform[=] A18'
//│ | | | | | ~> A21'
//│ | | | | ~> List[A21']
//│ | | | ~> (List[A21'] & tail22')
//│ | | ~> ((List[A21'] & tail22'),)
//│ | | transform[+] (Cons[A18'] & {head: head17', tail: tail19'})
//│ | | | transform[+] Cons[A18']
//│ | | | | transform[=] A18'
//│ | | | | ~> A21'
//│ | | | ~> Cons[A21']
//│ | | | transform[+] {head: head17', tail: tail19'}
//│ | | | | transform[+] head17'
//│ | | | | | Inlining bounds of head17' (~> head20')
//│ | | | | | transform[+] ⊥
//│ | | | | | ~> ⊥
//│ | | | | ~> head20'
//│ | | | | transform[+] tail19'
//│ | | | | | Inlining bounds of tail19' (~> tail22')
//│ | | | | | transform[+] ⊥
//│ | | | | | ~> ⊥
//│ | | | | ~> tail22'
//│ | | | ~> {head: head20', tail: tail22'}
//│ | | ~> (Cons[A21'] & {head: head20', tail: tail22'})
//│ | ~> ((List[A21'] & tail22') -> (Cons[A21'] & {head: head20', tail: tail22'}))
//│ ~> ((A21' & head20') -> ((List[A21'] & tail22') -> (Cons[A21'] & {head: head20', tail: tail22'})))
//│ ⬤ Resim: ((A21' & head20') -> ((List[A21'] & tail22') -> (Cons[A21'] & {head: head20', tail: tail22'})))
//│  where: 
//│ allVarPols: =head20', =A21', =tail22'
//│ consed: Map()
//│ Cons: ('A & 'head) -> (List['A] & 'tail) -> (Cons['A] & {head: 'head, tail: 'tail})
//│     = [Function: Cons2]


Cons 2
//│ res: (List['A] & 'tail) -> (Cons['A] with {head: 2, tail: 'tail})
//│   where
//│     'A :> 2
//│    = [Function (anonymous)]

Cons 2 Nil
//│ res: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 2
//│    = Cons { head: 2, tail: Nil {} }

res.head
//│ res: 2
//│    = 2

:e
Cons 1 res
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.547: 	Cons 1 res
//│ ║         	^^^^^^^^^^
//│ ╟── integer literal of type `2` does not match type `Cons[?A] | Nil`
//│ ║  l.536: 	Cons 2 Nil
//│ ║         	     ^
//│ ╟── but it flows into reference with expected type `Cons[?A0] | Nil`
//│ ║  l.547: 	Cons 1 res
//│ ║         	       ^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.4: 	type List[A] = Nil | Cons[A]
//│ ║       	               ^^^^^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.105: 	def Cons head tail = originalCons { head; tail } with { head; tail }
//│ ╙──       	                                          ^^^^
//│ res: (Cons['A] with {head: 1, tail: 2}) | error
//│   where
//│     'A :> 1
//│    = Cons { head: 1, tail: 2 }

// Here there used to be a loss of precision in the older with-field approach.
//    The problem occured when constraining `α8 w/ {head: α5, tail: [α6]}  <!  nil | {head: α2}`
//    as we can't decide whether to constrain `α8 <! nil` or `α5 <! α2`...
// I seemingly solved it by just pushing `with` extensions applied on variables to the right
//    just long enough to push it back on the left after travsering type variable bounds...
//    This is okay because `with` types otherwise never occur in negative position... Note we could
//    have used a different "delayed with" type to be cleaner, though it's just not necessary.
// But then I reverted to the use of simple field-hiding types, as they are simpler!
// 
Cons 1 (Cons 2 Nil)
//│ res: Cons['A] with {head: 1, tail: Cons['A] with {head: 2, tail: Nil}}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 1, tail: Cons { head: 2, tail: Nil {} } }

{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ res: {a: 1, b: 2, c: Nil}
//│    = { a: 1, b: 2, c: Nil {} }

Cons 2 Nil
//│ res: Cons['A] with {head: 2, tail: Nil}
//│   where
//│     'A :> 2
//│    = Cons { head: 2, tail: Nil {} }

Cons 1 (id res)
//│ res: Cons['A] with {head: 1, tail: Cons['A] with {head: 2, tail: Nil}}
//│   where
//│     'A :> 1 | 2
//│    = Cons { head: 1, tail: Cons { head: 2, tail: Nil {} } }

{ a = res.head; b = res.tail.head; c = res.tail.tail }
//│ res: {a: 1, b: 2, c: Nil}
//│    = { a: 1, b: 2, c: Nil {} }


def Cons head = originalCons { head=0; tail=Nil } with { head }
//│ Cons: 'a -> (Cons['A] with {head: 'a, tail: Nil})
//│   where
//│     'A :> 0
//│     = [Function: Cons3]

Cons 1
//│ res: Cons['A] with {head: 1, tail: Nil}
//│   where
//│     'A :> 0
//│    = Cons { head: 1, tail: Nil {} }

res.head
//│ res: 1
//│    = 1

def c = Cons 1
//│ c: Cons['A] with {head: 1, tail: Nil}
//│   where
//│     'A :> 0
//│  = Cons { head: 1, tail: Nil {} }

c.head
//│ res: 1
//│    = 1

def c: 'a -> List['b] -> List['a | 'b]
c 1 (c 2 Nil)
//│ c: 'a -> List['b] -> List['a | 'b]
//│  = <missing implementation>
//│ res: List['a]
//│   where
//│     'a :> 2 | 1
//│    = <no result>
//│      c is not implemented

def c: 'a -> ('l & List['b]) -> (Cons[anything] & { head: 'a; tail: 'l })
c 1 (c 2 Nil)
//│ c: 'a -> (List['b] & 'l) -> (Cons[anything] & {head: 'a, tail: 'l})
//│  = <missing implementation>
//│ res: Cons[anything] & {head: 1, tail: Cons[anything] & {head: 2, tail: Nil}}
//│    = <no result>
//│      c is not implemented
