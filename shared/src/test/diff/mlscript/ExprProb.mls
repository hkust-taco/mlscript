:NoProvs // TODO rm


def intToString: int -> string
def intToString x = toString x
def done x = case x of {}
//│ intToString: int -> string
//│            = <missing implementation>
//│ anything -> string
//│   <:  intToString:
//│ int -> string
//│            = [Function: intToString]
//│ done: nothing -> nothing
//│     = [Function: done]



class Lit: { val: int }
class Add[E]: { lhs: E; rhs: E }
def lit val = Lit { val }
def add lhs rhs = Add { lhs; rhs }
//│ Defined class Lit
//│ Defined class Add
//│ lit: 'val -> (Lit & {val: 'val})
//│   where
//│     'val <: int
//│    = [Function: lit]
//│ add: 'lhs -> 'rhs -> (Add['E] & {lhs: 'lhs, rhs: 'rhs})
//│   where
//│     'rhs <: 'E
//│     'lhs <: 'E
//│    = [Function: add]



rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> 'b) -> 'c -> 'b
//│   where
//│     'c <: Add[?] & 'd | 'a & ~add
//│     'd <: {lhs: 'e}
//│     'e <: 'c
//│           = [Function: eval1_stub]

rec def eval1_stub k e = case e of {
  | Add -> eval1_stub k e.lhs + eval1_stub k e.rhs
  | _ -> k e
  }
//│ eval1_stub: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | 'a & ~add
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│           = [Function: eval1_stub1]

:ns
rec def eval1_stub e = case e of {
  | Lit -> 1
  | Add -> eval1_stub e.lhs
  | _ -> 0
  }
//│ eval1_stub: 'a
//│   where
//│     'a :> 'b -> (1 | 'c | 0)
//│        <: 'd -> 'c
//│     'c :> 1 | 'c | 0
//│     'b <: lit & 'e | (add & 'f | 'g & ~add) & ~lit
//│     'f <: {lhs: 'd}
//│     'd <: 'b
//│           = [Function: eval1_stub2]

eval1_stub
//│ res: 'a -> (0 | 1)
//│   where
//│     'a <: Add[?] & 'b | Lit | ~add & ~lit
//│     'b <: {lhs: 'c}
//│     'c <: 'a
//│    = [Function: eval1_stub2]

// def eval1: ('b -> int) -> Expr['b] -> int
:stats
rec def eval1 k e = case e of {
  | Lit -> e.val
  | Add -> eval1 k e.lhs + eval1 k e.rhs
  | _ -> k e
  }
//│ eval1: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│      = [Function: eval1]
//│ constrain calls  : 44
//│ annoying  calls  : 0
//│ subtyping calls  : 16

:ns
eval1
//│ res: 'a
//│   where
//│     'a :> 'b -> 'c -> ('d | 'e | 'f)
//│        <: 'b -> ('g & 'h)
//│     'h :> 'c -> ('d | 'e | 'f)
//│        <: 'i -> 'j
//│     'j :> 'd | 'e | 'f
//│        <: int
//│     'g :> 'c -> ('d | 'e | 'f)
//│        <: 'k -> 'l
//│     'l :> 'd | 'e | 'f
//│        <: int
//│     'e := int
//│     'c <: lit & 'm | (add & 'n | 'o & ~add) & ~lit
//│     'n <: {lhs: 'i, rhs: 'k}
//│     'k <: 'c
//│     'i <: 'c
//│     'm <: {val: 'd}
//│     'd <: int
//│     'b <: 'o -> 'f
//│     'f <: int
//│    = [Function: eval1]

:re
error: ~Add[?]
//│ res: ~Add[?]
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~Lit) -> 'a
//│ res: ('a & (~{val: int} | ~lit)) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a) -> ('a & Add[?])
error: ('a) -> ('a & ~Add[?])
error: ('a & ~Add[?]) -> 'a
//│ res: 'a -> (Add[?] & 'a)
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: 'a -> ('a & ~add)
//│ Runtime error:
//│   Error: unexpected runtime error
//│ res: ('a & (~{Add#E :> anything <: nothing} | ~{lhs: nothing} | ~{rhs: nothing} | ~add)) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:re
error: ('a & ~add) -> 'a
//│ res: ('a & ~add) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

:ns
def eval1_ty_ugly: ('a -> int) -> (Lit | Add['b] | 'a & ~Lit & ~Add[?] as 'b) -> int
//│ eval1_ty_ugly: ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~Lit & ~Add[?]
//│              = <missing implementation>

eval1_ty_ugly
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b :> 'a & ~add & ~lit | Add['b] | Lit
//│        <: Add['b] | Lit | 'a & (~{val: int} & ~add | ~add & ~lit | ~{Add#E :> anything <: nothing} & ~lit | ~{lhs: nothing} & ~lit | ~{rhs: nothing} & ~lit)
//│    = <no result>
//│      eval1_ty_ugly is not implemented

:stats
def eval1_ty_ugly = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b :> 'a & ~add & ~lit | Add['b] | Lit
//│        <: Add['b] | Lit | 'a & (~{val: int} & ~add | ~add & ~lit | ~{Add#E :> anything <: nothing} & ~lit | ~{lhs: nothing} & ~lit | ~{rhs: nothing} & ~lit)
//│              = [Function: eval1]
//│ constrain calls  : 39
//│ annoying  calls  : 36
//│ subtyping calls  : 292

:ns
def eval1_ty: ('a -> int) -> (Lit | Add['b] | 'a & ~lit & ~add as 'b) -> int
//│ eval1_ty: ('a -> int) -> 'b -> int
//│   where
//│     'b := Lit | Add['b] | 'a & ~lit & ~add
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 39
//│ annoying  calls  : 36
//│ subtyping calls  : 112

:stats
eval1_ty_ugly = eval1_ty
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│   <:  eval1_ty_ugly:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b :> 'a & ~add & ~lit | Add['b] | Lit
//│        <: Add['b] | Lit | 'a & (~{val: int} & ~add | ~add & ~lit | ~{Add#E :> anything <: nothing} & ~lit | ~{lhs: nothing} & ~lit | ~{rhs: nothing} & ~lit)
//│              = [Function: eval1]
//│ constrain calls  : 12
//│ annoying  calls  : 1
//│ subtyping calls  : 231

:stats
eval1_ty = eval1_ty_ugly
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b :> 'a & ~add & ~lit | Add['b] | Lit
//│        <: Add['b] | Lit | 'a & (~{val: int} & ~add | ~add & ~lit | ~{Add#E :> anything <: nothing} & ~lit | ~{lhs: nothing} & ~lit | ~{rhs: nothing} & ~lit)
//│   <:  eval1_ty:
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b := 'a & ~add & ~lit | Add['b] | Lit
//│         = [Function: eval1]
//│ constrain calls  : 12
//│ annoying  calls  : 1
//│ subtyping calls  : 407


// Workaround:
:ns
type E1[A] = Lit | Add[E1[A]] | A & ~lit & ~add
def eval1_ty: ('a -> int) -> E1['a] -> int
//│ Defined type alias E1
//│ eval1_ty: ('a -> int) -> E1['a] -> int
//│         = <missing implementation>

eval1_ty
//│ res: ('a -> int) -> E1['a] -> int
//│    = <no result>
//│      eval1_ty is not implemented

:stats
def eval1_ty = eval1
//│ ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│   <:  eval1_ty:
//│ ('a -> int) -> E1['a] -> int
//│         = [Function: eval1]
//│ constrain calls  : 43
//│ annoying  calls  : 38
//│ subtyping calls  : 68
// :ds


:stats
rec def pretty1 k e = case e of {
  | Lit -> intToString e.val
  | Add -> concat (pretty1 k e.lhs) (pretty1 k e.rhs)
  | _ -> k e
  }
//│ pretty1: ('a -> string) -> 'b -> string
//│   where
//│     'b <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│     'c <: {lhs: 'd, rhs: 'e}
//│     'e <: 'b
//│     'd <: 'b
//│        = [Function: pretty1]
//│ constrain calls  : 50
//│ annoying  calls  : 0
//│ subtyping calls  : 17

// TODO find out why the `prettier` types are not simplified more

:stats
rec def prettier1 k ev e = case e of {
  | Lit -> intToString e.val
  | Add ->
      let tmp = pretty1 k e.lhs
      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
  | _ -> k e
  }
//│ prettier1: ('a -> string) -> ('b -> int) -> (Add[?] & 'b | Lit | 'a & ~add & ~lit) -> string
//│   where
//│     'b <: {lhs: Add[?] & 'c | Lit | 'a & ~add & ~lit, rhs: 'd}
//│     'd <: Add[?] & 'e | Lit | 'a & ~add & ~lit
//│     'e <: {lhs: 'f, rhs: 'g}
//│     'g <: 'd
//│     'f <: 'd
//│     'c <: {lhs: 'h, rhs: 'i}
//│     'i <: 'j
//│     'h <: 'j
//│     'j <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│          = [Function: prettier1]
//│ constrain calls  : 88
//│ annoying  calls  : 0
//│ subtyping calls  : 68


// FIXME canon does haywire here – way too expensive
// FIXME reconstruction makes α110 polar! – some info is lost – Note: only happens without :NoProvs
// :ds
:stats
prettier1
//│ res: ('a -> string) -> ('b -> int) -> (Add[?] & 'b | Lit | 'a & ~add & ~lit) -> string
//│   where
//│     'b <: {lhs: Add[?] & 'c | Lit | 'a & ~add & ~lit, rhs: 'd}
//│     'd <: Add[?] & 'e | Lit | 'a & ~add & ~lit
//│     'e <: {lhs: 'f, rhs: 'g}
//│     'g <: 'd
//│     'f <: 'd
//│     'c <: {lhs: 'h, rhs: 'i}
//│     'i <: 'j
//│     'h <: 'j
//│     'j <: Add[?] & 'c | Lit | 'a & ~add & ~lit
//│    = [Function: prettier1]
//│ constrain calls  : 0
//│ annoying  calls  : 0
//│ subtyping calls  : 68

:stats
e1 = Add{lhs = Lit {val = 1}; rhs = Add{lhs = Lit {val = 2}; rhs = Lit {val = 3}}}
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
//│ e1: Add['E] with {lhs: Lit & {val: 1}, rhs: Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   where
//│     'E :> (Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E0 :> Lit & {val: 2} | Lit & {val: 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: 2 | 3 | int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'
//│ constrain calls  : 281
//│ annoying  calls  : 240
//│ subtyping calls  : 470


e1 = add (lit 1) (add (lit 2) (lit 3))
eval1 done e1
pretty1 done e1
prettier1 done (eval1 done) e1
//│ e1: Add['E] with {lhs: Lit & {val: 1}, rhs: Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│   where
//│     'E :> (Add['E0] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E0 :> Lit & {val: 2} | Lit & {val: 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Add { lhs: Lit { val: 2 }, rhs: Lit { val: 3 } }
//│     }
//│ res: 2 | 3 | int
//│    = 6
//│ res: string
//│    = '123'
//│ res: string
//│    = '123'



class Nega[E]: { arg: E }
def nega arg = Nega { arg }
//│ Defined class Nega
//│ nega: 'arg -> (Nega['E] & {arg: 'arg})
//│   where
//│     'arg <: 'E
//│     = [Function: nega]



rec def eval2 k = eval1 (fun x -> case x of {
  | Nega -> 0 - (eval2 k x.arg)
  | _ -> k x
  })
//│ eval2: ('a -> int) -> 'b -> int
//│   where
//│     'b <: Add[?] & 'c | Lit | 'd & ~add & ~lit
//│     'd <: Nega[?] & 'e | 'a & ~nega
//│     'e <: {arg: 'f}
//│     'f <: 'b
//│     'c <: {lhs: 'g, rhs: 'h}
//│     'h <: 'b
//│     'g <: 'b
//│      = [Function: eval2]


// FIXME particularly egregious type!
// :ds
:stats
rec def prettier2 k ev = prettier1 (fun x -> case x of {
  | Nega -> concat "-" (prettier2 k ev x.arg)
  | _ -> k x
  }) ev
//│ prettier2: ('a -> string) -> ('b -> int) -> 'c -> string
//│   where
//│     'b <: {lhs: 'd, rhs: 'e}
//│     'e <: 'f
//│     'f <: Add[?] & 'g | Lit | 'h & ~add & ~lit
//│     'h <: 'i
//│     'g <: {lhs: 'j, rhs: 'k}
//│     'k <: 'f
//│     'j <: 'f
//│     'd <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'l <: {lhs: 'n, rhs: 'o}
//│     'o <: 'p
//│     'n <: 'p
//│     'p <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'm <: 'i
//│     'i <: Nega[?] & 'q | 'a & ~nega
//│     'q <: {arg: 'r}
//│     'r <: 'c
//│     'c <: Add[?] & 'b | Lit | 's & ~add & ~lit
//│     's <: 'i
//│          = [Function: prettier2]
//│ constrain calls  : 86
//│ annoying  calls  : 0
//│ subtyping calls  : 74

// :ds
:stats
prettier2
//│ res: ('a -> string) -> ('b -> int) -> 'c -> string
//│   where
//│     'b <: {lhs: 'd, rhs: 'e}
//│     'e <: 'f
//│     'f <: Add[?] & 'g | Lit | 'h & ~add & ~lit
//│     'h <: 'i
//│     'g <: {lhs: 'j, rhs: 'k}
//│     'k <: 'f
//│     'j <: 'f
//│     'd <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'l <: {lhs: 'n, rhs: 'o}
//│     'o <: 'p
//│     'n <: 'p
//│     'p <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'm <: 'i
//│     'i <: Nega[?] & 'q | 'a & ~nega
//│     'q <: {arg: 'r}
//│     'r <: 'c
//│     'c <: Add[?] & 'b | Lit | 's & ~add & ~lit
//│     's <: 'i
//│    = [Function: prettier2]
//│ constrain calls  : 0
//│ annoying  calls  : 0
//│ subtyping calls  : 74



:stats
eval2 done e1
//│ res: 2 | 3 | int
//│    = 6
//│ constrain calls  : 57
//│ annoying  calls  : 60
//│ subtyping calls  : 80

e2 = add (lit 1) (nega e1)
//│ e2: Add['E] with {lhs: Lit & {val: 1}, rhs: Nega['E0] with {arg: Add['E1] with {lhs: Lit & {val: 1}, rhs: Add['E2] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}}}
//│   where
//│     'E :> Lit & {val: 1} | (Nega['E0] with {arg: Add['E1] with {lhs: Lit & {val: 1}, rhs: Add['E2] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}})
//│     'E0 :> Add['E1] with {lhs: Lit & {val: 1}, rhs: Add['E2] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}}
//│     'E1 :> (Add['E2] with {lhs: Lit & {val: 2}, rhs: Lit & {val: 3}}) | Lit & {val: 1}
//│     'E2 :> Lit & {val: 2} | Lit & {val: 3}
//│   = Add {
//│       lhs: Lit { val: 1 },
//│       rhs: Nega { arg: Add { lhs: [Lit], rhs: [Add] } }
//│     }

:stats
eval2 done e2
//│ res: 2 | 3 | int
//│    = -5
//│ constrain calls  : 81
//│ annoying  calls  : 103
//│ subtyping calls  : 127

d2 = nega (add (lit 1) (nega (lit 1)))
//│ d2: Nega['E] with {arg: Add['E0] with {lhs: Lit & {val: 1}, rhs: Nega['E1] with {arg: Lit & {val: 1}}}}
//│   where
//│     'E :> Add['E0] with {lhs: Lit & {val: 1}, rhs: Nega['E1] with {arg: Lit & {val: 1}}}
//│     'E0 :> Lit & {val: 1} | (Nega['E1] with {arg: Lit & {val: 1}})
//│     'E1 :> Lit & {val: 1}
//│   = Nega { arg: Add { lhs: Lit { val: 1 }, rhs: Nega { arg: [Lit] } } }

:stats
eval2 done d2
//│ res: int
//│    = 0
//│ constrain calls  : 56
//│ annoying  calls  : 71
//│ subtyping calls  : 71


prettier2 done
//│ res: ('a -> int) -> 'b -> string
//│   where
//│     'a <: {lhs: 'c, rhs: 'd}
//│     'd <: 'e
//│     'e <: Add[?] & 'f | Lit | 'g & ~add & ~lit
//│     'g <: 'h
//│     'f <: {lhs: 'i, rhs: 'j}
//│     'j <: 'e
//│     'i <: 'e
//│     'c <: Add[?] & 'k | Lit | 'l & ~add & ~lit
//│     'k <: {lhs: 'm, rhs: 'n}
//│     'n <: 'o
//│     'm <: 'o
//│     'o <: Add[?] & 'k | Lit | 'l & ~add & ~lit
//│     'l <: 'h
//│     'h <: {arg: 'p} & Nega[?] & 'h
//│     'p <: 'b
//│     'b <: Add[?] & 'a | Lit | 'q & ~add & ~lit
//│     'q <: 'h
//│    = [Function (anonymous)]

:stats
prettier2 done (eval1 done)
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & 'b | Lit | 'c & ~add & ~lit
//│     'c <: 'd
//│     'b <: {lhs: 'e, rhs: 'f} & 'g
//│     'g <: Add[?] & 'h | Lit
//│     'h <: {lhs: 'i, rhs: 'j}
//│     'j <: 'g
//│     'i <: 'g
//│     'f <: 'k
//│     'k <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'm <: 'd
//│     'l <: {lhs: 'n, rhs: 'o}
//│     'o <: 'k
//│     'n <: 'k
//│     'e <: Add[?] & 'p | Lit | 'q & ~add & ~lit
//│     'p <: {lhs: 'r, rhs: 's}
//│     's <: 't
//│     'r <: 't
//│     't <: Add[?] & 'p | Lit | 'q & ~add & ~lit
//│     'q <: 'd
//│     'd <: {arg: 'u} & Nega[?] & 'd
//│     'u <: 'a
//│    = [Function (anonymous)]
//│ constrain calls  : 36
//│ annoying  calls  : 0
//│ subtyping calls  : 89

:stats
prettier2 done (eval2 done)
prettier2 done (eval2 done) e2
prettier2 done (eval2 done) d2
//│ res: 'a -> string
//│   where
//│     'a <: Add[?] & 'b | Lit | 'c & ~add & ~lit
//│     'c <: 'd
//│     'b <: {lhs: 'e, rhs: 'f} & 'g
//│     'g <: Add[?] & 'h | Lit | 'i & ~add & ~lit
//│     'i <: {arg: 'j} & Nega[?] & 'i
//│     'j <: 'g
//│     'h <: {lhs: 'k, rhs: 'l}
//│     'l <: 'g
//│     'k <: 'g
//│     'f <: 'm
//│     'm <: Add[?] & 'n | Lit | 'o & ~add & ~lit
//│     'o <: 'd
//│     'n <: {lhs: 'p, rhs: 'q}
//│     'q <: 'm
//│     'p <: 'm
//│     'e <: Add[?] & 'r | Lit | 's & ~add & ~lit
//│     'r <: {lhs: 't, rhs: 'u}
//│     'u <: 'v
//│     't <: 'v
//│     'v <: Add[?] & 'r | Lit | 's & ~add & ~lit
//│     's <: 'd
//│     'd <: {arg: 'w} & Nega[?] & 'd
//│     'w <: 'a
//│    = [Function (anonymous)]
//│ res: string
//│    = '1-123'
//│ res: string
//│    = '-1'
//│ constrain calls  : 343
//│ annoying  calls  : 335
//│ subtyping calls  : 583




// === === === ERROR CASES === === === //


:ShowRelativeLineNums


:e
eval1 done e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	eval1 done e2
//│ ║        	^^^^^^^^^^^^^
//│ ╟── expression of type `Nega[?E] with {arg: ?arg}` does not match type `nothing`
//│ ╟── Note: constraint arises from wildcard pattern:
//│ ║  l.88: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from field selection:
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                                   ^^^^^
//│ res: error | int
//│ Runtime error:
//│   Error: non-exhaustive case expression


:e
prettier2 done eval1 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] with {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.372: 	e1 = add (lit 1) (add (lit 2) (lit 3))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.88: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from refined scrutinee:
//│ ║  l.303: 	rec def prettier1 k ev e = case e of {
//│ ╙──       	                                ^
//│ res: error | string
//│    = '123'


:e
:stats
prettier2 done (eval1 done) e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done (eval1 done) e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `Nega[?E] with {arg: ?arg}` does not match type `nothing`
//│ ╟── Note: constraint arises from wildcard pattern:
//│ ║  l.88: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from field selection:
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ╙──      	                                   ^^^^^
//│ res: error | string
//│ Runtime error:
//│   Error: non-exhaustive case expression
//│ constrain calls  : 168
//│ annoying  calls  : 198
//│ subtyping calls  : 386

:e
:stats
prettier2 done eval2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ res: 'a -> string | error
//│   where
//│     'a <: Add[?] & 'b | Lit | 'c & ~add & ~lit
//│     'c <: 'd
//│     'b <: nothing -> int & {lhs: 'e, rhs: 'f}
//│     'f <: 'g
//│     'g <: Add[?] & 'h | Lit | 'i & ~add & ~lit
//│     'i <: 'd
//│     'h <: {lhs: 'j, rhs: 'k}
//│     'k <: 'g
//│     'j <: 'g
//│     'e <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'l <: {lhs: 'n, rhs: 'o}
//│     'o <: 'p
//│     'n <: 'p
//│     'p <: Add[?] & 'l | Lit | 'm & ~add & ~lit
//│     'm <: 'd
//│     'd <: {arg: 'q} & Nega[?] & 'd
//│     'q <: 'a
//│    = [Function (anonymous)]
//│ constrain calls  : 24
//│ annoying  calls  : 0
//│ subtyping calls  : 90

:e
:stats
prettier2 done eval2 e1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e1
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] with {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.372: 	e1 = add (lit 1) (add (lit 2) (lit 3))
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.405: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from refined scrutinee:
//│ ║  l.303: 	rec def prettier1 k ev e = case e of {
//│ ╙──       	                                ^
//│ res: error | string
//│    = '123'
//│ constrain calls  : 76
//│ annoying  calls  : 62
//│ subtyping calls  : 169

:e
:stats
prettier2 done eval2 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] with {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.489: 	e2 = add (lit 1) (nega e1)
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.405: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from refined scrutinee:
//│ ║  l.303: 	rec def prettier1 k ev e = case e of {
//│ ╙──       	                                ^
//│ res: error | string
//│    = '1-123'
//│ constrain calls  : 101
//│ annoying  calls  : 107
//│ subtyping calls  : 330

:e
:stats
prettier2 done eval2 d2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 d2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval2 d2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `Add[?E] with {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ╟── Note: constraint arises from application:
//│ ║  l.405: 	  | _ -> k x
//│ ║         	         ^^^
//│ ╟── from field selection:
//│ ║  l.423: 	  | Nega -> concat "-" (prettier2 k ev x.arg)
//│ ╙──       	                                       ^^^^^
//│ res: error | string
//│    = '-1-1'
//│ constrain calls  : 76
//│ annoying  calls  : 73
//│ subtyping calls  : 148

:e
:stats
prettier2 done eval1 e2
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── function of type `?a -> (?b | ?c | ?d)` does not match type `int`
//│ ║  l.85: 	rec def eval1 k e = case e of {
//│ ║        	                ^^^^^^^^^^^^^^^
//│ ║  l.86: 	  | Lit -> e.val
//│ ║        	^^^^^^^^^^^^^^^^
//│ ║  l.87: 	  | Add -> eval1 k e.lhs + eval1 k e.rhs
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.88: 	  | _ -> k e
//│ ║        	^^^^^^^^^^^^
//│ ║  l.89: 	  }
//│ ║        	^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.307: 	      in if ev e == 0 then tmp else concat tmp (pretty1 k e.rhs)
//│ ╙──       	            ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.+1: 	prettier2 done eval1 e2
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── application of type `Add[?E] with {lhs: ?lhs, rhs: ?rhs}` is not a function
//│ ║  l.489: 	e2 = add (lit 1) (nega e1)
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.88: 	  | _ -> k e
//│ ║        	         ^^^
//│ ╟── from refined scrutinee:
//│ ║  l.303: 	rec def prettier1 k ev e = case e of {
//│ ╙──       	                                ^
//│ res: error | string
//│    = '1-123'
//│ constrain calls  : 100
//│ annoying  calls  : 107
//│ subtyping calls  : 326

