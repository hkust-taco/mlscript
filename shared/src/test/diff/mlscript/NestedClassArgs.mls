:NoJS
:NoProvs


class C[A]
  method In: A -> A
  method In = id
//│ Defined class C[=A]
//│ Declared C.In: C['A] -> 'A -> 'A
//│ Defined C.In: C['A] -> 'a -> 'a

def c: C[C[int]]
//│ c: C[C[int]]

def c: 'a -> C[C['a]]
//│ c: 'a -> C[C['a]]

def c: C[C['a]] -> 'a
//│ c: C[C['a]] -> 'a

def c: C['a] as 'a
//│ c: 'a
//│   where
//│     'a := C['a]

def c: C['a] | 'a as 'a
//│ c: 'a
//│   where
//│     'a :> C['a]

def c: C[C['a]] as 'a
//│ c: 'a
//│   where
//│     'a := C[C['a]]

def c: C[C['a] & 'a] as 'a
//│ c: 'a
//│   where
//│     'a := C[C['a] & 'a]

def c: C[C['a] & 'a | 'a] as 'a
//│ c: 'a
//│   where
//│     'a := C['a]

def c: C['a]
//│ c: C['a]


class C2[A]: { a: A }
  method In: A -> A
  method In = id
//│ Defined class C2[=A]
//│ Declared C2.In: C2['A] -> 'A -> 'A
//│ Defined C2.In: C2['A] -> 'a -> 'a


def mkC: 'a -> C2['a]
//│ mkC: 'a -> C2['a]

mkC' a = C2 { a }
//│ mkC': ('a & 'A) -> (C2['A] with {a: 'a})

mkC = mkC'
//│ ('a & 'A) -> (C2['A] with {a: 'a})
//│   <:  mkC:
//│ 'a -> C2['a]

rec def rc = mkC(rc)
//│ rc: 'rc
//│   where
//│     'rc :> C2['a]
//│     'a :> 'rc

rec def rc = mkC'(rc)
//│ rc: 'a
//│   where
//│     'a :> C2['A] with {a: 'a}
//│     'A :> 'a



class C3[A]: { a: C3[A] }
  method In: A -> A
  method In = id
//│ Defined class C3[=A]
//│ Declared C3.In: C3['A] -> 'A -> 'A
//│ Defined C3.In: C3['A] -> 'a -> 'a

def c: 'a -> C3['a]
//│ c: 'a -> C3['a]

rec def c a = C3 { a = c a }
//│ anything -> 'a
//│   where
//│     'a :> C3['A] with {a: 'a}
//│   <:  c:
//│ 'a -> C3['a]

rec def c (a: 'X) = C3 { a = c a: 'X }: C3['X]
//│ anything -> C3['X]
//│   <:  c:
//│ 'a -> C3['a]


class C4[A]: { a: C[C4[A]] }
  method In: A -> A
  method In = id
//│ Defined class C4[=A]
//│ Declared C4.In: C4['A] -> 'A -> 'A
//│ Defined C4.In: C4['A] -> 'a -> 'a

def c: 'a -> C4['a]
//│ c: 'a -> C4['a]

C{}
//│ res: C['A]

def c4 a = C4{ a = C{} }
//│ c4: anything -> (C4['A] with {a: C[C4['A]]})

def c = c4
//│ anything -> (C4['A] with {a: C[C4['A]]})
//│   <:  c:
//│ 'a -> C4['a]


class C5[A]: { a: C2[C5[A]] }
  method In: A -> A
  method In = id
//│ Defined class C5[=A]
//│ Declared C5.In: C5['A] -> 'A -> 'A
//│ Defined C5.In: C5['A] -> 'a -> 'a

def c: 'a -> C5['a]
//│ c: 'a -> C5['a]

rec def c5 a = C5{ a = C2 { a = c5 a } }
//│ c5: anything -> 'a
//│   where
//│     'a :> C5['A] with {a: C2['A0] with {a: 'a}}
//│     'A0 :> 'a | C5['A]
//│         <: C5['A]

c = c5
//│ anything -> 'a
//│   where
//│     'a :> C5['A] with {a: C2['A0] with {a: 'a}}
//│     'A0 :> 'a | C5['A]
//│         <: C5['A]
//│   <:  c:
//│ 'a -> C5['a]


class C6[A]: { a: C5[C6[A]] }
  method In: A -> A
  method In = id
//│ Defined class C6[=A]
//│ Declared C6.In: C6['A] -> 'A -> 'A
//│ Defined C6.In: C6['A] -> 'a -> 'a

def c: 'a -> C6['a]
//│ c: 'a -> C6['a]

// :s
// :d
// rec def c a = C6{ a = c5 (c a) }

rec def c6 a = C6{ a = c5 (c6 a) }
//│ c6: anything -> (C6['A] with {a: 'a})
//│   where
//│     'a :> C5[C6['A]] with {a: C2['A0] with {a: 'a}}
//│     'A0 :> 'a | C5[C6['A]]
//│         <: C5[C6['A]]

:stats
c = c6
//│ anything -> (C6['A] with {a: 'a})
//│   where
//│     'a :> C5[C6['A]] with {a: C2['A0] with {a: 'a}}
//│     'A0 :> 'a | C5[C6['A]]
//│         <: C5[C6['A]]
//│   <:  c:
//│ 'a -> C6['a]
//│ constrain calls  : 212
//│ annoying  calls  : 179
//│ subtyping calls  : 2368


// A reproduction of an issue found while trying out TypeRef ctor typing:

// anything -> (C6['A] with {a: 'a})
//   where
//     'a :> C5[C6['A]] with {a: C2['A0] with {a: 'a}}
//     'A0 :> 'a | C5[C6['A]]
//         <: C5[C6['A]] | C5[C6['A]] & ~c5 | C5[C6['A]] & ~{C5#A = C6['A]} | C5[C6['A]] & ~{a: C2[C5[C6['A]]]}

def e: C5[C6['A]] | C5[C6['A]] & ~c5 | C5[C6['A]] | C5[C6['A]] & ~{a: C2[C5[C6['A]]]}
//│ e: C5[C6['A]]

def e: C5[C6['A]] & {a: C2[C5[C6['A]] | C5[C6['A]] & ~c5 | C5[C6['A]] | C5[C6['A]] & ~{a: C2[C5[C6['A]]]}] & {a: 'a}}
//│ e: C5[C6['A]] & {a: C2[C5[C6['A]]] & {a: nothing}}

type Inner = C5[C6['A]] & {a: C2[C5[C6['A]] | C5[C6['A]] & ~c5 | C5[C6['A]] | C5[C6['A]] & ~{a: C2[C5[C6['A]]]}] & {a: 'a}} as 'a
//│ Defined type alias Inner

def e: anything -> (C6['A] & {a: Inner})
//│ e: anything -> (C6['A] with {a: Inner})

c = e
//│ anything -> (C6['A] with {a: Inner})
//│   <:  c:
//│ 'a -> C6['a]


// Simplification/Minimization:

type T1 = { x: T1 & { x: T1 } }
type T2 = { x: T2 }
//│ Defined type alias T1
//│ Defined type alias T2

// :stdout
// :d
error : T1 : T2
//│ res: T2





class N: {}
class S[T]: { v: T }
  method In: T -> ()
  method In _ = ()
type O[T] = S[T] | N
class L[T]: { h: T; t: O[L[T]] }
  method Append: T -> L[T]
  method Append elem = L { h = elem; t = S { v = this } }
// Defined class N
//│ Defined class N
//│ Defined class S[=T]
//│ Declared S.In: S['T] -> 'T -> ()
//│ Defined S.In: S['T] -> anything -> ()
//│ Defined type alias O[=T]
//│ Defined class L[=T]
//│ Declared L.Append: L['T] -> 'T -> L['T]
//│ Defined L.Append: (L['T] & 'this) -> ('T & 'h) -> (L['T] with {h: 'h, t: S[L['T]] & {v: L['T] & 'this}})

// :ds
// L.Append

// before:
//  Defined L.Append: L['T] -> ('T & 'a & 'b) -> (L['T & 'b .. 'T | 'b] with {h: 'a, t: S[L['T & 'b .. 'T | 'b] & 'c .. L['T & 'b .. 'T | 'b] | L['T] | 'c] with {v: L['T]}})

L.Append
//│ res: L['T] -> 'T -> L['T]


def append ls elem = L { h = elem; t = S { v = ls } }
//│ append: (L['T] & 'v & 'T0) -> ('T & 'h) -> (L['T] with {h: 'h, t: S['T0] with {v: 'v}})

def append0 ls = L { h = 0; t = S { v = ls } }
//│ append0: (L['T] & 'v & 'T0) -> (L['T] with {h: 0, t: S['T0] with {v: 'v}})
//│   where
//│     'T :> 0

def appendNil elem = L { h = elem; t = N{} }
//│ appendNil: ('h & 'T) -> (L['T] with {h: 'h, t: N})


S{v=1}
//│ res: S['T] & {v: 1}
//│   where
//│     'T :> 1

