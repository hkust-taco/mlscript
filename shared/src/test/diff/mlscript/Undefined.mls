class Undefined: { x: undefined }
//│ Defined class Undefined

Undefined
//│ res: {x: undefined & 'x} -> (Undefined with {x: 'x})
//│    = [Function: res]

Undefined { x = undefined }
//│ res: Undefined
//│    = Undefined { x: undefined }

:e
Undefined { x = "I am here to make a type mismatch." }
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.13: 	Undefined { x = "I am here to make a type mismatch." }
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"I am here to make a type mismatch."` does not match type `undefined`
//│ ║  l.13: 	Undefined { x = "I am here to make a type mismatch." }
//│ ║        	                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.1: 	class Undefined: { x: undefined }
//│ ╙──     	                      ^^^^^^^^^
//│ res: error | (Undefined with {x: "I am here to make a type mismatch."})
//│    = Undefined { x: 'I am here to make a type mismatch.' }

:e
type Undefined = { x: string }
//│ ╔══[ERROR] Type 'Undefined' is already defined.
//│ ║  l.27: 	type Undefined = { x: string }
//│ ╙──      	     ^^^^^^^^^

type AnotherUndefined = { x: undefined }
//│ Defined type alias AnotherUndefined

type MoreOnTypes0 = undefined
//│ Defined type alias MoreOnTypes0

type MoreOnTypes1 = undefined -> undefined
//│ Defined type alias MoreOnTypes1

type MoreOnTypes2 = undefined -> undefined -> undefined
//│ Defined type alias MoreOnTypes2

type MoreOnTypes3 = (undefined -> undefined) -> null
//│ Defined type alias MoreOnTypes3

sample = undefined
sample: undefined
//│ sample: undefined
//│       = undefined
//│ res: undefined
//│    = undefined

sample2 = null
sample2: null
//│ sample2: null
//│        = null
//│ res: null
//│    = null

:e
sample: bool
sample2: bool
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.62: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── undefined literal of type `undefined` does not match type `bool`
//│ ║  l.47: 	sample = undefined
//│ ║        	         ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.62: 	sample: bool
//│ ║        	^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.62: 	sample: bool
//│ ╙──      	        ^^^^
//│ res: bool
//│    = undefined
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.63: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── null literal of type `null` does not match type `bool`
//│ ║  l.54: 	sample2 = null
//│ ║        	          ^^^^
//│ ╟── but it flows into reference with expected type `bool`
//│ ║  l.63: 	sample2: bool
//│ ║        	^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.63: 	sample2: bool
//│ ╙──      	         ^^^^
//│ res: bool
//│    = null

if false then sample else 0
if true then sample2 else 0
//│ res: 0 | undefined
//│    = 0
//│ res: 0 | null
//│    = null


def bar = fun sample -> (sample: MoreOnTypes0)
bar undefined
//│ bar: undefined -> undefined
//│    = [Function: bar]
//│ res: undefined
//│    = undefined

:e
bar "undefined"
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.109: 	bar "undefined"
//│ ║         	^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"undefined"` does not match type `undefined`
//│ ║  l.109: 	bar "undefined"
//│ ║         	    ^^^^^^^^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.35: 	type MoreOnTypes0 = undefined
//│ ║        	                    ^^^^^^^^^
//│ ╟── from reference:
//│ ║  l.101: 	def bar = fun sample -> (sample: MoreOnTypes0)
//│ ╙──       	                         ^^^^^^
//│ res: error | undefined
//│    = 'undefined'

case (undefined) of { undefined -> "undefined it is" | null -> "null it is"}
//│ res: "null it is" | "undefined it is"
//│    = 'undefined it is'

case (null) of { undefined -> "undefined it is" | null -> "null it is" }
//│ res: "null it is" | "undefined it is"
//│    = 'null it is'
