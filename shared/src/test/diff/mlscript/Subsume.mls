
// Declare signature:
def f: int -> int
//│ f: int -> int

// Define body:
def f x = x
//│ 'a -> 'a
//│   <:  f:
//│ int -> int

:e
def f = 42
//│ 42
//│   <:  f:
//│ int -> int
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.13: 	def f = 42
//│ ║        	        ^^
//│ ╟── expression of type `42` is not a function
//│ ╟── Note: constraint arises from function type:
//│ ║  l.3: 	def f: int -> int
//│ ╙──     	       ^^^^^^^^^^


f 1
//│ res: int

fun x -> f x
//│ res: int -> int



def boom: anything
//│ boom: anything

def boom = 1
//│ 1
//│   <:  boom:
//│ anything

:e
add boom 1
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.43: 	add boom 1
//│ ║        	^^^^^^^^
//│ ╟── expression of type `anything` does not match type `int`
//│ ║  l.34: 	def boom: anything
//│ ║        	          ^^^^^^^^
//│ ╟── but it flows into reference with expected type `int`
//│ ║  l.43: 	add boom 1
//│ ╙──      	    ^^^^
//│ res: error | int


def boom: nothing
//│ boom: nothing

:e
def boom = 1
//│ 1
//│   <:  boom:
//│ nothing
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.60: 	def boom = 1
//│ ║        	           ^
//│ ╟── expression of type `1` does not match type `nothing`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.56: 	def boom: nothing
//│ ╙──      	          ^^^^^^^


def boom: 'a
//│ boom: nothing

:e
def boom = 1
//│ 1
//│   <:  boom:
//│ nothing
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.77: 	def boom = 1
//│ ║        	           ^
//│ ╟── expression of type `1` does not match type `'a`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.73: 	def boom: 'a
//│ ╙──      	          ^^



def id: 'a -> 'a
//│ id: 'a -> 'a

id 1
id true
//│ res: 1
//│ res: true

def id x = x
//│ 'a -> 'a
//│   <:  id:
//│ 'a -> 'a

id 1
id true
//│ res: 1
//│ res: true


:e
def id n = add n 1
//│ int -> int
//│   <:  id:
//│ 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.111: 	def id n = add n 1
//│ ║         	       ^^^^^^^^^^^
//│ ╟── expression of type `'a` does not match type `int`
//│ ║  l.91: 	def id: 'a -> 'a
//│ ║        	        ^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.111: 	def id n = add n 1
//│ ╙──       	               ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.111: 	def id n = add n 1
//│ ║         	       ^^^^^^^^^^^
//│ ╟── expression of type `int` does not match type `'a`
//│ ║  l.111: 	def id n = add n 1
//│ ║         	           ^^^^^^^
//│ ╟── but it flows into function of type `?a -> ?b`
//│ ║  l.111: 	def id n = add n 1
//│ ║         	       ^^^^^^^^^^^
//│ ╟── which does not match type `'a -> 'a`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.91: 	def id: 'a -> 'a
//│ ╙──      	              ^^

:e
def id (x: int) = x
//│ int -> int
//│   <:  id:
//│ 'a -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.139: 	def id (x: int) = x
//│ ║         	        ^^^^^^^^^^^
//│ ╟── expression of type `'a` does not match type `int`
//│ ║  l.91: 	def id: 'a -> 'a
//│ ║        	        ^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.139: 	def id (x: int) = x
//│ ╙──       	           ^^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.139: 	def id (x: int) = x
//│ ║         	        ^^^^^^^^^^^
//│ ╟── expression of type `int` does not match type `'a`
//│ ║  l.139: 	def id (x: int) = x
//│ ║         	           ^^^
//│ ╟── but it flows into reference with expected type `'a`
//│ ║  l.139: 	def id (x: int) = x
//│ ║         	                  ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.91: 	def id: 'a -> 'a
//│ ╙──      	              ^^



def f: (int & 'a) -> 'a
//│ f: (int & 'a) -> 'a

def impl a = a a
//│ impl: ('a -> 'b & 'a) -> 'b

:e
def f = impl
//│ ('a -> 'b & 'a) -> 'b
//│   <:  f:
//│ (int & 'a) -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.174: 	def f = impl
//│ ║         	        ^^^^
//│ ╟── expression of type `int & 'a` does not match type `?a -> ?b`
//│ ║  l.167: 	def f: (int & 'a) -> 'a
//│ ║         	        ^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.170: 	def impl a = a a
//│ ╙──       	             ^^^

f 1 
//│ res: 1


def f: (int & 'a) -> (int & 'a) -> 'a 
def f a b = if gt a b then a else b
//│ f: (int & 'a) -> (int & 'a) -> 'a
//│ (int & 'a) -> (int & 'a) -> 'a
//│   <:  f:
//│ (int & 'a) -> (int & 'a) -> 'a

f 1 
//│ res: (int & 'a) -> ('a | 1)

:e
def f a b = if gt a b then a else b b // mistake!
//│ (int & 'a) -> nothing -> 'a
//│   <:  f:
//│ (int & 'a) -> (int & 'a) -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.203: 	def f a b = if gt a b then a else b b // mistake!
//│ ║         	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `int & 'a` does not match type `?a -> ?b`
//│ ║  l.192: 	def f: (int & 'a) -> (int & 'a) -> 'a 
//│ ║         	                      ^^^^^^^^
//│ ╟── Note: constraint arises from application:
//│ ║  l.203: 	def f a b = if gt a b then a else b b // mistake!
//│ ╙──       	                                  ^^^

f 1 
//│ res: (int & 'a) -> ('a | 1)

res 2
//│ res: 1 | 2


:e
def g: (int & 'a) -> 'a
def g a = add a 1
//│ g: (int & 'a) -> 'a
//│ int -> int
//│   <:  g:
//│ (int & 'a) -> 'a
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.226: 	def g a = add a 1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── expression of type `int` does not match type `'a`
//│ ║  l.226: 	def g a = add a 1
//│ ║         	          ^^^^^^^
//│ ╟── but it flows into function of type `?a -> ?b`
//│ ║  l.226: 	def g a = add a 1
//│ ║         	      ^^^^^^^^^^^
//│ ╟── which does not match type `(int & 'a) -> 'a`
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.225: 	def g: (int & 'a) -> 'a
//│ ╙──       	                     ^^

