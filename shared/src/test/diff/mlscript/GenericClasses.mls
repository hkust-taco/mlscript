
class None: {}
def None = None{}
//│ Defined class None
//│ None: None
//│     = None {}

class Some[A]: { value: A }
def Some v = Some { value = v }
//│ Defined class Some[+A]
//│ Some: 'value -> Some['value]
//│     = [Function: Some1]

Some 42
(Some 42).value
//│ res: Some[42]
//│    = Some { value: 42 }
//│ res: 42
//│    = 42

type Option[A] = Some[A] | None
//│ Defined type alias Option[+A]

None: Option[int]
Some 42 : Option[int]
//│ res: Option[int]
//│    = None {}
//│ res: Option[int]
//│    = Some { value: 42 }

:e
res.value
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.32: 	res.value
//│ ║        	^^^^^^^^^
//│ ╟── type `None` does not have field 'value'
//│ ║  l.21: 	type Option[A] = Some[A] | None
//│ ║        	                           ^^^^
//│ ╟── but it flows into reference with expected type `{value: ?value}`
//│ ║  l.32: 	res.value
//│ ╙──      	^^^
//│ res: error | int
//│    = 42

:e
42: Option[int, int]
//│ ╔══[ERROR] Wrong number of type arguments – expected 1, found 2
//│ ║  l.46: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.46: 	42: Option[int, int]
//│ ║        	^^
//│ ╟── integer literal of type `42` does not match type `None | Some[int]`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.21: 	type Option[A] = Some[A] | None
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.46: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ res: Option[int]
//│    = 42


class Foo1[A]: { x: A }
class Bar1: Foo1[int]
//│ Defined class Foo1[+A]
//│ Defined class Bar1

Bar1
//│ res: {x: int & 'x} -> (Bar1 with {x: 'x})
//│    = [Function: res]

g = Bar1 { x = 42 }
//│ g: Bar1 with {x: 42}
//│  = Bar1 { x: 42 }

g: Foo1['a]
//│ res: Foo1[int]
//│    = Bar1 { x: 42 }

res.x
//│ res: int
//│    = 42

g: Foo1['a]: Foo1[int]
//│ res: Foo1[int]
//│    = Bar1 { x: 42 }

res.x
//│ res: int
//│    = 42

:e
g: Foo1['a]: Foo1[string]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.94: 	g: Foo1['a]: Foo1[string]
//│ ║        	^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.65: 	class Bar1: Foo1[int]
//│ ║        	                 ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.94: 	g: Foo1['a]: Foo1[string]
//│ ╙──      	                  ^^^^^^
//│ res: Foo1[string]
//│    = Bar1 { x: 42 }


:w
class Foo2[A]
//│ Defined class Foo2[±A]
//│ ╔══[WARNING] Type definition Foo2 has bivariant type parameters:
//│ ║  l.109: 	class Foo2[A]
//│ ║         	      ^^^^
//│ ╟── A is irrelevant and may be removed
//│ ║  l.109: 	class Foo2[A]
//│ ╙──       	           ^

Foo2
//│ res: anything -> Foo2[anything]
//│    = [Function: res]

:re
error: Foo2[int]
//│ res: Foo2[anything]
//│ Runtime error:
//│   Error: unexpected runtime error

f = fun x -> case x of { Foo2 -> x }
//│ f: (Foo2[anything] & 'a) -> 'a
//│  = [Function: f]

f (Foo2 {})
//│ res: Foo2[anything]
//│    = Foo2 {}

:re
error: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[anything] & 'a) -> 'a
//│ Runtime error:
//│   Error: unexpected runtime error

f: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[anything] & 'a) -> 'a
//│    = [Function: f]

:ns
f: (Foo2[?] & 'a) -> 'a
//│ res: (Foo2[?] & 'a) -> 'a
//│   where
//│     'a :> Foo2[?] & 'a
//│        <: (foo2 | ~{Foo2#A = ?} | ~foo2 | ~(foo2 & {Foo2#A = ?})) & (foo2 | ~(foo2 & {Foo2#A = ?}))
//│    = [Function: f]

f
//│ res: (Foo2[anything] & 'a) -> 'a
//│    = [Function: f]


def mrg: Foo2[int] & Foo2[string]
//│ mrg: Foo2[anything]
//│    = <missing implementation>

mrg: Foo2[int]
//│ res: Foo2[anything]
//│    = <no result>
//│      mrg is not implemented

:e
mrg = Foo2{}
//│ Foo2[anything]
//│   <:  mrg:
//│ Foo2[anything]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.169: 	mrg = Foo2{}
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `string` is not an instance of `int`
//│ ║  l.159: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	                          ^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.159: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	              ^^^
//│ ╟── Note: class type parameter A is defined at:
//│ ║  l.109: 	class Foo2[A]
//│ ╙──       	           ^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.169: 	mrg = Foo2{}
//│ ║         	^^^^^^^^^^^^
//│ ╟── type `int` is not an instance of `string`
//│ ║  l.159: 	def mrg: Foo2[int] & Foo2[string]
//│ ║         	              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.159: 	def mrg: Foo2[int] & Foo2[string]
//│ ╙──       	                          ^^^^^^
//│    = Foo2 {}

def mrg: Foo2[int] | Foo2[string]
//│ mrg: Foo2[anything]
//│    = <missing implementation>

