
class None: {}
def None = None{}
//│ Defined class None
//│ None: none

class Some[A]: { value: A }
def Some v = Some { value = v }
//│ Defined class Some
//│ Some: 'a -> some & {value: 'a}

Some 42
(Some 42).value
//│ res: some & {value: 42}
//│ res: 42

type Option[A] = Some[A] | None
//│ Defined type Option

None: Option[int]
Some 42 : Option[int]
//│ res: Option[int]
//│ res: Option[int]

:e
res.value
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.26: 	res.value
//│ ║        	^^^
//│ ╟── expression of type `none` does not have field 'value'
//│ ║  l.17: 	type Option[A] = Some[A] | None
//│ ║        	                           ^^^^
//│ ╟── but it flows into reference with expected type `{value: ?a}`
//│ ║  l.26: 	res.value
//│ ╙──      	^^^
//│ res: error | int

// FIXME properly check:
42: Option[int, int]
//│ ╔══[ERROR] Wrong number of type arguments – expected 1, found 2
//│ ║  l.39: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ /!!!\ Uncaught error: java.lang.StackOverflowError
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:130)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)
//│ 	at: mlscript.ConstraintSolver.$anonfun$constrain$5(ConstraintSolver.scala:259)
//│ 	at: scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.scala:18)
//│ 	at: mlscript.TyperHelpers.trace(TyperHelpers.scala:17)
//│ 	at: mlscript.ConstraintSolver.annoyingImpl$1(ConstraintSolver.scala:128)
//│ 	at: mlscript.ConstraintSolver.annoying$1(ConstraintSolver.scala:125)

