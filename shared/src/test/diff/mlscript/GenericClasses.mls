
class None: {}
def None = None{}
//│ Defined class None
//│ None: none

class Some[A]: { value: A }
def Some v = Some { value = v }
//│ Defined class Some
//│ Some: 'a -> (some & {value: 'a})

Some 42
(Some 42).value
//│ res: some & {value: 42}
//│ res: 42

type Option[A] = Some[A] | None
//│ Defined type alias Option

None: Option[int]
Some 42 : Option[int]
//│ res: some & {value: int} | none
//│ res: some & {value: int} | none

:e
res.value
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.26: 	res.value
//│ ║        	^^^^^^^^^
//│ ╟── expression of type `none` does not have field 'value'
//│ ║  l.17: 	type Option[A] = Some[A] | None
//│ ║        	                           ^^^^
//│ ╟── but it flows into reference with expected type `{value: ?a}`
//│ ║  l.26: 	res.value
//│ ╙──      	^^^
//│ res: error | int

:e
42: Option[int, int]
//│ ╔══[ERROR] Wrong number of type arguments – expected 1, found 2
//│ ║  l.39: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.39: 	42: Option[int, int]
//│ ║        	^^
//│ ╟── expression of type `42` does not match type `some & {value: int} | none`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.17: 	type Option[A] = Some[A] | None
//│ ║        	                 ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.39: 	42: Option[int, int]
//│ ╙──      	    ^^^^^^^^^^^^^^^^
//│ res: some & {value: int} | none

