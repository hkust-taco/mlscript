
"hello": 'a
//│ res: "hello"

:e
"hello": 'a -> 'a
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.6: 	"hello": 'a -> 'a
//│ ║       	^^^^^^^
//│ ╟── expression of type `"hello"` is not a function
//│ ╟── Note: constraint arises from function type:
//│ ║  l.6: 	"hello": 'a -> 'a
//│ ╙──     	         ^^^^^^^^
//│ res: error -> error

{ name = "Bob" } : { name: 'a }
//│ res: {name: "Bob"}

def foo(n: 'a) = add n 1
//│ foo: int -> int
def foo(n: 'a) = add n 1: 'a
//│ foo: int -> int


class Foo[A]: { field: A }
//│ Defined class Foo

def foo(f: Foo['a]) = f.field
//│ foo: Foo['a] -> 'a


(succ 1): int
//│ res: int


def foo({ a; b }: { a: int; b: string}) = { b; a }
//│ foo: {a: int, b: string} -> {a: int, b: string}

:e
def foo({ a = "hey" }: { a: string}) = 0
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.40: 	def foo({ a = "hey" }: { a: string}) = 0
//│ ║        	        ^^^^^^^^^^^^^
//│ ╟── expression of type `string` does not match type `"hey"`
//│ ║  l.40: 	def foo({ a = "hey" }: { a: string}) = 0
//│ ║        	                            ^^^^^^
//│ ╟── Note: constraint arises from string literal:
//│ ║  l.40: 	def foo({ a = "hey" }: { a: string}) = 0
//│ ╙──      	              ^^^^^
//│ foo: {a: string} -> 0

:e
def foo({ a; b }: { a: int }) = b
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.53: 	def foo({ a; b }: { a: int }) = b
//│ ║        	        ^^^^^^^^
//│ ╟── expression of type `{a: int}` does not have field 'b'
//│ ║  l.53: 	def foo({ a; b }: { a: int }) = b
//│ ╙──      	                  ^^^^^^^^^^
//│ foo: {a: int} -> nothing

