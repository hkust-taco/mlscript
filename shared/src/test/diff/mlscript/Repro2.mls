:d
class Box[A]: { value: A }
  method Get = this.value
//│ 0. Typing type Record(List((value,TypeName(A))))
//│ | vars=Map(A -> A0') newDefsInfo=Map(Box -> (Cls,1))
//│ => {value: A0'} | 
//│ >>> Going through method Get in Box
//│ >>> Created a type variable for "this" this2' <: Box[A0']
//│ >>> reverseRigid2 (2 entries)
//│ >>> 1. A o: ‹class type parameter:Loc(10,11,Repro2:+2)› -> A0' o: ‹class type parameter:Loc(10,11,Repro2:+2)›
//│ >>> 2. this [NO PROV] -> this2' [NO PROV]
//│ >>> folding a term: this.value
//│ >>> prt.name = Box, nme.name = Get
//│ >>> So now we're inheriting Box.Get
//│ >>> Got nothing from the context. Try to type the term.
//│ 1. Typing term this.value
//│ | 1. Typing term this
//│ | 1. : [(this & Box[A0'])]
//│ | CONSTRAIN [[(this & Box[A0'])]] <! {value: α3'}
//│ |   where 
//│ | C [[(this & Box[A0'])]] <! {value: α3'}
//│ | | C [(this & Box[A0'])] <! {value: α3'}
//│ | | | C (this & Box[A0']) <! {value: α3'}
//│ | | | | ARGH  DNF(box<>{Box#A: (A0' -> A0'), value: A0'}∧this)  <!  DNF({value: α3'})
//│ | | | | | Consider box<>{Box#A: (A0' -> A0'), value: A0'}∧this <: DNF({value: α3'})
//│ | | | | | Possible: List({value: α3'})
//│ | | | | | Factorized: List({value: α3'})
//│ | | | | | A  box<>{Box#A: (A0' -> A0'), value: A0'}∧this  %  List()  <!  List({value: α3'})  %  ⊥
//│ | | | | | | A  box<>{Box#A: (A0' -> A0'), value: A0'}∧this  %  List()  <!  List()  %  RhsField(value,α3')
//│ | | | | | | | A  box<>{Box#A: (A0' -> A0'), value: A0'}∧this  %  List()  <!  List()  %  |Some(Right(RhsField(value,α3')))
//│ | | | | | | | | A  {Box#A: (A0' -> A0'), value: A0'}∧this  %  List()  <!  List()  %  |Some(Right(RhsField(value,α3')))
//│ | | | | | | | | | C A0' <! α3'
//│ 1. : α3'
//│ >>> substituted method body type: PolymorphicType(0,α3')
//│ >>> Box.Get : PolymorphicType(0,(((this2' & Box[A0']),) -> α3'))
//│ >> Checking subsumption for inferred type of Get : MethodType(0,Some(((this2' & Box[A0']),α3')),List(TypeName(Box)),false)
//│ Defined class Box
//│ Typed as: (((this2' & Box[A0']),) -> α3')
//│  where: A0' <: [[α3']], this2' <: Box[A0']
//│ Defined Box.Get: Box['A] -> 'A

:d
class IntBox: Box[int]
//│ 0. Typing type AppliedType(TypeName(Box),List(TypeName(int)))
//│ | vars=Map() newDefsInfo=Map(IntBox -> (Cls,0))
//│ => Box[Int] | 
//│ >>> Going through method Get in Box
//│ >>> Created a type variable for "this" this1' <: IntBox
//│ >>> reverseRigid2 (1 entries)
//│ >>> 1. this [NO PROV] -> this1' [NO PROV]
//│ >>> folding a term: this.value
//│ >>> prt.name = Box, nme.name = Get
//│ >>> So now we're inheriting Box.Get
//│ >>> Found a method from the context: MethodType(0,Some(((this2' & Box[A0']),α3')),List(TypeName(Box)),false)
//│ >>> Its body type is PolymorphicType(0,[α3'])
//│ >>> We're going to substitute:
//│ >>> 1. A0' -> Int
//│ >>> substituted method body type: PolymorphicType(0,α3')
//│ >>> Box.Get : PolymorphicType(0,(((this1' & IntBox),) -> α3'))
//│ >> Checking subsumption for inferred type of Get : MethodType(0,Some((IntBox,α3')),List(TypeName(Box)),false)
//│ Defined class IntBox

ib0 = IntBox { value = 0 }
//│ ib0: IntBox & {value: 0}
//│    = IntBox { value: 0 }

ib0.(IntBox.Get)
//│ res: nothing
//│    = undefined
