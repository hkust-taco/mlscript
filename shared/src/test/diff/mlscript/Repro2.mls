:d
class Box[A]: { value: A }
  method Get = this.value
//│ 0. Typing type Record(List((value,TypeName(A))))
//│ | vars=Map(A -> A0') newDefsInfo=Map(Box -> (Cls,1))
//│ => {value: A0'} | 
//│ >>> Going through method Get in Box
//│ >>> Created a type variable for "this" this2' <: Box[A0']
//│ >>> reverseRigid2 (2 entries)
//│ >>> 1. A o: ‹class type parameter:Loc(10,11,Repro2:+2)› -> A0' o: ‹class type parameter:Loc(10,11,Repro2:+2)›
//│ >>> 2. this [NO PROV] -> this2' [NO PROV]
//│ >>> folding a term: this.value
//│ >>> prt.name = Box, nme.name = Get
//│ >>> So now we're inheriting Box.Get
//│ >>> Got nothing from the context. Try to type the term.
//│ 1. Typing term this.value
//│ | 1. Typing term this
//│ | 1. : [(this & Box[A])]
//│ | CONSTRAIN [[(this & Box[A])]] <! {value: α3'}
//│ |   where 
//│ | C [[(this & Box[A])]] <! {value: α3'}
//│ | | C [(this & Box[A])] <! {value: α3'}
//│ | | | C (this & Box[A]) <! {value: α3'}
//│ | | | | ARGH  DNF(box<>{Box#A: (A -> A), value: A}∧this)  <!  DNF({value: α3'})
//│ | | | | | Consider box<>{Box#A: (A -> A), value: A}∧this <: DNF({value: α3'})
//│ | | | | | Possible: List({value: α3'})
//│ | | | | | Factorized: List({value: α3'})
//│ | | | | | A  box<>{Box#A: (A -> A), value: A}∧this  %  List()  <!  List({value: α3'})  %  ⊥
//│ | | | | | | A  box<>{Box#A: (A -> A), value: A}∧this  %  List()  <!  List()  %  RhsField(value,α3')
//│ | | | | | | | A  box<>{Box#A: (A -> A), value: A}∧this  %  List()  <!  List()  %  |Some(Right(RhsField(value,α3')))
//│ | | | | | | | | A  {Box#A: (A -> A), value: A}∧this  %  List()  <!  List()  %  |Some(Right(RhsField(value,α3')))
//│ | | | | | | | | | C A <! α3'
//│ 1. : α3'
//│ >>> substituted method body type: PolymorphicType(0,α4')
//│ >>> Box.Get : PolymorphicType(0,(((this2' & Box[A0']),) -> α4'))
//│ >> Checking subsumption for inferred type of Get : MethodType(0,Some(((this2' & Box[A0']),α4')),List(TypeName(Box)),false)
//│ Defined class Box
//│ Typed as: (((this2' & Box[A0']),) -> α4')
//│  where: this2' <: Box[A0'], α4' :> A0'
//│ Defined Box.Get: Box['A] -> 'A

// Box.Get should be PolymorphicType(0, (this1' & IntBox,) -> α3')
//  where int <: α3' 

:d
class IntBox: Box[int]
//│ 0. Typing type AppliedType(TypeName(Box),List(TypeName(int)))
//│ | vars=Map() newDefsInfo=Map(IntBox -> (Cls,0))
//│ => Box[Int] | 
//│ >>> Going through method Get in Box
//│ >>> Created a type variable for "this" this1' <: IntBox
//│ >>> reverseRigid2 (1 entries)
//│ >>> 1. this [NO PROV] -> this1' [NO PROV]
//│ >>> folding a term: this.value
//│ >>> prt.name = Box, nme.name = Get
//│ >>> So now we're inheriting Box.Get
//│ >>> Found a method from the context: MethodType(0,Some(((this2' & Box[A0']),α4')),List(TypeName(Box)),false)
//│ >>> Its body type is PolymorphicType(0,[α4'])
//│ >>> We're going to substitute:
//│ >>> 1. A0' -> Int
//│ >>> substituted method body type: PolymorphicType(0,α3')
//│ >>> Box.Get : PolymorphicType(0,(((this1' & IntBox),) -> α3'))
//│ >> Checking subsumption for inferred type of Get : MethodType(0,Some((IntBox,α3')),List(TypeName(Box)),false)
//│ Defined class IntBox

IntBox.Get
//│ res: IntBox -> int
//│    = undefined

ib0 = IntBox { value = 0 }
//│ ib0: IntBox & {value: 0}
//│    = IntBox { value: 0 }

ib0.(IntBox.Get)
//│ res: int
//│    = undefined
