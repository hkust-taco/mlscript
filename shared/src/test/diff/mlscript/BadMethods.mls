:AllowTypeErrors

class Foo[A]: { x: A }
    method Map[B]: (A -> B) -> A
class Bar[A]: Foo[A]
    method Map[B]: B -> A
    rec method Map f = f Map (fun x -> Map)
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.7: 	    rec method Map f = f Map (fun x -> Map)
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `B` is not a function
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	    rec method Map f = f Map (fun x -> Map)
//│ ╙──     	                       ^^^^^
//│ Defined class Foo
//│ Declared Foo.Map: (foo & {Foo#A = 'A, x: 'A}) -> ('A -> anything) -> 'A
//│ Defined class Bar
//│ Declared Bar.Map: (bar & {Foo#A = 'A, Bar#A = 'A, x: 'A}) -> (('a -> (anything -> 'a) -> 'b) -> 'b as 'a)
//│ Defined Bar.Map: (bar & {Foo#A = 'A, Bar#A = 'A, x: 'A}) -> (('a -> (anything -> 'a) -> 'b) -> 'b as 'a)

Foo.Map
Bar.Map
//│ res: (foo & {Foo#A = 'A, x: 'A}) -> ('A -> anything) -> 'A
//│ res: (bar & {Foo#A = 'A, Bar#A = 'A, x: 'A}) -> (('a -> (anything -> 'a) -> 'b) -> 'b as 'a)




class bar[A, B]: Foo[A] & { Y: B; z: int }
    method identity z = z
    method identity z = z
//│ ╔══[ERROR] Type names must start with a capital letter
//│ ║  l.29: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	      ^^^
//│ ╔══[ERROR] Field identifiers must start with a small letter
//│ ║  l.29: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	                            ^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.30: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.31: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ ╔══[ERROR] Method 'bar.identity' is already defined.
//│ ║  l.31: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ Defined class bar
//│ Defined bar.identity: (bar & {Foo#A = 'A, z: int, Y: 'B, x: 'A, bar#A: 'A -> 'A, bar#B: 'B -> 'B}) -> 'a -> 'a
//│ Defined bar.identity: (bar & {Foo#A = 'A, z: int, Y: 'B, x: 'A, bar#A: 'A -> 'A, bar#B: 'B -> 'B}) -> 'a -> 'a




class ImplicitCall[A]: { x: A }
    method Fun = this.x
//│ Defined class ImplicitCall
//│ Defined ImplicitCall.Fun: (implicitCall & {ImplicitCall#A = 'A, x: 'A}) -> 'A

i = ImplicitCall { x = "stonks" }
i.Fun
//│ i: implicitCall & {ImplicitCall#A :> 'A | "stonks" <: 'A, x: "stonks"}
//│ res: "stonks"

class NoMoreImplicitCall
    method Fun = "not stonks"
//│ Defined class NoMoreImplicitCall
//│ Defined NoMoreImplicitCall.Fun: noMoreImplicitCall -> "not stonks"

i.Fun
//│ ╔══[ERROR] Implicit call to method Fun is forbidden because it is ambiguous.
//│ ║  l.69: 	i.Fun
//│ ║        	^^^^^
//│ ╟── Unrelated methods named Fun are defined by:
//│ ╟── • class ImplicitCall
//│ ║  l.54: 	class ImplicitCall[A]: { x: A }
//│ ║        	      ^^^^^^^^^^^^
//│ ╟── • class NoMoreImplicitCall
//│ ║  l.64: 	class NoMoreImplicitCall
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ res: error




def this = fun x -> fun y -> add x y
this 42 42
//│ this: int -> int -> int
//│ res: int

class BadThis: { x: int; y: int }
    method Sum = this this.x this.y
    method Funny = this 42 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.91: 	    method Sum = this this.x this.y
//│ ║        	                 ^^^^^^^^^^^
//│ ╟── expression of type `badThis & {x: int, y: int}` does not match type `?a -> ?b`
//│ ║  l.90: 	class BadThis: { x: int; y: int }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `?a -> ?b`
//│ ║  l.91: 	    method Sum = this this.x this.y
//│ ╙──      	                 ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.92: 	    method Funny = this 42 42
//│ ║        	                   ^^^^^^^
//│ ╟── expression of type `badThis & {x: int, y: int}` does not match type `42 -> ?a`
//│ ║  l.90: 	class BadThis: { x: int; y: int }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `42 -> ?a`
//│ ║  l.92: 	    method Funny = this 42 42
//│ ╙──      	                   ^^^^
//│ Defined class BadThis
//│ Defined BadThis.Sum: (badThis & {y: int, x: int}) -> error
//│ Defined BadThis.Funny: (badThis & {y: int, x: int}) -> error




class BadSelf[A]: { x: A }
    method F = this.x 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.119: 	    method F = this.x 42
//│ ║         	               ^^^^^^^^^
//│ ╟── expression of type `A` is not a function
//│ ║  l.119: 	    method F = this.x 42
//│ ╙──       	               ^^^^^^
//│ Defined class BadSelf
//│ Defined BadSelf.F: (badSelf & {BadSelf#A = 'A, x: 'A}) -> error

c = BadSelf { x = fun x -> x }
c.F
//│ c: badSelf & {BadSelf#A :> 'A | 'a -> 'a <: 'A, x: 'a -> 'a}
//│ res: error




class Simple2[A]: { a: A }
    method Get: A
//│ Defined class Simple2
//│ Declared Simple2.Get: (simple2 & {a: 'A, Simple2#A = 'A}) -> 'A

class Simple3[A, B]: Simple2[A]
    method Get: B
//│ ╔══[ERROR] Type mismatch in method declaration:
//│ ║  l.143: 	    method Get: B
//│ ║         	           ^^^^^^
//│ ╟── expression of type `B` does not match type `A`
//│ ╟── Note: constraint arises from method declaration:
//│ ║  l.138: 	    method Get: A
//│ ╙──       	           ^^^^^^
//│ Defined class Simple3
//│ Declared Simple3.Get: (simple3 & {a: 'A, Simple3#B = 'B, Simple2#A = 'A, Simple3#A = 'A}) -> 'B




class AbstractPair[A, B]: { x: A; y: B }
    method Test: (A -> B -> bool) -> bool
    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ Defined class AbstractPair
//│ Declared AbstractPair.Test: (abstractPair & {AbstractPair#B = 'B, y: 'B, AbstractPair#A = 'A, x: 'A}) -> ('A -> 'B -> bool) -> bool
//│ Declared AbstractPair.Map: (abstractPair & {AbstractPair#B = 'B, y: 'B, AbstractPair#A = 'A, x: 'A}) -> ('A -> 'C) -> ('B -> 'D) -> (abstractPair & {AbstractPair#B = 'D, y: 'D, AbstractPair#A = 'C, x: 'C})

class BadPair[A, B]: AbstractPair[A, B]
    method Test f = f this.x this.x
    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.165: 	    method Test f = f this.x this.x
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `A` does not match type `B`
//│ ║  l.165: 	    method Test f = f this.x this.x
//│ ╙──       	                             ^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.166: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `C` does not match type `D`
//│ ║  l.166: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into function of type `?a -> ?b`
//│ ║  l.166: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── which does not match type `(B -> D) -> AbstractPair[C, D]`
//│ ╟── Note: constraint arises from record type:
//│ ║  l.157: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	                          ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.159: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.166: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `C` does not match type `D`
//│ ╟── but it flows into application of type `?a`
//│ ║  l.166: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── which does not match type `AbstractPair[C, D]`
//│ ╟── Note: constraint arises from applied type reference:
//│ ║  l.159: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ Defined class BadPair
//│ Defined BadPair.Test: (badPair & {BadPair#A = 'A, AbstractPair#A = 'A, x: 'A, y: 'B, BadPair#B = 'B, AbstractPair#B = 'B}) -> ('A -> 'A -> 'a) -> 'a
//│ Defined BadPair.Map: (badPair & {BadPair#A = 'A, AbstractPair#A = 'A, x: 'A, y: 'B, BadPair#B = 'B, AbstractPair#B = 'B}) -> ('A -> ('B0 & 'a & 'A0)) -> anything -> (badPair & {BadPair#A = 'A0, AbstractPair#A = 'A0, x: 'a, y: 'a, BadPair#B = 'B0, AbstractPair#B = 'B0})

bp = BadPair { x = 42; y = true }
bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ bp: badPair & {BadPair#A :> 'A | 42 <: 'A, AbstractPair#A :> 'A | 42 <: 'A, x: 42, y: true, BadPair#B :> 'B | true <: 'B, AbstractPair#B :> 'B | true <: 'B}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.205: 	bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `42` does not match type `bool`
//│ ║  l.204: 	bp = BadPair { x = 42; y = true }
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from argument:
//│ ║  l.205: 	bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ ╙──       	                                         ^
//│ res: 42 | error

BadPair = BadPair { x = 42; y = 0 }
BadPair.Map
BadPair.(BadPair.Map)
//│ BadPair: badPair & {BadPair#A :> 'A | 42 <: 'A, AbstractPair#A :> 'A | 42 <: 'A, x: 42, y: 0, BadPair#B :> 'B | 0 <: 'B, AbstractPair#B :> 'B | 0 <: 'B}
//│ res: (badPair & {BadPair#A = 'A, AbstractPair#A = 'A, x: 'A, y: 'B, BadPair#B = 'B, AbstractPair#B = 'B}) -> ('A -> ('A0 & 'a & 'B0)) -> anything -> (badPair & {BadPair#A = 'A0, AbstractPair#A = 'A0, x: 'a, y: 'a, BadPair#B = 'B0, AbstractPair#B = 'B0})
//│ ╔══[ERROR] Class BadPair has no method BadPair.Map
//│ ║  l.220: 	BadPair.(BadPair.Map)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^
//│ res: (42 -> ('A & 'a & 'B)) -> anything -> (badPair & {BadPair#A = 'A, AbstractPair#A = 'A, x: 'a, y: 'a, BadPair#B = 'B, AbstractPair#B = 'B})


class ClassA
    method MtdA = 42
//│ Defined class ClassA
//│ Defined ClassA.MtdA: classA -> 42

:e
class ClassB: ClassA
    method MtdA = 43
//│ ╔══[ERROR] Overriding method ClassA.MtdA without explicit declaration is not allowed.
//│ ║  l.236: 	    method MtdA = 43
//│ ╙──       	           ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.236: 	    method MtdA = 43
//│ ║         	           ^^^^^^^^^
//│ ╟── expression of type `43` does not match type `42`
//│ ║  l.236: 	    method MtdA = 43
//│ ║         	                  ^^
//│ ╟── but it flows into method definition with expected type `42`
//│ ║  l.236: 	    method MtdA = 43
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.230: 	    method MtdA = 42
//│ ╙──       	                  ^^
//│ Defined class ClassB
//│ Defined ClassB.MtdA: classB -> 43

:e
class ClassC: ClassA
    method MtdA: int
    method MtdA = 43
//│ ╔══[ERROR] Overriding method ClassA.MtdA without explicit declaration is not allowed.
//│ ║  l.257: 	    method MtdA: int
//│ ╙──       	           ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method declaration:
//│ ║  l.257: 	    method MtdA: int
//│ ║         	           ^^^^^^^^^
//│ ╟── expression of type `int` does not match type `42`
//│ ║  l.257: 	    method MtdA: int
//│ ║         	                 ^^^
//│ ╟── but it flows into method declaration with expected type `42`
//│ ║  l.257: 	    method MtdA: int
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.230: 	    method MtdA = 42
//│ ╙──       	                  ^^
//│ ╔══[ERROR] Overriding method ClassA.MtdA without explicit declaration is not allowed.
//│ ║  l.258: 	    method MtdA = 43
//│ ╙──       	           ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.258: 	    method MtdA = 43
//│ ║         	           ^^^^^^^^^
//│ ╟── expression of type `43` does not match type `42`
//│ ║  l.258: 	    method MtdA = 43
//│ ║         	                  ^^
//│ ╟── but it flows into method definition with expected type `42`
//│ ║  l.258: 	    method MtdA = 43
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.230: 	    method MtdA = 42
//│ ╙──       	                  ^^
//│ Defined class ClassC
//│ Declared ClassC.MtdA: classC -> 43
//│ Defined ClassC.MtdA: classC -> 43

:e
class ClassD: ClassA
    method MtdA: int
class ClassE: ClassD
    method MtdA = 43
//│ ╔══[ERROR] Overriding method ClassA.MtdA without explicit declaration is not allowed.
//│ ║  l.295: 	    method MtdA: int
//│ ╙──       	           ^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in method declaration:
//│ ║  l.295: 	    method MtdA: int
//│ ║         	           ^^^^^^^^^
//│ ╟── expression of type `int` does not match type `42`
//│ ║  l.295: 	    method MtdA: int
//│ ║         	                 ^^^
//│ ╟── but it flows into method declaration with expected type `42`
//│ ║  l.295: 	    method MtdA: int
//│ ║         	           ^^^^^^^^^
//│ ╟── Note: constraint arises from integer literal:
//│ ║  l.230: 	    method MtdA = 42
//│ ╙──       	                  ^^
//│ Defined class ClassD
//│ Declared ClassD.MtdA: classD -> 42
//│ Defined class ClassE
//│ Defined ClassE.MtdA: classE -> 43

(ClassE{}).MtdA // typed as 42!
//│ res: 42


:e
class Class2A[A]
    method MtdA: A
trait Trait2A[B]
    method MtdA: B
class Class2B: Class2A[int] & Trait2A[string]
    method MtdA = "ok"
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.328: 	    method MtdA = "ok"
//│ ║         	           ^^^^^^^^^^^
//│ ╟── expression of type `"ok"` does not match type `int`
//│ ║  l.328: 	    method MtdA = "ok"
//│ ║         	                  ^^^^
//│ ╟── but it flows into method definition with expected type `int`
//│ ║  l.328: 	    method MtdA = "ok"
//│ ║         	           ^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.327: 	class Class2B: Class2A[int] & Trait2A[string]
//│ ║         	                       ^^^
//│ ╟── from method declaration:
//│ ║  l.324: 	    method MtdA: A
//│ ╙──       	           ^^^^^^^
//│ Defined class Class2A
//│ Declared Class2A.MtdA: (class2A & {Class2A#A = 'A}) -> 'A
//│ Defined trait Trait2A
//│ Declared Trait2A.MtdA: ({Trait2A#B = 'B} & trait2A) -> 'B
//│ Defined class Class2B
//│ Defined Class2B.MtdA: (class2B & {Class2A#A = int, Trait2A#B = string} & trait2A) -> "ok"


:e
:ns // TODO: investigate weird type of `Class3B.MtdA` without `:ns`
class Class3A[A]
    method MtdA: A
type Type3A = Class3A[string]
class Class3B: Type3A
    method MtdA = 1
//│ ╔══[ERROR] cannot inherit from a type alias
//│ ║  l.357: 	class Class3B: Type3A
//│ ╙──       	      ^^^^^^^^^^^^^^^
//│ Defined class Class3A
//│ Declared Class3A.MtdA: Class3A['A] -> 'A
//│ Defined type alias Type3A


:e
Oops.M
//│ ╔══[ERROR] Method M not found
//│ ║  l.368: 	Oops.M
//│ ╙──       	^^^^^^
//│ res: error


class Test4A
    method Mth4A: anything
    method Mth4A = true
//│ Defined class Test4A
//│ Declared Test4A.Mth4A: test4A -> true
//│ Defined Test4A.Mth4A: test4A -> true
:e
class Test4B: Test4A
    method Mth4A: int
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.377: 	    method Mth4A = true
//│ ║         	           ^^^^^^^^^^^^
//│ ╟── expression of type `true` does not match type `int`
//│ ║  l.377: 	    method Mth4A = true
//│ ║         	                   ^^^^
//│ ╟── but it flows into method definition with expected type `int`
//│ ║  l.377: 	    method Mth4A = true
//│ ║         	           ^^^^^^^^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.383: 	    method Mth4A: int
//│ ╙──       	                  ^^^
//│ Defined class Test4B
//│ Declared Test4B.Mth4A: test4B -> true

:e
class Test5A
    method Mth5A: 42
class Test5B: Test5A
    method Mth5A = 43
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.403: 	    method Mth5A = 43
//│ ║         	           ^^^^^^^^^^
//│ ╟── expression of type `43` does not match type `42`
//│ ║  l.403: 	    method Mth5A = 43
//│ ║         	                   ^^
//│ ╟── but it flows into method definition with expected type `42`
//│ ║  l.403: 	    method Mth5A = 43
//│ ║         	           ^^^^^^^^^^
//│ ╟── Note: constraint arises from method declaration:
//│ ║  l.401: 	    method Mth5A: 42
//│ ╙──       	           ^^^^^
//│ Defined class Test5A
//│ Declared Test5A.Mth5A: test5A -> 42
//│ Defined class Test5B
//│ Defined Test5B.Mth5A: test5B -> 43
