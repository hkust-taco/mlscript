:AllowTypeErrors

class Foo[A]: { x: A }
    method Map[B]: (A -> B) -> A
class Bar[A]: Foo[A]
    method Map[B]: B -> A
    rec method Map f = f Map (fun x -> Map)
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.7: 	    rec method Map f = f Map (fun x -> Map)
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `_α25` is not a function
//│ ╟── Note: constraint arises from application:
//│ ║  l.7: 	    rec method Map f = f Map (fun x -> Map)
//│ ╙──     	                       ^^^^^
//│ Defined class Foo
//│ Declared Foo.Map: foo & {x: 'a} -> ('a -> anything) -> 'a
//│ Defined class Bar
//│ Declared Bar.Map: bar & {x: anything} -> (('a -> (anything -> 'a) -> 'b) -> 'b) as 'a
//│ Defined Bar.Map: bar & {x: anything} -> (('a -> (anything -> 'a) -> 'b) -> 'b) as 'a

Foo.Map
Bar.Map
//│ res: foo & {x: 'a} -> ('a -> anything) -> 'a
//│ res: bar & {x: anything} -> (('a -> (anything -> 'a) -> 'b) -> 'b) as 'a




class bar[A, B]: Foo[A] & { Y: B; z: int }
    method identity z = z
    method identity z = z
//│ ╔══[ERROR] Type names must start with a capital letter
//│ ║  l.29: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	      ^^^
//│ ╔══[ERROR] Field identifiers must start with a small letter
//│ ║  l.29: 	class bar[A, B]: Foo[A] & { Y: B; z: int }
//│ ╙──      	                            ^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.30: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ ╔══[ERROR] Method names must start with a capital letter
//│ ║  l.31: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ ╔══[ERROR] Method 'bar.identity' is already defined.
//│ ║  l.31: 	    method identity z = z
//│ ╙──      	           ^^^^^^^^
//│ Defined class bar
//│ Defined bar.identity: bar & {Y: anything, z: int, x: anything} -> 'a -> 'a
//│ Defined bar.identity: bar & {Y: anything, z: int, x: anything} -> 'a -> 'a




class ImplicitCall[A]: { x: A }
    method Fun = this.x
//│ Defined class ImplicitCall
//│ Defined ImplicitCall.Fun: implicitCall & {x: 'a} -> 'a

i = ImplicitCall { x = "stonks" }
i.Fun
//│ i: implicitCall & {x: "stonks"}
//│ res: "stonks"

class NoMoreImplicitCall
    method Fun = "not stonks"
//│ Defined class NoMoreImplicitCall
//│ Defined NoMoreImplicitCall.Fun: noMoreImplicitCall -> "not stonks"

i.Fun
//│ ╔══[ERROR] Implicit call of Fun is disabled
//│ ║  l.69: 	i.Fun
//│ ║        	  ^^^
//│ ╟── Defined by ImplicitCall
//│ ║  l.54: 	class ImplicitCall[A]: { x: A }
//│ ║        	      ^^^^^^^^^^^^
//│ ╟── Defined by NoMoreImplicitCall
//│ ║  l.64: 	class NoMoreImplicitCall
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.69: 	i.Fun
//│ ║        	^^^^^
//│ ╟── expression of type `implicitCall & {x: ?a | "stonks"}` does not match type `{Fun: ?b}`
//│ ║  l.59: 	i = ImplicitCall { x = "stonks" }
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{Fun: ?c}`
//│ ║  l.69: 	i.Fun
//│ ╙──      	^
//│ res: error




def this = fun x -> fun y -> add x y
this 42 42
//│ this: int -> int -> int
//│ res: int

class BadThis: { x: int; y: int }
    method Sum = this this.x this.y
    method Funny = this 42 42
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.99: 	    method Sum = this this.x this.y
//│ ║        	                 ^^^^^^^^^^^
//│ ╟── expression of type `badThis & {y: int, x: int}` does not match type `?a | int -> ?b`
//│ ║  l.98: 	class BadThis: { x: int; y: int }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `?c | int -> ?d`
//│ ║  l.99: 	    method Sum = this this.x this.y
//│ ╙──      	                 ^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.100: 	    method Funny = this 42 42
//│ ║         	                   ^^^^^^^
//│ ╟── expression of type `badThis & {y: int, x: int}` does not match type `42 -> ?a`
//│ ║  l.98: 	class BadThis: { x: int; y: int }
//│ ║        	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `42 -> ?b`
//│ ║  l.100: 	    method Funny = this 42 42
//│ ╙──       	                   ^^^^
//│ Defined class BadThis
//│ Defined BadThis.Sum: badThis & {y: int, x: int} -> error
//│ Defined BadThis.Funny: badThis & {y: int, x: int} -> error




class AbstractPair[A, B]: { x: A; y: B }
    method Test: (A -> B -> bool) -> bool
    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ Defined class AbstractPair
//│ Declared AbstractPair.Test: abstractPair & {y: 'a, x: 'b} -> ('b -> 'a -> bool) -> bool
//│ Declared AbstractPair.Map: abstractPair & {y: 'a, x: 'b} -> ('b -> 'c) -> ('a -> 'd) -> abstractPair & {y: 'd, x: 'c}

class BadPair[A, B]: AbstractPair[A, B]
    method Test f = f this.x this.x
    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ╔══[ERROR] Type mismatch in method definition:
//│ ║  l.135: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `_α296` does not match type `_α298`
//│ ║  l.135: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into function of type `?a -> ?b | badPair & {y: ?c | _α296, x: ?d | _α296}`
//│ ║  l.135: 	    method Map fx fy = BadPair { x = fx this.x; y = fx this.x }
//│ ║         	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── which does not match type `(_α297 -> _α298) -> abstractPair & {y: _α298, x: _α296}`
//│ ╟── Note: constraint arises from record type:
//│ ║  l.126: 	class AbstractPair[A, B]: { x: A; y: B }
//│ ║         	                          ^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.128: 	    method Map[C, D]: (A -> C) -> (B -> D) -> AbstractPair[C, D]
//│ ╙──       	                                              ^^^^^^^^^^^^^^^^^^
//│ Defined class BadPair
//│ Defined BadPair.Test: badPair & {y: anything, x: 'a} -> ('a -> 'a -> 'b) -> 'b
//│ Defined BadPair.Map: badPair & {y: anything, x: 'a} -> ('a -> 'b) -> anything -> badPair & {y: 'b, x: 'b}

bp = BadPair { x = 42; y = true }
bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ bp: badPair & {y: true, x: 42}
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.157: 	bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `42` does not match type `bool`
//│ ║  l.156: 	bp = BadPair { x = 42; y = true }
//│ ║         	                   ^^
//│ ╟── Note: constraint arises from argument:
//│ ║  l.157: 	bp.(BadPair.Test) (fun x -> fun y -> if (y) then x else y)
//│ ╙──       	                                         ^
//│ res: 42 | error

BadPair = BadPair { x = 42; y = 0 }
BadPair.Map
BadPair.(BadPair.Map)
//│ BadPair: badPair & {y: 0, x: 42}
//│ res: badPair & {y: anything, x: 'a} -> ('a -> 'b) -> anything -> badPair & {y: 'b, x: 'b}
//│ ╔══[ERROR] Class BadPair has no method BadPair.Map
//│ ║  l.172: 	BadPair.(BadPair.Map)
//│ ╙──       	^^^^^^^^^^^^^^^^^^^^^
//│ res: (42 -> 'a) -> anything -> badPair & {y: 'a, x: 'a}
