// Preamble
def plus1 x = x + 1
//│ plus1: int -> int
//│      = [Function: plus1]

// Let's try something with type parameters.
class IntBox: { value: int }
  method Get = this.value
//│ Defined class IntBox
//│ Defined IntBox.Get: IntBox -> int

ib0 = IntBox { value = 0 }
//│ ib0: IntBox & {value: 0}
//│    = IntBox { value: 0 }

ib0.Get
//│ res: int
//│    = 0

// Extend with some function.
class MappableIntBox: IntBox
  method Map f = MappableIntBox { value = f this.value }
//│ Defined class MappableIntBox
//│ Defined MappableIntBox.Map: MappableIntBox -> (int -> (int & 'a)) -> (MappableIntBox with {value: 'a})

mib0 = MappableIntBox { value = 0 }
//│ mib0: MappableIntBox & {value: 0}
//│     = MappableIntBox { value: 0 }

mib0.Get
//│ res: int
//│    = 0

mib0.Map
//│ res: (int -> (int & 'a)) -> (MappableIntBox with {value: 'a})
//│    = [Function: Map]

mib0.Map plus1
//│ res: MappableIntBox
//│    = MappableIntBox { value: 1 }

// Naughty map...
:e
mib0.Map (fun _ -> "str")
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.44: 	mib0.Map (fun _ -> "str")
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"str"` does not match type `int`
//│ ║  l.44: 	mib0.Map (fun _ -> "str")
//│ ║        	                   ^^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.7: 	class IntBox: { value: int }
//│ ║       	                       ^^^
//│ ╟── from application:
//│ ║  l.22: 	  method Map f = MappableIntBox { value = f this.value }
//│ ╙──      	                                          ^^^^^^^^^^^^
//│ res: error | (MappableIntBox with {value: "str"})
//│    = MappableIntBox { value: 'str' }

// What if without the derivation?
// Oh it's the same.
class BetterIntBox: { value: int }
  method Get = this.value
  method Map f = BetterIntBox { value = f this.value }
//│ Defined class BetterIntBox
//│ Defined BetterIntBox.Get: BetterIntBox -> int
//│ Defined BetterIntBox.Map: BetterIntBox -> (int -> (int & 'a)) -> (BetterIntBox with {value: 'a})

// I think the return type should be BetterIntBox & {value: int & 'b}

// Some examples from TypeClasses.mls
class Monoid[A]
  method Empty: A
//│ Defined class Monoid
//│ Declared Monoid.Empty: Monoid['A] -> 'A

// Some more interesting case. Are they valid at the main branch?
// Yeah... The result are the same.
class Myself[A]
  method Me = this
//│ Defined class Myself
//│ Defined Myself.Me: (Myself['A] & 'this) -> (Myself['A] & 'this)

m0 = Myself {}
//│ m0: Myself['A]
//│   = Myself {}

m0.Me
//│ res: Myself['A]
//│    = Myself {}

// Make box generic!
// Looks fine.
class Box[A]: { value: A }
  method Get = this.value
//│ Defined class Box
//│ Defined Box.Get: Box['A] -> 'A

// More test cases from Addable.mls!
// It seems some type variables leaked from the context...

:e
class Addable[A]
  method Me = this
  method Oops = this.oops // disallowed if rigid
  method Add: A -> A
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.105: 	  method Oops = this.oops // disallowed if rigid
//│ ║         	                ^^^^^^^^^
//│ ╟── reference of type `Addable[?A] & this` does not have field 'oops'
//│ ║  l.105: 	  method Oops = this.oops // disallowed if rigid
//│ ╙──       	                ^^^^
//│ Defined class Addable
//│ Declared Addable.Add: Addable['A] -> 'A -> 'A
//│ Defined Addable.Me: (Addable['A] & 'this) -> (Addable['A] & 'this)
//│ Defined Addable.Oops: Addable['A] -> error

class Num: Addable[Num] & { val: int }
  method Add that = Num { val = this.val + that.val }
//│ Defined class Num
//│ Defined Num.Add: Num -> {val: int} -> Num

class Str: Addable[Str] & { val: string }
  method Add that = Str { val = concat this.val that.val }
//│ Defined class Str
//│ Defined Str.Add: Str -> {val: string} -> Str

n = Num { val = 1 }
//│ n: Num & {val: 1}
//│  = Num { val: 1 }

n.Add n
//│ res: Num
//│    = Num { val: 2 }

s = Str { val = "hey" }
//│ s: Str & {val: "hey"}
//│  = Str { val: 'hey' }

s.Add
//│ res: (Str & 'A) -> ('A | Str)
//│    = [Function: Add]

// Make inherited methods agree with the current this.
// Import more examples from the old branch!
