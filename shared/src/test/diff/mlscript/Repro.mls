
x = { a = 1 }
//│ x: {a: 1}
//│  = { a: 1 }

x with { b = 2 }
//│ res: {a: 1, b: 2}
//│    = { a: 1, b: 2 }

def f x = x with { b = 2 }
//│ f: (('a,) & {_1: 'a}) -> ('a\b & {b: 2})
//│  = [Function: f]

def r: {b: string; c: int}\b
//│ r: {c: int}

(1,2,3) with { _4 = "oops" }
//│ res: (1, 2, 3,) & {_1: 1, _2: 2, _3: 3, _4: "oops"}
//│    = Array { '0': 1, '1': 2, '2': 3, _4: 'oops' }

(1,2,3) with { _1 = "oops" }
//│ res: {_1: "oops", _2: 2, _3: 3}
//│    = Array { '0': 1, '1': 2, '2': 3, _1: 'oops' }

def r: int \ _1
//│ r: int

def r: (1,2,3) \ _1
//│ r: {_2: 2, _3: 3}
// (1,2,3).toRecord \ _1

def r: (1,2,3) \ _12345
//│ r: (1, 2, 3,) & {_1: 1, _2: 2, _3: 3}

def arr: Array[int]
def arr = (1,2)
//│ arr: Array[int]
//│ (1, 2,) & {_1: 1, _2: 2}
//│   <:  arr:
//│ Array[int]
//│    = [ 1, 2 ]

:e
arr._1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.44: 	arr._1
//│ ║        	^^^^^^
//│ ╟── type `Array[int]` does not have field '_1'
//│ ║  l.35: 	def arr: Array[int]
//│ ║        	         ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_1: ?a}`
//│ ║  l.44: 	arr._1
//│ ╙──      	^^^
//│ res: error
//│    = undefined

rr = arr with { x = 1 }
//│ rr: Array[int] & {x: 1}
//│   = Array { '0': 1, '1': 2, x: 1 }

rr.x
//│ res: 1
//│    = 1






t = (1, 2, 3) with {x = 1}
// t = (1, 2, 3)
//│ t: (1, 2, 3,) & {_1: 1, _2: 2, _3: 3, x: 1}
//│  = Array { '0': 1, '1': 2, '2': 3, x: 1 }

t._1
t._2
t.x
//│ res: 1
//│    = undefined
//│ res: 2
//│    = undefined
//│ res: 1
//│    = 1


// :d
def test: {x: 1} & (1, 2, 3)
//│ test: (1, 2, 3,) & {_1: 1, _2: 2, _3: 3, x: 1}


// def f x = x[1]
// Array['a] -> 'a

// def f x = x.1
// {1: 'a} -> 'a

// f(... : Array[int])
// Array[int] <: {1: 'a}

// { 1 = 3456 }



f(1,2,3) : 1 | 2 | 3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.104: 	f(1,2,3) : 1 | 2 | 3
//│ ║         	^^^^^^^
//│ ╟── tuple literal of type `(1, 2, 3,)` does not match type `(?a,)`
//│ ║  l.104: 	f(1,2,3) : 1 | 2 | 3
//│ ╙──       	  ^^^^^
//│ res: 1 | 2 | 3
//│    = [Number: 1] { b: 2 }


(arr[0])[1][2]
//│ /!\ Parse error: Expected ")":1:5, found "[0])[1][2]" at l.115:5: (arr[0])[1][2]

f a b c
//│ ╔══[ERROR] identifier not found: a
//│ ║  l.118: 	f a b c
//│ ╙──       	  ^
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.118: 	f a b c
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.118: 	f a b c
//│ ╙──       	      ^
//│ res: nothing
//│ Runtime error:
//│   ReferenceError: a is not defined


class A: { x: int }
//│ Defined class A

def myval: A & { x: anything }
//│ myval: A

// def myval: a & { x: string }
// //│ myval: A with {x: string}


def tuuu: (1 | 2, true) & {_1: 2 | 3}
//│ tuuu: (1 | 2, true,) & {_1: 2, _2: true}
// tuuu: ((1 | 2) & (2 | 3), true,)
// tuuu: (2, true,)

// (S, T, U)
// Array[S | T | U] & { _1: S; _2: T; _3: U }

def f(x: int, y: string) = x
//│ f: ((int, string,) & {_1: int, _2: string}) -> int
//│  = [Function: f1]

// f(x = 1, y = "asf")

def f x = x
def f(x,) = x
//│ f: (('a,) & {_1: 'a}) -> 'a
//│  = [Function: f2]
//│ f: (('a,) & {_1: 'a}) -> 'a
//│  = [Function: f3]

// (1, 2)
// f((1, 2))

// [1, 2]
// f [1, 2]
// f ([1, 2], 2, 3)


f(1)
f 1
//│ res: 1
//│    = 1
//│ res: 1
//│    = 1

f(1,2)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.179: 	f(1,2)
//│ ║         	^^^^^
//│ ╟── tuple literal of type `(1, 2,)` does not match type `(?a,)`
//│ ║  l.179: 	f(1,2)
//│ ╙──       	  ^^^
//│ res: error
//│    = 1


trait T: { x: int }
//│ Defined trait T

def t: T
//│ t: {x: int} & t

t.x
//│ res: int
//│    = 1

rcd = { x = 1 }
//│ rcd: {x: 1}
//│    = { x: 1 }

T rcd
//│ res: {x: 1} & t
//│    = { x: 1 }

res: { x: int }
//│ res: {x: int}
//│    = { x: 1 }


