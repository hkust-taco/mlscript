
x = { a = 1 }
//│ x: {a: 1}
//│  = { a: 1 }

x with { b = 2 }
//│ res: {a: 1, b: 2}
//│    = { a: 1, b: 2 }

def f x = x with { b = 2 }
//│ f: 'a -> ('a\b & {b: 2})
//│  = [Function: f]

def r: {b: string; c: int}\b
//│ r: {c: int}

(1,2,3) with { _4 = "oops" }
//│ res: (1, 2, 3,) & {_4: "oops"}
//│    = Array { '0': 1, '1': 2, '2': 3, _4: 'oops' }

(1,2,3) with { _1 = "oops" }
//│ res: {_1: "oops", _2: 2, _3: 3}
//│    = Array { '0': 1, '1': 2, '2': 3, _1: 'oops' }

def r: int \ _1
//│ r: int

def r: (1,2,3) \ _1
//│ r: {_2: 2, _3: 3}
// (1,2,3).toRecord \ _1

def r: (1,2,3) \ _12345
//│ r: (1, 2, 3,)

def arr: Array[int]
def arr = (1,2)
//│ arr: Array[int]
//│ (1, 2,)
//│   <:  arr:
//│ Array[int]
//│    = [ 1, 2 ]

:re
fr = f r
fr : Array[int] & {b: int}
//│ fr: (1, 2, 3,) & {b: 2}
//│ Runtime error:
//│   ReferenceError: r is not defined
//│ res: Array[int] & {b: int}
//│ Runtime error:
//│   ReferenceError: fr is not defined

:e
arr._1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.54: 	arr._1
//│ ║        	^^^^^^
//│ ╟── type `Array[int]` does not have field '_1'
//│ ║  l.35: 	def arr: Array[int]
//│ ║        	         ^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_1: ?a}`
//│ ║  l.54: 	arr._1
//│ ╙──      	^^^
//│ res: error
//│    = undefined

rr = arr with { x = 1 }
//│ rr: Array[int] & {x: 1}
//│   = Array { '0': 1, '1': 2, x: 1 }

rr.x
//│ res: 1
//│    = 1






t = (1, 2, 3) with {x = 1}
// t = (1, 2, 3)
//│ t: (1, 2, 3,) & {x: 1}
//│  = Array { '0': 1, '1': 2, '2': 3, x: 1 }

t._1
t._2
t.x
//│ res: 1
//│    = undefined
//│ res: 2
//│    = undefined
//│ res: 1
//│    = 1



// :d
def test: {x: 1} & (1, 2, 3)
//│ test: (1, 2, 3,) & {x: 1}


// def f x = x[1]
// Array['a] -> 'a

// def f x = x.1
// {1: 'a} -> 'a

// f(... : Array[int])
// Array[int] <: {1: 'a}

// { 1 = 3456 }

:e
f(1,2,3) : 1 | 2 | 3
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.114: 	f(1,2,3) : 1 | 2 | 3
//│ ║         	^^^^^^^
//│ ╟── tuple literal of type `(1, 2, 3,)` does not match type `(?a,)`
//│ ║  l.114: 	f(1,2,3) : 1 | 2 | 3
//│ ╙──       	  ^^^^^
//│ res: 1 | 2 | 3
//│    = [Number: 1] { b: 2 }

:e
(arr[0])[1][2]
//│ ╔══[ERROR] Type mismatch in array subscription:
//│ ║  l.125: 	(arr[0])[1][2]
//│ ║         	 ^^^^^^^^^
//│ ╟── type `int` does not match type `Array[?a]`
//│ ║  l.35: 	def arr: Array[int]
//│ ║        	               ^^^
//│ ╟── but it flows into array subscription with expected type `Array[?a]`
//│ ║  l.125: 	(arr[0])[1][2]
//│ ╙──       	 ^^^^^
//│ res: nothing
//│ Code generation crashed:
//│   (arr[0])[1][2] (of class mlscript.Subs)

:e
f a b c
//│ ╔══[ERROR] identifier not found: a
//│ ║  l.140: 	f a b c
//│ ╙──       	  ^
//│ ╔══[ERROR] identifier not found: b
//│ ║  l.140: 	f a b c
//│ ╙──       	    ^
//│ ╔══[ERROR] identifier not found: c
//│ ║  l.140: 	f a b c
//│ ╙──       	      ^
//│ res: nothing
//│ Runtime error:
//│   ReferenceError: a is not defined


class A: { x: int }
//│ Defined class A

def myval: A & { x: anything }
//│ myval: A

// def myval: a & { x: string }
// //│ myval: A with {x: string}


def tuuu: (1 | 2, true) & {_1: 2 | 3}
//│ tuuu: (1 | 2, true,) & {_1: 2, _2: true}
// tuuu: ((1 | 2) & (2 | 3), true,)
// tuuu: (2, true,)

// (S, T, U)
// Array[S | T | U] & { _1: S; _2: T; _3: U }

def f(x: int, y: string) = x
//│ f: (int, string,) -> int
//│  = [Function: f1]

// f(x = 1, y = "asf")

def f x = x
def f(x,) = x
//│ f: 'a -> 'a
//│  = [Function: f2]
//│ f: 'a -> 'a
//│  = [Function: f3]

// (1, 2)
// f((1, 2))

// [1, 2]
// f [1, 2]
// f ([1, 2], 2, 3)


f(1)
f 1
//│ res: 1
//│    = 1
//│ res: 1
//│    = 1

f((1,2))
//│ res: (1, 2,)
//│    = [ 1, 2 ]


trait T: { x: int }
//│ Defined trait T

def t: T
//│ t: {x: int} & t

t.x
//│ res: int
//│    = 1

rcd = { x = 1 }
//│ rcd: {x: 1}
//│    = { x: 1 }

T rcd
//│ res: {x: 1} & t
//│    = { x: 1 }

res: { x: int }
//│ res: {x: int}
//│    = { x: 1 }


(1,2, (true, false, ("hello", "world", "bye")))
//│ res: (1, 2, (true, false, ("hello", "world", "bye",),),)
//│    = [ 1, 2, [ true, false, [ 'hello', 'world', 'bye' ] ] ]

k1 = (6, "hi", false) with {_5=5; _6=true}
k1._1
k1._3
//│ k1: (6, "hi", false,) & {_5: 5, _6: true}
//│   = Array { '0': 6, '1': 'hi', '2': false, _5: 5, _6: true }
//│ res: 6
//│    = undefined
//│ res: false
//│    = undefined

(1,2,3) with {_4 = true}
//│ res: (1, 2, 3,) & {_4: true}
//│    = Array { '0': 1, '1': 2, '2': 3, _4: true }

(1, 2, true) with {_0 = "hello"}
//│ res: (1, 2, true,) & {_0: "hello"}
//│    = Array { '0': 1, '1': 2, '2': true, _0: 'hello' }

ta1 = (5, 6, true, false, "hahaha")
ta2 = ta1 with {x = 123; _7 = "bye"; _1 = 0}
ta1._1
ta2._2
ta2._3
//│ ta1: (5, 6, true, false, "hahaha",)
//│    = [ 5, 6, true, false, 'hahaha' ]
//│ ta2: {_1: 0, _2: 6, _3: true, _4: false, _5: "hahaha", _7: "bye", x: 123}
//│    = Array {
//│        '0': 5,
//│        '1': 6,
//│        '2': true,
//│        '3': false,
//│        '4': 'hahaha',
//│        x: 123,
//│        _7: 'bye',
//│        _1: 0
//│      }
//│ res: 5
//│    = undefined
//│ res: 6
//│    = undefined
//│ res: true
//│    = undefined

def rep5: 'a -> Array['a]
def rep5 x = (x,x,x,x,x)
//│ rep5: 'a -> Array['a]
//│ 'a -> ('a, 'a, 'a, 'a, 'a,)
//│   <:  rep5:
//│ 'a -> Array['a]
//│     = [Function: rep5]

rep5 1 with {_1 = 10}
a2 = rep5 2 with {_2 = true; x = "haha"}
a2._2
//│ res: Array[1] & {_1: 10}
//│    = Array { '0': 1, '1': 1, '2': 1, '3': 1, '4': 1, _1: 10 }
//│ a2: Array[2] & {_2: true, x: "haha"}
//│   = Array { '0': 2, '1': 2, '2': 2, '3': 2, '4': 2, _2: true, x: 'haha' }
//│ res: true
//│    = true

:e
a2._1
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.295: 	a2._1
//│ ║         	^^^^^
//│ ╟── type `Array[?a]` does not match type `{_1: ?b} | ~{_2: true, x: "haha"}`
//│ ║  l.276: 	def rep5: 'a -> Array['a]
//│ ║         	                ^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{_1: ?b} | ~{_2: true, x: "haha"}`
//│ ║  l.295: 	a2._1
//│ ╙──       	^^
//│ res: error
//│    = undefined

(1,2,3,true) with {_a = 1; _b1 = false}
//│ res: (1, 2, 3, true,) & {_a: 1, _b1: false}
//│    = Array { '0': 1, '1': 2, '2': 3, '3': true, _a: 1, _b1: false }

ht1 = (1,2,false) with {_1 = 'a'; _2 = 'hello'; _3 = false}
ht1._1
//│ ht1: {_1: "a", _2: "hello", _3: false}
//│    = Array { '0': 1, '1': 2, '2': false, _1: 'a', _2: 'hello', _3: false }
//│ res: "a"
//│    = 'a'

def hg1 t = (t._1, t._2)
hg1 ht1
hg1 ((5,5,5))
//│ hg1: {_1: 'a, _2: 'b} -> ('a, 'b,)
//│    = [Function: hg1]
//│ res: ("a", "hello",)
//│    = [ 'a', 'hello' ]
//│ res: (5, 5,)
//│    = [ undefined, undefined ]
