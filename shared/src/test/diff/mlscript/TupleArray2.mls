
:e
(1,2): (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	^^^^^
//│ ╟── integer literal of type `1` does not match type `2`
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.3: 	(1,2): (2,1)
//│ ╙──     	        ^
//│ res: (2, 1,)
//│    = [ 1, 2 ]

:e
(1,2): (2,1,0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.17: 	(1,2): (2,1,0)
//│ ║        	^^^^^
//│ ╟── tuple literal of type `(1, 2,)` does not match type `(2, 1, 0,)`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	(1,2): (2,1,0)
//│ ╙──      	       ^^^^^^^
//│ res: (2, 1, 0,)
//│    = [ 1, 2 ]

:e
(1,2) with { x = 1 } : (2,1,0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.29: 	(1,2) with { x = 1 } : (2,1,0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(1, 2,) & {x: 1}` is not a 3-element tuple
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.29: 	(1,2) with { x = 1 } : (2,1,0)
//│ ╙──      	                       ^^^^^^^
//│ res: (2, 1, 0,)
//│    = Array { '0': 1, '1': 2, x: 1 }

trait T
//│ Defined trait T

:e
(1,2) with { x = 1 } : (2,1,0) | t
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.44: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(1, 2,) & {x: 1}` does not match type `(2, 1, 0,) | t`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.44: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ╙──      	                       ^^^^^^^^^^^
//│ res: (2, 1, 0,) | t
//│    = Array { '0': 1, '1': 2, x: 1 }

:e
(1,2) with { x = 1 } : (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.56: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `2`
//│ ║  l.56: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.56: 	(1,2) with { x = 1 } : (2,1)
//│ ╙──      	                        ^
//│ res: (2, 1,)
//│    = Array { '0': 1, '1': 2, x: 1 }

(1,2) with { x = 1 } : (1,2)
//│ res: (1, 2,)
//│    = Array { '0': 1, '1': 2, x: 1 }


:re
error: (1,2) & t | Array[3]
//│ res: (1, 2,) & t | Array[3]
//│ Runtime error:
//│   Error: unexpected runtime error


def arr: Array[1]
//│ arr: Array[1]

arr: Array[2] | (1, 1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.84: 	arr: Array[2] | (1, 1)
//│ ║        	^^^
//│ ╟── type `1` does not match type `Array[1] | 2`
//│ ║  l.81: 	def arr: Array[1]
//│ ╙──      	               ^
//│ res: Array[2 | Array[1]]
//│ Runtime error:
//│   ReferenceError: arr is not defined

arr: Array[2] | (1, 2)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.95: 	arr: Array[2] | (1, 2)
//│ ║        	^^^
//│ ╟── type `1` does not match type `Array[1 | 2] | 2`
//│ ║  l.81: 	def arr: Array[1]
//│ ╙──      	               ^
//│ res: Array[2 | Array[1 | 2]]
//│ Runtime error:
//│   ReferenceError: arr is not defined

:e
arr: Array[2] & t | (1, 1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.107: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── type `Array[1]` does not match type `Array[2] & t | (1, 1,)`
//│ ║  l.81: 	def arr: Array[1]
//│ ║        	         ^^^^^^^^
//│ ╟── but it flows into reference with expected type `Array[2] & t | (1, 1,)`
//│ ║  l.107: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.107: 	arr: Array[2] & t | (1, 1)
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^
//│ res: (1, 1,) | Array[2] & t
//│ Runtime error:
//│   ReferenceError: arr is not defined

def arrt: Array[1] & t
//│ arrt: Array[1] & t

:re
arrt: Array[2] & t | (1, 1)
//│ res: (1, 1,) | Array[2] & t
//│ Runtime error:
//│   ReferenceError: arrt is not defined


def f_1: 'a -> (Array['a] & t)
//│ f_1: 'a -> (Array['a] & t)

def f_2: 'a -> (Array['a] & t | (1,))
//│ f_2: 'a -> ((1,) | Array['a] & t)

:e
f_1 = f_2
//│ 'a -> ((1,) | Array['a] & t)
//│   <:  f_1:
//│ 'a -> (Array['a] & t)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `1` is not an instance of type 'a
//│ ║  l.137: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	                                 ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.134: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.141: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `(1,)` is not an instance of type T
//│ ║  l.137: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	               ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from trait tag:
//│ ║  l.134: 	def f_1: 'a -> (Array['a] & t)
//│ ║         	                            ^
//│ ╟── from intersection type:
//│ ║  l.134: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	               ^^^^^^^^^^^^^^^
//│ Runtime error:
//│   ReferenceError: f_2 is not defined

:re
f_2 = f_1
//│ 'a -> (Array['a] & t)
//│   <:  f_2:
//│ 'a -> ((1,) | Array['a] & t)
//│ Runtime error:
//│   ReferenceError: f_1 is not defined



def test: (string, 1) & { _1: "hello" }
//│ test: (string, 1,) & {_1: "hello", _2: 1}

:e
test = ("hi", 1)
//│ ("hi", 1,)
//│   <:  test:
//│ (string, 1,) & {_1: "hello", _2: 1}
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.183: 	test = ("hi", 1)
//│ ║         	^^^^^^^^^^^^^^^^
//│ ╟── string literal of type `"hi"` does not match type `"hello"`
//│ ║  l.183: 	test = ("hi", 1)
//│ ║         	        ^^^^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.179: 	def test: (string, 1) & { _1: "hello" }
//│ ╙──       	                              ^^^^^^^
//│     = [ 'hi', 1 ]

test = ("hello", 1)
//│ ("hello", 1,)
//│   <:  test:
//│ (string, 1,) & {_1: "hello", _2: 1}
//│     = [ 'hello', 1 ]

(fun ((a, b)) -> a) test
//│ res: string
//│    = 'hello'

test: { _1: 'a }
//│ res: {_1: "hello"}
//│    = [ 'hello', 1 ]

test: ('a, 1)
//│ res: (string, 1,)
//│    = [ 'hello', 1 ]

:e
class A: (1,2)
//│ ╔══[ERROR] cannot inherit from a tuple type
//│ ║  l.217: 	class A: (1,2)
//│ ╙──       	      ^^^^^^^^
//│ Code generation met an error:
//│   unable to derive from type Tuple(List((None,Literal(1)), (None,Literal(2))))


:re
error: Array[1] & { _1: int }
//│ res: Array[1] & {_1: int}
//│ Runtime error:
//│   Error: unexpected runtime error

