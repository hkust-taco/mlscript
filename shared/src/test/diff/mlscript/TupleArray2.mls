
:e
(1,2): (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	^^^^^
//│ ╟── integer literal of type `1` does not match type `2`
//│ ║  l.3: 	(1,2): (2,1)
//│ ║       	 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.3: 	(1,2): (2,1)
//│ ╙──     	        ^
//│ res: (2, 1,)
//│    = [ 1, 2 ]

:e
(1,2): (2,1,0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.17: 	(1,2): (2,1,0)
//│ ║        	^^^^^
//│ ╟── tuple literal of type `(1, 2,)` does not match type `(2, 1, 0,)`
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.17: 	(1,2): (2,1,0)
//│ ╙──      	       ^^^^^^^
//│ res: (2, 1, 0,)
//│    = [ 1, 2 ]

:e
(1,2) with { x = 1 } : (2,1,0)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.29: 	(1,2) with { x = 1 } : (2,1,0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(1, 2,) & {x: 1}` is not a 3-element tuple
//│ ╟── Note: constraint arises from tuple type:
//│ ║  l.29: 	(1,2) with { x = 1 } : (2,1,0)
//│ ╙──      	                       ^^^^^^^
//│ res: (2, 1, 0,)
//│    = Array { '0': 1, '1': 2, x: 1 }

trait T
//│ Defined trait T

:e
(1,2) with { x = 1 } : (2,1,0) | t
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.44: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── `with` extension of type `(1, 2,) & {x: 1}` does not match type `(2, 1, 0,) | t`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.44: 	(1,2) with { x = 1 } : (2,1,0) | t
//│ ╙──      	                       ^^^^^^^^^^^
//│ res: (2, 1, 0,) | t
//│    = Array { '0': 1, '1': 2, x: 1 }

(1,2) with { x = 1 } : (2,1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── integer literal of type `1` does not match type `2`
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ║        	 ^
//│ ╟── Note: constraint arises from literal type:
//│ ║  l.55: 	(1,2) with { x = 1 } : (2,1)
//│ ╙──      	                        ^
//│ res: (2, 1,)
//│    = Array { '0': 1, '1': 2, x: 1 }

(1,2) with { x = 1 } : (1,2)
//│ res: (1, 2,)
//│    = Array { '0': 1, '1': 2, x: 1 }


error: (1,2) & t | Array[3]
//│ res: (1, 2,) & t | Array[3]
//│ Runtime error:
//│   Error: unexpected runtime error


def arr: Array[1]
//│ arr: Array[1]

arr: Array[2] | (1, 1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.82: 	arr: Array[2] | (1, 1)
//│ ║        	^^^
//│ ╟── type `1` does not match type `Array[1] | 2`
//│ ║  l.79: 	def arr: Array[1]
//│ ╙──      	               ^
//│ res: Array[2 | Array[1]]
//│ Runtime error:
//│   ReferenceError: arr is not defined

arr: Array[2] | (1, 2)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.93: 	arr: Array[2] | (1, 2)
//│ ║        	^^^
//│ ╟── type `1` does not match type `Array[1 | 2] | 2`
//│ ║  l.79: 	def arr: Array[1]
//│ ╙──      	               ^
//│ res: Array[2 | Array[1 | 2]]
//│ Runtime error:
//│   ReferenceError: arr is not defined

:e
arr: Array[2] & t | (1, 1)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.105: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── type `Array[1]` does not match type `Array[2] & t | (1, 1,)`
//│ ║  l.79: 	def arr: Array[1]
//│ ║        	         ^^^^^^^^
//│ ╟── but it flows into reference with expected type `Array[2] & t | (1, 1,)`
//│ ║  l.105: 	arr: Array[2] & t | (1, 1)
//│ ║         	^^^
//│ ╟── Note: constraint arises from union type:
//│ ║  l.105: 	arr: Array[2] & t | (1, 1)
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^
//│ res: (1, 1,) | Array[2] & t
//│ Runtime error:
//│   ReferenceError: arr is not defined

def arrt: Array[1] & t
//│ arrt: Array[1] & t

arrt: Array[2] & t | (1, 1)
//│ res: (1, 1,) | Array[2] & t
//│ Runtime error:
//│   ReferenceError: arrt is not defined


def f_1: 'a -> (Array['a] & t)
//│ f_1: 'a -> (Array['a] & t)

def f_2: 'a -> (Array['a] & t | (1,))
//│ f_2: 'a -> ((1,) | Array['a] & t)

:e
f_1 = f_2
//│ 'a -> ((1,) | Array['a] & t)
//│   <:  f_1:
//│ 'a -> (Array['a] & t)
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.138: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `1` is not an instance of type 'a
//│ ║  l.134: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	                                 ^
//│ ╟── Note: constraint arises from type variable:
//│ ║  l.131: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	                      ^^
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.138: 	f_1 = f_2
//│ ║         	^^^^^^^^^
//│ ╟── type `(1,)` is not an instance of type T
//│ ║  l.134: 	def f_2: 'a -> (Array['a] & t | (1,))
//│ ║         	               ^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── Note: constraint arises from trait tag:
//│ ║  l.131: 	def f_1: 'a -> (Array['a] & t)
//│ ║         	                            ^
//│ ╟── from intersection type:
//│ ║  l.131: 	def f_1: 'a -> (Array['a] & t)
//│ ╙──       	               ^^^^^^^^^^^^^^^
//│ Runtime error:
//│   ReferenceError: f_2 is not defined

f_2 = f_1
//│ 'a -> (Array['a] & t)
//│   <:  f_2:
//│ 'a -> ((1,) | Array['a] & t)
//│ Runtime error:
//│   ReferenceError: f_1 is not defined



def test: (string, 1) & { _1: "hello" }
//│ test: (string, 1,) & {_1: "hello", _2: 1}

(fun ((a, b)) -> a) test
//│ res: string
//│ Runtime error:
//│   ReferenceError: test is not defined

test: { _1: 'a }
//│ res: {_1: "hello"}
//│ Runtime error:
//│   ReferenceError: test is not defined

test: ('a, 1)
//│ res: (string, 1,)
//│ Runtime error:
//│   ReferenceError: test is not defined

:e
class A: (1,2)
//│ ╔══[ERROR] cannot inherit from a tuple type
//│ ║  l.194: 	class A: (1,2)
//│ ╙──       	      ^^^^^^^^
//│ Code generation met an error:
//│   unable to derive from type Tuple(List((None,Literal(1)), (None,Literal(2))))


error: Array[1] & { _1: int }
//│ res: Array[1] & {_1: int}
//│ Runtime error:
//│   Error: unexpected runtime error

