:global
:bbml



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α1_2, α2_2: (forall α3_3: (Region[α3_3]) ->{α1_2 ∨ α3_3} α2_2) ->{α1_2} α2_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in term (letreg#2(λr@3. r@3#0)).ref 1
//│ ╟── because: cannot constrain  α7_1  <:  Region[α8_1]
//│ ╟── because: cannot constrain  α7_1  <:  Region[((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥]
//│ ╟── because: cannot constrain  Region[out ⊤ ∧ ⊤]  <:  Region[((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥]
//│ ╟── because: cannot constrain  ((⊤ ∧ ⊤) ∧ ⊤) ∨ ⊥  <:  ((⊤ ∧ ⊤) ∧ α8_1) ∨ ⊥
//│ ╟── because: cannot constrain  ⊤  <:  α8_1
//│ ╙── because: cannot constrain  ⊤  <:  ⊥
//│ ╔══[ERROR] Type error in term { (letreg#2(λr@3. r@3#0)).ref 1 }
//│ ╟── because: cannot constrain  α8_1 ∨ α6_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α8_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] General type is not allowed here.
//│ ╙──
//│ Type: ⊥

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

:e
f
//│ ╔══[ERROR] Variable not found: f
//│ ╙──
//│ Type: ⊥

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in term { letreg#8(λr@4. λarg@5. (r@4#0).ref arg@5#0)(0) }
//│ ╟── because: cannot constrain  α50_1 ∨ α41_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α50_1  <:  <α>0_0
//│ ╟── because: cannot constrain  α49_1  <:  <α>0_0
//│ ╙── because: cannot constrain  ⊤  <:  <α>0_0
//│ Type: Ref[in α46_1 out α46_1 ∨ Int, ?]



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in term λr@3. (r@3#0).ref 1 with expected type (Region[<α>54_2]) ->{⊥} α56_1
//│ ╟── because: cannot constrain  α57_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>54_2  <:  ⊥
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in term λr@3. !RegRef(Ref(r@3),Lit(IntLit(1))) with expected type (Region[<α>54_2]) ->{⊥} α60_1
//│ ╟── because: cannot constrain  α62_2 ∨ α61_2  <:  ⊥
//│ ╟── because: cannot constrain  α62_2  <:  ⊥
//│ ╟── because: cannot constrain  α61_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>54_2  <:  ⊥
//│ ╔══[ERROR] Type error in term λr@3. !RegRef(Ref(r@3),Lit(IntLit(1))) with expected type (Region[<α>54_2]) ->{⊥} α60_1
//│ ╟── because: cannot constrain  α62_2 ∨ α61_2  <:  ⊥
//│ ╟── because: cannot constrain  α61_2  <:  ⊥
//│ ╙── because: cannot constrain  <α>54_2  <:  ⊥
//│ Type: Int


