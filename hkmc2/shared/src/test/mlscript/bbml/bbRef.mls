:global
:bbml


region x in 42
//│ Type: Int

region x in x
//│ Type: Region[?]


region x in x.ref 42
//│ Type: Ref[Int, ?]

let r = region x in x.ref 42
r
//│ Type: Ref[Int, ?]

:e
let r = region x in x.ref 42
!r
//│ ╔══[ERROR] Type error in block
//│ ║  l.20: 	let r = region x in x.ref 42
//│ ║        	                    ^^^^^^^^
//│ ║  l.21: 	!r
//│ ║        	^^
//│ ╟── because: cannot constrain  (α16_1 ∨ α14_1) ∨ Alloc  <:  Alloc
//│ ╟── because: cannot constrain  α16_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α15_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α15_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Int

fun mkRef() = region x in x.ref 42
mkRef
//│ Type: () ->{Alloc} Ref[Int, ?]

:e
let t = region x in x in t.ref 42
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.39: 	let t = region x in x in t.ref 42
//│ ║        	                         ^^^^^^^^
//│ ╟── because: cannot constrain  Region[?]  <:  Region[α25_1]
//│ ╟── because: cannot constrain  D(  )  <:  α25_1
//│ ╟── because: cannot constrain    <:  α25_1
//│ ╙── because: cannot constrain    <:  ¬()
//│ ╔══[ERROR] Type error in block
//│ ║  l.39: 	let t = region x in x in t.ref 42
//│ ║        	                    ^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  (α25_1 ∨ α24_1) ∨ Alloc  <:  Alloc
//│ ╟── because: cannot constrain  α25_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Ref[Int, ?]


region x in
  let r = x.ref 42 in r := 0
//│ Type: Int

:e
let t = region x in
  x.ref 42
in t := 0
//│ ╔══[ERROR] Type error in block
//│ ║  l.62: 	  x.ref 42
//│ ║        	  ^^^^^^^^
//│ ║  l.63: 	in t := 0
//│ ║        	^^^^^^^^^
//│ ╟── because: cannot constrain  (α34_1 ∨ α32_1) ∨ Alloc  <:  Alloc
//│ ╟── because: cannot constrain  α34_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α33_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α33_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Int


region x in
  let r = x.ref 42 in !r
//│ Type: Int

:e
let t = region x in
  x.ref 42
in !t
//│ ╔══[ERROR] Type error in block
//│ ║  l.83: 	  x.ref 42
//│ ║        	  ^^^^^^^^
//│ ║  l.84: 	in !t
//│ ║        	^^^^^
//│ ╟── because: cannot constrain  (α45_1 ∨ α43_1) ∨ Alloc  <:  Alloc
//│ ╟── because: cannot constrain  α45_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α44_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α44_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Int

region x in
  let r = x.ref 42 in let t = r := 0 in !r
//│ Type: Int

fun rid: [A] -> A ->{Alloc} A
fun rid(x) =
  let t = (region y in 42) in x
//│ Type: ⊤

:e
fun rid: [A] -> A -> A
fun rid(x) =
  let t = (region y in 42) in x
//│ ╔══[ERROR] Type error in function literal with expected type (<α>59_2) ->{⊥} <α>59_2
//│ ║  l.108: 	fun rid(x) =
//│ ║         	        ^^^^
//│ ║  l.109: 	  let t = (region y in 42) in x
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── because: cannot constrain  α61_2 ∨ Alloc  <:  ⊥
//│ Type: ⊤

:e
region x in
  (let dz = x.ref 42 in 42): [A] -> Int
//│ ╔══[ERROR] Type error in block with expected type forall α63_3: Int
//│ ║  l.120: 	  (let dz = x.ref 42 in 42): [A] -> Int
//│ ║         	            ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α64_3  <:  ⊥
//│ ╟── because: cannot constrain  α64_3  <:  ¬()
//│ ╙── because: cannot constrain  <α>62_2  <:  ¬()
//│ Type: forall α63_3: Int


:e
let t =
  region x in
    y => x.ref y
  in t(42)
//│ ╔══[ERROR] Type error in block
//│ ║  l.133: 	    y => x.ref y
//│ ║         	    ^^^^^^^^^^^^
//│ ║  l.134: 	  in t(42)
//│ ║         	^^^^^^^^^^
//│ ╟── because: cannot constrain  (α74_1 ∨ α69_1) ∨ Alloc  <:  Alloc
//│ ╟── because: cannot constrain  α74_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Ref[in α71_1 out α71_1 ∨ Int, ?]

fun foo: [A] -> Int ->{A | Alloc} Int
fun foo(x) =
  region y in x + 1
//│ Type: ⊤

