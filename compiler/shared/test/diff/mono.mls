:NewParser
:ParseOnly
// :mono
fun f(x) = if x then 42 else 1337
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |#then| |42| |#else| |1337|
//│ Parsed: {fun f = x, => if (x) then 42 else 1337}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), If((x) then 42, Some(IntLit(1337))))))
//│ Lifted:
//│ TypingUnit {fun f = x, => if (x) then 42 else 1337}

// :mono
fun foo() = 42
//│ |#fun| |foo|(||)| |#=| |42|
//│ Parsed: {fun foo =  => 42}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Lam(Tup(), IntLit(42))))
//│ Lifted:
//│ TypingUnit {fun foo =  => 42}

// :mono
fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ |#fun| |foo|(|x|,| |##|b|)| |#=| |#if| |b| |#then| |x| |#else| |1337|↵|#let| |a| |#=| |foo|(|42|,| |true|)|↵|#let| |b| |#=| |foo|(|23|,| |false|)|
//│ Parsed: {fun foo = x, #b, => if (b) then x else 1337; let a = foo (42, true,); let b = foo (23, false,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Lam(Tup(_: Var(x), _: Var(b)), If((b) then x, Some(IntLit(1337))))), NuFunDef(Some(false), a, [], App(Var(foo), Tup(_: IntLit(42), _: Var(true)))), NuFunDef(Some(false), b, [], App(Var(foo), Tup(_: IntLit(23), _: Var(false)))))
//│ Lifted:
//│ TypingUnit {
//│   fun foo = x, #b, => if (b) then x else 1337
//│   let a = foo (42, true,)
//│   let b = foo (23, false,)
//│ }

// :mono
let x = 42 + 1337
//│ |#let| |x| |#=| |42| |+| |1337|
//│ Parsed: {let x = + (42,) (1337,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, [], App(App(Var(+), Tup(_: IntLit(42))), Tup(_: IntLit(1337)))))
//│ Lifted:
//│ TypingUnit {let x = + (42,) (1337,)}

class Bar(#x)
fun foo(#b) = b
let a = foo(new Bar(1))
let b = foo(new Bar(2))
//│ |#class| |Bar|(|##|x|)|↵|#fun| |foo|(|##|b|)| |#=| |b|↵|#let| |a| |#=| |foo|(|#new| |Bar|(|1|)|)|↵|#let| |b| |#=| |foo|(|#new| |Bar|(|2|)|)|
//│ Parsed: {class Bar(#x,) {}; fun foo = #b, => b; let a = foo (new Bar(1,) {},); let b = foo (new Bar(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(_: Var(x)), (), TypingUnit()), NuFunDef(None, foo, [], Lam(Tup(_: Var(b)), Var(b))), NuFunDef(Some(false), a, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),1,)), TypingUnit(List()))))), NuFunDef(Some(false), b, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),2,)), TypingUnit(List()))))))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1(#x,) {}
//│   fun foo = #b, => b
//│   let a = foo (new Bar$1(1,) {},)
//│   let b = foo (new Bar$1(2,) {},)
//│ }

// :mono
class OneInt(#a){
  fun inc() = a+1
}
(new OneInt(1)).inc()
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |inc|(||)| |#=| |a|+|1|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.inc|(||)|
//│ Parsed: {class OneInt(#a,) {fun inc =  => + (a,) (1,)}; ('(' new OneInt(1,) {}, ')').inc ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, inc, [], Lam(Tup(), App(App(Var(+), Tup(_: Var(a))), Tup(_: IntLit(1))))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),1,)), TypingUnit(List())))), inc), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(#a,) {fun inc =  => + ((this).a,) (1,)}
//│   Code(List(('(' new OneInt$1(1,) {}, ')').inc ()))
//│ }

// :mono
class OneInt(#a){
  fun add(x) = 
    new OneInt(a+x.a)
}
(new OneInt(1)).add(new OneInt(2))
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |add|(|x|)| |#=| |→|#new| |OneInt|(|a|+|x|.a|)|←|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.add|(|#new| |OneInt|(|2|)|)|
//│ Parsed: {class OneInt(#a,) {fun add = x, => {new OneInt(+ (a,) ((x).a,),) {}}}; ('(' new OneInt(1,) {}, ')').add (new OneInt(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, add, [], Lam(Tup(_: Var(x)), Blk(...))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),1,)), TypingUnit(List())))), add), Tup(_: New(Some((TypeName(OneInt),2,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(#a,) {
//│     fun add = x, => {new OneInt$1(+ ((this).a,) ((x).a,),) {}}
//│   }
//│   Code(List(('(' new OneInt$1(1,) {}, ')').add (new OneInt$1(2,) {},)))
//│ }

// :mono
if true then 1 else 0
if 1+1 > 1 then 1-1 else 1*1
//│ |#if| |true| |#then| |1| |#else| |0|↵|#if| |1|+|1| |>| |1| |#then| |1|-|1| |#else| |1|*|1|
//│ Parsed: {if (true) then 1 else 0; if (> (+ (1,) (1,),) (1,)) then - (1,) (1,) else * (1,) (1,)}
//│ Parsed:
//│ TypingUnit(If((true) then 1, Some(IntLit(0))), If((> (+ (1,) (1,),) (1,)) then - (1,) (1,), Some(App(App(Var(*), Tup(_: IntLit(1))), Tup(_: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List(if (true) then 1 else 0))
//│   Code(List(if (> (+ (1,) (1,),) (1,)) then - (1,) (1,) else * (1,) (1,)))
//│ }

// :mono
if(b) then 1 else 2
//│ |#if|(|b|)| |#then| |1| |#else| |2|
//│ Parsed: {if ('(' b, ')') then 1 else 2}
//│ Parsed:
//│ TypingUnit(If(('(' b, ')') then 1, Some(IntLit(2))))
//│ Lifted:
//│ TypingUnit {Code(List(if ('(' b, ')') then 1 else 2))}

// :mono
((f, g) => f(g))(f => f, true)
//│ |(|(|f|,| |g|)| |=>| |f|(|g|)|)|(|f| |=>| |f|,| |true|)|
//│ Parsed: {'(' f, g, => f (g,), ')' (f, => f, true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Tup(_: Lam(Tup(_: Var(f), _: Var(g)), App(Var(f), Tup(_: Var(g)))))), Tup(_: Lam(Tup(_: Var(f)), Var(f)), _: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List('(' f, g, => f (g,), ')' (f, => f, true,)))
//│ }


// :mono
(b => if b then true else false) (true)
//│ |(|b| |=>| |#if| |b| |#then| |true| |#else| |false|)| |(|true|)|
//│ Parsed: {'(' b, => if (b) then true else false, ')' (true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Tup(_: Lam(Tup(_: Var(b)), If((b) then true, Some(Var(false)))))), Tup(_: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List('(' b, => if (b) then true else false, ')' (true,)))
//│ }

// :mono
fun f(x) =
  if(x > 0) then x+1 else x-1
f(2)+3
//│ |#fun| |f|(|x|)| |#=|→|#if|(|x| |>| |0|)| |#then| |x|+|1| |#else| |x|-|1|←|↵|f|(|2|)|+|3|
//│ Parsed: {fun f = x, => {if ('(' > (x,) (0,), ')') then + (x,) (1,) else - (x,) (1,)}; + (f (2,),) (3,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), Blk(...))), App(App(Var(+), Tup(_: App(Var(f), Tup(_: IntLit(2))))), Tup(_: IntLit(3))))
//│ Lifted:
//│ TypingUnit {
//│   fun f = x, => {if ('(' > (x,) (0,), ')') then + (x,) (1,) else - (x,) (1,)}
//│   Code(List(+ (f (2,),) (3,)))
//│ }

// :mono
fun fac(n) = 
  if (n > 1) then fac(n - 1) * n else 1
fac(2)
//│ |#fun| |fac|(|n|)| |#=| |→|#if| |(|n| |>| |1|)| |#then| |fac|(|n| |-| |1|)| |*| |n| |#else| |1|←|↵|fac|(|2|)|
//│ Parsed: {fun fac = n, => {if ('(' > (n,) (1,), ')') then * (fac (- (n,) (1,),),) (n,) else 1}; fac (2,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, fac, [], Lam(Tup(_: Var(n)), Blk(...))), App(Var(fac), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   fun fac = n, => {if ('(' > (n,) (1,), ')') then * (fac (- (n,) (1,),),) (n,) else 1}
//│   Code(List(fac (2,)))
//│ }

// :mono
class List(l, hasTail)  {}
class Nil(l, hasTail)  {}
fun count(lst) =
  if lst.hasTail then count(lst.l)+1 else 1
count(new List(new List(new Nil(0, false), true), true))
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|l|,| |hasTail|)| |{||}|↵|#fun| |count|(|lst|)| |#=|→|#if| |lst|.hasTail| |#then| |count|(|lst|.l|)|+|1| |#else| |1|←|↵|count|(|#new| |List|(|#new| |List|(|#new| |Nil|(|0|,| |false|)|,| |true|)|,| |true|)|)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(l, hasTail,) {}; fun count = lst, => {if ((lst).hasTail) then + (count ((lst).l,),) (1,) else 1}; count (new List(new List(new Nil(0, false,) {}, true,) {}, true,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuFunDef(None, count, [], Lam(Tup(_: Var(lst)), Blk(...))), App(Var(count), Tup(_: New(Some((TypeName(List),new List(new Nil(0, false,) {}, true,) {}, true,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(l, hasTail,) {}
//│   class Nil$2(l, hasTail,) {}
//│   fun count = lst, => {if ((lst).hasTail) then + (count ((lst).l,),) (1,) else 1}
//│   Code(List(count (new List$1(new List$1(new Nil$2(0, false,) {}, true,) {}, true,) {},)))
//│ }

:mono
class List(e, tail){
  fun gen() = new List(e, tail.gen())
}
class Nil(){
  fun gen() = new List(0, this)
}
fun generate(x) = 
  if x > 0 then new List(x, generate(x+1)) else new Nil()
generate(10).gen()
//│ |#class| |List|(|e|,| |tail|)|{|→|#fun| |gen|(||)| |#=| |#new| |List|(|e|,| |tail|.gen|(||)|)|←|↵|}|↵|#class| |Nil|(||)|{|→|#fun| |gen|(||)| |#=| |#new| |List|(|0|,| |this|)|←|↵|}|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |List|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|generate|(|10|)|.gen|(||)|
//│ Parsed: {class List(e, tail,) {fun gen =  => new List(e, (tail).gen (),) {}}; class Nil() {fun gen =  => new List(0, this,) {}}; fun generate = x, => {if (> (x,) (0,)) then new List(x, generate (+ (x,) (1,),),) {} else new Nil() {}}; (generate (10,)).gen ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, gen, [], Lam(Tup(), New(Some((TypeName(List),e, (tail).gen (),)), TypingUnit(List())))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, gen, [], Lam(Tup(), New(Some((TypeName(List),0, this,)), TypingUnit(List())))))), NuFunDef(None, generate, [], Lam(Tup(_: Var(x)), Blk(...))), App(Sel(App(Var(generate), Tup(_: IntLit(10))), gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(e, tail,) {
//│     fun gen =  => new List$1((this).e, ((this).tail).gen (),) {}
//│   }
//│   class Nil$2() {fun gen =  => new List$1(0, this,) {}}
//│   fun generate = x, => {if (> (x,) (0,)) then new List$1(x, generate (+ (x,) (1,),),) {} else new Nil$2() {}}
//│   Code(List((generate (10,)).gen ()))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$3()
//│ fun gen$List$1(this) =
//│   new List$1 (this.e, this.tail match {case obj: List$1 => gen$List$1(obj); case obj: Nil$2 => gen$Nil$2(obj)}) 
//│ fun gen$Nil$2(this) =
//│   new List$1 (#0, this) 
//│ fun main$$3() =
//│   generate(#10) match {case obj: Nil$2 => gen$Nil$2(obj); case obj: List$1 => gen$List$1(obj)}
//│ fun generate(x) =
//│   if (x > #0) then new List$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] evaluating main$$3, rests: HashSet()
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> [] @{}
//│ [mono] ┌ SPEC CALL generate with ([10])
//│ [mono] │ comparing (([],0)) with (Plain([10]))
//│ [mono] │ first time encounter generate
//│ [mono] │ evaluating generate, rests: HashSet()
//│ [mono] │ ========== updating generate ==========
//│ [mono] │ generate: (([10],1)) -> [] @{main$$3}
//│ [mono] │ ┌ SPEC CALL generate with ([11])
//│ [mono] │ │ comparing (([10],1)) with (Plain([*LIT*]))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ comparing [] with [List$1@{e: [10], tail: []}]
//│ [mono] │ adding these funcs to queue: Set(main$$3, generate)
//│ [mono] │ generate: (([*LIT*],100000)) -> [List$1@{e: [10], tail: ***}] @{main$$3, generate}
//│ [mono] └ SPEC CALL [List$1@{e: [10], tail: ***}]
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}])
//│ [mono] │ comparing (([],0)) with (Plain([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}]))
//│ [mono] │ first time encounter gen$List$1
//│ [mono] │ evaluating gen$List$1, rests: HashSet(main$$3, generate)
//│ [mono] │ ========== updating gen$List$1 ==========
//│ [mono] │ gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [] @{main$$3}
//│ [mono] │ ┌ SPEC CALL gen$List$1 with ([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}])
//│ [mono] │ │ comparing (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) with (Plain([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}]))
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ comparing [] with [List$1@{e: [10], tail: []}]
//│ [mono] │ adding these funcs to queue: Set(main$$3, gen$List$1)
//│ [mono] │ gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [List$1@{e: [10], tail: []}] @{main$$3, gen$List$1}
//│ [mono] └ SPEC CALL [List$1@{e: [10], tail: []}]
//│ [mono] comparing [] with [List$1@{e: [10], tail: []}]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$3: () -> [List$1@{e: [10], tail: []}] @{}
//│ [mono] evaluating gen$List$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$List$1 ==========
//│ [mono] gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [List$1@{e: [10], tail: []}] @{main$$3, gen$List$1}
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}])
//│ [mono] │ comparing (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) with (Plain([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}]))
//│ [mono] └ SPEC CALL [List$1@{e: [10], tail: []}]
//│ [mono] comparing [List$1@{e: [10], tail: []}] with [List$1@{e: [10], tail: [List$1@{e: [10], tail: []}]}]
//│ [mono] adding these funcs to queue: Set(main$$3, gen$List$1)
//│ [mono] gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{main$$3, gen$List$1}
//│ [mono] evaluating gen$List$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$List$1 ==========
//│ [mono] gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{main$$3, gen$List$1}
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}])
//│ [mono] │ comparing (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) with (Plain([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] with [List$1@{e: [10], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}]}]
//│ [mono] gen$List$1: (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{main$$3, gen$List$1}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{}
//│ [mono] ┌ SPEC CALL generate with ([10])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [10], tail: ***}]
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}])
//│ [mono] │ comparing (([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}],3)) with (Plain([List$1@{e: [10], tail: [List$1@{e: [10], tail: ***}]}]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] with [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}]
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [10], tail: ***}] @{main$$3, generate}
//│ [mono] ┌ SPEC CALL generate with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [10], tail: ***}]
//│ [mono] comparing [List$1@{e: [10], tail: ***}] with [List$1@{e: [*LIT*], tail: [List$1@{e: [10], tail: ***}]} | Nil$2@{}]
//│ [mono] adding these funcs to queue: Set(main$$3, generate)
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$3, generate}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] @{}
//│ [mono] ┌ SPEC CALL generate with ([10])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}],3)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}]
//│ [mono] ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([],0)) with (Plain([Nil$2@{}]))
//│ [mono] │ first time encounter gen$Nil$2
//│ [mono] │ evaluating gen$Nil$2, rests: HashSet(gen$List$1, generate)
//│ [mono] │ ========== updating gen$Nil$2 ==========
//│ [mono] │ gen$Nil$2: (([Nil$2@{}],1)) -> [] @{main$$3}
//│ [mono] │ comparing [] with [List$1@{e: [0], tail: [Nil$2@{}]}]
//│ [mono] │ adding these funcs to queue: Set(main$$3)
//│ [mono] │ gen$Nil$2: (([Nil$2@{}],1)) -> [List$1@{e: [0], tail: [Nil$2@{}]}] @{main$$3}
//│ [mono] └ SPEC CALL [List$1@{e: [0], tail: [Nil$2@{}]}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]}] with [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***}]} | Nil$2@{}]}]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] @{}
//│ [mono] evaluating gen$List$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$List$1 ==========
//│ [mono] gen$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}],100002)) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] @{main$$3, gen$List$1}
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}],100002)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([Nil$2@{}],1)) with (Plain([Nil$2@{}]))
//│ [mono] └ SPEC CALL [List$1@{e: [0], tail: [Nil$2@{}]}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] with [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]}]}]
//│ [mono] gen$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}],100002)) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] @{main$$3, gen$List$1}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] @{}
//│ [mono] ┌ SPEC CALL generate with ([10])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]
//│ [mono] ┌ SPEC CALL gen$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}],100002)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([Nil$2@{}],1)) with (Plain([Nil$2@{}]))
//│ [mono] └ SPEC CALL [List$1@{e: [0], tail: [Nil$2@{}]}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] with [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]}]
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}] @{}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$3, generate}
//│ [mono] ┌ SPEC CALL generate with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] with [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$3, generate}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] gen$List$1: ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]) -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] gen$Nil$2: ([Nil$2@{}]) -> [List$1@{e: [0], tail: [Nil$2@{}]}]
//│ [mono] main$$3: () -> [List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] generate: ([*LIT*]) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]

:mono
class List(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = x.count()
fun generate(x) = 
  if x > 0 then new List(x, generate(x+1)) else new Nil()
foo(new List(1, new List(2, new Nil())))
foo(generate(1))
//│ |#class| |List|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |x|.count|(||)|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |List|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|foo|(|#new| |List|(|1|,| |#new| |List|(|2|,| |#new| |Nil|(||)|)|)|)|↵|foo|(|generate|(|1|)|)|
//│ Parsed: {class List(e, tail,) {fun count =  => + (1,) ((tail).count (),)}; class Nil() {fun count =  => 0}; fun foo = x, => (x).count (); fun generate = x, => {if (> (x,) (0,)) then new List(x, generate (+ (x,) (1,),),) {} else new Nil() {}}; foo (new List(1, new List(2, new Nil() {},) {},) {},); foo (generate (1,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), App(App(Var(+), Tup(_: IntLit(1))), Tup(_: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, foo, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), count), Tup()))), NuFunDef(None, generate, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: New(Some((TypeName(List),1, new List(2, new Nil() {},) {},)), TypingUnit(List())))), App(Var(foo), Tup(_: App(Var(generate), Tup(_: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(e, tail,) {fun count =  => + (1,) (((this).tail).count (),)}
//│   class Nil$2() {fun count =  => 0}
//│   fun foo = x, => (x).count ()
//│   fun generate = x, => {if (> (x,) (0,)) then new List$1(x, generate (+ (x,) (1,),),) {} else new Nil$2() {}}
//│   Code(List(foo (new List$1(1, new List$1(2, new Nil$2() {},) {},) {},)))
//│   Code(List(foo (generate (1,),)))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$4()
//│ main$$5()
//│ fun count$Nil$2(this) =
//│   #0
//│ fun foo(x) =
//│   x match {case obj: List$1 => count$List$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ fun count$List$1(this) =
//│   (#1 + this.tail match {case obj: Nil$2 => count$Nil$2(obj); case obj: List$1 => count$List$1(obj)})
//│ fun main$$5() =
//│   foo(generate(#1))
//│ fun main$$4() =
//│   foo(new List$1 (#1, new List$1 (#2, new Nil$2 () ) ) )
//│ fun generate(x) =
//│   if (x > #0) then new List$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] evaluating main$$5, rests: HashSet(main$$4)
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> [] @{}
//│ [mono] ┌ SPEC CALL generate with ([1])
//│ [mono] │ comparing (([],0)) with (Plain([1]))
//│ [mono] │ first time encounter generate
//│ [mono] │ evaluating generate, rests: HashSet(main$$4)
//│ [mono] │ ========== updating generate ==========
//│ [mono] │ generate: (([1],1)) -> [] @{main$$5}
//│ [mono] │ ┌ SPEC CALL generate with ([2])
//│ [mono] │ │ comparing (([1],1)) with (Plain([*LIT*]))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ comparing [] with [List$1@{e: [1], tail: []}]
//│ [mono] │ adding these funcs to queue: Set(main$$5, generate)
//│ [mono] │ generate: (([*LIT*],100000)) -> [List$1@{e: [1], tail: ***}] @{main$$5, generate}
//│ [mono] └ SPEC CALL [List$1@{e: [1], tail: ***}]
//│ [mono] ┌ SPEC CALL foo with ([List$1@{e: [1], tail: ***}])
//│ [mono] │ comparing (([],0)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] │ first time encounter foo
//│ [mono] │ evaluating foo, rests: HashSet(main$$5, main$$4, generate)
//│ [mono] │ ========== updating foo ==========
//│ [mono] │ foo: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [] @{main$$5}
//│ [mono] │ ┌ SPEC CALL count$List$1 with ([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}])
//│ [mono] │ │ comparing (([],0)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] │ │ first time encounter count$List$1
//│ [mono] │ │ evaluating count$List$1, rests: HashSet(main$$5, main$$4, generate)
//│ [mono] │ │ ========== updating count$List$1 ==========
//│ [mono] │ │ count$List$1: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [] @{foo}
//│ [mono] │ │ ┌ SPEC CALL count$List$1 with ([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}])
//│ [mono] │ │ │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] │ │ └ SPEC CALL []
//│ [mono] │ │ comparing [] with [*LIT*]
//│ [mono] │ │ adding these funcs to queue: Set(foo, count$List$1)
//│ [mono] │ │ count$List$1: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] │ └ SPEC CALL [*LIT*]
//│ [mono] │ comparing [] with [*LIT*]
//│ [mono] │ adding these funcs to queue: Set(main$$5)
//│ [mono] │ foo: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{main$$5}
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] evaluating foo, rests: HashSet(count$List$1, main$$5, main$$4, generate)
//│ [mono] ========== updating foo ==========
//│ [mono] foo: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{main$$5}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] foo: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{main$$5}
//│ [mono] evaluating count$List$1, rests: HashSet(main$$5, main$$4, generate)
//│ [mono] ========== updating count$List$1 ==========
//│ [mono] count$List$1: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] count$List$1: (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] evaluating main$$5, rests: HashSet(main$$4, generate)
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] ┌ SPEC CALL generate with ([1])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [1], tail: ***}]
//│ [mono] ┌ SPEC CALL foo with ([List$1@{e: [1], tail: ***}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] evaluating main$$4, rests: HashSet(generate)
//│ [mono] ========== updating main$$4 ==========
//│ [mono] main$$4: () -> [] @{}
//│ [mono] ┌ SPEC CALL foo with ([List$1@{e: [1], tail: [List$1@{e: [2], tail: [Nil$2@{}]}]}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$4: () -> [*LIT*] @{}
//│ [mono] evaluating foo, rests: HashSet(generate)
//│ [mono] ========== updating foo ==========
//│ [mono] foo: (([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}],3)) -> [*LIT*] @{main$$5, main$$4}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]}],3)) with (Plain([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] foo: (([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}],3)) -> [*LIT*] @{main$$5, main$$4}
//│ [mono] evaluating count$List$1, rests: HashSet(generate)
//│ [mono] ========== updating count$List$1 ==========
//│ [mono] count$List$1: (([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}],3)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}]}],3)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] count$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] evaluating count$List$1, rests: HashSet(generate)
//│ [mono] ========== updating count$List$1 ==========
//│ [mono] count$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL count$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([],0)) with (Plain([Nil$2@{}]))
//│ [mono] │ first time encounter count$Nil$2
//│ [mono] │ evaluating count$Nil$2, rests: HashSet(generate)
//│ [mono] │ ========== updating count$Nil$2 ==========
//│ [mono] │ count$Nil$2: (([Nil$2@{}],1)) -> [] @{count$List$1}
//│ [mono] │ comparing [] with [0]
//│ [mono] │ adding these funcs to queue: Set(count$List$1)
//│ [mono] │ count$Nil$2: (([Nil$2@{}],1)) -> [0] @{count$List$1}
//│ [mono] └ SPEC CALL [0]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] count$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] evaluating count$List$1, rests: HashSet(generate)
//│ [mono] ========== updating count$List$1 ==========
//│ [mono] count$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL count$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([Nil$2@{}],1)) with (Plain([Nil$2@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] count$List$1: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]} | Nil$2@{}]}],100002)) -> [*LIT*] @{foo, count$List$1}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [1], tail: ***}] @{main$$5, generate}
//│ [mono] ┌ SPEC CALL generate with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [1], tail: ***}]
//│ [mono] comparing [List$1@{e: [1], tail: ***}] with [List$1@{e: [*LIT*], tail: [List$1@{e: [1], tail: ***}]} | Nil$2@{}]
//│ [mono] adding these funcs to queue: Set(main$$5, generate)
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$5, generate}
//│ [mono] evaluating main$$5, rests: HashSet(generate)
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] ┌ SPEC CALL generate with ([1])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]
//│ [mono] ┌ SPEC CALL foo with ([List$1@{e: [*LIT*], tail: ***} | Nil$2@{}])
//│ [mono] │ comparing (([List$1@{e: [1], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]}]}],3)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]} | Nil$2@{}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] evaluating foo, rests: HashSet(generate)
//│ [mono] ========== updating foo ==========
//│ [mono] foo: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]} | Nil$2@{}],100003)) -> [*LIT*] @{main$$5, main$$4}
//│ [mono] ┌ SPEC CALL count$List$1 with ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]}])
//│ [mono] │ comparing (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]}],100002)) with (Plain([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL count$Nil$2 with ([Nil$2@{}])
//│ [mono] │ comparing (([Nil$2@{}],1)) with (Plain([Nil$2@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] foo: (([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]} | Nil$2@{}],100003)) -> [*LIT*] @{main$$5, main$$4}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$5, generate}
//│ [mono] ┌ SPEC CALL generate with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]
//│ [mono] comparing [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] with [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]
//│ [mono] generate: (([*LIT*],100000)) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}] @{main$$5, generate}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] count$Nil$2: ([Nil$2@{}]) -> [0]
//│ [mono] foo: ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]} | Nil$2@{}]) -> [*LIT*]
//│ [mono] count$List$1: ([List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: [Nil$2@{} | List$1@{e: [*LIT*], tail: [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]}]} | Nil$2@{}]}]) -> [*LIT*]
//│ [mono] main$$5: () -> [*LIT*]
//│ [mono] main$$4: () -> [*LIT*]
//│ [mono] generate: ([*LIT*]) -> [List$1@{e: [*LIT*], tail: ***} | Nil$2@{}]


:mono
class E() {
  fun derive(x) = new E
  fun isEmpty() = 0
}
class Ep(){
  fun derive(x) = new E
  fun isEmpty() = 1
}
class C(i){
  fun derive(x) = 
    if x < i then new Ep else new E
  fun isEmpty() = 0
}
class A(e1, e2){
  fun derive(x) = new A(e1.derive(x), e2.derive(x))
  fun isEmpty() = e1.isEmpty() * e2.isEmpty()
}
fun gen(x) = 
  if x then new A(gen(x+1), new C(x)) else new E()
// (new A(new C(1), new A(new C(2), new C(3)))).derive(0).isEmpty()
gen(1).derive(0).isEmpty()
gen(1).isEmpty()
(new C(1)).derive(0).isEmpty()
//│ |#class| |E|(||)| |{|→|#fun| |derive|(|x|)| |#=| |#new| |E|↵|#fun| |isEmpty|(||)| |#=| |0|←|↵|}|↵|#class| |Ep|(||)|{|→|#fun| |derive|(|x|)| |#=| |#new| |E|↵|#fun| |isEmpty|(||)| |#=| |1|←|↵|}|↵|#class| |C|(|i|)|{|→|#fun| |derive|(|x|)| |#=| |→|#if| |x| |<| |i| |#then| |#new| |Ep| |#else| |#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |0|←|↵|}|↵|#class| |A|(|e1|,| |e2|)|{|→|#fun| |derive|(|x|)| |#=| |#new| |A|(|e1|.derive|(|x|)|,| |e2|.derive|(|x|)|)|↵|#fun| |isEmpty|(||)| |#=| |e1|.isEmpty|(||)| |*| |e2|.isEmpty|(||)|←|↵|}|↵|#fun| |gen|(|x|)| |#=| |→|#if| |x| |#then| |#new| |A|(|gen|(|x|+|1|)|,| |#new| |C|(|x|)|)| |#else| |#new| |E|(||)|←|↵|/* (new A(new C(1), new A(new C(2), new C(3)))).derive(0).isEmpty()*/|↵|gen|(|1|)|.derive|(|0|)|.isEmpty|(||)|↵|gen|(|1|)|.isEmpty|(||)|↵|(|#new| |C|(|1|)|)|.derive|(|0|)|.isEmpty|(||)|
//│ Parsed: {class E() {fun derive = x, => new E() {}; fun isEmpty =  => 0}; class Ep() {fun derive = x, => new E() {}; fun isEmpty =  => 1}; class C(i,) {fun derive = x, => {if (< (x,) (i,)) then new Ep() {} else new E() {}}; fun isEmpty =  => 0}; class A(e1, e2,) {fun derive = x, => new A((e1).derive (x,), (e2).derive (x,),) {}; fun isEmpty =  => * ((e1).isEmpty (),) ((e2).isEmpty (),)}; fun gen = x, => {if (x) then new A(gen (+ (x,) (1,),), new C(x,) {},) {} else new E() {}}; ((gen (1,)).derive (0,)).isEmpty (); (gen (1,)).isEmpty (); (('(' new C(1,) {}, ')').derive (0,)).isEmpty ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, E, (), Tup(), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), New(Some((TypeName(E),)), TypingUnit(List())))), NuFunDef(None, isEmpty, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, Ep, (), Tup(), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), New(Some((TypeName(E),)), TypingUnit(List())))), NuFunDef(None, isEmpty, [], Lam(Tup(), IntLit(1))))), NuTypeDef(class, C, (), Tup(_: Var(i)), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, A, (), Tup(_: Var(e1), _: Var(e2)), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), New(Some((TypeName(A),(e1).derive (x,), (e2).derive (x,),)), TypingUnit(List())))), NuFunDef(None, isEmpty, [], Lam(Tup(), App(App(Var(*), Tup(_: App(Sel(Var(e1), isEmpty), Tup()))), Tup(_: App(Sel(Var(e2), isEmpty), Tup()))))))), NuFunDef(None, gen, [], Lam(Tup(_: Var(x)), Blk(...))), App(Sel(App(Sel(App(Var(gen), Tup(_: IntLit(1))), derive), Tup(_: IntLit(0))), isEmpty), Tup()), App(Sel(App(Var(gen), Tup(_: IntLit(1))), isEmpty), Tup()), App(Sel(App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(C),1,)), TypingUnit(List())))), derive), Tup(_: IntLit(0))), isEmpty), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class E$1() {fun derive = x, => new E$1() {}; fun isEmpty =  => 0}
//│   class Ep$2() {fun derive = x, => new E$1() {}; fun isEmpty =  => 1}
//│   class C$3(i,) {
//│     fun derive = x, => {if (< (x,) ((this).i,)) then new Ep$2() {} else new E$1() {}}
//│     fun isEmpty =  => 0
//│   }
//│   class A$4(e1, e2,) {
//│     fun derive = x, => new A$4(((this).e1).derive (x,), ((this).e2).derive (x,),) {}
//│     fun isEmpty =  => * (((this).e1).isEmpty (),) (((this).e2).isEmpty (),)
//│   }
//│   fun gen = x, => {if (x) then new A$4(gen (+ (x,) (1,),), new C$3(x,) {},) {} else new E$1() {}}
//│   Code(List(((gen (1,)).derive (0,)).isEmpty ()))
//│   Code(List((gen (1,)).isEmpty ()))
//│   Code(List((('(' new C$3(1,) {}, ')').derive (0,)).isEmpty ()))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$5()
//│ main$$6()
//│ main$$7()
//│ fun isEmpty$Ep$2(this) =
//│   #1
//│ fun gen(x) =
//│   if x then new A$4 (gen((x + #1)), new C$3 (x) )  else new E$1 () 
//│ fun isEmpty$C$3(this) =
//│   #0
//│ fun isEmpty$E$1(this) =
//│   #0
//│ fun isEmpty$A$4(this) =
//│   (this.e1 match {case obj: A$4 => isEmpty$A$4(obj); case obj: E$1 => isEmpty$E$1(obj)} * this.e2 match {case obj: C$3 => isEmpty$C$3(obj); case obj: Ep$2 => isEmpty$Ep$2(obj); case obj: E$1 => isEmpty$E$1(obj)})
//│ fun derive$A$4(this, x) =
//│   new A$4 (this.e1 match {case obj: A$4 => derive$A$4(obj, x); case obj: E$1 => derive$E$1(obj, x)}, this.e2 match {case obj: C$3 => derive$C$3(obj, x)}) 
//│ fun derive$E$1(this, x) =
//│   new E$1 () 
//│ fun derive$C$3(this, x) =
//│   if (x < this.i) then new Ep$2 ()  else new E$1 () 
//│ fun main$$7() =
//│   new C$3 (#1)  match {case obj: C$3 => derive$C$3(obj, #0)} match {case obj: Ep$2 => isEmpty$Ep$2(obj); case obj: E$1 => isEmpty$E$1(obj)}
//│ fun main$$6() =
//│   gen(#1) match {case obj: A$4 => isEmpty$A$4(obj); case obj: E$1 => isEmpty$E$1(obj)}
//│ fun main$$5() =
//│   gen(#1) match {case obj: A$4 => derive$A$4(obj, #0); case obj: E$1 => derive$E$1(obj, #0)} match {case obj: A$4 => isEmpty$A$4(obj); case obj: E$1 => isEmpty$E$1(obj)}
//│ [mono] evaluating main$$7, rests: HashSet(main$$6, main$$5)
//│ [mono] ========== updating main$$7 ==========
//│ [mono] main$$7: () -> [] @{}
//│ [mono] ┌ SPEC CALL derive$C$3 with ([C$3@{i: [1]}], [0])
//│ [mono] │ comparing (([],0), ([],0)) with (Plain([C$3@{i: [1]}]), Plain([0]))
//│ [mono] │ first time encounter derive$C$3
//│ [mono] │ evaluating derive$C$3, rests: HashSet(main$$6, main$$5)
//│ [mono] │ ========== updating derive$C$3 ==========
//│ [mono] │ derive$C$3: (([C$3@{i: [1]}],2) X ([0],1)) -> [] @{main$$7}
//│ [mono] │ ┌ SPEC CALL < with ([0])
//│ [mono] │ │ !!!!!!!
//│ [mono] │ │ calling unknown function <([0])
//│ [mono] │ │ Set(gen, derive$C$3, main$$7, main$$6, main$$5)
//│ [mono] │ └ SPEC CALL [?1?]
//│ [mono] │ comparing [] with [E$1@{} | Ep$2@{}]
//│ [mono] │ adding these funcs to queue: Set(main$$7)
//│ [mono] │ derive$C$3: (([C$3@{i: [1]}],2) X ([0],1)) -> [E$1@{} | Ep$2@{}] @{main$$7}
//│ [mono] └ SPEC CALL [E$1@{} | Ep$2@{}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([],0)) with (Plain([E$1@{}]))
//│ [mono] │ first time encounter isEmpty$E$1
//│ [mono] │ evaluating isEmpty$E$1, rests: HashSet(main$$7, main$$6, main$$5)
//│ [mono] │ ========== updating isEmpty$E$1 ==========
//│ [mono] │ isEmpty$E$1: (([E$1@{}],1)) -> [] @{main$$7}
//│ [mono] │ comparing [] with [0]
//│ [mono] │ adding these funcs to queue: Set(main$$7)
//│ [mono] │ isEmpty$E$1: (([E$1@{}],1)) -> [0] @{main$$7}
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$Ep$2 with ([Ep$2@{}])
//│ [mono] │ comparing (([],0)) with (Plain([Ep$2@{}]))
//│ [mono] │ first time encounter isEmpty$Ep$2
//│ [mono] │ evaluating isEmpty$Ep$2, rests: HashSet(main$$7, main$$6, main$$5)
//│ [mono] │ ========== updating isEmpty$Ep$2 ==========
//│ [mono] │ isEmpty$Ep$2: (([Ep$2@{}],1)) -> [] @{main$$7}
//│ [mono] │ comparing [] with [1]
//│ [mono] │ adding these funcs to queue: Set(main$$7)
//│ [mono] │ isEmpty$Ep$2: (([Ep$2@{}],1)) -> [1] @{main$$7}
//│ [mono] └ SPEC CALL [1]
//│ [mono] comparing [] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$7: () -> [*LIT*] @{}
//│ [mono] evaluating main$$7, rests: HashSet(main$$6, main$$5)
//│ [mono] ========== updating main$$7 ==========
//│ [mono] main$$7: () -> [*LIT*] @{}
//│ [mono] ┌ SPEC CALL derive$C$3 with ([C$3@{i: [1]}], [0])
//│ [mono] │ comparing (([C$3@{i: [1]}],2), ([0],1)) with (Plain([C$3@{i: [1]}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{} | Ep$2@{}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$Ep$2 with ([Ep$2@{}])
//│ [mono] │ comparing (([Ep$2@{}],1)) with (Plain([Ep$2@{}]))
//│ [mono] └ SPEC CALL [1]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] main$$7: () -> [*LIT*] @{}
//│ [mono] evaluating main$$6, rests: HashSet(main$$5)
//│ [mono] ========== updating main$$6 ==========
//│ [mono] main$$6: () -> [] @{}
//│ [mono] ┌ SPEC CALL gen with ([1])
//│ [mono] │ comparing (([],0)) with (Plain([1]))
//│ [mono] │ first time encounter gen
//│ [mono] │ evaluating gen, rests: HashSet(main$$5)
//│ [mono] │ ========== updating gen ==========
//│ [mono] │ gen: (([1],1)) -> [] @{main$$6}
//│ [mono] │ ┌ SPEC CALL gen with ([2])
//│ [mono] │ │ comparing (([1],1)) with (Plain([*LIT*]))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ comparing [] with [E$1@{} | A$4@{e1: [], e2: [C$3@{i: [1]}]}]
//│ [mono] │ adding these funcs to queue: Set(main$$6, gen)
//│ [mono] │ gen: (([*LIT*],100000)) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}] @{main$$6, gen}
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}])
//│ [mono] │ comparing (([],0)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}]))
//│ [mono] │ first time encounter isEmpty$A$4
//│ [mono] │ evaluating isEmpty$A$4, rests: HashSet(gen, main$$6, main$$5)
//│ [mono] │ ========== updating isEmpty$A$4 ==========
//│ [mono] │ isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}],4)) -> [] @{main$$6}
//│ [mono] │ ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] │ └ SPEC CALL [0]
//│ [mono] │ ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}])
//│ [mono] │ │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}],4)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}]))
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ ┌ SPEC CALL isEmpty$C$3 with ([C$3@{i: [1]}])
//│ [mono] │ │ comparing (([],0)) with (Plain([C$3@{i: [1]}]))
//│ [mono] │ │ first time encounter isEmpty$C$3
//│ [mono] │ │ evaluating isEmpty$C$3, rests: HashSet(gen, main$$6, main$$5)
//│ [mono] │ │ ========== updating isEmpty$C$3 ==========
//│ [mono] │ │ isEmpty$C$3: (([C$3@{i: [1]}],2)) -> [] @{isEmpty$A$4}
//│ [mono] │ │ comparing [] with [0]
//│ [mono] │ │ adding these funcs to queue: Set(isEmpty$A$4)
//│ [mono] │ │ isEmpty$C$3: (([C$3@{i: [1]}],2)) -> [0] @{isEmpty$A$4}
//│ [mono] │ └ SPEC CALL [0]
//│ [mono] │ comparing [] with [0]
//│ [mono] │ adding these funcs to queue: Set(main$$6, isEmpty$A$4)
//│ [mono] │ isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [1]}]}],4)) -> [0] @{main$$6, isEmpty$A$4}
//│ [mono] └ SPEC CALL [0]
//│ [mono] comparing [] with [0]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$6: () -> [0] @{}
//│ [mono] evaluating gen, rests: HashSet(isEmpty$A$4, main$$6, main$$5)
//│ [mono] ========== updating gen ==========
//│ [mono] gen: (([*LIT*],100000)) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}] @{main$$6, gen}
//│ [mono] ┌ SPEC CALL gen with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}]
//│ [mono] comparing [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}] with [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [1]}]}], e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] adding these funcs to queue: Set(main$$6, gen)
//│ [mono] gen: (([*LIT*],100000)) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}] @{main$$6, gen}
//│ [mono] evaluating gen, rests: HashSet(isEmpty$A$4, main$$6, main$$5)
//│ [mono] ========== updating gen ==========
//│ [mono] gen: (([*LIT*],100000)) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}] @{main$$6, gen}
//│ [mono] ┌ SPEC CALL gen with ([*LIT*])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] comparing [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}] with [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] gen: (([*LIT*],100000)) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}] @{main$$6, gen}
//│ [mono] evaluating isEmpty$A$4, rests: HashSet(main$$6, main$$5)
//│ [mono] ========== updating isEmpty$A$4 ==========
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],4)) -> [0] @{main$$6, isEmpty$A$4}
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],4)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$C$3 with ([C$3@{i: [*LIT*]}])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],2)) with (Plain([C$3@{i: [*LIT*]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [0]
//│ [mono] comparing [0] with [0]
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) -> [*LIT*] @{main$$6, isEmpty$A$4}
//│ [mono] evaluating isEmpty$C$3, rests: HashSet(isEmpty$A$4, main$$6, main$$5)
//│ [mono] ========== updating isEmpty$C$3 ==========
//│ [mono] isEmpty$C$3: (([C$3@{i: [*LIT*]}],100001)) -> [0] @{isEmpty$A$4}
//│ [mono] comparing [0] with [0]
//│ [mono] isEmpty$C$3: (([C$3@{i: [*LIT*]}],100001)) -> [*LIT*] @{isEmpty$A$4}
//│ [mono] evaluating isEmpty$A$4, rests: HashSet(main$$6, main$$5)
//│ [mono] ========== updating isEmpty$A$4 ==========
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) -> [*LIT*] @{main$$6, isEmpty$A$4}
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL isEmpty$C$3 with ([C$3@{i: [*LIT*]}])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],100001)) with (Plain([C$3@{i: [*LIT*]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) -> [*LIT*] @{main$$6, isEmpty$A$4}
//│ [mono] evaluating main$$6, rests: HashSet(main$$5)
//│ [mono] ========== updating main$$6 ==========
//│ [mono] main$$6: () -> [0] @{}
//│ [mono] ┌ SPEC CALL gen with ([1])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [0] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$6: () -> [*LIT*] @{}
//│ [mono] evaluating main$$5, rests: HashSet()
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> [] @{}
//│ [mono] ┌ SPEC CALL gen with ([1])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] ┌ SPEC CALL derive$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], [0])
//│ [mono] │ comparing (([],0), ([],0)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]), Plain([0]))
//│ [mono] │ first time encounter derive$A$4
//│ [mono] │ evaluating derive$A$4, rests: HashSet()
//│ [mono] │ ========== updating derive$A$4 ==========
//│ [mono] │ derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [] @{main$$5}
//│ [mono] │ ┌ SPEC CALL derive$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], [0])
//│ [mono] │ │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003), ([0],1)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]), Plain([0]))
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ ┌ SPEC CALL derive$E$1 with ([E$1@{}], [0])
//│ [mono] │ │ comparing (([],0), ([],0)) with (Plain([E$1@{}]), Plain([0]))
//│ [mono] │ │ first time encounter derive$E$1
//│ [mono] │ │ evaluating derive$E$1, rests: HashSet()
//│ [mono] │ │ ========== updating derive$E$1 ==========
//│ [mono] │ │ derive$E$1: (([E$1@{}],1) X ([0],1)) -> [] @{derive$A$4}
//│ [mono] │ │ comparing [] with [E$1@{}]
//│ [mono] │ │ adding these funcs to queue: Set(derive$A$4)
//│ [mono] │ │ derive$E$1: (([E$1@{}],1) X ([0],1)) -> [E$1@{}] @{derive$A$4}
//│ [mono] │ └ SPEC CALL [E$1@{}]
//│ [mono] │ ┌ SPEC CALL derive$C$3 with ([C$3@{i: [*LIT*]}], [0])
//│ [mono] │ │ comparing (([C$3@{i: [1]}],2), ([0],1)) with (Plain([C$3@{i: [*LIT*]}]), Plain([0]))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL [E$1@{} | Ep$2@{}]
//│ [mono] │ comparing [] with [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] │ adding these funcs to queue: Set(main$$5, derive$A$4)
//│ [mono] │ derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}] @{main$$5, derive$A$4}
//│ [mono] └ SPEC CALL [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] ┌ SPEC CALL derive$E$1 with ([E$1@{}], [0])
//│ [mono] │ comparing (([E$1@{}],1), ([0],1)) with (Plain([E$1@{}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] evaluating isEmpty$A$4, rests: HashSet(derive$A$4, derive$C$3, main$$5)
//│ [mono] ========== updating isEmpty$A$4 ==========
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) -> [*LIT*] @{main$$6, isEmpty$A$4, main$$5}
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$C$3 with ([C$3@{i: [*LIT*]}])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],100001)) with (Plain([C$3@{i: [*LIT*]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL isEmpty$Ep$2 with ([Ep$2@{}])
//│ [mono] │ comparing (([Ep$2@{}],1)) with (Plain([Ep$2@{}]))
//│ [mono] └ SPEC CALL [1]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) -> [*LIT*] @{main$$6, isEmpty$A$4, main$$5}
//│ [mono] evaluating derive$A$4, rests: HashSet(derive$C$3, main$$5)
//│ [mono] ========== updating derive$A$4 ==========
//│ [mono] derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}] @{main$$5, derive$A$4}
//│ [mono] ┌ SPEC CALL derive$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], [0])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003), ([0],1)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]), Plain([0]))
//│ [mono] └ SPEC CALL [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] ┌ SPEC CALL derive$E$1 with ([E$1@{}], [0])
//│ [mono] │ comparing (([E$1@{}],1), ([0],1)) with (Plain([E$1@{}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{}]
//│ [mono] ┌ SPEC CALL derive$C$3 with ([C$3@{i: [*LIT*]}], [0])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],100001), ([0],1)) with (Plain([C$3@{i: [*LIT*]}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{} | Ep$2@{}]
//│ [mono] comparing [A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}] with [A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{}], e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] adding these funcs to queue: Set(main$$5, derive$A$4)
//│ [mono] derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}] @{main$$5, derive$A$4}
//│ [mono] evaluating derive$A$4, rests: HashSet(derive$C$3, main$$5)
//│ [mono] ========== updating derive$A$4 ==========
//│ [mono] derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}] @{main$$5, derive$A$4}
//│ [mono] ┌ SPEC CALL derive$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], [0])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003), ([0],1)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]), Plain([0]))
//│ [mono] └ SPEC CALL [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] ┌ SPEC CALL derive$E$1 with ([E$1@{}], [0])
//│ [mono] │ comparing (([E$1@{}],1), ([0],1)) with (Plain([E$1@{}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{}]
//│ [mono] ┌ SPEC CALL derive$C$3 with ([C$3@{i: [*LIT*]}], [0])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],100001), ([0],1)) with (Plain([C$3@{i: [*LIT*]}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{} | Ep$2@{}]
//│ [mono] comparing [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}] with [A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] derive$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003) X ([0],1)) -> [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}] @{main$$5, derive$A$4}
//│ [mono] evaluating derive$C$3, rests: HashSet(main$$5)
//│ [mono] ========== updating derive$C$3 ==========
//│ [mono] derive$C$3: (([C$3@{i: [*LIT*]}],100001) X ([0],1)) -> [E$1@{} | Ep$2@{}] @{main$$7, derive$A$4}
//│ [mono] ┌ SPEC CALL < with ([0])
//│ [mono] │ !!!!!!!
//│ [mono] │ calling unknown function <([0])
//│ [mono] │ Set(isEmpty$Ep$2, gen, isEmpty$C$3, isEmpty$E$1, isEmpty$A$4, derive$A$4, derive$E$1, derive$C$3, main$$7, main$$6, main$$5)
//│ [mono] └ SPEC CALL [?3?]
//│ [mono] comparing [E$1@{} | Ep$2@{}] with [E$1@{} | Ep$2@{}]
//│ [mono] derive$C$3: (([C$3@{i: [*LIT*]}],100001) X ([0],1)) -> [E$1@{} | Ep$2@{}] @{main$$7, derive$A$4}
//│ [mono] evaluating main$$5, rests: HashSet()
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] ┌ SPEC CALL gen with ([1])
//│ [mono] │ comparing (([*LIT*],100000)) with (Plain([*LIT*]))
//│ [mono] └ SPEC CALL [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] ┌ SPEC CALL derive$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], [0])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}],100003), ([0],1)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}]), Plain([0]))
//│ [mono] └ SPEC CALL [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] ┌ SPEC CALL derive$E$1 with ([E$1@{}], [0])
//│ [mono] │ comparing (([E$1@{}],1), ([0],1)) with (Plain([E$1@{}]), Plain([0]))
//│ [mono] └ SPEC CALL [E$1@{}]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}]))
//│ [mono] │ find finer args
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] main$$5: () -> [*LIT*] @{}
//│ [mono] evaluating isEmpty$A$4, rests: HashSet()
//│ [mono] ========== updating isEmpty$A$4 ==========
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) -> [*LIT*] @{main$$6, isEmpty$A$4, main$$5}
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$A$4 with ([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}])
//│ [mono] │ comparing (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) with (Plain([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL isEmpty$E$1 with ([E$1@{}])
//│ [mono] │ comparing (([E$1@{}],1)) with (Plain([E$1@{}]))
//│ [mono] └ SPEC CALL [0]
//│ [mono] ┌ SPEC CALL isEmpty$C$3 with ([C$3@{i: [*LIT*]}])
//│ [mono] │ comparing (([C$3@{i: [*LIT*]}],100001)) with (Plain([C$3@{i: [*LIT*]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] ┌ SPEC CALL isEmpty$Ep$2 with ([Ep$2@{}])
//│ [mono] │ comparing (([Ep$2@{}],1)) with (Plain([Ep$2@{}]))
//│ [mono] └ SPEC CALL [1]
//│ [mono] comparing [*LIT*] with [*LIT*]
//│ [mono] isEmpty$A$4: (([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}],100004)) -> [*LIT*] @{main$$6, isEmpty$A$4, main$$5}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] isEmpty$Ep$2: ([Ep$2@{}]) -> [1]
//│ [mono] gen: ([*LIT*]) -> [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}]
//│ [mono] isEmpty$C$3: ([C$3@{i: [*LIT*]}]) -> [*LIT*]
//│ [mono] isEmpty$E$1: ([E$1@{}]) -> [0]
//│ [mono] isEmpty$A$4: ([A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}], e2: [E$1@{} | Ep$2@{} | C$3@{i: [*LIT*]}]}]) -> [*LIT*]
//│ [mono] derive$A$4: ([A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [C$3@{i: [*LIT*]}]}], e2: [C$3@{i: [*LIT*]}]}] X [0]) -> [A$4@{e1: [E$1@{} | A$4@{e1: ***, e2: [E$1@{} | Ep$2@{}]}], e2: [E$1@{} | Ep$2@{}]}]
//│ [mono] derive$E$1: ([E$1@{}] X [0]) -> [E$1@{}]
//│ [mono] derive$C$3: ([C$3@{i: [*LIT*]}] X [0]) -> [E$1@{} | Ep$2@{}]
//│ [mono] main$$7: () -> [*LIT*]
//│ [mono] main$$6: () -> [*LIT*]
//│ [mono] main$$5: () -> [*LIT*]


// :mono
class List(l, hasTail)  {}
class Nil(hasTail)  {}
fun gen() = 
  if anyUnknown then new List(gen(), true) else new Nil(false)
gen()
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|hasTail|)| |{||}|↵|#fun| |gen|(||)| |#=| |→|#if| |anyUnknown| |#then| |#new| |List|(|gen|(||)|,| |true|)| |#else| |#new| |Nil|(|false|)|←|↵|gen|(||)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(hasTail,) {}; fun gen =  => {if (anyUnknown) then new List(gen (), true,) {} else new Nil(false,) {}}; gen ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(hasTail)), (), TypingUnit()), NuFunDef(None, gen, [], Lam(Tup(), Blk(...))), App(Var(gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(l, hasTail,) {}
//│   class Nil$2(hasTail,) {}
//│   fun gen =  => {if (anyUnknown) then new List$1(gen (), true,) {} else new Nil$2(false,) {}}
//│   Code(List(gen ()))
//│ }



// :mono
class Foo(x){
  fun bar(y) = x+y
  fun boo(z) = bar(z)+x
}
(new Foo(1)).boo(2)
//│ |#class| |Foo|(|x|)|{|→|#fun| |bar|(|y|)| |#=| |x|+|y|↵|#fun| |boo|(|z|)| |#=| |bar|(|z|)|+|x|←|↵|}|↵|(|#new| |Foo|(|1|)|)|.boo|(|2|)|
//│ Parsed: {class Foo(x,) {fun bar = y, => + (x,) (y,); fun boo = z, => + (bar (z,),) (x,)}; ('(' new Foo(1,) {}, ')').boo (2,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(_: Var(x)), (), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(y)), App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), NuFunDef(None, boo, [], Lam(Tup(_: Var(z)), App(App(Var(+), Tup(_: App(Var(bar), Tup(_: Var(z))))), Tup(_: Var(x))))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(Foo),1,)), TypingUnit(List())))), boo), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1(x,) {
//│     fun bar = y, => + ((this).x,) (y,)
//│     fun boo = z, => + ((this).bar (z,),) ((this).x,)
//│   }
//│   Code(List(('(' new Foo$1(1,) {}, ')').boo (2,)))
//│ }

:mono
class OneInt(a){
  fun fac() = 
    if(a > 0) then (new OneInt(a-1)).fac() else 1 
}
(new OneInt(10)).fac()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |fac|(||)| |#=| |→|#if|(|a| |>| |0|)| |#then| |(|#new| |OneInt|(|a|-|1|)|)|.fac|(||)| |#else| |1| |←|←|↵|}|↵|(|#new| |OneInt|(|10|)|)|.fac|(||)|
//│ Parsed: {class OneInt(a,) {fun fac =  => {if ('(' > (a,) (0,), ')') then ('(' new OneInt(- (a,) (1,),) {}, ')').fac () else 1}}; ('(' new OneInt(10,) {}, ')').fac ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, fac, [], Lam(Tup(), Blk(...))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),10,)), TypingUnit(List())))), fac), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(a,) {
//│     fun fac =  => {if ('(' > ((this).a,) (0,), ')') then ('(' new OneInt$1(- ((this).a,) (1,),) {}, ')').fac () else 1}
//│   }
//│   Code(List(('(' new OneInt$1(10,) {}, ')').fac ()))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$1()
//│ fun fac$OneInt$1(this) =
//│   if (this.a > #0) then new OneInt$1 ((this.a - #1))  match {case obj: OneInt$1 => fac$OneInt$1(obj)} else #1
//│ fun main$$1() =
//│   new OneInt$1 (#10)  match {case obj: OneInt$1 => fac$OneInt$1(obj)}
//│ [mono] evaluating main$$1, rests: HashSet()
//│ [mono] ========== updating main$$1 ==========
//│ [mono] main$$1: () -> [] @{}
//│ [mono] ┌ SPEC CALL fac$OneInt$1 with ([OneInt$1@{a: [10]}])
//│ [mono] │ comparing (([],0)) with (Plain([OneInt$1@{a: [10]}]))
//│ [mono] │ first time encounter fac$OneInt$1
//│ [mono] │ evaluating fac$OneInt$1, rests: HashSet()
//│ [mono] │ ========== updating fac$OneInt$1 ==========
//│ [mono] │ fac$OneInt$1: (([OneInt$1@{a: [10]}],2)) -> [] @{main$$1}
//│ [mono] │ ┌ SPEC CALL fac$OneInt$1 with ([OneInt$1@{a: [9]}])
//│ [mono] │ │ comparing (([OneInt$1@{a: [10]}],2)) with (Plain([OneInt$1@{a: [*LIT*]}]))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL []
//│ [mono] │ comparing [] with []
//│ [mono] │ fac$OneInt$1: (([OneInt$1@{a: [*LIT*]}],100001)) -> [] @{main$$1, fac$OneInt$1}
//│ [mono] └ SPEC CALL []
//│ [mono] comparing [] with []
//│ [mono] main$$1: () -> [] @{}
//│ [mono] evaluating fac$OneInt$1, rests: HashSet()
//│ [mono] ========== updating fac$OneInt$1 ==========
//│ [mono] fac$OneInt$1: (([OneInt$1@{a: [*LIT*]}],100001)) -> [] @{main$$1, fac$OneInt$1}
//│ [mono] ┌ SPEC CALL fac$OneInt$1 with ([OneInt$1@{a: [*LIT*]}])
//│ [mono] │ comparing (([OneInt$1@{a: [*LIT*]}],100001)) with (Plain([OneInt$1@{a: [*LIT*]}]))
//│ [mono] └ SPEC CALL []
//│ [mono] comparing [] with [1]
//│ [mono] adding these funcs to queue: Set(main$$1, fac$OneInt$1)
//│ [mono] fac$OneInt$1: (([OneInt$1@{a: [*LIT*]}],100001)) -> [1] @{main$$1, fac$OneInt$1}
//│ [mono] evaluating fac$OneInt$1, rests: HashSet(main$$1)
//│ [mono] ========== updating fac$OneInt$1 ==========
//│ [mono] fac$OneInt$1: (([OneInt$1@{a: [*LIT*]}],100001)) -> [1] @{main$$1, fac$OneInt$1}
//│ [mono] ┌ SPEC CALL fac$OneInt$1 with ([OneInt$1@{a: [*LIT*]}])
//│ [mono] │ comparing (([OneInt$1@{a: [*LIT*]}],100001)) with (Plain([OneInt$1@{a: [*LIT*]}]))
//│ [mono] └ SPEC CALL [1]
//│ [mono] comparing [1] with [1]
//│ [mono] fac$OneInt$1: (([OneInt$1@{a: [*LIT*]}],100001)) -> [*LIT*] @{main$$1, fac$OneInt$1}
//│ [mono] evaluating main$$1, rests: HashSet()
//│ [mono] ========== updating main$$1 ==========
//│ [mono] main$$1: () -> [] @{}
//│ [mono] ┌ SPEC CALL fac$OneInt$1 with ([OneInt$1@{a: [10]}])
//│ [mono] │ comparing (([OneInt$1@{a: [*LIT*]}],100001)) with (Plain([OneInt$1@{a: [*LIT*]}]))
//│ [mono] └ SPEC CALL [*LIT*]
//│ [mono] comparing [] with [*LIT*]
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$1: () -> [*LIT*] @{}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] fac$OneInt$1: ([OneInt$1@{a: [*LIT*]}]) -> [*LIT*]
//│ [mono] main$$1: () -> [*LIT*]

// :mono
trait AnyFoo {
  fun bar(b): int
}
class FooPlus(#a): AnyFoo {
  fun bar(b) = a + b
}
class FooMinus(#a): AnyFoo {
  fun bar(b) = a - b
}
fun f(x) = x.bar(42)
f(new FooPlus(1))
f(new FooMinus(2))
//│ |#trait| |AnyFoo| |{|→|#fun| |bar|(|b|)|#:| |int|←|↵|}|↵|#class| |FooPlus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |+| |b|←|↵|}|↵|#class| |FooMinus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |-| |b|←|↵|}|↵|#fun| |f|(|x|)| |#=| |x|.bar|(|42|)|↵|f|(|#new| |FooPlus|(|1|)|)|↵|f|(|#new| |FooMinus|(|2|)|)|
//│ Parsed: {trait AnyFoo(): {fun bar: [] -> b -> int}; class FooPlus(#a,): AnyFoo {fun bar = b, => + (a,) (b,)}; class FooMinus(#a,): AnyFoo {fun bar = b, => - (a,) (b,)}; fun f = x, => (x).bar (42,); f (new FooPlus(1,) {},); f (new FooMinus(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(trait, AnyFoo, (), Tup(), (), TypingUnit(NuFunDef(None, bar, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(b))))),TypeName(int)))))), NuTypeDef(class, FooPlus, (), Tup(_: Var(a)), (Var(AnyFoo)), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(b)), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b))))))), NuTypeDef(class, FooMinus, (), Tup(_: Var(a)), (Var(AnyFoo)), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(b)), App(App(Var(-), Tup(_: Var(a))), Tup(_: Var(b))))))), NuFunDef(None, f, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), bar), Tup(_: IntLit(42))))), App(Var(f), Tup(_: New(Some((TypeName(FooPlus),1,)), TypingUnit(List())))), App(Var(f), Tup(_: New(Some((TypeName(FooMinus),2,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   trait AnyFoo$1[b]() {fun bar = b -> int}
//│   class FooPlus$2[b](#a,): AnyFoo$1 () {fun bar = b, => + ((this).a,) (b,)}
//│   class FooMinus$3[b](#a,): AnyFoo$1 () {fun bar = b, => - ((this).a,) (b,)}
//│   fun f = x, => (x).bar (42,)
//│   Code(List(f (new FooPlus$2(1,) {},)))
//│   Code(List(f (new FooMinus$3(2,) {},)))
//│ }

// :mono
fun f(x) = 
  if x > any then 0
  else g(x-1)
fun g(x) = 
  if x > any then g(x-1)
  else f(x-2)
g(1)
//│ |#fun| |f|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |0|↵|#else| |g|(|x|-|1|)|←|↵|#fun| |g|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |g|(|x|-|1|)|↵|#else| |f|(|x|-|2|)|←|↵|g|(|1|)|
//│ Parsed: {fun f = x, => {if (> (x,) (any,)) then 0 else g (- (x,) (1,),)}; fun g = x, => {if (> (x,) (any,)) then g (- (x,) (1,),) else f (- (x,) (2,),)}; g (1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, g, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(g), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   fun f = x, => {if (> (x,) (any,)) then 0 else g (- (x,) (1,),)}
//│   fun g = x, => {if (> (x,) (any,)) then g (- (x,) (1,),) else f (- (x,) (2,),)}
//│   Code(List(g (1,)))
//│ }

// :mono
class OneInt(a){
  fun get = a
}
class OneBool(b){
  fun get = b
}
(if b then new OneInt(1) else new OneBool(true)).get()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |get| |#=| |a|←|↵|}|↵|#class| |OneBool|(|b|)|{|→|#fun| |get| |#=| |b|←|↵|}|↵|(|#if| |b| |#then| |#new| |OneInt|(|1|)| |#else| |#new| |OneBool|(|true|)|)|.get|(||)|
//│ Parsed: {class OneInt(a,) {fun get = a}; class OneBool(b,) {fun get = b}; ('(' if (b) then new OneInt(1,) {} else new OneBool(true,) {}, ')').get ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, get, [], Var(a)))), NuTypeDef(class, OneBool, (), Tup(_: Var(b)), (), TypingUnit(NuFunDef(None, get, [], Var(b)))), App(Sel(Bra(rcd = false, Tup(_: If((b) then new OneInt(1,) {}, Some(New(Some((TypeName(OneBool),true,)), TypingUnit(List())))))), get), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(a,) {fun get = (this).a}
//│   class OneBool$2(b,) {fun get = (this).b}
//│   Code(List(('(' if (b) then new OneInt$1(1,) {} else new OneBool$2(true,) {}, ')').get ()))
//│ }

// :mono
class Bar(x: int) {
  fun FooMinus(y: int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
Car().da(Bar(1337))
bar.car
//│ |#class| |Bar|(|x|#:| |int|)| |{|→|#fun| |FooMinus|(|y|#:| |int|)| |#=| |x| |+| |y|↵|#fun| |car| |#=| |foo|(|2|)|←|↵|}|↵|#class| |Car| |{|→|#fun| |da|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|←|↵|}|↵|#fun| |baz|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|↵|#let| |bar| |#=| |Bar|(|42|)|↵|baz|(|bar|)|↵|Car|(||)|.da|(|Bar|(|1337|)|)|↵|bar|.car|
//│ Parsed: {class Bar(x: int,) {fun FooMinus = y: int, => + (x,) (y,); fun car = foo (2,)}; class Car() {fun da = b: Bar, => (b).foo (2,)}; fun baz = b: Bar, => (b).foo (2,); let bar = Bar (42,); baz (bar,); (Car ()).da (Bar (1337,),); (bar).car}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(x: Var(int)), (), TypingUnit(NuFunDef(None, FooMinus, [], Lam(Tup(y: Var(int)), App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), NuFunDef(None, car, [], App(Var(foo), Tup(_: IntLit(2)))))), NuTypeDef(class, Car, (), Tup(), (), TypingUnit(NuFunDef(None, da, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))))), NuFunDef(None, baz, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))), NuFunDef(Some(false), bar, [], App(Var(Bar), Tup(_: IntLit(42)))), App(Var(baz), Tup(_: Var(bar))), App(Sel(App(Var(Car), Tup()), da), Tup(_: App(Var(Bar), Tup(_: IntLit(1337))))), Sel(Var(bar), car))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1(x: int,) {
//│     fun FooMinus = y: int, => + ((this).x,) (y,)
//│     fun car = foo (2,)
//│   }
//│   class Car$2() {fun da = b: Bar$1, => (b).foo (2,)}
//│   fun baz = b: Bar$1, => (b).foo (2,)
//│   let bar = Bar$1 (42,)
//│   Code(List(baz (bar,)))
//│   Code(List((Car$2 ()).da (Bar$1 (1337,),)))
//│   Code(List((bar).car))
//│ }
