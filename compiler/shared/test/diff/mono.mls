:NewParser
:NewDefs
:ParseOnly
// :mono
fun f(x) = if x then 42 else 1337
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |#then| |42| |#else| |1337|
//│ Parsed: {fun f = (x,) => if (x) then 42 else 1337}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), If(IfThen(Var(x), IntLit(42), Some(IntLit(1337))))))
//│ Lifted:
//│ TypingUnit {fun f$1 = (x,) => if (x) then 42 else 1337}
//│ 

// :mono
fun foo() = 42
//│ |#fun| |foo|(||)| |#=| |42|
//│ Parsed: {fun foo = () => 42}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(), IntLit(42))))
//│ Lifted:
//│ TypingUnit {fun foo$1 = () => 42}
//│ 

// :mono
fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ |#fun| |foo|(|x|,| |##|b|)| |#=| |#if| |b| |#then| |x| |#else| |1337|↵|#let| |a| |#=| |foo|(|42|,| |true|)|↵|#let| |b| |#=| |foo|(|23|,| |false|)|
//│ Parsed: {fun foo = (x, #b,) => if (b) then x else 1337; let a = foo(42, true,); let b = foo(23, false,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x), _: Var(b)), If(IfThen(Var(b), Var(x), Some(IntLit(1337))))), NuFunDef(Some(false), a, None, [], App(Var(foo), Tup(_: IntLit(42), _: Var(true)))), NuFunDef(Some(false), b, None, [], App(Var(foo), Tup(_: IntLit(23), _: Var(false)))))
//│ Lifted:
//│ TypingUnit {
//│   fun foo$3 = (x, #b,) => if (b) then x else 1337
//│   let a$1 = () => foo$3(42, true,)
//│   let b$2 = () => foo$3(23, false,)
//│ }
//│ 

// :mono
let x = 42 + 1337
//│ |#let| |x| |#=| |42| |+| |1337|
//│ Parsed: {let x = +(42, 1337,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, None, [], App(Var(+), Tup(_: IntLit(42), _: IntLit(1337)))))
//│ Lifted:
//│ TypingUnit {let x$1 = () => +(42, 1337,)}
//│ 

// :mono
class Bar(#x)
fun foo(#b) = b
let a = foo(new Bar(1))
let b = foo(new Bar(2))
//│ |#class| |Bar|(|##|x|)|↵|#fun| |foo|(|##|b|)| |#=| |b|↵|#let| |a| |#=| |foo|(|#new| |Bar|(|1|)|)|↵|#let| |b| |#=| |foo|(|#new| |Bar|(|2|)|)|
//│ Parsed: {class Bar(#x,) {}; fun foo = (#b,) => b; let a = foo(new Bar([1,]) {},); let b = foo(new Bar([2,]) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(_: Var(x)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(b)), Var(b))), NuFunDef(Some(false), a, None, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),[1,])), TypingUnit())))), NuFunDef(Some(false), b, None, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),[2,])), TypingUnit())))))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1([#x,]) {}
//│   fun foo$3 = (#b,) => b
//│   let a$1 = () => foo$3(new Bar$1([1,]) {},)
//│   let b$2 = () => foo$3(new Bar$1([2,]) {},)
//│ }
//│ 

// :mono
class OneInt(#a){
  fun inc() = a+1
}
(new OneInt(1)).inc()
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |inc|(||)| |#=| |a|+|1|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.inc|(||)|
//│ Parsed: {class OneInt(#a,) {fun inc = () => +(a, 1,)}; ('(' new OneInt([1,]) {} ')').inc()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, inc, None, [], Lam(Tup(), App(Var(+), Tup(_: Var(a), _: IntLit(1))))))), App(Sel(Bra(rcd = false, New(Some((TypeName(OneInt),[1,])), TypingUnit())), inc), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([#a,]) {fun inc = () => +((this).a, 1,)}
//│   Code(List(('(' new OneInt$1([1,]) {} ')').inc()))
//│ }
//│ 

// :mono
class OneInt(#a){
  fun add(x) = 
    new OneInt(a+x.a)
}
(new OneInt(1)).add(new OneInt(2))
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |add|(|x|)| |#=| |→|#new| |OneInt|(|a|+|x|.a|)|←|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.add|(|#new| |OneInt|(|2|)|)|
//│ Parsed: {class OneInt(#a,) {fun add = (x,) => {new OneInt([+(a, (x).a,),]) {}}}; ('(' new OneInt([1,]) {} ')').add(new OneInt([2,]) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, add, None, [], Lam(Tup(_: Var(x)), Blk(...))))), App(Sel(Bra(rcd = false, New(Some((TypeName(OneInt),[1,])), TypingUnit())), add), Tup(_: New(Some((TypeName(OneInt),[2,])), TypingUnit()))))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([#a,]) {
//│     fun add = (x,) => {new OneInt$1([+((this).a, (x).a,),]) {}}
//│   }
//│   Code(List(('(' new OneInt$1([1,]) {} ')').add(new OneInt$1([2,]) {},)))
//│ }
//│ 

// :mono
if true then 1 else 0
if 1+1 > 1 then 1-1 else 1*1
//│ |#if| |true| |#then| |1| |#else| |0|↵|#if| |1|+|1| |>| |1| |#then| |1|-1| |#else| |1|*|1|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.105: 	if 1+1 > 1 then 1-1 else 1*1
//│ ╙──       	                ^^^
//│ Parsed: {if (true) then 1 else 0; if (>(+(1, 1,), 1,)) then 1(-1,) else *(1, 1,)}
//│ Parsed:
//│ TypingUnit(If(IfThen(Var(true), IntLit(1), Some(IntLit(0))), If(IfThen(App(Var(>), Tup(_: App(Var(+), Tup(_: IntLit(1), _: IntLit(1))), _: IntLit(1))), App(IntLit(1), Tup(_: IntLit(-1))), Some(App(Var(*), Tup(_: IntLit(1), _: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List(if (true) then 1 else 0))
//│   Code(List(if (>(+(1, 1,), 1,)) then 1(-1,) else *(1, 1,)))
//│ }
//│ 

// :mono
if(b) then 1 else 2
//│ |#if|(|b|)| |#then| |1| |#else| |2|
//│ Parsed: {if ('(' b ')') then 1 else 2}
//│ Parsed:
//│ TypingUnit(If(IfThen(Bra(rcd = false, Var(b)), IntLit(1), Some(IntLit(2))))
//│ Lifted:
//│ TypingUnit {Code(List(if ('(' b ')') then 1 else 2))}
//│ 

// :mono
((f, g) => f(g))(f => f, true)
//│ |(|(|f|,| |g|)| |=>| |f|(|g|)|)|(|f| |=>| |f|,| |true|)|
//│ Parsed: {'(' (f, g,) => f(g,) ')'((f,) => f, true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Lam(Tup(_: Var(f), _: Var(g)), App(Var(f), Tup(_: Var(g))))), Tup(_: Lam(Tup(_: Var(f)), Var(f)), _: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda2$1$1([]) {fun apply = (f, g,) => f(g,)}
//│   class Lambda1$2$2([]) {fun apply = (f,) => f}
//│   Code(List('(' {new Lambda2$1$1([]) {}} ')'({new Lambda1$2$2([]) {}}, true,)))
//│ }
//│ 


:mono
(b => if b then true else false) (true)
//│ |(|b| |=>| |#if| |b| |#then| |true| |#else| |false|)| |(|true|)|
//│ Parsed: {'(' (b,) => if (b) then true else false ')'(true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Lam(Tup(_: Var(b)), If(IfThen(Var(b), Var(true), Some(Var(false))))), Tup(_: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$1$1([]) {fun apply = (b,) => if (b) then true else false}
//│   Code(List('(' {new Lambda1$1$1([]) {}} ')'(true,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun apply$Lambda1$1$1(this, b) =
//│   if b then true else false
//│ fun main$$1() =
//│   new Lambda1$1$1 ()  match {case obj: Lambda1$1$1 => apply$Lambda1$1$1(obj, true)}
//│ class Lambda1$1$1() {
//│ }
//│ 

// :mono
fun f(x) =
  if(x > 0) then x+1 else x-1
f(2)+3
//│ |#fun| |f|(|x|)| |#=|→|#if|(|x| |>| |0|)| |#then| |x|+|1| |#else| |x|-1|←|↵|f|(|2|)|+|3|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.170: 	  if(x > 0) then x+1 else x-1
//│ ╙──       	                          ^^^
//│ Parsed: {fun f = (x,) => {if ('(' >(x, 0,) ')') then +(x, 1,) else x(-1,)}; +(f(2,), 3,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(+), Tup(_: App(Var(f), Tup(_: IntLit(2))), _: IntLit(3))))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x,) => {if ('(' >(x, 0,) ')') then +(x, 1,) else x(-1,)}
//│   Code(List(+(f$1(2,), 3,)))
//│ }
//│ 

// :mono
fun fac(n) = 
  if (n > 1) then fac(n - 1) * n else 1
fac(2)
//│ |#fun| |fac|(|n|)| |#=| |→|#if| |(|n| |>| |1|)| |#then| |fac|(|n| |-| |1|)| |*| |n| |#else| |1|←|↵|fac|(|2|)|
//│ Parsed: {fun fac = (n,) => {if ('(' >(n, 1,) ')') then *(fac(-(n, 1,),), n,) else 1}; fac(2,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, fac, None, [], Lam(Tup(_: Var(n)), Blk(...))), App(Var(fac), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   fun fac$1 = (n,) => {if ('(' >(n, 1,) ')') then *(fac$1(-(n, 1,),), n,) else 1}
//│   Code(List(fac$1(2,)))
//│ }
//│ 

// :mono
class List(l, hasTail)  {}
class Nil(l, hasTail)  {}
fun count(lst) =
  if lst.hasTail then count(lst.l)+1 else 1
count(new List(new List(new Nil(0, false), true), true))
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|l|,| |hasTail|)| |{||}|↵|#fun| |count|(|lst|)| |#=|→|#if| |lst|.hasTail| |#then| |count|(|lst|.l|)|+|1| |#else| |1|←|↵|count|(|#new| |List|(|#new| |List|(|#new| |Nil|(|0|,| |false|)|,| |true|)|,| |true|)|)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(l, hasTail,) {}; fun count = (lst,) => {if ((lst).hasTail) then +(count((lst).l,), 1,) else 1}; count(new List([new List([new Nil([0, false,]) {}, true,]) {}, true,]) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), None, None, TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(l), _: Var(hasTail)), (), None, None, TypingUnit()), NuFunDef(None, count, None, [], Lam(Tup(_: Var(lst)), Blk(...))), App(Var(count), Tup(_: New(Some((TypeName(List),[new List([new Nil([0, false,]) {}, true,]) {}, true,])), TypingUnit()))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([l, hasTail,]) {}
//│   class Nil$2([l, hasTail,]) {}
//│   fun count$1 = (lst,) => {if ((lst).hasTail) then +(count$1((lst).l,), 1,) else 1}
//│   Code(List(count$1(new List$1([new List$1([new Nil$2([0, false,]) {}, true,]) {}, true,]) {},)))
//│ }
//│ 

:mono
class Cons(e, tail){
  fun gen() = new Cons(e, tail.gen())
}
class Nil(){
  fun gen() = new Cons(0, this)
}
fun generate(x) = 
  if x > 0 then new Cons(x, generate(x+1)) else new Nil()
generate(10).gen()
//│ |#class| |Cons|(|e|,| |tail|)|{|→|#fun| |gen|(||)| |#=| |#new| |Cons|(|e|,| |tail|.gen|(||)|)|←|↵|}|↵|#class| |Nil|(||)|{|→|#fun| |gen|(||)| |#=| |#new| |Cons|(|0|,| |this|)|←|↵|}|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |Cons|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|generate|(|10|)|.gen|(||)|
//│ Parsed: {class Cons(e, tail,) {fun gen = () => new Cons([e, (tail).gen(),]) {}}; class Nil() {fun gen = () => new Cons([0, this,]) {}}; fun generate = (x,) => {if (>(x, 0,)) then new Cons([x, generate(+(x, 1,),),]) {} else new Nil([]) {}}; (generate(10,)).gen()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Cons, (), Tup(_: Var(e), _: Var(tail)), (), None, None, TypingUnit(NuFunDef(None, gen, None, [], Lam(Tup(), New(Some((TypeName(Cons),[e, (tail).gen(),])), TypingUnit()))))), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, gen, None, [], Lam(Tup(), New(Some((TypeName(Cons),[0, this,])), TypingUnit()))))), NuFunDef(None, generate, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Sel(App(Var(generate), Tup(_: IntLit(10))), gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1([e, tail,]) {
//│     fun gen = () => new Cons$1([(this).e, ((this).tail).gen(),]) {}
//│   }
//│   class Nil$2([]) {fun gen = () => new Cons$1([0, this,]) {}}
//│   fun generate$1 = (x,) => {if (>(x, 0,)) then new Cons$1([x, generate$1(+(x, 1,),),]) {} else new Nil$2([]) {}}
//│   Code(List((generate$1(10,)).gen()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$3()
//│ fun gen$Cons$1(this) =
//│   new Cons$1 (this.e, this.tail match {case obj: Cons$1 => gen$Cons$1(obj); case obj: Nil$2 => gen$Nil$2(obj)}) 
//│ fun generate$1(x) =
//│   if >(x, #0) then new Cons$1 (x, generate$1(+(x, #1)))  else new Nil$2 () 
//│ fun gen$Nil$2(this) =
//│   new Cons$1 (#0, this) 
//│ fun main$$3() =
//│   generate$1(#10) match {case obj: Cons$1 => gen$Cons$1(obj); case obj: Nil$2 => gen$Nil$2(obj)}
//│ class Nil$2() {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ 

:mono
class List(e, tail) {
  fun map(f) = new List(f(e), tail.map(f))
  fun count() = 1 + tail.count()
}
class Nil() {
  fun map(f) = this
  fun count() = 0
}
fun add2(x) = x+2
(new List(1, new List(2, new Nil()))).map(x => x+1).map(x => add2(x))
//│ |#class| |List|(|e|,| |tail|)| |{|→|#fun| |map|(|f|)| |#=| |#new| |List|(|f|(|e|)|,| |tail|.map|(|f|)|)|↵|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |map|(|f|)| |#=| |this|↵|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |add2|(|x|)| |#=| |x|+|2|↵|(|#new| |List|(|1|,| |#new| |List|(|2|,| |#new| |Nil|(||)|)|)|)|.map|(|x| |=>| |x|+|1|)|.map|(|x| |=>| |add2|(|x|)|)|
//│ Parsed: {class List(e, tail,) {fun map = (f,) => new List([f(e,), (tail).map(f,),]) {}; fun count = () => +(1, (tail).count(),)}; class Nil() {fun map = (f,) => this; fun count = () => 0}; fun add2 = (x,) => +(x, 2,); (('(' new List([1, new List([2, new Nil([]) {},]) {},]) {} ')').map((x,) => +(x, 1,),)).map((x,) => add2(x,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), None, None, TypingUnit(NuFunDef(None, map, None, [], Lam(Tup(_: Var(f)), New(Some((TypeName(List),[f(e,), (tail).map(f,),])), TypingUnit()))), NuFunDef(None, count, None, [], Lam(Tup(), App(Var(+), Tup(_: IntLit(1), _: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, map, None, [], Lam(Tup(_: Var(f)), Var(this))), NuFunDef(None, count, None, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, add2, None, [], Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(2))))), App(Sel(App(Sel(Bra(rcd = false, New(Some((TypeName(List),[1, new List([2, new Nil([]) {},]) {},])), TypingUnit())), map), Tup(_: Lam(Tup(_: Var(x)), App(Var(+), Tup(_: Var(x), _: IntLit(1)))))), map), Tup(_: Lam(Tup(_: Var(x)), App(Var(add2), Tup(_: Var(x)))))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([e, tail,]) {
//│     fun map = (f,) => new List$1([f((this).e,), ((this).tail).map(f,),]) {}
//│     fun count = () => +(1, ((this).tail).count(),)
//│   }
//│   class Nil$2([]) {fun map = (f,) => this; fun count = () => 0}
//│   class Lambda1$2$3([]) {fun apply = (x,) => +(x, 1,)}
//│   class Lambda1$3$4([]) {fun apply = (x,) => add2$1(x,)}
//│   fun add2$1 = (x,) => +(x, 2,)
//│   Code(List((('(' new List$1([1, new List$1([2, new Nil$2([]) {},]) {},]) {} ')').map({new Lambda1$2$3([]) {}},)).map({new Lambda1$3$4([]) {}},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ fun map$List$1(this, f) =
//│   new List$1 (f match {case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, this.e); case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, this.e)}, this.tail match {case obj: List$1 => map$List$1(obj, f); case obj: Nil$2 => map$Nil$2(obj, f)}) 
//│ fun add2$1(x) =
//│   +(x, #2)
//│ fun main$$5() =
//│   new List$1 (#1, new List$1 (#2, new Nil$2 () ) )  match {case obj: List$1 => map$List$1(obj, new Lambda1$2$3 () )} match {case obj: List$1 => map$List$1(obj, new Lambda1$3$4 () )}
//│ fun apply$Lambda1$3$4(this, x) =
//│   add2$1(x)
//│ fun map$Nil$2(this, f) =
//│   this
//│ fun apply$Lambda1$2$3(this, x) =
//│   +(x, #1)
//│ class Lambda1$3$4() {
//│ }
//│ class Nil$2() {
//│ }
//│ class List$1(e, tail) {
//│ }
//│ class Lambda1$2$3() {
//│ }
//│ 

// :mono
class List(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = x.count()
fun generate(x) = 
  if x > 0 then new List(x, generate(x+1)) else new Nil()
foo(new List(1, new List(2, new Nil())))
foo(generate(1))
//│ |#class| |List|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |x|.count|(||)|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |List|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|foo|(|#new| |List|(|1|,| |#new| |List|(|2|,| |#new| |Nil|(||)|)|)|)|↵|foo|(|generate|(|1|)|)|
//│ Parsed: {class List(e, tail,) {fun count = () => +(1, (tail).count(),)}; class Nil() {fun count = () => 0}; fun foo = (x,) => (x).count(); fun generate = (x,) => {if (>(x, 0,)) then new List([x, generate(+(x, 1,),),]) {} else new Nil([]) {}}; foo(new List([1, new List([2, new Nil([]) {},]) {},]) {},); foo(generate(1,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), App(Var(+), Tup(_: IntLit(1), _: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), count), Tup()))), NuFunDef(None, generate, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: New(Some((TypeName(List),[1, new List([2, new Nil([]) {},]) {},])), TypingUnit()))), App(Var(foo), Tup(_: App(Var(generate), Tup(_: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([e, tail,]) {fun count = () => +(1, ((this).tail).count(),)}
//│   class Nil$2([]) {fun count = () => 0}
//│   fun foo$1 = (x,) => (x).count()
//│   fun generate$2 = (x,) => {if (>(x, 0,)) then new List$1([x, generate$2(+(x, 1,),),]) {} else new Nil$2([]) {}}
//│   Code(List(foo$1(new List$1([1, new List$1([2, new Nil$2([]) {},]) {},]) {},)))
//│   Code(List(foo$1(generate$2(1,),)))
//│ }
//│ 

:mono
fun foo(x) = 
  (f => f(x))(z => z+1)
foo(2)
//│ |#fun| |foo|(|x|)| |#=| |→|(|f| |=>| |f|(|x|)|)|(|z| |=>| |z|+|1|)|←|↵|foo|(|2|)|
//│ Parsed: {fun foo = (x,) => {'(' (f,) => f(x,) ')'((z,) => +(z, 1,),)}; foo(2,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([x,]) {fun apply = (f,) => f((this).x,)}
//│   class Lambda1$3$2([]) {fun apply = (z,) => +(z, 1,)}
//│   fun foo$1 = (x,) => {'(' {new Lambda1$2$1([x,]) {}} ')'({new Lambda1$3$2([]) {}},)}
//│   Code(List(foo$1(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$3()
//│ fun apply$Lambda1$2$1(this, f) =
//│   f match {case obj: Lambda1$3$2 => apply$Lambda1$3$2(obj, this.x)}
//│ fun foo$1(x) =
//│   new Lambda1$2$1 (x)  match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, new Lambda1$3$2 () )}
//│ fun main$$3() =
//│   foo$1(#2)
//│ fun apply$Lambda1$3$2(this, z) =
//│   +(z, #1)
//│ class Lambda1$2$1(x) {
//│ }
//│ class Lambda1$3$2() {
//│ }
//│ 

:mono
fun f(x) =
  (y => f(x+y)).apply(x+1)
f(1)
//│ |#fun| |f|(|x|)| |#=|→|(|y| |=>| |f|(|x|+|y|)|)|.apply|(|x|+|1|)|←|↵|f|(|1|)|
//│ Parsed: {fun f = (x,) => {('(' (y,) => f(+(x, y,),) ')').apply(+(x, 1,),)}; f(1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(f), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([x,]) {fun apply = (y,) => f$1(+((this).x, y,),)}
//│   fun f$1 = (x,) => {('(' {new Lambda1$2$1([x,]) {}} ')').apply(+(x, 1,),)}
//│   Code(List(f$1(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun apply$Lambda1$2$1(this, y) =
//│   f$1(+(this.x, y))
//│ fun f$1(x) =
//│   new Lambda1$2$1 (x)  match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, +(x, #1))}
//│ fun main$$2() =
//│   f$1(#1)
//│ class Lambda1$2$1(x) {
//│ }
//│ 


:mono
fun f(x) = f(x)
f(0)
f(1)
//│ |#fun| |f|(|x|)| |#=| |f|(|x|)|↵|f|(|0|)|↵|f|(|1|)|
//│ Parsed: {fun f = (x,) => f(x,); f(0,); f(1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), App(Var(f), Tup(_: Var(x))))), App(Var(f), Tup(_: IntLit(0))), App(Var(f), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x,) => f$1(x,)
//│   Code(List(f$1(0,)))
//│   Code(List(f$1(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ main$$2()
//│ fun f$1(x) =
//│   f$1(x)
//│ fun main$$2() =
//│   f$1(#1)
//│ fun main$$1() =
//│   f$1(#0)
//│ 

:mono
class Cons(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
class Lambda(){
  fun apply(l) = 
    l.count()
}
class Lambda2(a){
  fun apply(l) = 
    (new Cons(a, l)).count()
}
fun foo(x) = 
  x.apply(new Cons(1, new Nil())) + x.apply(new Nil())
foo(new Lambda())
foo(new Lambda2(2))
//│ |#class| |Cons|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#class| |Lambda|(||)|{|→|#fun| |apply|(|l|)| |#=| |→|l|.count|(||)|←|←|↵|}|↵|#class| |Lambda2|(|a|)|{|→|#fun| |apply|(|l|)| |#=| |→|(|#new| |Cons|(|a|,| |l|)|)|.count|(||)|←|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |→|x|.apply|(|#new| |Cons|(|1|,| |#new| |Nil|(||)|)|)| |+| |x|.apply|(|#new| |Nil|(||)|)|←|↵|foo|(|#new| |Lambda|(||)|)|↵|foo|(|#new| |Lambda2|(|2|)|)|
//│ Parsed: {class Cons(e, tail,) {fun count = () => +(1, (tail).count(),)}; class Nil() {fun count = () => 0}; class Lambda() {fun apply = (l,) => {(l).count()}}; class Lambda2(a,) {fun apply = (l,) => {('(' new Cons([a, l,]) {} ')').count()}}; fun foo = (x,) => {+((x).apply(new Cons([1, new Nil([]) {},]) {},), (x).apply(new Nil([]) {},),)}; foo(new Lambda([]) {},); foo(new Lambda2([2,]) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Cons, (), Tup(_: Var(e), _: Var(tail)), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), App(Var(+), Tup(_: IntLit(1), _: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, Lambda, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Var(l)), Blk(...))))), NuTypeDef(class, Lambda2, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, apply, None, [], Lam(Tup(_: Var(l)), Blk(...))))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: New(Some((TypeName(Lambda),[])), TypingUnit()))), App(Var(foo), Tup(_: New(Some((TypeName(Lambda2),[2,])), TypingUnit()))))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1([e, tail,]) {fun count = () => +(1, ((this).tail).count(),)}
//│   class Nil$2([]) {fun count = () => 0}
//│   class Lambda$3([]) {fun apply = (l,) => {(l).count()}}
//│   class Lambda2$4([a,]) {
//│     fun apply = (l,) => {('(' new Cons$1([(this).a, l,]) {} ')').count()}
//│   }
//│   fun foo$1 = (x,) => {+((x).apply(new Cons$1([1, new Nil$2([]) {},]) {},), (x).apply(new Nil$2([]) {},),)}
//│   Code(List(foo$1(new Lambda$3([]) {},)))
//│   Code(List(foo$1(new Lambda2$4([2,]) {},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ main$$6()
//│ fun count$Cons$1(this) =
//│   +(#1, this.tail match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)})
//│ fun foo$1(x) =
//│   +(x match {case obj: Lambda2$4 => apply$Lambda2$4(obj, new Cons$1 (#1, new Nil$2 () ) ); case obj: Lambda$3 => apply$Lambda$3(obj, new Cons$1 (#1, new Nil$2 () ) )}, x match {case obj: Lambda2$4 => apply$Lambda2$4(obj, new Nil$2 () ); case obj: Lambda$3 => apply$Lambda$3(obj, new Nil$2 () )})
//│ fun apply$Lambda$3(this, l) =
//│   l match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ fun count$Nil$2(this) =
//│   #0
//│ fun apply$Lambda2$4(this, l) =
//│   new Cons$1 (this.a, l)  match {case obj: Cons$1 => count$Cons$1(obj)}
//│ fun main$$6() =
//│   foo$1(new Lambda2$4 (#2) )
//│ fun main$$5() =
//│   foo$1(new Lambda$3 () )
//│ class Nil$2() {
//│ }
//│ class Lambda2$4(a) {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ class Lambda$3() {
//│ }
//│ 

:mono
class Cons(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = 
  x(new Cons(1, new Nil())) + x(new Nil())
foo(l => l.count())
foo(l => (new Cons(2, l)).count())
//│ |#class| |Cons|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |→|x|(|#new| |Cons|(|1|,| |#new| |Nil|(||)|)|)| |+| |x|(|#new| |Nil|(||)|)|←|↵|foo|(|l| |=>| |l|.count|(||)|)|↵|foo|(|l| |=>| |(|#new| |Cons|(|2|,| |l|)|)|.count|(||)|)|
//│ Parsed: {class Cons(e, tail,) {fun count = () => +(1, (tail).count(),)}; class Nil() {fun count = () => 0}; fun foo = (x,) => {+(x(new Cons([1, new Nil([]) {},]) {},), x(new Nil([]) {},),)}; foo((l,) => (l).count(),); foo((l,) => ('(' new Cons([2, l,]) {} ')').count(),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Cons, (), Tup(_: Var(e), _: Var(tail)), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), App(Var(+), Tup(_: IntLit(1), _: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, count, None, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: Lam(Tup(_: Var(l)), App(Sel(Var(l), count), Tup())))), App(Var(foo), Tup(_: Lam(Tup(_: Var(l)), App(Sel(Bra(rcd = false, New(Some((TypeName(Cons),[2, l,])), TypingUnit())), count), Tup())))))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1([e, tail,]) {fun count = () => +(1, ((this).tail).count(),)}
//│   class Nil$2([]) {fun count = () => 0}
//│   class Lambda1$2$3([]) {fun apply = (l,) => (l).count()}
//│   class Lambda1$3$4([]) {
//│     fun apply = (l,) => ('(' new Cons$1([2, l,]) {} ')').count()
//│   }
//│   fun foo$1 = (x,) => {+(x(new Cons$1([1, new Nil$2([]) {},]) {},), x(new Nil$2([]) {},),)}
//│   Code(List(foo$1({new Lambda1$2$3([]) {}},)))
//│   Code(List(foo$1({new Lambda1$3$4([]) {}},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ main$$6()
//│ fun count$Cons$1(this) =
//│   +(#1, this.tail match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)})
//│ fun foo$1(x) =
//│   +(x match {case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, new Cons$1 (#1, new Nil$2 () ) ); case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, new Cons$1 (#1, new Nil$2 () ) )}, x match {case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, new Nil$2 () ); case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, new Nil$2 () )})
//│ fun count$Nil$2(this) =
//│   #0
//│ fun main$$6() =
//│   foo$1(new Lambda1$3$4 () )
//│ fun main$$5() =
//│   foo$1(new Lambda1$2$3 () )
//│ fun apply$Lambda1$3$4(this, l) =
//│   new Cons$1 (#2, l)  match {case obj: Cons$1 => count$Cons$1(obj)}
//│ fun apply$Lambda1$2$3(this, l) =
//│   l match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ class Lambda1$3$4() {
//│ }
//│ class Nil$2() {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ class Lambda1$2$3() {
//│ }
//│ 

// :mono
class E() {
  fun derive(x) = 
    new E
  fun isEmpty() = 
    false
}
class Ep(){
  fun derive(x) = 
    new E
  fun isEmpty() = 
    true
}
class Ch(i){
  fun derive(x) = 
    if x == i then new Ep else new E
  fun isEmpty() = 
    false
}
class A(e1, e2){
  fun derive(x) = 
    new A(e1.derive(x), e2.derive(x))
  fun isEmpty() = 
    e1.isEmpty() || e2.isEmpty()
}
class C(e1, e2){
  fun derive(x) = 
    if e1.isEmpty() then new A(new C(e1.derive(x), e2), e2.derive(x)) else new C(e1.derive(x), e2)
  fun isEmpty() = 
    e1.isEmpty() && e2.isEmpty()
}
(new C(new Ch(1), new A(new Ch(2), new Ch(3)))).derive(0).isEmpty()
//│ |#class| |E|(||)| |{|→|#fun| |derive|(|x|)| |#=| |→|#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|false|←|←|↵|}|↵|#class| |Ep|(||)|{|→|#fun| |derive|(|x|)| |#=| |→|#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|true|←|←|↵|}|↵|#class| |Ch|(|i|)|{|→|#fun| |derive|(|x|)| |#=| |→|#if| |x| |==| |i| |#then| |#new| |Ep| |#else| |#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|false|←|←|↵|}|↵|#class| |A|(|e1|,| |e2|)|{|→|#fun| |derive|(|x|)| |#=| |→|#new| |A|(|e1|.derive|(|x|)|,| |e2|.derive|(|x|)|)|←|↵|#fun| |isEmpty|(||)| |#=| |→|e1|.isEmpty|(||)| |||| |e2|.isEmpty|(||)|←|←|↵|}|↵|#class| |C|(|e1|,| |e2|)|{|→|#fun| |derive|(|x|)| |#=| |→|#if| |e1|.isEmpty|(||)| |#then| |#new| |A|(|#new| |C|(|e1|.derive|(|x|)|,| |e2|)|,| |e2|.derive|(|x|)|)| |#else| |#new| |C|(|e1|.derive|(|x|)|,| |e2|)|←|↵|#fun| |isEmpty|(||)| |#=| |→|e1|.isEmpty|(||)| |&&| |e2|.isEmpty|(||)|←|←|↵|}|↵|(|#new| |C|(|#new| |Ch|(|1|)|,| |#new| |A|(|#new| |Ch|(|2|)|,| |#new| |Ch|(|3|)|)|)|)|.derive|(|0|)|.isEmpty|(||)|
//│ Parsed: {class E() {fun derive = (x,) => {new E([]) {}}; fun isEmpty = () => {false}}; class Ep() {fun derive = (x,) => {new E([]) {}}; fun isEmpty = () => {true}}; class Ch(i,) {fun derive = (x,) => {if (==(x, i,)) then new Ep([]) {} else new E([]) {}}; fun isEmpty = () => {false}}; class A(e1, e2,) {fun derive = (x,) => {new A([(e1).derive(x,), (e2).derive(x,),]) {}}; fun isEmpty = () => {||((e1).isEmpty(), (e2).isEmpty(),)}}; class C(e1, e2,) {fun derive = (x,) => {if ((e1).isEmpty()) then new A([new C([(e1).derive(x,), e2,]) {}, (e2).derive(x,),]) {} else new C([(e1).derive(x,), e2,]) {}}; fun isEmpty = () => {&&((e1).isEmpty(), (e2).isEmpty(),)}}; (('(' new C([new Ch([1,]) {}, new A([new Ch([2,]) {}, new Ch([3,]) {},]) {},]) {} ')').derive(0,)).isEmpty()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, E, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, derive, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, None, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, Ep, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, derive, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, None, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, Ch, (), Tup(_: Var(i)), (), None, None, TypingUnit(NuFunDef(None, derive, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, None, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, A, (), Tup(_: Var(e1), _: Var(e2)), (), None, None, TypingUnit(NuFunDef(None, derive, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, None, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, C, (), Tup(_: Var(e1), _: Var(e2)), (), None, None, TypingUnit(NuFunDef(None, derive, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, None, [], Lam(Tup(), Blk(...))))), App(Sel(App(Sel(Bra(rcd = false, New(Some((TypeName(C),[new Ch([1,]) {}, new A([new Ch([2,]) {}, new Ch([3,]) {},]) {},])), TypingUnit())), derive), Tup(_: IntLit(0))), isEmpty), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class E$1([]) {
//│     fun derive = (x,) => {new E$1([]) {}}
//│     fun isEmpty = () => {false}
//│   }
//│   class Ep$2([]) {
//│     fun derive = (x,) => {new E$1([]) {}}
//│     fun isEmpty = () => {true}
//│   }
//│   class Ch$3([i,]) {
//│     fun derive = (x,) => {if (==(x, (this).i,)) then new Ep$2([]) {} else new E$1([]) {}}
//│     fun isEmpty = () => {false}
//│   }
//│   class A$4([e1, e2,]) {
//│     fun derive = (x,) => {new A$4([((this).e1).derive(x,), ((this).e2).derive(x,),]) {}}
//│     fun isEmpty = () => {||(((this).e1).isEmpty(), ((this).e2).isEmpty(),)}
//│   }
//│   class C$5([e1, e2,]) {
//│     fun derive = (x,) => {if (((this).e1).isEmpty()) then new A$4([new C$5([((this).e1).derive(x,), (this).e2,]) {}, ((this).e2).derive(x,),]) {} else new C$5([((this).e1).derive(x,), (this).e2,]) {}}
//│     fun isEmpty = () => {&&(((this).e1).isEmpty(), ((this).e2).isEmpty(),)}
//│   }
//│   Code(List((('(' new C$5([new Ch$3([1,]) {}, new A$4([new Ch$3([2,]) {}, new Ch$3([3,]) {},]) {},]) {} ')').derive(0,)).isEmpty()))
//│ }
//│ 


// :mono
class List(l, hasTail)  {}
class Nil(hasTail)  {}
fun gen() = 
  if anyUnknown then new List(gen(), true) else new Nil(false)
gen()
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|hasTail|)| |{||}|↵|#fun| |gen|(||)| |#=| |→|#if| |anyUnknown| |#then| |#new| |List|(|gen|(||)|,| |true|)| |#else| |#new| |Nil|(|false|)|←|↵|gen|(||)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(hasTail,) {}; fun gen = () => {if (anyUnknown) then new List([gen(), true,]) {} else new Nil([false,]) {}}; gen()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), None, None, TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(hasTail)), (), None, None, TypingUnit()), NuFunDef(None, gen, None, [], Lam(Tup(), Blk(...))), App(Var(gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([l, hasTail,]) {}
//│   class Nil$2([hasTail,]) {}
//│   fun gen$1 = () => {if (anyUnknown) then new List$1([gen$1(), true,]) {} else new Nil$2([false,]) {}}
//│   Code(List(gen$1()))
//│ }
//│ 



// :mono
class Foo(x){
  fun bar(y) = x+y
  fun boo(z) = bar(z)+x
}
(new Foo(1)).boo(2)
//│ |#class| |Foo|(|x|)|{|→|#fun| |bar|(|y|)| |#=| |x|+|y|↵|#fun| |boo|(|z|)| |#=| |bar|(|z|)|+|x|←|↵|}|↵|(|#new| |Foo|(|1|)|)|.boo|(|2|)|
//│ Parsed: {class Foo(x,) {fun bar = (y,) => +(x, y,); fun boo = (z,) => +(bar(z,), x,)}; ('(' new Foo([1,]) {} ')').boo(2,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(_: Var(x)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(_: Var(y)), App(Var(+), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, boo, None, [], Lam(Tup(_: Var(z)), App(Var(+), Tup(_: App(Var(bar), Tup(_: Var(z))), _: Var(x))))))), App(Sel(Bra(rcd = false, New(Some((TypeName(Foo),[1,])), TypingUnit())), boo), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x,]) {
//│     fun bar = (y,) => +((this).x, y,)
//│     fun boo = (z,) => +((this).bar(z,), (this).x,)
//│   }
//│   Code(List(('(' new Foo$1([1,]) {} ')').boo(2,)))
//│ }
//│ 

// :mono
class OneInt(a){
  fun fac() = 
    if(a > 0) then (new OneInt(a-1)).fac() else 1 
}
(new OneInt(10)).fac()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |fac|(||)| |#=| |→|#if|(|a| |>| |0|)| |#then| |(|#new| |OneInt|(|a|-1|)|)|.fac|(||)| |#else| |1| |←|←|↵|}|↵|(|#new| |OneInt|(|10|)|)|.fac|(||)|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.657: 	    if(a > 0) then (new OneInt(a-1)).fac() else 1 
//│ ╙──       	                               ^^^
//│ Parsed: {class OneInt(a,) {fun fac = () => {if ('(' >(a, 0,) ')') then ('(' new OneInt([a(-1,),]) {} ')').fac() else 1}}; ('(' new OneInt([10,]) {} ')').fac()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, fac, None, [], Lam(Tup(), Blk(...))))), App(Sel(Bra(rcd = false, New(Some((TypeName(OneInt),[10,])), TypingUnit())), fac), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([a,]) {
//│     fun fac = () => {if ('(' >((this).a, 0,) ')') then ('(' new OneInt$1([(this).a(-1,),]) {} ')').fac() else 1}
//│   }
//│   Code(List(('(' new OneInt$1([10,]) {} ')').fac()))
//│ }
//│ 

:mono
trait AnyFoo {
}
class FooPlus(#a): AnyFoo {
  fun bar(b) = a + b
}
class FooMinus(#a): AnyFoo {
  fun bar(b) = a - b
}
fun f(x) = x.bar(42)
f(new FooPlus(1))
f(new FooMinus(2))
//│ |#trait| |AnyFoo| |{|↵|}|↵|#class| |FooPlus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |+| |b|←|↵|}|↵|#class| |FooMinus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |-| |b|←|↵|}|↵|#fun| |f|(|x|)| |#=| |x|.bar|(|42|)|↵|f|(|#new| |FooPlus|(|1|)|)|↵|f|(|#new| |FooMinus|(|2|)|)|
//│ Parsed: {trait AnyFoo {}; class FooPlus(#a,): AnyFoo {fun bar = (b,) => +(a, b,)}; class FooMinus(#a,): AnyFoo {fun bar = (b,) => -(a, b,)}; fun f = (x,) => (x).bar(42,); f(new FooPlus([1,]) {},); f(new FooMinus([2,]) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(trait, AnyFoo, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, FooPlus, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(_: Var(b)), App(Var(+), Tup(_: Var(a), _: Var(b))))))), NuTypeDef(class, FooMinus, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, bar, None, [], Lam(Tup(_: Var(b)), App(Var(-), Tup(_: Var(a), _: Var(b))))))), NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), bar), Tup(_: IntLit(42))))), App(Var(f), Tup(_: New(Some((TypeName(FooPlus),[1,])), TypingUnit()))), App(Var(f), Tup(_: New(Some((TypeName(FooMinus),[2,])), TypingUnit()))))
//│ Lifted:
//│ TypingUnit {
//│   trait AnyFoo$1([]) {}
//│   class FooPlus$2([#a,]) {fun bar = (b,) => +((this).a, b,)}
//│   class FooMinus$3([#a,]) {fun bar = (b,) => -((this).a, b,)}
//│   fun f$1 = (x,) => (x).bar(42,)
//│   Code(List(f$1(new FooPlus$2([1,]) {},)))
//│   Code(List(f$1(new FooMinus$3([2,]) {},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ main$$5()
//│ fun bar$FooPlus$2(this, b) =
//│   +(this.a, b)
//│ fun f$1(x) =
//│   x match {case obj: FooMinus$3 => bar$FooMinus$3(obj, #42); case obj: FooPlus$2 => bar$FooPlus$2(obj, #42)}
//│ fun main$$5() =
//│   f$1(new FooMinus$3 (#2) )
//│ fun bar$FooMinus$3(this, b) =
//│   -(this.a, b)
//│ fun main$$4() =
//│   f$1(new FooPlus$2 (#1) )
//│ trait AnyFoo$1() {
//│ }
//│ class FooPlus$2(#a) {
//│ }
//│ class FooMinus$3(#a) {
//│ }
//│ 

:mono
fun f(x) = 
  if x > any then 0
  else g(x-1)
fun g(x) = 
  if x > any then g(x-1)
  else f(x-2)
g(1)
//│ |#fun| |f|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |0|↵|#else| |g|(|x|-1|)|←|↵|#fun| |g|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |g|(|x|-1|)|↵|#else| |f|(|x|-2|)|←|↵|g|(|1|)|
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.727: 	  else g(x-1)
//│ ╙──       	         ^^^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.729: 	  if x > any then g(x-1)
//│ ╙──       	                    ^^^
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.730: 	  else f(x-2)
//│ ╙──       	         ^^^
//│ Parsed: {fun f = (x,) => {if (>(x, any,)) then 0 else g(x(-1,),)}; fun g = (x,) => {if (>(x, any,)) then g(x(-1,),) else f(x(-2,),)}; g(1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, None, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, g, None, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(g), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x,) => {if (>(x, any,)) then 0 else g$2(x(-1,),)}
//│   fun g$2 = (x,) => {if (>(x, any,)) then g$2(x(-1,),) else f$1(x(-2,),)}
//│   Code(List(g$2(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun f$1(x) =
//│   if >(x, any) then #0 else g$2(x(#-1))
//│ fun g$2(x) =
//│   if >(x, any) then g$2(x(#-1)) else f$1(x(#-2))
//│ fun main$$2() =
//│   g$2(#1)
//│ 

:mono
class OneInt(a){
  fun get = a
}
class OneBool(b){
  fun get = b
}
(if b then new OneInt(1) else new OneBool(true)).get()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |get| |#=| |a|←|↵|}|↵|#class| |OneBool|(|b|)|{|→|#fun| |get| |#=| |b|←|↵|}|↵|(|#if| |b| |#then| |#new| |OneInt|(|1|)| |#else| |#new| |OneBool|(|true|)|)|.get|(||)|
//│ Parsed: {class OneInt(a,) {fun get = a}; class OneBool(b,) {fun get = b}; ('(' if (b) then new OneInt([1,]) {} else new OneBool([true,]) {} ')').get()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Var(a)))), NuTypeDef(class, OneBool, (), Tup(_: Var(b)), (), None, None, TypingUnit(NuFunDef(None, get, None, [], Var(b)))), App(Sel(Bra(rcd = false, If(IfThen(Var(b), New(Some((TypeName(OneInt),[1,])), TypingUnit()), Some(New(Some((TypeName(OneBool),[true,])), TypingUnit())))), get), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([a,]) {fun get = () => (this).a}
//│   class OneBool$2([b,]) {fun get = () => (this).b}
//│   Code(List(('(' if (b) then new OneInt$1([1,]) {} else new OneBool$2([true,]) {} ')').get()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun get$OneInt$1(this) =
//│   this.a
//│ fun get$OneBool$2(this) =
//│   this.b
//│ fun main$$2() =
//│   if b then new OneInt$1 (#1)  else new OneBool$2 (true)  match {case obj: OneInt$1 => get$OneInt$1(obj); case obj: OneBool$2 => get$OneBool$2(obj)}
//│ class OneInt$1(a) {
//│ }
//│ class OneBool$2(b) {
//│ }
//│ 

// :mono
class Bar(x: int) {
  fun FooMinus(y: int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
Car().da(Bar(1337))
bar.car
//│ |#class| |Bar|(|x|#:| |int|)| |{|→|#fun| |FooMinus|(|y|#:| |int|)| |#=| |x| |+| |y|↵|#fun| |car| |#=| |foo|(|2|)|←|↵|}|↵|#class| |Car| |{|→|#fun| |da|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|←|↵|}|↵|#fun| |baz|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|↵|#let| |bar| |#=| |Bar|(|42|)|↵|baz|(|bar|)|↵|Car|(||)|.da|(|Bar|(|1337|)|)|↵|bar|.car|
//│ Parsed: {class Bar(x: int,) {fun FooMinus = (y: int,) => +(x, y,); fun car = foo(2,)}; class Car {fun da = (b: Bar,) => (b).foo(2,)}; fun baz = (b: Bar,) => (b).foo(2,); let bar = Bar(42,); baz(bar,); (Car()).da(Bar(1337,),); (bar).car}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(x: Var(int)), (), None, None, TypingUnit(NuFunDef(None, FooMinus, None, [], Lam(Tup(y: Var(int)), App(Var(+), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, car, None, [], App(Var(foo), Tup(_: IntLit(2)))))), NuTypeDef(class, Car, (), Tup(), (), None, None, TypingUnit(NuFunDef(None, da, None, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))))), NuFunDef(None, baz, None, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))), NuFunDef(Some(false), bar, None, [], App(Var(Bar), Tup(_: IntLit(42)))), App(Var(baz), Tup(_: Var(bar))), App(Sel(App(Var(Car), Tup()), da), Tup(_: App(Var(Bar), Tup(_: IntLit(1337))))), Sel(Var(bar), car))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1([x: int,]) {
//│     fun FooMinus = (y: int,) => +((this).x, y,)
//│     fun car = () => foo(2,)
//│   }
//│   class Car$2([]) {fun da = (b: Bar$1,) => (b).foo(2,)}
//│   fun baz$2 = (b: Bar$1,) => (b).foo(2,)
//│   let bar$1 = () => Bar$1(42,)
//│   Code(List(baz$2(bar,)))
//│   Code(List((Car$2()).da(Bar$1(1337,),)))
//│   Code(List((bar).car))
//│ }
//│ 

:mono
:d
class Sup(a){
  fun foo = a
}
class Sub(b): Sup(b+b){
}
class Sub2(c): Sub(c+c){
  fun foo = a+c
}
(new Sub(10)).foo()
(new Sub2(c)).foo()
//│ |#class| |Sup|(|a|)|{|→|#fun| |foo| |#=| |a|←|↵|}|↵|#class| |Sub|(|b|)|#:| |Sup|(|b|+|b|)|{|↵|}|↵|#class| |Sub2|(|c|)|#:| |Sub|(|c|+|c|)|{|→|#fun| |foo| |#=| |a|+|c|←|↵|}|↵|(|#new| |Sub|(|10|)|)|.foo|(||)|↵|(|#new| |Sub2|(|c|)|)|.foo|(||)|
//│ Parsed: {class Sup(a,) {fun foo = a}; class Sub(b,): Sup[+[b, b]] {}; class Sub2(c,): Sub[+[c, c]] {fun foo = +(a, c,)}; ('(' new Sub([10,]) {} ')').foo(); ('(' new Sub2([c,]) {} ')').foo()}
//│ 
//│ 	at: scala.None$.get(Option.scala:627)
//│ 	at: scala.None$.get(Option.scala:626)
//│ 	at: mlscript.compiler.mono.Monomorph.getFieldVal$$anonfun$1(Monomorph.scala:303)
//│ 	at: mlscript.compiler.debug.RainbowDebug.trace(RainbowDebug.scala:21)
//│ 	at: mlscript.compiler.mono.Monomorph.getFieldVal(Monomorph.scala:309)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.$anonfun$5(Specializer.scala:77)
//│ 	at: scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:100)
//│ 	at: scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)
//│ 	at: scala.collection.immutable.Set$Set1.map(Set.scala:156)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.evaluate(Specializer.scala:80)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.evaluate(Specializer.scala:43)
//│ 	at: mlscript.compiler.mono.Monomorph.updateFunc(Monomorph.scala:203)
//│ 	at: mlscript.compiler.mono.Monomorph.updateFunction(Monomorph.scala:139)
//│ 	at: mlscript.compiler.mono.Monomorph.defunctionalize(Monomorph.scala:114)
//│ 	at: mlscript.compiler.DiffTestCompiler.postProcess(Test.scala:35)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:432)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1055)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ [mono] ┌────┬──────────────────────────┐
//│ │ 1 │ main$$3()                │
//│ │ 2 │ main$$4()                │
//│ │ 3 │ fun main$$4() =          │
//│ │ 4 │   new Sub2$3 (c) .foo()  │
//│ │ 5 │ fun main$$3() =          │
//│ │ 6 │   new Sub$2 (#10) .foo() │
//│ │ 7 │ class Sub2$3(c) {        │
//│ │ 8 │ }                        │
//│ │ 9 │ class Sup$1(a) {         │
//│ │ 10 │ }                        │
//│ │ 11 │ class Sub$2(b) {         │
//│ │ 12 │ }                        │
//│ └────┴──────────────────────────┘
//│ [mono] evaluating main$$4, rests: HashSet(main$$3)
//│ [mono] ========== updating main$$4 ==========
//│ [mono] main$$4: () -> *49*=[*49*=...] @{}
//│ [mono] ┌ SPEC NEW Sub2$3(List([?74?]))
//│ [mono] │ par objs: List()
//│ [mono] └ SPEC NEW Sub2$3@{c: [?74?]}
//│ [mono] ┌ SPEC SEL Sub2$3@{c: [?74?]} :: foo
//│ [mono] │ defined
//│ [mono] └ SPEC SEL [foo$Sub2$3() given {this: [Sub2$3@{c: [?74?]}]}]
//│ [mono] ┌ SPEC CALL foo$Sub2$3 with ([Sub2$3@{c: [?74?]}])
//│ [mono] │ comparing ([]) with (Plain([Sub2$3@{c: [?74?]}]))
//│ [mono] │ first time encounter foo$Sub2$3
//│ [mono] │ evaluating foo$Sub2$3, rests: HashSet(main$$3)
//│ [mono] │ ========== updating foo$Sub2$3 ==========
//│ [mono] │ foo$Sub2$3: ([Sub2$3@{c: [?74?]}]) -> *50*=[*50*=...] @{main$$4}
//│ [mono] │ comparing [*50*=...] with [?77?]
//│ [mono] │ foo$Sub2$3: ([Sub2$3@{c: [?74?]}]) -> *50*=[?77?] @{main$$4}
//│ [mono] └ SPEC CALL [*50*=[?77?]]
//│ [mono] comparing [*49*=...] with [*50*=[?77?]]
//│ [mono] main$$4: () -> *49*=[*50*=[?77?]] @{}
//│ [mono] evaluating main$$3, rests: HashSet()
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *48*=[*48*=...] @{}
//│ [mono] ┌ SPEC NEW Sub$2(List([10]))
//│ [mono] │ par objs: List()
//│ [mono] └ SPEC NEW Sub$2@{b: [10]}
//│ [mono] ┌ SPEC SEL Sub$2@{b: [10]} :: foo
//│ [mono] │ else
//│ 

:mono
class Foo(f){
  fun foo = f(1)
}
class F1(): Foo(x => x+1){}
class F2(): Foo(x => x+2){}
(new F1()).foo()
(new F2()).foo()
//│ |#class| |Foo|(|f|)|{|→|#fun| |foo| |#=| |f|(|1|)|←|↵|}|↵|#class| |F1|(||)|#:| |Foo|(|x| |=>| |x|+|1|)|{||}|↵|#class| |F2|(||)|#:| |Foo|(|x| |=>| |x|+|2|)|{||}|↵|(|#new| |F1|(||)|)|.foo|(||)|↵|(|#new| |F2|(||)|)|.foo|(||)|
//│ Parsed: {class Foo(f,) {fun foo = f(1,)}; class F1(): Foo[x -> +[x, 1]] {}; class F2(): Foo[x -> +[x, 2]] {}; ('(' new F1([]) {} ')').foo(); ('(' new F2([]) {} ')').foo()}
//│ 
//│ 	at: scala.None$.get(Option.scala:627)
//│ 	at: scala.None$.get(Option.scala:626)
//│ 	at: mlscript.compiler.mono.Monomorph.getFieldVal$$anonfun$1(Monomorph.scala:303)
//│ 	at: mlscript.compiler.debug.RainbowDebug.trace(RainbowDebug.scala:21)
//│ 	at: mlscript.compiler.mono.Monomorph.getFieldVal(Monomorph.scala:309)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.$anonfun$5(Specializer.scala:77)
//│ 	at: scala.collection.StrictOptimizedIterableOps.map(StrictOptimizedIterableOps.scala:100)
//│ 	at: scala.collection.StrictOptimizedIterableOps.map$(StrictOptimizedIterableOps.scala:87)
//│ 	at: scala.collection.immutable.Set$Set1.map(Set.scala:156)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.evaluate(Specializer.scala:80)
//│ 	at: mlscript.compiler.mono.specializer.Specializer.evaluate(Specializer.scala:43)
//│ 	at: mlscript.compiler.mono.Monomorph.updateFunc(Monomorph.scala:203)
//│ 	at: mlscript.compiler.mono.Monomorph.updateFunction(Monomorph.scala:139)
//│ 	at: mlscript.compiler.mono.Monomorph.defunctionalize(Monomorph.scala:114)
//│ 	at: mlscript.compiler.DiffTestCompiler.postProcess(Test.scala:35)
//│ 	at: mlscript.DiffTests.rec$1(DiffTests.scala:432)
//│ 	at: mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1055)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ 	at: org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ 	at: org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ [mono] ┌────┬──────────────────────┐
//│ │ 1 │ main$$3()            │
//│ │ 2 │ main$$4()            │
//│ │ 3 │ fun main$$4() =      │
//│ │ 4 │   new F2$3 () .foo() │
//│ │ 5 │ fun main$$3() =      │
//│ │ 6 │   new F1$2 () .foo() │
//│ │ 7 │ class F1$2() {       │
//│ │ 8 │ }                    │
//│ │ 9 │ class F2$3() {       │
//│ │ 10 │ }                    │
//│ │ 11 │ class Foo$1(f) {     │
//│ │ 12 │ }                    │
//│ └────┴──────────────────────┘
//│ [mono] evaluating main$$4, rests: HashSet(main$$3)
//│ [mono] ========== updating main$$4 ==========
//│ [mono] main$$4: () -> *52*=[*52*=...] @{}
//│ [mono] ┌ SPEC NEW F2$3(List())
//│ [mono] │ par objs: List()
//│ [mono] └ SPEC NEW F2$3@{}
//│ [mono] ┌ SPEC SEL F2$3@{} :: foo
//│ [mono] │ else
//│ 
