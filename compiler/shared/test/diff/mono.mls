
:NewDefs

:mono
fun f(x: Int) = if x then 42 else 1337
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((S(x), Fld(_, Var("Int"))) :: Nil), If(IfThen(Var("x"), IntLit(42), Some(IntLit(1337)))))))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x: Int,) => if (x) then 42 else 1337
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun f$1(x) =
//│   if x then #42 else #1337
//│ fun f: (x: Int) -> (1337 | 42)

:mono
fun foo() = 42
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup(Nil), IntLit(42)))))
//│ Lifted:
//│ TypingUnit {fun foo$1 = () => 42}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun foo$1() =
//│   #42
//│ fun foo: () -> 42

:mono
fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("b"))) :: Nil), If(IfThen(Var("b"), Var("x"), Some(IntLit(1337)))))), NuFunDef(Some(false), a, N, Nil, L(App(Var("foo"), Tup((N, Fld(_, IntLit(42))) :: (N, Fld(_, Var("true"))) :: Nil)))), NuFunDef(Some(false), b, N, Nil, L(App(Var("foo"), Tup((N, Fld(_, IntLit(23))) :: (N, Fld(_, Var("false"))) :: Nil)))))
//│ Lifted:
//│ TypingUnit {
//│   fun foo$3 = (x, #b,) => if (b) then x else 1337
//│   let a$1 = () => foo$3(42, true,)
//│   let b$2 = () => foo$3(23, false,)
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun b$2() =
//│   foo$3(#23, false)
//│ fun foo$3(x, #b) =
//│   if b then x else #1337
//│ fun a$1() =
//│   foo$3(#42, true)
//│ fun foo: forall 'a. ('a, Object) -> (1337 | 'a)
//│ let a: 1337 | 42
//│ let b: 1337 | 23
//│ a
//│   = 42
//│ b
//│   = 1337

:mono
let x = 42 + 1337
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, N, Nil, L(App(Var("+"), Tup((N, Fld(_, IntLit(42))) :: (N, Fld(_, IntLit(1337))) :: Nil)))))
//│ Lifted:
//│ TypingUnit {let x$1 = () => +(42, 1337,)}
//│ Mono:
//│ 
//│ Defunc result: 
//│ fun x$1() =
//│   +(#42, #1337)
//│ let x: Int
//│ x
//│   = 1379

//:mono
//:e // FIXME: Mutable Parameters
//class Bar(#x)
//fun foo(#b) = b
//let a = foo(new Bar(1))
//let b = foo(new Bar(2))

//:mono
//:w // FIXME: Mutable Parameters
//class OneInt(#a){
//  fun inc() = a+1
//}
//(new OneInt(1)).inc()

//:mono
//:e // FIXME: Mutable Parameters
//class OneInt(#a){
//  fun add(x) = 
//    new OneInt(a+x.a)
//}
//(new OneInt(1)).add(new OneInt(2))

:mono
if true then 1 else 0
if 1+1 > 1 then 1 - 1 else 1*1
//│ Parsed:
//│ TypingUnit(If(IfThen(Var("true"), IntLit(1), Some(IntLit(0))), If(IfThen(App(Var(">"), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: (N, Fld(_, IntLit(1))) :: Nil)), App(Var("-"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, IntLit(1))) :: Nil)), Some(App(Var("*"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, IntLit(1))) :: Nil)))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List(if (true) then 1 else 0))
//│   Code(List(if (>(+(1, 1,), 1,)) then -(1, 1,) else *(1, 1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$0()
//│ main$$1()
//│ fun main$$0() =
//│   if true then #1 else #0
//│ fun main$$1() =
//│   if >(+(#1, #1), #1) then -(#1, #1) else *(#1, #1)
//│ Int
//│ res
//│     = 1
//│ res
//│     = 0

:mono
if(b) then 1 else 2
//│ Parsed:
//│ TypingUnit(If(IfThen(Bra(rcd = false, Var("b")), IntLit(1), Some(IntLit(2))))
//│ Lifted:
//│ TypingUnit {Code(List(if ('(' b ')') then 1 else 2))}
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$0()
//│ fun main$$0() =
//│   if b then #1 else #2
//│ 1 | 2
//│ res
//│     = 2

:mono
((f, g) => f(g))(f => f, true)
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Lam(Tup((N, Fld(_, Var("f"))) :: (N, Fld(_, Var("g"))) :: Nil), App(Var("f"), Tup((N, Fld(_, Var("g"))) :: Nil)))), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("f"))) :: Nil), Var("f")))) :: (N, Fld(_, Var("true"))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda2$1$1([]) {fun apply = (f, g,) => f(g,)}
//│   class Lambda1$2$2([]) {fun apply = (f,) => f}
//│   Code(List('(' {new Lambda2$1$1([]) {}} ')'({new Lambda1$2$2([]) {}}, true,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun apply$Lambda2$1$1(this, f, g) =
//│   f match {case obj: Lambda1$2$2 => apply$Lambda1$2$2(obj, g)}
//│ fun main$$2() =
//│   new Lambda2$1$1 ()  match {case obj: Lambda2$1$1 => apply$Lambda2$1$1(obj, new Lambda1$2$2 () , true)}
//│ fun apply$Lambda1$2$2(this, f) =
//│   f
//│ class Lambda2$1$1() {
//│ }
//│ class Lambda1$2$2() {
//│ }
//│ true
//│ res
//│     = true


:mono
(b => if b then true else false) (true)
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Lam(Tup((N, Fld(_, Var("b"))) :: Nil), If(IfThen(Var("b"), Var("true"), Some(Var("false"))))), Tup((N, Fld(_, Var("true"))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$1$1([]) {fun apply = (b,) => if (b) then true else false}
//│   Code(List('(' {new Lambda1$1$1([]) {}} ')'(true,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun apply$Lambda1$1$1(this, b) =
//│   if b then true else false
//│ fun main$$1() =
//│   new Lambda1$1$1 ()  match {case obj: Lambda1$1$1 => apply$Lambda1$1$1(obj, true)}
//│ class Lambda1$1$1() {
//│ }
//│ Bool
//│ res
//│     = true

:mono
fun f(x) =
  if(x > 0) then x+1 else x - 1
f(2)+3
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(Bra(rcd = false, App(Var(">"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(0))) :: Nil))), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)), Some(App(Var("-"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)))))))), App(Var("+"), Tup((N, Fld(_, App(Var("f"), Tup((N, Fld(_, IntLit(2))) :: Nil)))) :: (N, Fld(_, IntLit(3))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x,) => {if ('(' >(x, 0,) ')') then +(x, 1,) else -(x, 1,)}
//│   Code(List(+(f$1(2,), 3,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun f$1(x) =
//│   if >(x, #0) then +(x, #1) else -(x, #1)
//│ fun main$$1() =
//│   +(f$1(#2), #3)
//│ fun f: Int -> Int
//│ Int
//│ res
//│     = 6

:mono
fun fac(n) = 
  if (n > 1) then fac(n - 1) * n else 1
fac(2)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, fac, N, Nil, L(Lam(Tup((N, Fld(_, Var("n"))) :: Nil), Blk(If(IfThen(Bra(rcd = false, App(Var(">"), Tup((N, Fld(_, Var("n"))) :: (N, Fld(_, IntLit(1))) :: Nil))), App(Var("*"), Tup((N, Fld(_, App(Var("fac"), Tup((N, Fld(_, App(Var("-"), Tup((N, Fld(_, Var("n"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)))) :: (N, Fld(_, Var("n"))) :: Nil)), Some(IntLit(1))))))), App(Var("fac"), Tup((N, Fld(_, IntLit(2))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   fun fac$1 = (n,) => {if ('(' >(n, 1,) ')') then *(fac$1(-(n, 1,),), n,) else 1}
//│   Code(List(fac$1(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun fac$1(n) =
//│   if >(n, #1) then *(fac$1(-(n, #1)), n) else #1
//│ fun main$$1() =
//│   fac$1(#2)
//│ fun fac: Int -> Int
//│ Int
//│ res
//│     = 2

:mono
class List(val l: List | Nil | undefined, val hasTail: Bool)  {}
class Nil(val l: List | Nil | undefined, val hasTail: Bool)  {}
fun count(lst) =
  if lst.hasTail then
    let l = lst.l
    if l is undefined then 1 else count(l)+1
  else 0
count(new List(new List(new Nil(undefined, false), true), true))
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("List"), Ls(), S(Tup((S(l), Fld(_, App(Var("|"), Tup((N, Fld(_, App(Var("|"), Tup((N, Fld(_, Var("List"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: (N, Fld(_, UnitLit(true))) :: Nil)))) :: (S(hasTail), Fld(_, Var("Bool"))) :: Nil)), N, N, Ls(), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup((S(l), Fld(_, App(Var("|"), Tup((N, Fld(_, App(Var("|"), Tup((N, Fld(_, Var("List"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: (N, Fld(_, UnitLit(true))) :: Nil)))) :: (S(hasTail), Fld(_, Var("Bool"))) :: Nil)), N, N, Ls(), N, N, TypingUnit()), NuFunDef(None, count, N, Nil, L(Lam(Tup((N, Fld(_, Var("lst"))) :: Nil), Blk(If(IfThen(Sel(Var("lst"), hasTail), Blk(NuFunDef(Some(false), l, N, Nil, L(Sel(Var("lst"), l))), If(IfThen(App(Var("is"), Tup((N, Fld(_, Var("l"))) :: (N, Fld(_, UnitLit(true))) :: Nil)), IntLit(1), Some(App(Var("+"), Tup((N, Fld(_, App(Var("count"), Tup((N, Fld(_, Var("l"))) :: Nil)))) :: (N, Fld(_, IntLit(1))) :: Nil))))), Some(IntLit(0))))))), App(Var("count"), Tup((N, Fld(_, App(NuNew(Var("List")), Tup((N, Fld(_, App(NuNew(Var("List")), Tup((N, Fld(_, App(NuNew(Var("Nil")), Tup((N, Fld(_, UnitLit(true))) :: (N, Fld(_, Var("false"))) :: Nil)))) :: (N, Fld(_, Var("true"))) :: Nil)))) :: (N, Fld(_, Var("true"))) :: Nil)))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([val l: |(|(List, Nil,), undefined,), val hasTail: Bool,]) {}
//│   class Nil$2([val l: |(|(List, Nil,), undefined,), val hasTail: Bool,]) {}
//│   let l$2 = (lst,) => (lst).l
//│   fun count$1 = (lst,) => {if ((lst).hasTail) then {if (is(l, undefined,)) then 1 else +(count$1(l,), 1,)} else 0}
//│   Code(List(count$1(new List$1([new List$1([new Nil$2([undefined, false,]) {}, true,]) {}, true,]) {},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ fun l$2(lst) =
//│   lst.l
//│ fun count$1(lst) =
//│   if lst.hasTail then if is(l, #()) then #1 else +(count$1(l), #1) else #0
//│ fun main$$4() =
//│   count$1(new List$1 (new List$1 (new Nil$2 (#(), false) , true) , true) )
//│ class Nil$2(l, hasTail) {
//│ }
//│ class List$1(l, hasTail) {
//│ }
//│ class List(l: List | Nil | (), hasTail: Bool)
//│ class Nil(l: List | Nil | (), hasTail: Bool)
//│ fun count: forall 'a. 'a -> Int
//│ Int
//│ where
//│   'a <: {hasTail: Object, l: Object & 'a & ~() | ()}
//│ res
//│     = 2

//:mono
//class Cons(e, tail){
//  fun gen() = new Cons(e, tail.gen())
//}
//class Nil(){
//  fun gen() = new Cons(0, this)
//}
//fun generate(x) = 
//  if x > 0 then new Cons(x, generate(x+1)) else new Nil()
//generate(10).gen()

:mono
class List(e: Int, tail: List | Nil) {
  fun map: (Int -> Int) -> List 
  fun map(f)= new List(f(e), tail.map(f))
  fun count(): Int
  fun count() = 1 + tail.count()
}
class Nil() {
  fun map(f) = this
  fun count() = 0
}
fun add2(x) = x+2
(new List(1, new List(2, new Nil()))).map(x => x+1).map(x => add2(x))
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("List"), Ls(), S(Tup((S(e), Fld(_, Var("Int"))) :: (S(tail), Fld(_, App(Var("|"), Tup((N, Fld(_, Var("List"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, map, N, Nil, R(PolyType(Ls(), Function(Tuple(N -> Fld(N, Function(Tuple(N -> Fld(N, TypeName("Int"))), TypeName("Int")))), TypeName("List"))))), NuFunDef(None, map, N, Nil, L(Lam(Tup((N, Fld(_, Var("f"))) :: Nil), App(NuNew(Var("List")), Tup((N, Fld(_, App(Var("f"), Tup((N, Fld(_, Var("e"))) :: Nil)))) :: (N, Fld(_, App(Sel(Var("tail"), map), Tup((N, Fld(_, Var("f"))) :: Nil)))) :: Nil))))), NuFunDef(None, count, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Int"))))), NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), App(Var("+"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(Sel(Var("tail"), count), Tup(Nil)))) :: Nil))))))), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, map, N, Nil, L(Lam(Tup((N, Fld(_, Var("f"))) :: Nil), Var("this")))), NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), IntLit(0)))))), NuFunDef(None, add2, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(2))) :: Nil))))), App(Sel(App(Sel(Bra(rcd = false, App(NuNew(Var("List")), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(NuNew(Var("List")), Tup((N, Fld(_, IntLit(2))) :: (N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil))), map), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil))))) :: Nil)), map), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("add2"), Tup((N, Fld(_, Var("x"))) :: Nil))))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([e: Int, tail: |(List, Nil,),]) {
//│     fun map = (Int -> Int) -> List$1
//│     fun map = (f,) => new List$1([f((this).e,), ((this).tail).map(f,),]) {}
//│     fun count = () -> Int
//│     fun count = () => +(1, ((this).tail).count(),)
//│   }
//│   class Nil$2([]) {fun map = (f,) => this; fun count = () => 0}
//│   class Lambda1$2$3([]) {fun apply = (x,) => +(x, 1,)}
//│   class Lambda1$3$4([]) {fun apply = (x,) => add2$1(x,)}
//│   fun add2$1 = (x,) => +(x, 2,)
//│   Code(List((('(' new List$1([1, new List$1([2, new Nil$2([]) {},]) {},]) {} ')').map({new Lambda1$2$3([]) {}},)).map({new Lambda1$3$4([]) {}},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ fun map$List$1(this, f) =
//│   new List$1 (f match {case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, this.e); case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, this.e)}, this.tail match {case obj: List$1 => map$List$1(obj, f); case obj: Nil$2 => map$Nil$2(obj, f)}) 
//│ fun add2$1(x) =
//│   +(x, #2)
//│ fun main$$5() =
//│   new List$1 (#1, new List$1 (#2, new Nil$2 () ) )  match {case obj: List$1 => map$List$1(obj, new Lambda1$2$3 () )} match {case obj: List$1 => map$List$1(obj, new Lambda1$3$4 () )}
//│ fun apply$Lambda1$3$4(this, x) =
//│   add2$1(x)
//│ fun map$Nil$2(this, f) =
//│   this
//│ fun apply$Lambda1$2$3(this, x) =
//│   +(x, #1)
//│ class Lambda1$3$4() {
//│ }
//│ class Nil$2() {
//│ }
//│ class List$1(e, tail) {
//│ }
//│ class Lambda1$2$3() {
//│ }
//│ class List(e: Int, tail: List | Nil) {
//│   fun count: () -> Int
//│   fun map: (Int -> Int) -> List
//│ }
//│ class Nil() {
//│   fun count: () -> 0
//│   fun map: anything -> Nil
//│ }
//│ fun add2: Int -> Int
//│ List
//│ res
//│     = List {}

:mono
:AllowRuntimeErrors
class List(e: Int, tail: List | Nil) {
  fun count(): Int
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = x.count()
fun generate(x) = 
  if x > 0 then new List(x, generate(x+1)) else new Nil()
foo(new List(1, new List(2, new Nil())))
foo(generate(1))
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("List"), Ls(), S(Tup((S(e), Fld(_, Var("Int"))) :: (S(tail), Fld(_, App(Var("|"), Tup((N, Fld(_, Var("List"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Int"))))), NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), App(Var("+"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(Sel(Var("tail"), count), Tup(Nil)))) :: Nil))))))), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), IntLit(0)))))), NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Sel(Var("x"), count), Tup(Nil))))), NuFunDef(None, generate, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(App(Var(">"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(0))) :: Nil)), App(NuNew(Var("List")), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, App(Var("generate"), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)))) :: Nil)), Some(App(NuNew(Var("Nil")), Tup(Nil)))))))), App(Var("foo"), Tup((N, Fld(_, App(NuNew(Var("List")), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(NuNew(Var("List")), Tup((N, Fld(_, IntLit(2))) :: (N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil)))) :: Nil)), App(Var("foo"), Tup((N, Fld(_, App(Var("generate"), Tup((N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([e: Int, tail: |(List, Nil,),]) {
//│     fun count = () -> Int
//│     fun count = () => +(1, ((this).tail).count(),)
//│   }
//│   class Nil$2([]) {fun count = () => 0}
//│   fun foo$1 = (x,) => (x).count()
//│   fun generate$2 = (x,) => {if (>(x, 0,)) then new List$1([x, generate$2(+(x, 1,),),]) {} else new Nil$2([]) {}}
//│   Code(List(foo$1(new List$1([1, new List$1([2, new Nil$2([]) {},]) {},]) {},)))
//│   Code(List(foo$1(generate$2(1,),)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ main$$5()
//│ fun foo$1(x) =
//│   x match {case obj: Nil$2 => count$Nil$2(obj); case obj: List$1 => count$List$1(obj)}
//│ fun count$Nil$2(this) =
//│   #0
//│ fun count$List$1(this) =
//│   +(#1, this.tail match {case obj: List$1 => count$List$1(obj); case obj: Nil$2 => count$Nil$2(obj)})
//│ fun generate$2(x) =
//│   if >(x, #0) then new List$1 (x, generate$2(+(x, #1)))  else new Nil$2 () 
//│ fun main$$5() =
//│   foo$1(generate$2(#1))
//│ fun main$$4() =
//│   foo$1(new List$1 (#1, new List$1 (#2, new Nil$2 () ) ) )
//│ class Nil$2() {
//│ }
//│ class List$1(e, tail) {
//│ }
//│ class List(e: Int, tail: List | Nil) {
//│   fun count: () -> Int
//│ }
//│ class Nil() {
//│   fun count: () -> 0
//│ }
//│ fun foo: forall 'a. {count: () -> 'a} -> 'a
//│ fun generate: Int -> (List | Nil)
//│ Int
//│ res
//│     = 2
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:mono
fun foo(x) = 
  (f => f(x))(z => z+1)
foo(2)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(App(Bra(rcd = false, Lam(Tup((N, Fld(_, Var("f"))) :: Nil), App(Var("f"), Tup((N, Fld(_, Var("x"))) :: Nil)))), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("z"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("z"))) :: (N, Fld(_, IntLit(1))) :: Nil))))) :: Nil)))))), App(Var("foo"), Tup((N, Fld(_, IntLit(2))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([x,]) {fun apply = (f,) => f((this).x,)}
//│   class Lambda1$3$2([]) {fun apply = (z,) => +(z, 1,)}
//│   fun foo$1 = (x,) => {'(' {new Lambda1$2$1([x,]) {}} ')'({new Lambda1$3$2([]) {}},)}
//│   Code(List(foo$1(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$3()
//│ fun apply$Lambda1$2$1(this, f) =
//│   f match {case obj: Lambda1$3$2 => apply$Lambda1$3$2(obj, this.x)}
//│ fun foo$1(x) =
//│   new Lambda1$2$1 (x)  match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, new Lambda1$3$2 () )}
//│ fun main$$3() =
//│   foo$1(#2)
//│ fun apply$Lambda1$3$2(this, z) =
//│   +(z, #1)
//│ class Lambda1$2$1(x) {
//│ }
//│ class Lambda1$3$2() {
//│ }
//│ fun foo: Int -> Int
//│ Int
//│ res
//│     = 3

:mono
fun f(x) =
  (y => f(x+y))(x+1)
f(1)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(App(Bra(rcd = false, Lam(Tup((N, Fld(_, Var("y"))) :: Nil), App(Var("f"), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("y"))) :: Nil)))) :: Nil)))), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)))))), App(Var("f"), Tup((N, Fld(_, IntLit(1))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([x,]) {fun apply = (y,) => f$1(+((this).x, y,),)}
//│   fun f$1 = (x,) => {'(' {new Lambda1$2$1([x,]) {}} ')'(+(x, 1,),)}
//│   Code(List(f$1(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun apply$Lambda1$2$1(this, y) =
//│   f$1(+(this.x, y))
//│ fun f$1(x) =
//│   new Lambda1$2$1 (x)  match {case obj: Lambda1$2$1 => apply$Lambda1$2$1(obj, +(x, #1))}
//│ fun main$$2() =
//│   f$1(#1)
//│ class Lambda1$2$1(x) {
//│ }
//│ fun f: Int -> nothing
//│ nothing
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded


:mono
fun f(x) = f(x)
f(0)
f(1)
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("f"), Tup((N, Fld(_, Var("x"))) :: Nil))))), App(Var("f"), Tup((N, Fld(_, IntLit(0))) :: Nil)), App(Var("f"), Tup((N, Fld(_, IntLit(1))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   fun f$1 = (x,) => f$1(x,)
//│   Code(List(f$1(0,)))
//│   Code(List(f$1(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ main$$2()
//│ fun f$1(x) =
//│   f$1(x)
//│ fun main$$2() =
//│   f$1(#1)
//│ fun main$$1() =
//│   f$1(#0)
//│ fun f: anything -> nothing
//│ nothing
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:mono
class Cons(e: 'A, tail: Cons | Nil) {
  fun count(): Int
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
class Lambda(){
  fun apply(l) = 
    l.count()
}
class Lambda2(a: Int){
  fun apply(l) = 
    (new Cons(a, l)).count()
}
fun foo(x) = 
  x.apply(new Cons(1, new Nil())) + x.apply(new Nil())
foo(new Lambda())
foo(new Lambda2(2))
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Cons"), Ls(), S(Tup((S(e), Fld(_, Var("'A"))) :: (S(tail), Fld(_, App(Var("|"), Tup((N, Fld(_, Var("Cons"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Int"))))), NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), App(Var("+"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(Sel(Var("tail"), count), Tup(Nil)))) :: Nil))))))), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), IntLit(0)))))), NuTypeDef(Cls, TypeName("Lambda"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, apply, N, Nil, L(Lam(Tup((N, Fld(_, Var("l"))) :: Nil), Blk(App(Sel(Var("l"), count), Tup(Nil)))))))), NuTypeDef(Cls, TypeName("Lambda2"), Ls(), S(Tup((S(a), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, apply, N, Nil, L(Lam(Tup((N, Fld(_, Var("l"))) :: Nil), Blk(App(Sel(Bra(rcd = false, App(NuNew(Var("Cons")), Tup((N, Fld(_, Var("a"))) :: (N, Fld(_, Var("l"))) :: Nil))), count), Tup(Nil)))))))), NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(App(Var("+"), Tup((N, Fld(_, App(Sel(Var("x"), apply), Tup((N, Fld(_, App(NuNew(Var("Cons")), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil)))) :: (N, Fld(_, App(Sel(Var("x"), apply), Tup((N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil)))))), App(Var("foo"), Tup((N, Fld(_, App(NuNew(Var("Lambda")), Tup(Nil)))) :: Nil)), App(Var("foo"), Tup((N, Fld(_, App(NuNew(Var("Lambda2")), Tup((N, Fld(_, IntLit(2))) :: Nil)))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1([e: 'A, tail: |(Cons, Nil,),]) {
//│     fun count = () -> Int
//│     fun count = () => +(1, ((this).tail).count(),)
//│   }
//│   class Nil$2([]) {fun count = () => 0}
//│   class Lambda$3([]) {fun apply = (l,) => {(l).count()}}
//│   class Lambda2$4([a: Int,]) {
//│     fun apply = (l,) => {('(' new Cons$1([(this).a, l,]) {} ')').count()}
//│   }
//│   fun foo$1 = (x,) => {+((x).apply(new Cons$1([1, new Nil$2([]) {},]) {},), (x).apply(new Nil$2([]) {},),)}
//│   Code(List(foo$1(new Lambda$3([]) {},)))
//│   Code(List(foo$1(new Lambda2$4([2,]) {},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ main$$6()
//│ fun count$Cons$1(this) =
//│   +(#1, this.tail match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)})
//│ fun foo$1(x) =
//│   +(x match {case obj: Lambda2$4 => apply$Lambda2$4(obj, new Cons$1 (#1, new Nil$2 () ) ); case obj: Lambda$3 => apply$Lambda$3(obj, new Cons$1 (#1, new Nil$2 () ) )}, x match {case obj: Lambda2$4 => apply$Lambda2$4(obj, new Nil$2 () ); case obj: Lambda$3 => apply$Lambda$3(obj, new Nil$2 () )})
//│ fun apply$Lambda$3(this, l) =
//│   l match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ fun count$Nil$2(this) =
//│   #0
//│ fun apply$Lambda2$4(this, l) =
//│   new Cons$1 (this.a, l)  match {case obj: Cons$1 => count$Cons$1(obj)}
//│ fun main$$6() =
//│   foo$1(new Lambda2$4 (#2) )
//│ fun main$$5() =
//│   foo$1(new Lambda$3 () )
//│ class Nil$2() {
//│ }
//│ class Lambda2$4(a) {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ class Lambda$3() {
//│ }
//│ class Cons(e: nothing, tail: Cons | Nil) {
//│   fun count: () -> Int
//│ }
//│ class Nil() {
//│   fun count: () -> 0
//│ }
//│ class Lambda() {
//│   fun apply: forall 'a. {count: () -> 'a} -> 'a
//│ }
//│ class Lambda2(a: Int) {
//│   fun apply: (Cons | Nil) -> Int
//│ }
//│ fun foo: {apply: (Cons | Nil) -> Int} -> Int
//│ Int
//│ res
//│     = 1
//│ res
//│     = 3

:mono
class Cons(e: Int, tail: Cons | Nil) {
  fun count(): Int
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = 
  x(new Cons(1, new Nil())) + x(new Nil())
foo(l => l.count())
foo(l => (new Cons(2, l)).count())
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Cons"), Ls(), S(Tup((S(e), Fld(_, Var("Int"))) :: (S(tail), Fld(_, App(Var("|"), Tup((N, Fld(_, Var("Cons"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Int"))))), NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), App(Var("+"), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(Sel(Var("tail"), count), Tup(Nil)))) :: Nil))))))), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, count, N, Nil, L(Lam(Tup(Nil), IntLit(0)))))), NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(App(Var("+"), Tup((N, Fld(_, App(Var("x"), Tup((N, Fld(_, App(NuNew(Var("Cons")), Tup((N, Fld(_, IntLit(1))) :: (N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil)))) :: (N, Fld(_, App(Var("x"), Tup((N, Fld(_, App(NuNew(Var("Nil")), Tup(Nil)))) :: Nil)))) :: Nil)))))), App(Var("foo"), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("l"))) :: Nil), App(Sel(Var("l"), count), Tup(Nil))))) :: Nil)), App(Var("foo"), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("l"))) :: Nil), App(Sel(Bra(rcd = false, App(NuNew(Var("Cons")), Tup((N, Fld(_, IntLit(2))) :: (N, Fld(_, Var("l"))) :: Nil))), count), Tup(Nil))))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1([e: Int, tail: |(Cons, Nil,),]) {
//│     fun count = () -> Int
//│     fun count = () => +(1, ((this).tail).count(),)
//│   }
//│   class Nil$2([]) {fun count = () => 0}
//│   class Lambda1$2$3([]) {fun apply = (l,) => (l).count()}
//│   class Lambda1$3$4([]) {
//│     fun apply = (l,) => ('(' new Cons$1([2, l,]) {} ')').count()
//│   }
//│   fun foo$1 = (x,) => {+(x(new Cons$1([1, new Nil$2([]) {},]) {},), x(new Nil$2([]) {},),)}
//│   Code(List(foo$1({new Lambda1$2$3([]) {}},)))
//│   Code(List(foo$1({new Lambda1$3$4([]) {}},)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ main$$6()
//│ fun count$Cons$1(this) =
//│   +(#1, this.tail match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)})
//│ fun foo$1(x) =
//│   +(x match {case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, new Cons$1 (#1, new Nil$2 () ) ); case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, new Cons$1 (#1, new Nil$2 () ) )}, x match {case obj: Lambda1$3$4 => apply$Lambda1$3$4(obj, new Nil$2 () ); case obj: Lambda1$2$3 => apply$Lambda1$2$3(obj, new Nil$2 () )})
//│ fun count$Nil$2(this) =
//│   #0
//│ fun main$$6() =
//│   foo$1(new Lambda1$3$4 () )
//│ fun main$$5() =
//│   foo$1(new Lambda1$2$3 () )
//│ fun apply$Lambda1$3$4(this, l) =
//│   new Cons$1 (#2, l)  match {case obj: Cons$1 => count$Cons$1(obj)}
//│ fun apply$Lambda1$2$3(this, l) =
//│   l match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ class Lambda1$3$4() {
//│ }
//│ class Nil$2() {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ class Lambda1$2$3() {
//│ }
//│ class Cons(e: Int, tail: Cons | Nil) {
//│   fun count: () -> Int
//│ }
//│ class Nil() {
//│   fun count: () -> 0
//│ }
//│ fun foo: ((Cons | Nil) -> Int) -> Int
//│ Int
//│ res
//│     = 1
//│ res
//│     = 3

:mono
class Exp() {
  virtual fun derive(x: Int): Exp
  virtual fun derive(x: Int) = Exp()
  virtual fun isEmpty(): Bool
  virtual fun isEmpty() = false
}
class E() extends Exp {
  fun derive(x) = 
    new E
  fun isEmpty() = 
    false
}
class Ep() extends Exp {
  fun derive(x) = 
    new E
  fun isEmpty() = 
    true
}
class Ch(i: Int) extends Exp {
  fun derive(x) = 
    if x == i then new Ep else new E
  fun isEmpty() = 
    false
}
class A(e1: Exp, e2: Exp) extends Exp {
  fun derive(x) = 
    new A(e1.derive(x), e2.derive(x))
  fun isEmpty() = 
    e1.isEmpty() || e2.isEmpty()
}
class C(e1: Exp, e2: Exp) extends Exp {
  fun derive(x) = 
    if e1.isEmpty() then new A(new C(e1.derive(x), e2), e2.derive(x)) else new C(e1.derive(x), e2)
  fun isEmpty() = 
    e1.isEmpty() && e2.isEmpty()
}
(new C(new Ch(1), new A(new Ch(2), new Ch(3)))).derive(0).isEmpty()
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Exp"), Ls(), S(Tup(Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, R(PolyType(Ls(), Function(Tuple(S(x) -> Fld(N, TypeName("Int"))), TypeName("Exp"))))), NuFunDef(None, derive, N, Nil, L(Lam(Tup((S(x), Fld(_, Var("Int"))) :: Nil), App(Var("Exp"), Tup(Nil))))), NuFunDef(None, isEmpty, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Bool"))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Var("false")))))), NuTypeDef(Cls, TypeName("E"), Ls(), S(Tup(Nil)), N, N, Ls(Var("Exp")), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(NuNew(Var("E")))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Blk(Var("false"))))))), NuTypeDef(Cls, TypeName("Ep"), Ls(), S(Tup(Nil)), N, N, Ls(Var("Exp")), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(NuNew(Var("E")))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Blk(Var("true"))))))), NuTypeDef(Cls, TypeName("Ch"), Ls(), S(Tup((S(i), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(Var("Exp")), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(App(Var("=="), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("i"))) :: Nil)), NuNew(Var("Ep")), Some(NuNew(Var("E")))))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Blk(Var("false"))))))), NuTypeDef(Cls, TypeName("A"), Ls(), S(Tup((S(e1), Fld(_, Var("Exp"))) :: (S(e2), Fld(_, Var("Exp"))) :: Nil)), N, N, Ls(Var("Exp")), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(App(NuNew(Var("A")), Tup((N, Fld(_, App(Sel(Var("e1"), derive), Tup((N, Fld(_, Var("x"))) :: Nil)))) :: (N, Fld(_, App(Sel(Var("e2"), derive), Tup((N, Fld(_, Var("x"))) :: Nil)))) :: Nil)))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Blk(App(Var("||"), Tup((N, Fld(_, App(Sel(Var("e1"), isEmpty), Tup(Nil)))) :: (N, Fld(_, App(Sel(Var("e2"), isEmpty), Tup(Nil)))) :: Nil)))))))), NuTypeDef(Cls, TypeName("C"), Ls(), S(Tup((S(e1), Fld(_, Var("Exp"))) :: (S(e2), Fld(_, Var("Exp"))) :: Nil)), N, N, Ls(Var("Exp")), N, N, TypingUnit(NuFunDef(None, derive, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(App(Sel(Var("e1"), isEmpty), Tup(Nil)), App(NuNew(Var("A")), Tup((N, Fld(_, App(NuNew(Var("C")), Tup((N, Fld(_, App(Sel(Var("e1"), derive), Tup((N, Fld(_, Var("x"))) :: Nil)))) :: (N, Fld(_, Var("e2"))) :: Nil)))) :: (N, Fld(_, App(Sel(Var("e2"), derive), Tup((N, Fld(_, Var("x"))) :: Nil)))) :: Nil)), Some(App(NuNew(Var("C")), Tup((N, Fld(_, App(Sel(Var("e1"), derive), Tup((N, Fld(_, Var("x"))) :: Nil)))) :: (N, Fld(_, Var("e2"))) :: Nil)))))))), NuFunDef(None, isEmpty, N, Nil, L(Lam(Tup(Nil), Blk(App(Var("&&"), Tup((N, Fld(_, App(Sel(Var("e1"), isEmpty), Tup(Nil)))) :: (N, Fld(_, App(Sel(Var("e2"), isEmpty), Tup(Nil)))) :: Nil)))))))), App(Sel(App(Sel(Bra(rcd = false, App(NuNew(Var("C")), Tup((N, Fld(_, App(NuNew(Var("Ch")), Tup((N, Fld(_, IntLit(1))) :: Nil)))) :: (N, Fld(_, App(NuNew(Var("A")), Tup((N, Fld(_, App(NuNew(Var("Ch")), Tup((N, Fld(_, IntLit(2))) :: Nil)))) :: (N, Fld(_, App(NuNew(Var("Ch")), Tup((N, Fld(_, IntLit(3))) :: Nil)))) :: Nil)))) :: Nil))), derive), Tup((N, Fld(_, IntLit(0))) :: Nil)), isEmpty), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Exp$1([]) {
//│     fun derive = (x: Int) -> Exp$1
//│     fun derive = (x: Int,) => Exp$1()
//│     fun isEmpty = () -> Bool
//│     fun isEmpty = () => false
//│   }
//│   class E$2([]): Exp$1() {
//│     fun derive = (x,) => {new E$2([]) {}}
//│     fun isEmpty = () => {false}
//│   }
//│   class Ep$3([]): Exp$1() {
//│     fun derive = (x,) => {new E$2([]) {}}
//│     fun isEmpty = () => {true}
//│   }
//│   class Ch$4([i: Int,]): Exp$1() {
//│     fun derive = (x,) => {if (==(x, (this).i,)) then new Ep$3([]) {} else new E$2([]) {}}
//│     fun isEmpty = () => {false}
//│   }
//│   class A$5([e1: Exp, e2: Exp,]): Exp$1() {
//│     fun derive = (x,) => {new A$5([((this).e1).derive(x,), ((this).e2).derive(x,),]) {}}
//│     fun isEmpty = () => {||(((this).e1).isEmpty(), ((this).e2).isEmpty(),)}
//│   }
//│   class C$6([e1: Exp, e2: Exp,]): Exp$1() {
//│     fun derive = (x,) => {if (((this).e1).isEmpty()) then new A$5([new C$6([((this).e1).derive(x,), (this).e2,]) {}, ((this).e2).derive(x,),]) {} else new C$6([((this).e1).derive(x,), (this).e2,]) {}}
//│     fun isEmpty = () => {&&(((this).e1).isEmpty(), ((this).e2).isEmpty(),)}
//│   }
//│   Code(List((('(' new C$6([new Ch$4([1,]) {}, new A$5([new Ch$4([2,]) {}, new Ch$4([3,]) {},]) {},]) {} ')').derive(0,)).isEmpty()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$6()
//│ fun isEmpty$E$2(this) =
//│   false
//│ fun isEmpty$A$5(this) =
//│   ||(this.e1 match {case obj: Ch$4 => isEmpty$Ch$4(obj)}, this.e2 match {case obj: Ch$4 => isEmpty$Ch$4(obj)})
//│ fun isEmpty$Ch$4(this) =
//│   false
//│ fun derive$A$5(this, x) =
//│   new A$5 (this.e1 match {case obj: Ch$4 => derive$Ch$4(obj, x)}, this.e2 match {case obj: Ch$4 => derive$Ch$4(obj, x)}) 
//│ fun isEmpty$C$6(this) =
//│   &&(this.e1 match {case obj: Ep$3 => isEmpty$Ep$3(obj); case obj: E$2 => isEmpty$E$2(obj)}, this.e2 match {case obj: A$5 => isEmpty$A$5(obj)})
//│ fun derive$C$6(this, x) =
//│   if this.e1 match {case obj: Ch$4 => isEmpty$Ch$4(obj)} then new A$5 (new C$6 (this.e1 match {case obj: Ch$4 => derive$Ch$4(obj, x)}, this.e2) , this.e2 match {case obj: A$5 => derive$A$5(obj, x)})  else new C$6 (this.e1 match {case obj: Ch$4 => derive$Ch$4(obj, x)}, this.e2) 
//│ fun main$$6() =
//│   new C$6 (new Ch$4 (#1) , new A$5 (new Ch$4 (#2) , new Ch$4 (#3) ) )  match {case obj: C$6 => derive$C$6(obj, #0)} match {case obj: C$6 => isEmpty$C$6(obj)}
//│ fun derive$Ch$4(this, x) =
//│   if ==(x, this.i) then new Ep$3 ()  else new E$2 () 
//│ fun isEmpty$Ep$3(this) =
//│   true
//│ class A$5(e1, e2): Exp$1() {
//│ }
//│ class E$2(): Exp$1() {
//│ }
//│ class C$6(e1, e2): Exp$1() {
//│ }
//│ class Ch$4(i): Exp$1() {
//│ }
//│ class Ep$3(): Exp$1() {
//│ }
//│ class Exp$1() {
//│ }
//│ class Exp() {
//│   fun derive: (x: Int) -> Exp
//│   fun isEmpty: () -> Bool
//│ }
//│ class E() extends Exp {
//│   fun derive: anything -> E
//│   fun isEmpty: () -> false
//│ }
//│ class Ep() extends Exp {
//│   fun derive: anything -> E
//│   fun isEmpty: () -> true
//│ }
//│ class Ch(i: Int) extends Exp {
//│   fun derive: Num -> (E | Ep)
//│   fun isEmpty: () -> false
//│ }
//│ class A(e1: Exp, e2: Exp) extends Exp {
//│   fun derive: Int -> A
//│   fun isEmpty: () -> Bool
//│ }
//│ class C(e1: Exp, e2: Exp) extends Exp {
//│   fun derive: Int -> (A | C)
//│   fun isEmpty: () -> Bool
//│ }
//│ Bool
//│ res
//│     = false


:mono
val anyUnknown = false
class List(l: List | Nil, hasTail: Bool)  {}
class Nil(hasTail: Bool)  {}
fun gen() = 
  if anyUnknown then new List(gen(), true) else new Nil(false)
gen()
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), anyUnknown, N, Nil, L(Var("false"))), NuTypeDef(Cls, TypeName("List"), Ls(), S(Tup((S(l), Fld(_, App(Var("|"), Tup((N, Fld(_, Var("List"))) :: (N, Fld(_, Var("Nil"))) :: Nil)))) :: (S(hasTail), Fld(_, Var("Bool"))) :: Nil)), N, N, Ls(), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("Nil"), Ls(), S(Tup((S(hasTail), Fld(_, Var("Bool"))) :: Nil)), N, N, Ls(), N, N, TypingUnit()), NuFunDef(None, gen, N, Nil, L(Lam(Tup(Nil), Blk(If(IfThen(Var("anyUnknown"), App(NuNew(Var("List")), Tup((N, Fld(_, App(Var("gen"), Tup(Nil)))) :: (N, Fld(_, Var("true"))) :: Nil)), Some(App(NuNew(Var("Nil")), Tup((N, Fld(_, Var("false"))) :: Nil)))))))), App(Var("gen"), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class List$1([l: |(List, Nil,), hasTail: Bool,]) {}
//│   class Nil$2([hasTail: Bool,]) {}
//│   let anyUnknown$2 = () => false
//│   fun gen$1 = () => {if (anyUnknown) then new List$1([gen$1(), true,]) {} else new Nil$2([false,]) {}}
//│   Code(List(gen$1()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ fun anyUnknown$2() =
//│   false
//│ fun gen$1() =
//│   if anyUnknown then new List$1 (gen$1(), true)  else new Nil$2 (false) 
//│ fun main$$4() =
//│   gen$1()
//│ class Nil$2(hasTail) {
//│ }
//│ class List$1(l, hasTail) {
//│ }
//│ val anyUnknown: false
//│ class List(l: List | Nil, hasTail: Bool)
//│ class Nil(hasTail: Bool)
//│ fun gen: () -> (List | Nil)
//│ List | Nil
//│ anyUnknown
//│            = false
//│ res
//│     = Nil {}



:mono
class Foo(x: Int){
  fun bar(y) = x+y
  fun boo(z) = bar(z)+x
}
(new Foo(1)).boo(2)
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Foo"), Ls(), S(Tup((S(x), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(Lam(Tup((N, Fld(_, Var("y"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("y"))) :: Nil))))), NuFunDef(None, boo, N, Nil, L(Lam(Tup((N, Fld(_, Var("z"))) :: Nil), App(Var("+"), Tup((N, Fld(_, App(Var("bar"), Tup((N, Fld(_, Var("z"))) :: Nil)))) :: (N, Fld(_, Var("x"))) :: Nil))))))), App(Sel(Bra(rcd = false, App(NuNew(Var("Foo")), Tup((N, Fld(_, IntLit(1))) :: Nil))), boo), Tup((N, Fld(_, IntLit(2))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x: Int,]) {
//│     fun bar = (y,) => +((this).x, y,)
//│     fun boo = (z,) => +((this).bar(z,), (this).x,)
//│   }
//│   Code(List(('(' new Foo$1([1,]) {} ')').boo(2,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun boo$Foo$1(this, z) =
//│   +(this match {case obj: Foo$1 => bar$Foo$1(obj, z)}, this.x)
//│ fun bar$Foo$1(this, y) =
//│   +(this.x, y)
//│ fun main$$1() =
//│   new Foo$1 (#1)  match {case obj: Foo$1 => boo$Foo$1(obj, #2)}
//│ class Foo$1(x) {
//│ }
//│ class Foo(x: Int) {
//│   fun bar: Int -> Int
//│   fun boo: Int -> Int
//│ }
//│ Int
//│ res
//│     = 4

:mono
class OneInt(a: Int){
  fun fac: () -> Int
  fun fac = () ->
    if(a > 0) then (new OneInt(a - 1)).fac() else 1 
}
(new OneInt(10)).fac()
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("OneInt"), Ls(), S(Tup((S(a), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, fac, N, Nil, R(PolyType(Ls(), Function(Tuple(), TypeName("Int"))))), NuFunDef(None, fac, N, Nil, L(Lam(Tup(Nil), Blk(If(IfThen(Bra(rcd = false, App(Var(">"), Tup((N, Fld(_, Var("a"))) :: (N, Fld(_, IntLit(0))) :: Nil))), App(Sel(Bra(rcd = false, App(NuNew(Var("OneInt")), Tup((N, Fld(_, App(Var("-"), Tup((N, Fld(_, Var("a"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil))), fac), Tup(Nil)), Some(IntLit(1))))))))), App(Sel(Bra(rcd = false, App(NuNew(Var("OneInt")), Tup((N, Fld(_, IntLit(10))) :: Nil))), fac), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([a: Int,]) {
//│     fun fac = () -> Int
//│     fun fac = () => {if ('(' >((this).a, 0,) ')') then ('(' new OneInt$1([-((this).a, 1,),]) {} ')').fac() else 1}
//│   }
//│   Code(List(('(' new OneInt$1([10,]) {} ')').fac()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$1()
//│ fun fac$OneInt$1(this) =
//│   if >(this.a, #0) then new OneInt$1 (-(this.a, #1))  match {case obj: OneInt$1 => fac$OneInt$1(obj)} else #1
//│ fun main$$1() =
//│   new OneInt$1 (#10)  match {case obj: OneInt$1 => fac$OneInt$1(obj)}
//│ class OneInt$1(a) {
//│ }
//│ class OneInt(a: Int) {
//│   fun fac: () -> Int
//│ }
//│ Int
//│ res
//│     = 1

//:mono
//:e // FIXME: Mutable Parameters
//trait AnyFoo {
//}
//class FooPlus(#a): AnyFoo {
//  fun bar(b) = a + b
//}
//class FooMinus(#a): AnyFoo {
//  fun bar(b) = a - b
//}
//fun f(x) = x.bar(42)
//f(new FooPlus(1))
//f(new FooMinus(2))

:mono
val any = -20
fun f(x) = 
  if x > any then 0
  else g(x - 1)
fun g(x) = 
  if x > any then g(x - 1)
  else f(x - 2)
g(1)
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), any, N, Nil, L(IntLit(-20))), NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(App(Var(">"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("any"))) :: Nil)), IntLit(0), Some(App(Var("g"), Tup((N, Fld(_, App(Var("-"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)))))))), NuFunDef(None, g, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Blk(If(IfThen(App(Var(">"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("any"))) :: Nil)), App(Var("g"), Tup((N, Fld(_, App(Var("-"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil)))) :: Nil)), Some(App(Var("f"), Tup((N, Fld(_, App(Var("-"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(2))) :: Nil)))) :: Nil)))))))), App(Var("g"), Tup((N, Fld(_, IntLit(1))) :: Nil)))
//│ Lifted:
//│ TypingUnit {
//│   let any$3 = () => -20
//│   fun f$1 = (x,) => {if (>(x, any,)) then 0 else g$2(-(x, 1,),)}
//│   fun g$2 = (x,) => {if (>(x, any,)) then g$2(-(x, 1,),) else f$1(-(x, 2,),)}
//│   Code(List(g$2(1,)))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$3()
//│ fun any$3() =
//│   #-20
//│ fun f$1(x) =
//│   if >(x, any) then #0 else g$2(-(x, #1))
//│ fun g$2(x) =
//│   if >(x, any) then g$2(-(x, #1)) else f$1(-(x, #2))
//│ fun main$$3() =
//│   g$2(#1)
//│ val any: -20
//│ fun f: Int -> 0
//│ fun g: Int -> 0
//│ 0
//│ any
//│     = -20
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

:mono
class OneInt(a: Int){
  fun get = () -> a
}
class OneBool(b: Bool){
  fun get = () -> b
}
(if b then new OneInt(1) else new OneBool(true)).get()
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("OneInt"), Ls(), S(Tup((S(a), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, get, N, Nil, L(Lam(Tup(Nil), Var("a")))))), NuTypeDef(Cls, TypeName("OneBool"), Ls(), S(Tup((S(b), Fld(_, Var("Bool"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, get, N, Nil, L(Lam(Tup(Nil), Var("b")))))), App(Sel(Bra(rcd = false, If(IfThen(Var("b"), App(NuNew(Var("OneInt")), Tup((N, Fld(_, IntLit(1))) :: Nil)), Some(App(NuNew(Var("OneBool")), Tup((N, Fld(_, Var("true"))) :: Nil))))), get), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1([a: Int,]) {fun get = () => (this).a}
//│   class OneBool$2([b: Bool,]) {fun get = () => (this).b}
//│   Code(List(('(' if (b) then new OneInt$1([1,]) {} else new OneBool$2([true,]) {} ')').get()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$2()
//│ fun get$OneInt$1(this) =
//│   this.a
//│ fun get$OneBool$2(this) =
//│   this.b
//│ fun main$$2() =
//│   if b then new OneInt$1 (#1)  else new OneBool$2 (true)  match {case obj: OneInt$1 => get$OneInt$1(obj); case obj: OneBool$2 => get$OneBool$2(obj)}
//│ class OneInt$1(a) {
//│ }
//│ class OneBool$2(b) {
//│ }
//│ class OneInt(a: Int) {
//│   fun get: () -> Int
//│ }
//│ class OneBool(b: Bool) {
//│   fun get: () -> Bool
//│ }
//│ Int | false | true
//│ res
//│     = true

:mono
class Bar(x: Int) {
  fun foo(x) = x
  fun FooMinus(y: Int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
(new Car()).da(Bar(1337))
bar.car
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Bar"), Ls(), S(Tup((S(x), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Fld(_, Var("x"))) :: Nil), Var("x")))), NuFunDef(None, FooMinus, N, Nil, L(Lam(Tup((S(y), Fld(_, Var("Int"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, Var("y"))) :: Nil))))), NuFunDef(None, car, N, Nil, L(App(Var("foo"), Tup((N, Fld(_, IntLit(2))) :: Nil)))))), NuTypeDef(Cls, TypeName("Car"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, da, N, Nil, L(Lam(Tup((S(b), Fld(_, Var("Bar"))) :: Nil), App(Sel(Var("b"), foo), Tup((N, Fld(_, IntLit(2))) :: Nil))))))), NuFunDef(None, baz, N, Nil, L(Lam(Tup((S(b), Fld(_, Var("Bar"))) :: Nil), App(Sel(Var("b"), foo), Tup((N, Fld(_, IntLit(2))) :: Nil))))), NuFunDef(Some(false), bar, N, Nil, L(App(Var("Bar"), Tup((N, Fld(_, IntLit(42))) :: Nil)))), App(Var("baz"), Tup((N, Fld(_, Var("bar"))) :: Nil)), App(Sel(Bra(rcd = false, App(NuNew(Var("Car")), Tup(Nil))), da), Tup((N, Fld(_, App(Var("Bar"), Tup((N, Fld(_, IntLit(1337))) :: Nil)))) :: Nil)), Sel(Var("bar"), car))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1([x: Int,]) {
//│     fun foo = (x,) => x
//│     fun FooMinus = (y: Int,) => +((this).x, y,)
//│     fun car = () => (this).foo(2,)
//│   }
//│   class Car$2([]) {fun da = (b: Bar$1,) => (b).foo(2,)}
//│   fun baz$2 = (b: Bar$1,) => (b).foo(2,)
//│   let bar$1 = () => Bar$1(42,)
//│   Code(List(baz$2(bar,)))
//│   Code(List(('(' new Car$2([]) {} ')').da(Bar$1(1337,),)))
//│   Code(List((bar).car))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ main$$5()
//│ main$$6()
//│ fun bar$1() =
//│   Bar$1(#42)
//│ fun da$Car$2(this, b) =
//│   b match {}
//│ fun main$$6() =
//│   bar.car
//│ fun baz$2(b) =
//│   b match {}
//│ fun main$$5() =
//│   new Car$2 ()  match {case obj: Car$2 => da$Car$2(obj, Bar$1(#1337))}
//│ fun main$$4() =
//│   baz$2(bar)
//│ class Bar$1(x) {
//│ }
//│ class Car$2() {
//│ }
//│ class Bar(x: Int) {
//│   fun FooMinus: (y: Int) -> Int
//│   fun car: 2
//│   fun foo: forall 'a. 'a -> 'a
//│ }
//│ class Car {
//│   constructor()
//│   fun da: (b: Bar) -> 2
//│ }
//│ fun baz: (b: Bar) -> 2
//│ let bar: Bar
//│ 2
//│ bar
//│     = Bar {}
//│ res
//│     = 2
//│ res
//│     = 2
//│ res
//│     = 2

:mono
val c = 5
class Sup(a: Int){
  virtual fun foo = () -> a
}
class Sub(b: Int) extends Sup(b+b){
}
class Sub2(c: Int) extends Sub(c+c){
  fun foo = () -> a+c
}
(new Sub(10)).foo()
(new Sub2(c)).foo()
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), c, N, Nil, L(IntLit(5))), NuTypeDef(Cls, TypeName("Sup"), Ls(), S(Tup((S(a), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup(Nil), Var("a")))))), NuTypeDef(Cls, TypeName("Sub"), Ls(), S(Tup((S(b), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(App(Var("Sup"), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, Var("b"))) :: (N, Fld(_, Var("b"))) :: Nil)))) :: Nil))), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("Sub2"), Ls(), S(Tup((S(c), Fld(_, Var("Int"))) :: Nil)), N, N, Ls(App(Var("Sub"), Tup((N, Fld(_, App(Var("+"), Tup((N, Fld(_, Var("c"))) :: (N, Fld(_, Var("c"))) :: Nil)))) :: Nil))), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup(Nil), App(Var("+"), Tup((N, Fld(_, Var("a"))) :: (N, Fld(_, Var("c"))) :: Nil))))))), App(Sel(Bra(rcd = false, App(NuNew(Var("Sub")), Tup((N, Fld(_, IntLit(10))) :: Nil))), foo), Tup(Nil)), App(Sel(Bra(rcd = false, App(NuNew(Var("Sub2")), Tup((N, Fld(_, Var("c"))) :: Nil))), foo), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Sup$1([a: Int,]) {fun foo = () => (this).a}
//│   class Sub$2([b: Int,]): Sup$1(+((this).b, (this).b,),) {}
//│   class Sub2$3([c: Int,]): Sub$2(+((this).c, (this).c,),) {fun foo = () => +((this).a, (this).c,)}
//│   let c$1 = () => 5
//│   Code(List(('(' new Sub$2([10,]) {} ')').foo()))
//│   Code(List(('(' new Sub2$3([c,]) {} ')').foo()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$4()
//│ main$$5()
//│ fun c$1() =
//│   #5
//│ fun main$$5() =
//│   new Sub2$3 (c)  match {case obj: Sub2$3 => foo$Sub2$3(obj)}
//│ fun main$$4() =
//│   new Sub$2 (#10)  match {case obj: Sub$2 => foo$Sup$1(obj)}
//│ fun foo$Sup$1(this) =
//│   this.a
//│ fun foo$Sub2$3(this) =
//│   +(this.a, this.c)
//│ class Sub2$3(c): Sub$2(+(this.c, this.c)) {
//│ }
//│ class Sup$1(a) {
//│ }
//│ class Sub$2(b): Sup$1(+(this.b, this.b)) {
//│ }
//│ val c: 5
//│ class Sup(a: Int) {
//│   fun foo: () -> Int
//│ }
//│ class Sub(b: Int) extends Sup {
//│   fun foo: () -> Int
//│ }
//│ class Sub2(c: Int) extends Sub, Sup {
//│   fun foo: () -> Int
//│ }
//│ Int
//│ c
//│   = 5
//│ res
//│     = 20
//│ res
//│     = 47

:mono
class Foo(f: Int -> Int){
  fun foo = () -> f(1)
}
class F1() extends Foo(x => x+1){}
class F2() extends Foo(x => x+2){}
(new F1()).foo()
(new F2()).foo()
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Foo"), Ls(), S(Tup((S(f), Fld(_, App(Var("->"), Tup((N, Fld(_, Var("Int"))) :: (N, Fld(_, Var("Int"))) :: Nil)))) :: Nil)), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(Lam(Tup(Nil), App(Var("f"), Tup((N, Fld(_, IntLit(1))) :: Nil))))))), NuTypeDef(Cls, TypeName("F1"), Ls(), S(Tup(Nil)), N, N, Ls(App(Var("Foo"), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(1))) :: Nil))))) :: Nil))), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("F2"), Ls(), S(Tup(Nil)), N, N, Ls(App(Var("Foo"), Tup((N, Fld(_, Lam(Tup((N, Fld(_, Var("x"))) :: Nil), App(Var("+"), Tup((N, Fld(_, Var("x"))) :: (N, Fld(_, IntLit(2))) :: Nil))))) :: Nil))), N, N, TypingUnit()), App(Sel(Bra(rcd = false, App(NuNew(Var("F1")), Tup(Nil))), foo), Tup(Nil)), App(Sel(Bra(rcd = false, App(NuNew(Var("F2")), Tup(Nil))), foo), Tup(Nil)))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([f: ->(Int, Int,),]) {fun foo = () => (this).f(1,)}
//│   class F1$2_Lambda1$1$4([par$F1$2,]) {fun apply = (x,) => +(x, 1,)}
//│   class F1$2([]): Foo$1({new F1$2_Lambda1$1$4([this,]) {}},) {}
//│   class F2$3_Lambda1$2$5([par$F2$3,]) {fun apply = (x,) => +(x, 2,)}
//│   class F2$3([]): Foo$1({new F2$3_Lambda1$2$5([this,]) {}},) {}
//│   Code(List(('(' new F1$2([]) {} ')').foo()))
//│   Code(List(('(' new F2$3([]) {} ')').foo()))
//│ }
//│ Mono:
//│ 
//│ Defunc result: 
//│ main$$5()
//│ main$$6()
//│ fun apply$F2$3_Lambda1$2$5(this, x) =
//│   +(x, #2)
//│ fun foo$Foo$1(this) =
//│   this match {case obj: Foo$1 => obj.f match {case obj$F2$3_Lambda1$2$5: F2$3_Lambda1$2$5 => apply$F2$3_Lambda1$2$5(obj$F2$3_Lambda1$2$5, #1); case obj$F1$2_Lambda1$1$4: F1$2_Lambda1$1$4 => apply$F1$2_Lambda1$1$4(obj$F1$2_Lambda1$1$4, #1)}}
//│ fun main$$6() =
//│   new F2$3 ()  match {case obj: F2$3 => foo$Foo$1(obj)}
//│ fun main$$5() =
//│   new F1$2 ()  match {case obj: F1$2 => foo$Foo$1(obj)}
//│ fun apply$F1$2_Lambda1$1$4(this, x) =
//│   +(x, #1)
//│ class F1$2(): Foo$1(new F1$2_Lambda1$1$4 (this) ) {
//│ }
//│ class F2$3_Lambda1$2$5(par$F2$3) {
//│ }
//│ class F2$3(): Foo$1(new F2$3_Lambda1$2$5 (this) ) {
//│ }
//│ class Foo$1(f) {
//│ }
//│ class F1$2_Lambda1$1$4(par$F1$2) {
//│ }
//│ class Foo(f: Int -> Int) {
//│   fun foo: () -> Int
//│ }
//│ class F1() extends Foo {
//│   fun foo: () -> Int
//│ }
//│ class F2() extends Foo {
//│   fun foo: () -> Int
//│ }
//│ Int
//│ res
//│     = 2
//│ res
//│     = 3
