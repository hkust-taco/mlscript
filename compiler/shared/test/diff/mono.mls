:NewParser
:ParseOnly
// :mono
fun f(x) = if x then 42 else 1337
//│ |#fun| |f|(|x|)| |#=| |#if| |x| |#then| |42| |#else| |1337|
//│ Parsed: {fun f = x, => if (x) then 42 else 1337}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), If((x) then 42, Some(IntLit(1337))))))
//│ Lifted:
//│ TypingUnit {fun f = x, => if (x) then 42 else 1337}

// :mono
fun foo() = 42
//│ |#fun| |foo|(||)| |#=| |42|
//│ Parsed: {fun foo =  => 42}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Lam(Tup(), IntLit(42))))
//│ Lifted:
//│ TypingUnit {fun foo =  => 42}

// :mono
fun foo(x, #b) = if b then x else 1337
let a = foo(42, true)
let b = foo(23, false)
//│ |#fun| |foo|(|x|,| |##|b|)| |#=| |#if| |b| |#then| |x| |#else| |1337|↵|#let| |a| |#=| |foo|(|42|,| |true|)|↵|#let| |b| |#=| |foo|(|23|,| |false|)|
//│ Parsed: {fun foo = x, #b, => if (b) then x else 1337; let a = foo (42, true,); let b = foo (23, false,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Lam(Tup(_: Var(x), _: Var(b)), If((b) then x, Some(IntLit(1337))))), NuFunDef(Some(false), a, [], App(Var(foo), Tup(_: IntLit(42), _: Var(true)))), NuFunDef(Some(false), b, [], App(Var(foo), Tup(_: IntLit(23), _: Var(false)))))
//│ Lifted:
//│ TypingUnit {
//│   fun foo = x, #b, => if (b) then x else 1337
//│   let a = foo (42, true,)
//│   let b = foo (23, false,)
//│ }

// :mono
let x = 42 + 1337
//│ |#let| |x| |#=| |42| |+| |1337|
//│ Parsed: {let x = + (42,) (1337,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(Some(false), x, [], App(App(Var(+), Tup(_: IntLit(42))), Tup(_: IntLit(1337)))))
//│ Lifted:
//│ TypingUnit {let x = + (42,) (1337,)}

class Bar(#x)
fun foo(#b) = b
let a = foo(new Bar(1))
let b = foo(new Bar(2))
//│ |#class| |Bar|(|##|x|)|↵|#fun| |foo|(|##|b|)| |#=| |b|↵|#let| |a| |#=| |foo|(|#new| |Bar|(|1|)|)|↵|#let| |b| |#=| |foo|(|#new| |Bar|(|2|)|)|
//│ Parsed: {class Bar(#x,) {}; fun foo = #b, => b; let a = foo (new Bar(1,) {},); let b = foo (new Bar(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(_: Var(x)), (), TypingUnit()), NuFunDef(None, foo, [], Lam(Tup(_: Var(b)), Var(b))), NuFunDef(Some(false), a, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),1,)), TypingUnit(List()))))), NuFunDef(Some(false), b, [], App(Var(foo), Tup(_: New(Some((TypeName(Bar),2,)), TypingUnit(List()))))))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1(#x,) {}
//│   fun foo = #b, => b
//│   let a = foo (new Bar$1(1,) {},)
//│   let b = foo (new Bar$1(2,) {},)
//│ }

// :mono
class OneInt(#a){
  fun inc() = a+1
}
(new OneInt(1)).inc()
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |inc|(||)| |#=| |a|+|1|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.inc|(||)|
//│ Parsed: {class OneInt(#a,) {fun inc =  => + (a,) (1,)}; ('(' new OneInt(1,) {}, ')').inc ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, inc, [], Lam(Tup(), App(App(Var(+), Tup(_: Var(a))), Tup(_: IntLit(1))))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),1,)), TypingUnit(List())))), inc), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(#a,) {fun inc =  => + ((this).a,) (1,)}
//│   Code(List(('(' new OneInt$1(1,) {}, ')').inc ()))
//│ }

// :mono
class OneInt(#a){
  fun add(x) = 
    new OneInt(a+x.a)
}
(new OneInt(1)).add(new OneInt(2))
//│ |#class| |OneInt|(|##|a|)|{|→|#fun| |add|(|x|)| |#=| |→|#new| |OneInt|(|a|+|x|.a|)|←|←|↵|}|↵|(|#new| |OneInt|(|1|)|)|.add|(|#new| |OneInt|(|2|)|)|
//│ Parsed: {class OneInt(#a,) {fun add = x, => {new OneInt(+ (a,) ((x).a,),) {}}}; ('(' new OneInt(1,) {}, ')').add (new OneInt(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, add, [], Lam(Tup(_: Var(x)), Blk(...))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),1,)), TypingUnit(List())))), add), Tup(_: New(Some((TypeName(OneInt),2,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(#a,) {
//│     fun add = x, => {new OneInt$1(+ ((this).a,) ((x).a,),) {}}
//│   }
//│   Code(List(('(' new OneInt$1(1,) {}, ')').add (new OneInt$1(2,) {},)))
//│ }

// :mono
if true then 1 else 0
if 1+1 > 1 then 1-1 else 1*1
//│ |#if| |true| |#then| |1| |#else| |0|↵|#if| |1|+|1| |>| |1| |#then| |1|-|1| |#else| |1|*|1|
//│ Parsed: {if (true) then 1 else 0; if (> (+ (1,) (1,),) (1,)) then - (1,) (1,) else * (1,) (1,)}
//│ Parsed:
//│ TypingUnit(If((true) then 1, Some(IntLit(0))), If((> (+ (1,) (1,),) (1,)) then - (1,) (1,), Some(App(App(Var(*), Tup(_: IntLit(1))), Tup(_: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   Code(List(if (true) then 1 else 0))
//│   Code(List(if (> (+ (1,) (1,),) (1,)) then - (1,) (1,) else * (1,) (1,)))
//│ }

// :mono
if(b) then 1 else 2
//│ |#if|(|b|)| |#then| |1| |#else| |2|
//│ Parsed: {if ('(' b, ')') then 1 else 2}
//│ Parsed:
//│ TypingUnit(If(('(' b, ')') then 1, Some(IntLit(2))))
//│ Lifted:
//│ TypingUnit {Code(List(if ('(' b, ')') then 1 else 2))}

// :mono
((f, g) => f(g))(f => f, true)
//│ |(|(|f|,| |g|)| |=>| |f|(|g|)|)|(|f| |=>| |f|,| |true|)|
//│ Parsed: {'(' f, g, => f (g,), ')' (f, => f, true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Tup(_: Lam(Tup(_: Var(f), _: Var(g)), App(Var(f), Tup(_: Var(g)))))), Tup(_: Lam(Tup(_: Var(f)), Var(f)), _: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda2$1$1() {fun apply = f, g, => f (g,)}
//│   class Lambda1$2$2() {fun apply = f, => f}
//│   Code(List('(' {new Lambda2$1$1() {}}, ')' ({new Lambda1$2$2() {}}, true,)))
//│ }


// :mono
(b => if b then true else false) (true)
//│ |(|b| |=>| |#if| |b| |#then| |true| |#else| |false|)| |(|true|)|
//│ Parsed: {'(' b, => if (b) then true else false, ')' (true,)}
//│ Parsed:
//│ TypingUnit(App(Bra(rcd = false, Tup(_: Lam(Tup(_: Var(b)), If((b) then true, Some(Var(false)))))), Tup(_: Var(true))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$1$1() {fun apply = b, => if (b) then true else false}
//│   Code(List('(' {new Lambda1$1$1() {}}, ')' (true,)))
//│ }

// :mono
fun f(x) =
  if(x > 0) then x+1 else x-1
f(2)+3
//│ |#fun| |f|(|x|)| |#=|→|#if|(|x| |>| |0|)| |#then| |x|+|1| |#else| |x|-|1|←|↵|f|(|2|)|+|3|
//│ Parsed: {fun f = x, => {if ('(' > (x,) (0,), ')') then + (x,) (1,) else - (x,) (1,)}; + (f (2,),) (3,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), Blk(...))), App(App(Var(+), Tup(_: App(Var(f), Tup(_: IntLit(2))))), Tup(_: IntLit(3))))
//│ Lifted:
//│ TypingUnit {
//│   fun f = x, => {if ('(' > (x,) (0,), ')') then + (x,) (1,) else - (x,) (1,)}
//│   Code(List(+ (f (2,),) (3,)))
//│ }

// :mono
fun fac(n) = 
  if (n > 1) then fac(n - 1) * n else 1
fac(2)
//│ |#fun| |fac|(|n|)| |#=| |→|#if| |(|n| |>| |1|)| |#then| |fac|(|n| |-| |1|)| |*| |n| |#else| |1|←|↵|fac|(|2|)|
//│ Parsed: {fun fac = n, => {if ('(' > (n,) (1,), ')') then * (fac (- (n,) (1,),),) (n,) else 1}; fac (2,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, fac, [], Lam(Tup(_: Var(n)), Blk(...))), App(Var(fac), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   fun fac = n, => {if ('(' > (n,) (1,), ')') then * (fac (- (n,) (1,),),) (n,) else 1}
//│   Code(List(fac (2,)))
//│ }

// :mono
class List(l, hasTail)  {}
class Nil(l, hasTail)  {}
fun count(lst) =
  if lst.hasTail then count(lst.l)+1 else 1
count(new List(new List(new Nil(0, false), true), true))
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|l|,| |hasTail|)| |{||}|↵|#fun| |count|(|lst|)| |#=|→|#if| |lst|.hasTail| |#then| |count|(|lst|.l|)|+|1| |#else| |1|←|↵|count|(|#new| |List|(|#new| |List|(|#new| |Nil|(|0|,| |false|)|,| |true|)|,| |true|)|)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(l, hasTail,) {}; fun count = lst, => {if ((lst).hasTail) then + (count ((lst).l,),) (1,) else 1}; count (new List(new List(new Nil(0, false,) {}, true,) {}, true,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuFunDef(None, count, [], Lam(Tup(_: Var(lst)), Blk(...))), App(Var(count), Tup(_: New(Some((TypeName(List),new List(new Nil(0, false,) {}, true,) {}, true,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(l, hasTail,) {}
//│   class Nil$2(l, hasTail,) {}
//│   fun count = lst, => {if ((lst).hasTail) then + (count ((lst).l,),) (1,) else 1}
//│   Code(List(count (new List$1(new List$1(new Nil$2(0, false,) {}, true,) {}, true,) {},)))
//│ }

:mono
class Cons(e, tail){
  fun gen() = new Cons(e, tail.gen())
}
class Nil(){
  fun gen() = new Cons(0, this)
}
fun generate(x) = 
  if x > 0 then new Cons(x, generate(x+1)) else new Nil()
generate(10).gen()
//│ |#class| |Cons|(|e|,| |tail|)|{|→|#fun| |gen|(||)| |#=| |#new| |Cons|(|e|,| |tail|.gen|(||)|)|←|↵|}|↵|#class| |Nil|(||)|{|→|#fun| |gen|(||)| |#=| |#new| |Cons|(|0|,| |this|)|←|↵|}|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |Cons|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|generate|(|10|)|.gen|(||)|
//│ Parsed: {class Cons(e, tail,) {fun gen =  => new Cons(e, (tail).gen (),) {}}; class Nil() {fun gen =  => new Cons(0, this,) {}}; fun generate = x, => {if (> (x,) (0,)) then new Cons(x, generate (+ (x,) (1,),),) {} else new Nil() {}}; (generate (10,)).gen ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Cons, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, gen, [], Lam(Tup(), New(Some((TypeName(Cons),e, (tail).gen (),)), TypingUnit(List())))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, gen, [], Lam(Tup(), New(Some((TypeName(Cons),0, this,)), TypingUnit(List())))))), NuFunDef(None, generate, [], Lam(Tup(_: Var(x)), Blk(...))), App(Sel(App(Var(generate), Tup(_: IntLit(10))), gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1(e, tail,) {
//│     fun gen =  => new Cons$1((this).e, ((this).tail).gen (),) {}
//│   }
//│   class Nil$2() {fun gen =  => new Cons$1(0, this,) {}}
//│   fun generate = x, => {if (> (x,) (0,)) then new Cons$1(x, generate (+ (x,) (1,),),) {} else new Nil$2() {}}
//│   Code(List((generate (10,)).gen ()))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$3()
//│ fun gen$Cons$1(this) =
//│   new Cons$1 (this.e, this.tail match {case obj: Nil$2 => gen$Nil$2(obj); case obj: Cons$1 => gen$Cons$1(obj)}) 
//│ fun gen$Nil$2(this) =
//│   new Cons$1 (#0, this) 
//│ fun main$$3() =
//│   generate(#10) match {case obj: Nil$2 => gen$Nil$2(obj); case obj: Cons$1 => gen$Cons$1(obj)}
//│ fun generate(x) =
//│   if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ class Nil$2() {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ [mono] ┌───┬───────────────────────────────────────────────────────────────────────────┐
//│ │ 1 │ main$$3()                                                                 │
//│ │ 2 │ fun main$$3() =                                                           │
//│ │ 3 │   generate(#10).gen()                                                     │
//│ │ 4 │ fun generate(x) =                                                         │
//│ │ 5 │   if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 ()  │
//│ │ 6 │ class Nil$2() {                                                           │
//│ │ 7 │ }                                                                         │
//│ │ 8 │ class Cons$1(e, tail) {                                                   │
//│ │ 9 │ }                                                                         │
//│ └───┴───────────────────────────────────────────────────────────────────────────┘
//│ [mono] evaluating main$$3, rests: HashSet()
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *2*=[*2*=...]446468 @{}
//│ [mono] ┌ EVAL  generate(#10).gen()
//│ [mono] │ ┌ EVAL  generate(#10).gen
//│ [mono] │ │ ┌ EVAL  generate(#10)
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]241205
//│ [mono] │ │ │ ┌ EVAL  #10
//│ [mono] │ │ │ └ EVAL  [10]946944
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([10]946944)
//│ [mono] │ │ │ │ comparing (([]944117,0)) with (Plain([10]773991))
//│ [mono] │ │ │ │ first time encounter generate
//│ [mono] │ │ │ │ evaluating generate, rests: HashSet()
//│ [mono] │ │ │ │ ========== updating generate ==========
//│ [mono] │ │ │ │ generate: (([10]773991,1)) -> *1*=[*1*=...]435529 @{main$$3}
//│ [mono] │ │ │ │ ┌ EVAL  if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] │ │ │ │ │ ┌ EVAL  if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] │ │ │ │ │ │ ┌ EVAL  (x > #0)
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [10]773991
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  #0
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [0]245244
//│ [mono] │ │ │ │ │ │ └ EVAL  [true]467840
//│ [mono] │ │ │ │ │ │ ┌ EVAL  new Cons$1 (x, generate((x + #1))) 
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [10]773991
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  generate((x + #1))
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [generate(x) given {}]98216
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  (x + #1)
//│ [mono] │ │ │ │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ │ │ │ └ EVAL  [10]773991
//│ [mono] │ │ │ │ │ │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ │ │ │ │ │ └ EVAL  [1]618214
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [11]771866
//│ [mono] │ │ │ │ │ │ │ │ ┌ SPEC CALL generate with ([11]771866)
//│ [mono] │ │ │ │ │ │ │ │ │ comparing (([10]773991,1)) with (Plain([*LIT*]566055))
//│ [mono] │ │ │ │ │ │ │ │ │ find finer args
//│ [mono] │ │ │ │ │ │ │ │ └ SPEC CALL [*1*=[*1*=...]435529]59154
//│ [mono] │ │ │ │ │ │ │ │ call result: [*1*=[*1*=...]435529]59154
//│ [mono] │ │ │ │ │ │ │ │ merging []115737 with [*1*=[*1*=...]435529]59154
//│ [mono] │ │ │ │ │ │ │ │ result [*1*=[*1*=...]435529]5068
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [*1*=[*1*=...]435529]5068
//│ [mono] │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[*1*=...]435529]5068}]356015
//│ [mono] │ │ │ │ │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ │ │ │ │ └ EVAL  [Nil$2@{}]431217
//│ [mono] │ │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[*1*=...]435529]5068}]356015
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[*1*=...]435529]5068}]356015
//│ [mono] │ │ │ │ comparing [*1*=...]435529 with [Cons$1@{e: [10]773991, tail: [*1*=[*1*=...]435529]5068}]356015
//│ [mono] │ │ │ │ adding these funcs to queue: Set(main$$3, generate)
//│ [mono] │ │ │ │ generate: (([*LIT*]566055,100000)) -> *1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015 @{main$$3, generate}
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]185805
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]185805
//│ [mono] │ │ │ merging []938256 with [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]185805
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]290413
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]290413
//│ [mono] │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]265840}]840962
//│ [mono] │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]265840)
//│ [mono] │ │ comparing (([]364339,0)) with (Plain([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107))
//│ [mono] │ │ first time encounter gen$Cons$1
//│ [mono] │ │ evaluating gen$Cons$1, rests: HashSet(main$$3, generate)
//│ [mono] │ │ ========== updating gen$Cons$1 ==========
//│ [mono] │ │ gen$Cons$1: (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) -> *3*=[*3*=...]678569 @{main$$3}
//│ [mono] │ │ ┌ EVAL  new Cons$1 (this.e, this.tail.gen()) 
//│ [mono] │ │ │ ┌ EVAL  this.e
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107
//│ [mono] │ │ │ └ EVAL  [10]277488
//│ [mono] │ │ │ ┌ EVAL  this.tail.gen()
//│ [mono] │ │ │ │ ┌ EVAL  this.tail.gen
//│ [mono] │ │ │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107
//│ [mono] │ │ │ │ │ └ EVAL  [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]568228
//│ [mono] │ │ │ │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]791258}]62179
//│ [mono] │ │ │ │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]791258)
//│ [mono] │ │ │ │ │ comparing (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) with (Plain([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]933119))
//│ [mono] │ │ │ │ └ SPEC CALL [*3*=[*3*=...]678569]809765
//│ [mono] │ │ │ │ call result: [*3*=[*3*=...]678569]809765
//│ [mono] │ │ │ │ merging []218815 with [*3*=[*3*=...]678569]809765
//│ [mono] │ │ │ │ result [*3*=[*3*=...]678569]300678
//│ [mono] │ │ │ └ EVAL  [*3*=[*3*=...]678569]300678
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [10]277488, tail: [*3*=[*3*=...]678569]300678}]407363
//│ [mono] │ │ comparing [*3*=...]678569 with [Cons$1@{e: [10]277488, tail: [*3*=[*3*=...]678569]300678}]407363
//│ [mono] │ │ adding these funcs to queue: Set(main$$3, gen$Cons$1)
//│ [mono] │ │ gen$Cons$1: (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) -> *3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363 @{main$$3, gen$Cons$1}
//│ [mono] │ └ SPEC CALL [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]595743
//│ [mono] │ call result: [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]595743
//│ [mono] │ merging []932118 with [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]595743
//│ [mono] │ result [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]726572
//│ [mono] └ EVAL  [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]726572
//│ [mono] comparing [*2*=...]446468 with [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]726572
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]726572 @{}
//│ [mono] evaluating gen$Cons$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$Cons$1 ==========
//│ [mono] gen$Cons$1: (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) -> *3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363 @{main$$3, gen$Cons$1}
//│ [mono] ┌ EVAL  new Cons$1 (this.e, this.tail.gen()) 
//│ [mono] │ ┌ EVAL  this.e
//│ [mono] │ │ ┌ EVAL  this
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107
//│ [mono] │ └ EVAL  [10]364447
//│ [mono] │ ┌ EVAL  this.tail.gen()
//│ [mono] │ │ ┌ EVAL  this.tail.gen
//│ [mono] │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107
//│ [mono] │ │ │ └ EVAL  [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]659072
//│ [mono] │ │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]621451}]111512
//│ [mono] │ │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]621451)
//│ [mono] │ │ │ comparing (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) with (Plain([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]90170))
//│ [mono] │ │ └ SPEC CALL [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]7835
//│ [mono] │ │ call result: [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]7835
//│ [mono] │ │ merging []437242 with [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]7835
//│ [mono] │ │ result [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]767874
//│ [mono] │ └ EVAL  [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]767874
//│ [mono] └ EVAL  [Cons$1@{e: [10]364447, tail: [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]767874}]507104
//│ [mono] comparing [Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363 with [Cons$1@{e: [10]364447, tail: [*3*=[Cons$1@{e: [10]277488, tail: [*3*=...]300678}]407363]767874}]507104
//│ [mono] gen$Cons$1: (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) -> *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104 @{main$$3, gen$Cons$1}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726572 @{}
//│ [mono] ┌ EVAL  generate(#10).gen()
//│ [mono] │ ┌ EVAL  generate(#10).gen
//│ [mono] │ │ ┌ EVAL  generate(#10)
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]226557
//│ [mono] │ │ │ ┌ EVAL  #10
//│ [mono] │ │ │ └ EVAL  [10]710582
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([10]710582)
//│ [mono] │ │ │ │ comparing (([*LIT*]566055,100000)) with (Plain([*LIT*]310229))
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]120919
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]120919
//│ [mono] │ │ │ merging []708150 with [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]120919
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]709851
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]709851
//│ [mono] │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]493684}]525682
//│ [mono] │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]493684)
//│ [mono] │ │ comparing (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]506107,5)) with (Plain([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [10]773991, tail: ...}]356015]5068}]295517))
//│ [mono] │ └ SPEC CALL [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]400460
//│ [mono] │ call result: [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]400460
//│ [mono] │ merging []669796 with [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]400460
//│ [mono] │ result [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367
//│ [mono] └ EVAL  [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367
//│ [mono] comparing [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726572 with [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367 @{}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*]566055,100000)) -> *1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015 @{main$$3, generate}
//│ [mono] ┌ EVAL  if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] │ ┌ EVAL  (x > #0)
//│ [mono] │ │ ┌ EVAL  x
//│ [mono] │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ ┌ EVAL  #0
//│ [mono] │ │ └ EVAL  [0]425176
//│ [mono] │ └ EVAL  [*LIT*]455673
//│ [mono] │ ┌ EVAL  new Cons$1 (x, generate((x + #1))) 
//│ [mono] │ │ ┌ EVAL  x
//│ [mono] │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ ┌ EVAL  generate((x + #1))
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]68659
//│ [mono] │ │ │ ┌ EVAL  (x + #1)
//│ [mono] │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ └ EVAL  [1]230662
//│ [mono] │ │ │ └ EVAL  [*LIT*]687925
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([*LIT*]687925)
//│ [mono] │ │ │ │ comparing (([*LIT*]566055,100000)) with (Plain([*LIT*]345917))
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]385696
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]385696
//│ [mono] │ │ │ merging []33723 with [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]385696
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]47299
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]47299
//│ [mono] │ └ EVAL  [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]47299}]543166
//│ [mono] │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ └ EVAL  [Nil$2@{}]142725
//│ [mono] └ EVAL  [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]47299} | Nil$2@{}]642012
//│ [mono] comparing [Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015 with [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [10]773991, tail: [*1*=...]5068}]356015]47299} | Nil$2@{}]642012
//│ [mono] adding these funcs to queue: Set(main$$3, generate)
//│ [mono] generate: (([*LIT*]566055,100000)) -> *1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012 @{main$$3, generate}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367 @{}
//│ [mono] ┌ EVAL  generate(#10).gen()
//│ [mono] │ ┌ EVAL  generate(#10).gen
//│ [mono] │ │ ┌ EVAL  generate(#10)
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]111869
//│ [mono] │ │ │ ┌ EVAL  #10
//│ [mono] │ │ │ └ EVAL  [10]704974
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([10]704974)
//│ [mono] │ │ │ │ comparing (([*LIT*]566055,100000)) with (Plain([*LIT*]127031))
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]43871
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]43871
//│ [mono] │ │ │ merging []554043 with [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]43871
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]841328
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]841328
//│ [mono] │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]238870} | gen$Nil$2() given {this: [Nil$2@{}]935508}]123268
//│ [mono] │ ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}]935508)
//│ [mono] │ │ comparing (([]97006,0)) with (Plain([Nil$2@{}]877701))
//│ [mono] │ │ first time encounter gen$Nil$2
//│ [mono] │ │ evaluating gen$Nil$2, rests: HashSet(generate)
//│ [mono] │ │ ========== updating gen$Nil$2 ==========
//│ [mono] │ │ gen$Nil$2: (([Nil$2@{}]877701,1)) -> *4*=[*4*=...]519152 @{main$$3}
//│ [mono] │ │ ┌ EVAL  new Cons$1 (#0, this) 
//│ [mono] │ │ │ ┌ EVAL  #0
//│ [mono] │ │ │ └ EVAL  [0]413996
//│ [mono] │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ └ EVAL  [Nil$2@{}]877701
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774
//│ [mono] │ │ comparing [*4*=...]519152 with [Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774
//│ [mono] │ │ adding these funcs to queue: Set(main$$3)
//│ [mono] │ │ gen$Nil$2: (([Nil$2@{}]877701,1)) -> *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 @{main$$3}
//│ [mono] │ └ SPEC CALL [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]656947
//│ [mono] │ call result: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]656947
//│ [mono] │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]238870)
//│ [mono] │ │ comparing (([Cons$1@{e: [10]773991, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]5068}]506107,5)) with (Plain([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]978844
//│ [mono] │ call result: [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]978844
//│ [mono] │ merging []294987 with [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]656947
//│ [mono] │ result [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]19092
//│ [mono] │ merging [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]19092 with [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]978844
//│ [mono] │ result [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]969872
//│ [mono] └ EVAL  [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]969872
//│ [mono] comparing [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]329367 with [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]969872
//│ [mono] adding these funcs to queue: Set()
//│ [mono] main$$3: () -> *2*=[*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]969872 @{}
//│ [mono] evaluating gen$Cons$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$Cons$1 ==========
//│ [mono] gen$Cons$1: (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) -> *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104 @{main$$3, gen$Cons$1}
//│ [mono] ┌ EVAL  new Cons$1 (this.e, this.tail.gen()) 
//│ [mono] │ ┌ EVAL  this.e
//│ [mono] │ │ ┌ EVAL  this
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521
//│ [mono] │ └ EVAL  [*LIT*]211259
//│ [mono] │ ┌ EVAL  this.tail.gen()
//│ [mono] │ │ ┌ EVAL  this.tail.gen
//│ [mono] │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521
//│ [mono] │ │ │ └ EVAL  [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]987988
//│ [mono] │ │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]611974} | gen$Nil$2() given {this: [Nil$2@{}]710241}]564852
//│ [mono] │ │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]611974)
//│ [mono] │ │ │ comparing (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) with (Plain([Cons$1@{e: [*LIT*]45932, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]795876}]173592))
//│ [mono] │ │ └ SPEC CALL [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]472898
//│ [mono] │ │ call result: [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]472898
//│ [mono] │ │ ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}]710241)
//│ [mono] │ │ │ comparing (([Nil$2@{}]877701,1)) with (Plain([Nil$2@{}]467485))
//│ [mono] │ │ └ SPEC CALL [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]443107
//│ [mono] │ │ call result: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]443107
//│ [mono] │ │ merging []996289 with [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]472898
//│ [mono] │ │ result [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]179437
//│ [mono] │ │ merging [*3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]179437 with [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]443107
//│ [mono] │ │ result [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726509
//│ [mono] │ └ EVAL  [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726509
//│ [mono] └ EVAL  [Cons$1@{e: [*LIT*]211259, tail: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726509}]130025
//│ [mono] comparing [Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104 with [Cons$1@{e: [*LIT*]211259, tail: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774 | *3*=[Cons$1@{e: [10]364447, tail: [*3*=...]767874}]507104]726509}]130025
//│ [mono] adding these funcs to queue: Set(main$$3, gen$Cons$1)
//│ [mono] gen$Cons$1: (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) -> *3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 @{main$$3, gen$Cons$1}
//│ [mono] evaluating gen$Cons$1, rests: HashSet(main$$3, generate)
//│ [mono] ========== updating gen$Cons$1 ==========
//│ [mono] gen$Cons$1: (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) -> *3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 @{main$$3, gen$Cons$1}
//│ [mono] ┌ EVAL  new Cons$1 (this.e, this.tail.gen()) 
//│ [mono] │ ┌ EVAL  this.e
//│ [mono] │ │ ┌ EVAL  this
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521
//│ [mono] │ └ EVAL  [*LIT*]144235
//│ [mono] │ ┌ EVAL  this.tail.gen()
//│ [mono] │ │ ┌ EVAL  this.tail.gen
//│ [mono] │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521
//│ [mono] │ │ │ └ EVAL  [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]683896
//│ [mono] │ │ └ EVAL  [gen$Nil$2() given {this: [Nil$2@{}]402304} | gen$Cons$1() given {this: [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]954800}]797408
//│ [mono] │ │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]954800)
//│ [mono] │ │ │ comparing (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) with (Plain([Cons$1@{e: [*LIT*]390244, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]550955}]868530))
//│ [mono] │ │ └ SPEC CALL [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025]751281
//│ [mono] │ │ call result: [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025]751281
//│ [mono] │ │ ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}]402304)
//│ [mono] │ │ │ comparing (([Nil$2@{}]877701,1)) with (Plain([Nil$2@{}]784911))
//│ [mono] │ │ └ SPEC CALL [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]862537
//│ [mono] │ │ call result: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]862537
//│ [mono] │ │ merging []983536 with [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025]751281
//│ [mono] │ │ result [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025]532223
//│ [mono] │ │ merging [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025]532223 with [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]862537
//│ [mono] │ │ result [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361
//│ [mono] │ └ EVAL  [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361
//│ [mono] └ EVAL  [Cons$1@{e: [*LIT*]144235, tail: [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794
//│ [mono] comparing [Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 with [Cons$1@{e: [*LIT*]144235, tail: [*3*=[Cons$1@{e: [*LIT*]211259, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]726509}]130025 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794
//│ [mono] gen$Cons$1: (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) -> *3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 @{main$$3, gen$Cons$1}
//│ [mono] evaluating main$$3, rests: HashSet(generate)
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]969872 @{}
//│ [mono] ┌ EVAL  generate(#10).gen()
//│ [mono] │ ┌ EVAL  generate(#10).gen
//│ [mono] │ │ ┌ EVAL  generate(#10)
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]676913
//│ [mono] │ │ │ ┌ EVAL  #10
//│ [mono] │ │ │ └ EVAL  [10]123882
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([10]123882)
//│ [mono] │ │ │ │ comparing (([*LIT*]566055,100000)) with (Plain([*LIT*]823410))
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]862113
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]862113
//│ [mono] │ │ │ merging []880020 with [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]862113
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]26923
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]26923
//│ [mono] │ └ EVAL  [gen$Cons$1() given {this: [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]577613} | gen$Nil$2() given {this: [Nil$2@{}]256414}]160088
//│ [mono] │ ┌ SPEC CALL gen$Nil$2 with ([Nil$2@{}]256414)
//│ [mono] │ │ comparing (([Nil$2@{}]877701,1)) with (Plain([Nil$2@{}]586004))
//│ [mono] │ └ SPEC CALL [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]204477
//│ [mono] │ call result: [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]204477
//│ [mono] │ ┌ SPEC CALL gen$Cons$1 with ([Cons$1@{e: [*LIT*]566055, tail: [*1*=[Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: ...}]642012]47299}]577613)
//│ [mono] │ │ comparing (([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]734933}]141521,300006)) with (Plain([Cons$1@{e: [*LIT*]203630, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]402242}]147))
//│ [mono] │ └ SPEC CALL [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794]436063
//│ [mono] │ call result: [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794]436063
//│ [mono] │ merging []782992 with [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]204477
//│ [mono] │ result [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]977956
//│ [mono] │ merging [*4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]977956 with [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794]436063
//│ [mono] │ result [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]233330
//│ [mono] └ EVAL  [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]233330
//│ [mono] comparing [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]969872 with [*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]233330
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]233330 @{}
//│ [mono] evaluating generate, rests: HashSet()
//│ [mono] ========== updating generate ==========
//│ [mono] generate: (([*LIT*]566055,100000)) -> *1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012 @{main$$3, generate}
//│ [mono] ┌ EVAL  if (x > #0) then new Cons$1 (x, generate((x + #1)))  else new Nil$2 () 
//│ [mono] │ ┌ EVAL  (x > #0)
//│ [mono] │ │ ┌ EVAL  x
//│ [mono] │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ ┌ EVAL  #0
//│ [mono] │ │ └ EVAL  [0]86794
//│ [mono] │ └ EVAL  [*LIT*]973248
//│ [mono] │ ┌ EVAL  new Cons$1 (x, generate((x + #1))) 
//│ [mono] │ │ ┌ EVAL  x
//│ [mono] │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ ┌ EVAL  generate((x + #1))
//│ [mono] │ │ │ ┌ EVAL  generate
//│ [mono] │ │ │ └ EVAL  [generate(x) given {}]985318
//│ [mono] │ │ │ ┌ EVAL  (x + #1)
//│ [mono] │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ └ EVAL  [*LIT*]566055
//│ [mono] │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ └ EVAL  [1]131514
//│ [mono] │ │ │ └ EVAL  [*LIT*]436284
//│ [mono] │ │ │ ┌ SPEC CALL generate with ([*LIT*]436284)
//│ [mono] │ │ │ │ comparing (([*LIT*]566055,100000)) with (Plain([*LIT*]804833))
//│ [mono] │ │ │ └ SPEC CALL [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]679966
//│ [mono] │ │ │ call result: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]679966
//│ [mono] │ │ │ merging []902989 with [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]679966
//│ [mono] │ │ │ result [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]631787
//│ [mono] │ │ └ EVAL  [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]631787
//│ [mono] │ └ EVAL  [Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]631787}]601940
//│ [mono] │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ └ EVAL  [Nil$2@{}]990186
//│ [mono] └ EVAL  [Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]631787}]359428
//│ [mono] comparing [Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012 with [Nil$2@{} | Cons$1@{e: [*LIT*]566055, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]47299} | Nil$2@{}]642012]631787}]359428
//│ [mono] generate: (([*LIT*]566055,100000)) -> *1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]631787} | Nil$2@{}]359428 @{main$$3, generate}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] gen$Cons$1: ([Cons$1@{e: [*LIT*]285710, tail: [*1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]631787} | Nil$2@{}]359428]734933}]141521) -> *3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794
//│ [mono] gen$Nil$2: ([Nil$2@{}]877701) -> *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774
//│ [mono] main$$3: () -> *2*=[*3*=[Cons$1@{e: [*LIT*]144235, tail: [*3*=... | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]166361}]134794 | *4*=[Cons$1@{e: [0]413996, tail: [Nil$2@{}]877701}]244774]233330
//│ [mono] generate: ([*LIT*]566055) -> *1*=[Cons$1@{e: [*LIT*]566055, tail: [*1*=...]631787} | Nil$2@{}]359428

// :mono
class List(e, tail) {
  fun map(f) = new List(f(e), tail.map(f))
  fun count() = 1 + tail.count()
}
class Nil() {
  fun map(f) = this
  fun count() = 0
}
fun add2(x) = x+2
(new List(1, new List(2, new Nil()))).map(x => x+1).map(x => add2(x))
//│ |#class| |List|(|e|,| |tail|)| |{|→|#fun| |map|(|f|)| |#=| |#new| |List|(|f|(|e|)|,| |tail|.map|(|f|)|)|↵|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |map|(|f|)| |#=| |this|↵|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |add2|(|x|)| |#=| |x|+|2|↵|(|#new| |List|(|1|,| |#new| |List|(|2|,| |#new| |Nil|(||)|)|)|)|.map|(|x| |=>| |x|+|1|)|.map|(|x| |=>| |add2|(|x|)|)|
//│ Parsed: {class List(e, tail,) {fun map = f, => new List(f (e,), (tail).map (f,),) {}; fun count =  => + (1,) ((tail).count (),)}; class Nil() {fun map = f, => this; fun count =  => 0}; fun add2 = x, => + (x,) (2,); (('(' new List(1, new List(2, new Nil() {},) {},) {}, ')').map (x, => + (x,) (1,),)).map (x, => add2 (x,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, map, [], Lam(Tup(_: Var(f)), New(Some((TypeName(List),f (e,), (tail).map (f,),)), TypingUnit(List())))), NuFunDef(None, count, [], Lam(Tup(), App(App(Var(+), Tup(_: IntLit(1))), Tup(_: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, map, [], Lam(Tup(_: Var(f)), Var(this))), NuFunDef(None, count, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, add2, [], Lam(Tup(_: Var(x)), App(App(Var(+), Tup(_: Var(x))), Tup(_: IntLit(2))))), App(Sel(App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(List),1, new List(2, new Nil() {},) {},)), TypingUnit(List())))), map), Tup(_: Lam(Tup(_: Var(x)), App(App(Var(+), Tup(_: Var(x))), Tup(_: IntLit(1)))))), map), Tup(_: Lam(Tup(_: Var(x)), App(Var(add2), Tup(_: Var(x)))))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(e, tail,) {
//│     fun map = f, => new List$1(f ((this).e,), ((this).tail).map (f,),) {}
//│     fun count =  => + (1,) (((this).tail).count (),)
//│   }
//│   class Nil$2() {fun map = f, => this; fun count =  => 0}
//│   class Lambda1$1$3() {fun apply = x, => + (x,) (1,)}
//│   class Lambda1$2$4() {fun apply = x, => add2 (x,)}
//│   fun add2 = x, => + (x,) (2,)
//│   Code(List((('(' new List$1(1, new List$1(2, new Nil$2() {},) {},) {}, ')').map ({new Lambda1$1$3() {}},)).map ({new Lambda1$2$4() {}},)))
//│ }

//|     f match {
//|       case obj: Lambda1$1$3 => apply$Lambda1$1$3(obj, this.e); 
//|       case obj: Lambda1$2$4 => apply$Lambda1$2$4(obj, this.e)
//|     }, 
//|    this.tail match {
//|       case obj: Nil$2 => map$Nil$2(obj, f); 
//|       case obj: List$1 => map$List$1(obj, f)
//|     }
//|   ) 
//|     case obj: List$1 => map$List$1(obj, new Lambda1$1$3 () )
//|   } match {
//|     case obj: List$1 => map$List$1(obj, new Lambda1$2$4 () )
//|   }



// :mono
class List(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
fun foo(x) = x.count()
fun generate(x) = 
  if x > 0 then new List(x, generate(x+1)) else new Nil()
foo(new List(1, new List(2, new Nil())))
foo(generate(1))
//│ |#class| |List|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |x|.count|(||)|↵|#fun| |generate|(|x|)| |#=| |→|#if| |x| |>| |0| |#then| |#new| |List|(|x|,| |generate|(|x|+|1|)|)| |#else| |#new| |Nil|(||)|←|↵|foo|(|#new| |List|(|1|,| |#new| |List|(|2|,| |#new| |Nil|(||)|)|)|)|↵|foo|(|generate|(|1|)|)|
//│ Parsed: {class List(e, tail,) {fun count =  => + (1,) ((tail).count (),)}; class Nil() {fun count =  => 0}; fun foo = x, => (x).count (); fun generate = x, => {if (> (x,) (0,)) then new List(x, generate (+ (x,) (1,),),) {} else new Nil() {}}; foo (new List(1, new List(2, new Nil() {},) {},) {},); foo (generate (1,),)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), App(App(Var(+), Tup(_: IntLit(1))), Tup(_: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), IntLit(0))))), NuFunDef(None, foo, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), count), Tup()))), NuFunDef(None, generate, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: New(Some((TypeName(List),1, new List(2, new Nil() {},) {},)), TypingUnit(List())))), App(Var(foo), Tup(_: App(Var(generate), Tup(_: IntLit(1))))))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(e, tail,) {fun count =  => + (1,) (((this).tail).count (),)}
//│   class Nil$2() {fun count =  => 0}
//│   fun foo = x, => (x).count ()
//│   fun generate = x, => {if (> (x,) (0,)) then new List$1(x, generate (+ (x,) (1,),),) {} else new Nil$2() {}}
//│   Code(List(foo (new List$1(1, new List$1(2, new Nil$2() {},) {},) {},)))
//│   Code(List(foo (generate (1,),)))
//│ }

:mono
fun foo(x) = 
  (f => f(x))(z => z+1)
foo(2)
//│ |#fun| |foo|(|x|)| |#=| |→|(|f| |=>| |f|(|x|)|)|(|z| |=>| |z|+|1|)|←|↵|foo|(|2|)|
//│ Parsed: {fun foo = x, => {'(' f, => f (x,), ')' (z, => + (z,) (1,),)}; foo (2,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$1$1(x,) {fun apply = f, => f ((this).x,)}
//│   class Lambda1$2$2() {fun apply = z, => + (z,) (1,)}
//│   fun foo = x, => {'(' {new Lambda1$1$1(x,) {}}, ')' ({new Lambda1$2$2() {}},)}
//│   Code(List(foo (2,)))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$3()
//│ fun apply$Lambda1$1$1(this, f) =
//│   f match {case obj: Lambda1$2$2 => apply$Lambda1$2$2(obj, this.x)}
//│ fun foo(x) =
//│   new Lambda1$1$1 (x)  match {case obj: Lambda1$1$1 => apply$Lambda1$1$1(obj, new Lambda1$2$2 () )}
//│ fun main$$3() =
//│   foo(#2)
//│ fun apply$Lambda1$2$2(this, z) =
//│   (z + #1)
//│ class Lambda1$1$1(x) {
//│ }
//│ class Lambda1$2$2() {
//│ }
//│ [mono] ┌───┬─────────────────────────────────────────────────┐
//│ │ 1 │ main$$3()                                       │
//│ │ 2 │ fun foo(x) =                                    │
//│ │ 3 │   (new Lambda1$1$1 (x) , )(new Lambda1$2$2 () ) │
//│ │ 4 │ fun main$$3() =                                 │
//│ │ 5 │   foo(#2)                                       │
//│ │ 6 │ class Lambda1$1$1(x) {                          │
//│ │ 7 │ }                                               │
//│ │ 8 │ class Lambda1$2$2() {                           │
//│ │ 9 │ }                                               │
//│ └───┴─────────────────────────────────────────────────┘
//│ [mono] evaluating main$$3, rests: HashSet()
//│ [mono] ========== updating main$$3 ==========
//│ [mono] main$$3: () -> *6*=[*6*=...]972540 @{}
//│ [mono] ┌ EVAL  foo(#2)
//│ [mono] │ ┌ EVAL  foo
//│ [mono] │ └ EVAL  [foo(x) given {}]292788
//│ [mono] │ ┌ EVAL  #2
//│ [mono] │ └ EVAL  [2]44328
//│ [mono] │ ┌ SPEC CALL foo with ([2]44328)
//│ [mono] │ │ comparing (([]249361,0)) with (Plain([2]884782))
//│ [mono] │ │ first time encounter foo
//│ [mono] │ │ evaluating foo, rests: HashSet()
//│ [mono] │ │ ========== updating foo ==========
//│ [mono] │ │ foo: (([2]884782,1)) -> *5*=[*5*=...]221469 @{main$$3}
//│ [mono] │ │ ┌ EVAL  (new Lambda1$1$1 (x) , )(new Lambda1$2$2 () )
//│ [mono] │ │ │ ┌ EVAL  (new Lambda1$1$1 (x) , )(new Lambda1$2$2 () )
//│ [mono] │ │ │ │ ┌ EVAL  (new Lambda1$1$1 (x) , )
//│ [mono] │ │ │ │ │ ┌ EVAL  new Lambda1$1$1 (x) 
//│ [mono] │ │ │ │ │ │ ┌ EVAL  new Lambda1$1$1 (x) 
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [2]884782
//│ [mono] │ │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [2]884782}]241619
//│ [mono] │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [2]884782}]241619
//│ [mono] │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [2]884782}]241619
//│ [mono] │ │ │ │ ┌ EVAL  new Lambda1$2$2 () 
//│ [mono] │ │ │ │ │ ┌ EVAL  new Lambda1$2$2 () 
//│ [mono] │ │ │ │ │ └ EVAL  [Lambda1$2$2@{}]748878
//│ [mono] │ │ │ │ └ EVAL  [Lambda1$2$2@{}]748878
//│ [mono] │ │ │ │ ┌ SPEC CALL apply$Lambda1$1$1 with ([Lambda1$1$1@{x: [2]884782}]318593, [Lambda1$2$2@{}]748878)
//│ [mono] │ │ │ │ │ comparing (([]844284,0), ([]374495,0)) with (Plain([Lambda1$1$1@{x: [2]884782}]890026), Plain([Lambda1$2$2@{}]97477))
//│ [mono] │ │ │ │ │ first time encounter apply$Lambda1$1$1
//│ [mono] │ │ │ │ │ evaluating apply$Lambda1$1$1, rests: HashSet()
//│ [mono] │ │ │ │ │ ========== updating apply$Lambda1$1$1 ==========
//│ [mono] │ │ │ │ │ apply$Lambda1$1$1: (([Lambda1$1$1@{x: [2]884782}]890026,2) X ([Lambda1$2$2@{}]97477,1)) -> *7*=[*7*=...]154467 @{foo}
//│ [mono] │ │ │ │ │ ┌ EVAL  f(this.x)
//│ [mono] │ │ │ │ │ │ ┌ EVAL  f
//│ [mono] │ │ │ │ │ │ └ EVAL  [Lambda1$2$2@{}]97477
//│ [mono] │ │ │ │ │ │ ┌ EVAL  this.x
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [2]884782}]890026
//│ [mono] │ │ │ │ │ │ └ EVAL  [2]124143
//│ [mono] │ │ │ │ │ │ ┌ SPEC CALL apply$Lambda1$2$2 with ([Lambda1$2$2@{}]965309, [2]124143)
//│ [mono] │ │ │ │ │ │ │ comparing (([]522878,0), ([]246758,0)) with (Plain([Lambda1$2$2@{}]151341), Plain([2]679883))
//│ [mono] │ │ │ │ │ │ │ first time encounter apply$Lambda1$2$2
//│ [mono] │ │ │ │ │ │ │ evaluating apply$Lambda1$2$2, rests: HashSet()
//│ [mono] │ │ │ │ │ │ │ ========== updating apply$Lambda1$2$2 ==========
//│ [mono] │ │ │ │ │ │ │ apply$Lambda1$2$2: (([Lambda1$2$2@{}]151341,1) X ([2]679883,1)) -> *8*=[*8*=...]427103 @{apply$Lambda1$1$1}
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  (z + #1)
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  z
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [2]679883
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [1]447076
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [3]329135
//│ [mono] │ │ │ │ │ │ │ comparing [*8*=...]427103 with [3]329135
//│ [mono] │ │ │ │ │ │ │ apply$Lambda1$2$2: (([Lambda1$2$2@{}]151341,1) X ([2]679883,1)) -> *8*=[3]329135 @{apply$Lambda1$1$1}
//│ [mono] │ │ │ │ │ │ └ SPEC CALL [*8*=[3]329135]597991
//│ [mono] │ │ │ │ │ │ call result: [*8*=[3]329135]597991
//│ [mono] │ │ │ │ │ │ merging []963048 with [*8*=[3]329135]597991
//│ [mono] │ │ │ │ │ │ result [*8*=[3]329135]570854
//│ [mono] │ │ │ │ │ └ EVAL  [*8*=[3]329135]570854
//│ [mono] │ │ │ │ │ comparing [*7*=...]154467 with [*8*=[3]329135]570854
//│ [mono] │ │ │ │ │ apply$Lambda1$1$1: (([Lambda1$1$1@{x: [2]884782}]890026,2) X ([Lambda1$2$2@{}]97477,1)) -> *7*=[*8*=[3]329135]570854 @{foo}
//│ [mono] │ │ │ │ └ SPEC CALL [*7*=[*8*=[3]329135]570854]518807
//│ [mono] │ │ │ │ call result: [*7*=[*8*=[3]329135]570854]518807
//│ [mono] │ │ │ │ merging []524013 with [*7*=[*8*=[3]329135]570854]518807
//│ [mono] │ │ │ │ result [*7*=[*8*=[3]329135]570854]58141
//│ [mono] │ │ │ └ EVAL  [*7*=[*8*=[3]329135]570854]58141
//│ [mono] │ │ └ EVAL  [*7*=[*8*=[3]329135]570854]58141
//│ [mono] │ │ comparing [*5*=...]221469 with [*7*=[*8*=[3]329135]570854]58141
//│ [mono] │ │ foo: (([2]884782,1)) -> *5*=[*7*=[*8*=[3]329135]570854]58141 @{main$$3}
//│ [mono] │ └ SPEC CALL [*5*=[*7*=[*8*=[3]329135]570854]58141]733948
//│ [mono] │ call result: [*5*=[*7*=[*8*=[3]329135]570854]58141]733948
//│ [mono] │ merging []860020 with [*5*=[*7*=[*8*=[3]329135]570854]58141]733948
//│ [mono] │ result [*5*=[*7*=[*8*=[3]329135]570854]58141]992452
//│ [mono] └ EVAL  [*5*=[*7*=[*8*=[3]329135]570854]58141]992452
//│ [mono] comparing [*6*=...]972540 with [*5*=[*7*=[*8*=[3]329135]570854]58141]992452
//│ [mono] main$$3: () -> *6*=[*5*=[*7*=[*8*=[3]329135]570854]58141]992452 @{}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] apply$Lambda1$1$1: ([Lambda1$1$1@{x: [2]884782}]890026 X [Lambda1$2$2@{}]97477) -> *7*=[*8*=[3]329135]570854
//│ [mono] foo: ([2]884782) -> *5*=[*7*=[*8*=[3]329135]570854]58141
//│ [mono] main$$3: () -> *6*=[*5*=[*7*=[*8*=[3]329135]570854]58141]992452
//│ [mono] apply$Lambda1$2$2: ([Lambda1$2$2@{}]151341 X [2]679883) -> *8*=[3]329135

:mono
fun f(x) =
  (y => f(x+y)).apply(x+1)
f(1)
//│ |#fun| |f|(|x|)| |#=|→|(|y| |=>| |f|(|x|+|y|)|)|.apply|(|x|+|1|)|←|↵|f|(|1|)|
//│ Parsed: {fun f = x, => {('(' y, => f (+ (x,) (y,),), ')').apply (+ (x,) (1,),)}; f (1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(f), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$1$1(x,) {fun apply = y, => f (+ ((this).x,) (y,),)}
//│   fun f = x, => {('(' {new Lambda1$1$1(x,) {}}, ')').apply (+ (x,) (1,),)}
//│   Code(List(f (1,)))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$2()
//│ fun apply$Lambda1$1$1(this, y) =
//│   f((this.x + y))
//│ fun f(x) =
//│   new Lambda1$1$1 (x)  match {case obj: Lambda1$1$1 => apply$Lambda1$1$1(obj, (x + #1))}
//│ fun main$$2() =
//│   f(#1)
//│ class Lambda1$1$1(x) {
//│ }
//│ [mono] ┌───┬────────────────────────────────────────────┐
//│ │ 1 │ main$$2()                                  │
//│ │ 2 │ fun f(x) =                                 │
//│ │ 3 │   (new Lambda1$1$1 (x) , ).apply((x + #1)) │
//│ │ 4 │ fun main$$2() =                            │
//│ │ 5 │   f(#1)                                    │
//│ │ 6 │ class Lambda1$1$1(x) {                     │
//│ │ 7 │ }                                          │
//│ └───┴────────────────────────────────────────────┘
//│ [mono] evaluating main$$2, rests: HashSet()
//│ [mono] ========== updating main$$2 ==========
//│ [mono] main$$2: () -> *10*=[*10*=...]263411 @{}
//│ [mono] ┌ EVAL  f(#1)
//│ [mono] │ ┌ EVAL  f
//│ [mono] │ └ EVAL  [f(x) given {}]652110
//│ [mono] │ ┌ EVAL  #1
//│ [mono] │ └ EVAL  [1]711504
//│ [mono] │ ┌ SPEC CALL f with ([1]711504)
//│ [mono] │ │ comparing (([]43423,0)) with (Plain([1]551120))
//│ [mono] │ │ first time encounter f
//│ [mono] │ │ evaluating f, rests: HashSet()
//│ [mono] │ │ ========== updating f ==========
//│ [mono] │ │ f: (([1]551120,1)) -> *9*=[*9*=...]272491 @{main$$2}
//│ [mono] │ │ ┌ EVAL  (new Lambda1$1$1 (x) , ).apply((x + #1))
//│ [mono] │ │ │ ┌ EVAL  (new Lambda1$1$1 (x) , ).apply((x + #1))
//│ [mono] │ │ │ │ ┌ EVAL  (new Lambda1$1$1 (x) , ).apply
//│ [mono] │ │ │ │ │ ┌ EVAL  (new Lambda1$1$1 (x) , )
//│ [mono] │ │ │ │ │ │ ┌ EVAL  new Lambda1$1$1 (x) 
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  new Lambda1$1$1 (x) 
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [1]551120
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [1]551120}]260519
//│ [mono] │ │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [1]551120}]260519
//│ [mono] │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [1]551120}]260519
//│ [mono] │ │ │ │ └ EVAL  [apply$Lambda1$1$1(y) given {this: [Lambda1$1$1@{x: [1]551120}]70265}]125057
//│ [mono] │ │ │ │ ┌ EVAL  (x + #1)
//│ [mono] │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ └ EVAL  [1]551120
//│ [mono] │ │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ │ └ EVAL  [1]850514
//│ [mono] │ │ │ │ └ EVAL  [2]225064
//│ [mono] │ │ │ │ ┌ SPEC CALL apply$Lambda1$1$1 with ([Lambda1$1$1@{x: [1]551120}]70265, [2]225064)
//│ [mono] │ │ │ │ │ comparing (([]331078,0), ([]317254,0)) with (Plain([Lambda1$1$1@{x: [1]551120}]899673), Plain([2]885273))
//│ [mono] │ │ │ │ │ first time encounter apply$Lambda1$1$1
//│ [mono] │ │ │ │ │ evaluating apply$Lambda1$1$1, rests: HashSet()
//│ [mono] │ │ │ │ │ ========== updating apply$Lambda1$1$1 ==========
//│ [mono] │ │ │ │ │ apply$Lambda1$1$1: (([Lambda1$1$1@{x: [1]551120}]899673,2) X ([2]885273,1)) -> *11*=[*11*=...]628892 @{f}
//│ [mono] │ │ │ │ │ ┌ EVAL  f((this.x + y))
//│ [mono] │ │ │ │ │ │ ┌ EVAL  f
//│ [mono] │ │ │ │ │ │ └ EVAL  [f(x) given {}]710076
//│ [mono] │ │ │ │ │ │ ┌ EVAL  (this.x + y)
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  this.x
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [Lambda1$1$1@{x: [1]551120}]899673
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [1]546668
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  y
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [2]885273
//│ [mono] │ │ │ │ │ │ └ EVAL  [3]620274
//│ [mono] │ │ │ │ │ │ ┌ SPEC CALL f with ([3]620274)
//│ [mono] │ │ │ │ │ │ │ comparing (([1]551120,1)) with (Plain([*LIT*]137338))
//│ [mono] │ │ │ │ │ │ │ find finer args
//│ [mono] │ │ │ │ │ │ └ SPEC CALL [*9*=[*9*=...]272491]118118
//│ [mono] │ │ │ │ │ │ call result: [*9*=[*9*=...]272491]118118
//│ [mono] │ │ │ │ │ │ merging []294569 with [*9*=[*9*=...]272491]118118
//│ [mono] │ │ │ │ │ │ result [*9*=[*9*=...]272491]493312
//│ [mono] │ │ │ │ │ └ EVAL  [*9*=[*9*=...]272491]493312
//│ [mono] │ │ │ │ │ comparing [*11*=...]628892 with [*9*=[*9*=...]272491]493312
//│ [mono] │ │ │ │ │ apply$Lambda1$1$1: (([Lambda1$1$1@{x: [1]551120}]899673,2) X ([2]885273,1)) -> *11*=[*9*=[*9*=...]272491]493312 @{f}
//│ [mono] │ │ │ │ └ SPEC CALL [*11*=[*9*=[*9*=...]272491]493312]410939
//│ [mono] │ │ │ │ call result: [*11*=[*9*=[*9*=...]272491]493312]410939
//│ [mono] │ │ │ │ merging []909038 with [*11*=[*9*=[*9*=...]272491]493312]410939
//│ [mono] │ │ │ │ result [*11*=[*9*=[*9*=...]272491]493312]350837
//│ [mono] │ │ │ └ EVAL  [*11*=[*9*=[*9*=...]272491]493312]350837
//│ [mono] │ │ └ EVAL  [*11*=[*9*=[*9*=...]272491]493312]350837
//│ [mono] │ │ comparing [*9*=...]272491 with [*11*=[*9*=[*9*=...]272491]493312]350837
//│ [mono] │ │ f: (([*LIT*]137338,100000)) -> *9*=[*11*=[*9*=...]493312]350837 @{main$$2, apply$Lambda1$1$1}
//│ [mono] │ └ SPEC CALL [*9*=[*11*=[*9*=...]493312]350837]49790
//│ [mono] │ call result: [*9*=[*11*=[*9*=...]493312]350837]49790
//│ [mono] │ merging []617696 with [*9*=[*11*=[*9*=...]493312]350837]49790
//│ [mono] │ result [*9*=[*11*=[*9*=...]493312]350837]43915
//│ [mono] └ EVAL  [*9*=[*11*=[*9*=...]493312]350837]43915
//│ [mono] comparing [*10*=...]263411 with [*9*=[*11*=[*9*=...]493312]350837]43915
//│ [mono] main$$2: () -> *10*=[*9*=[*11*=[*9*=...]493312]350837]43915 @{}
//│ [mono] evaluating f, rests: HashSet()
//│ [mono] ========== updating f ==========
//│ [mono] f: (([*LIT*]137338,100000)) -> *9*=[*11*=[*9*=...]493312]350837 @{main$$2, apply$Lambda1$1$1}
//│ [mono] ┌ EVAL  new Lambda1$1$1 (x) .apply((x + #1))
//│ [mono] │ ┌ EVAL  new Lambda1$1$1 (x) .apply
//│ [mono] │ │ ┌ EVAL  new Lambda1$1$1 (x) 
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [*LIT*]137338
//│ [mono] │ │ └ EVAL  [Lambda1$1$1@{x: [*LIT*]137338}]873892
//│ [mono] │ └ EVAL  [apply$Lambda1$1$1(y) given {this: [Lambda1$1$1@{x: [*LIT*]137338}]255015}]243686
//│ [mono] │ ┌ EVAL  (x + #1)
//│ [mono] │ │ ┌ EVAL  x
//│ [mono] │ │ └ EVAL  [*LIT*]137338
//│ [mono] │ │ ┌ EVAL  #1
//│ [mono] │ │ └ EVAL  [1]484532
//│ [mono] │ └ EVAL  [*LIT*]349816
//│ [mono] │ ┌ SPEC CALL apply$Lambda1$1$1 with ([Lambda1$1$1@{x: [*LIT*]137338}]255015, [*LIT*]349816)
//│ [mono] │ │ comparing (([Lambda1$1$1@{x: [1]551120}]899673,2), ([2]885273,1)) with (Plain([Lambda1$1$1@{x: [*LIT*]62147}]944362), Plain([*LIT*]621953))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL [*11*=[*9*=[*11*=...]350837]493312]198943
//│ [mono] │ call result: [*11*=[*9*=[*11*=...]350837]493312]198943
//│ [mono] │ merging []583841 with [*11*=[*9*=[*11*=...]350837]493312]198943
//│ [mono] │ result [*11*=[*9*=[*11*=...]350837]493312]422571
//│ [mono] └ EVAL  [*11*=[*9*=[*11*=...]350837]493312]422571
//│ [mono] comparing [*11*=[*9*=...]493312]350837 with [*11*=[*9*=[*11*=...]350837]493312]422571
//│ [mono] f: (([*LIT*]137338,100000)) -> *9*=[*11*=[*9*=...]493312]422571 @{main$$2, apply$Lambda1$1$1}
//│ [mono] evaluating apply$Lambda1$1$1, rests: HashSet()
//│ [mono] ========== updating apply$Lambda1$1$1 ==========
//│ [mono] apply$Lambda1$1$1: (([Lambda1$1$1@{x: [*LIT*]62147}]944362,100001) X ([*LIT*]621953,100000)) -> *11*=[*9*=[*11*=...]422571]493312 @{f}
//│ [mono] ┌ EVAL  f((this.x + y))
//│ [mono] │ ┌ EVAL  f
//│ [mono] │ └ EVAL  [f(x) given {}]539759
//│ [mono] │ ┌ EVAL  (this.x + y)
//│ [mono] │ │ ┌ EVAL  this.x
//│ [mono] │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ └ EVAL  [Lambda1$1$1@{x: [*LIT*]62147}]944362
//│ [mono] │ │ └ EVAL  [*LIT*]31983
//│ [mono] │ │ ┌ EVAL  y
//│ [mono] │ │ └ EVAL  [*LIT*]621953
//│ [mono] │ └ EVAL  [*LIT*]252249
//│ [mono] │ ┌ SPEC CALL f with ([*LIT*]252249)
//│ [mono] │ │ comparing (([*LIT*]137338,100000)) with (Plain([*LIT*]266429))
//│ [mono] │ └ SPEC CALL [*9*=[*11*=[*9*=...]493312]422571]665559
//│ [mono] │ call result: [*9*=[*11*=[*9*=...]493312]422571]665559
//│ [mono] │ merging []782169 with [*9*=[*11*=[*9*=...]493312]422571]665559
//│ [mono] │ result [*9*=[*11*=[*9*=...]493312]422571]449699
//│ [mono] └ EVAL  [*9*=[*11*=[*9*=...]493312]422571]449699
//│ [mono] comparing [*9*=[*11*=...]422571]493312 with [*9*=[*11*=[*9*=...]493312]422571]449699
//│ [mono] apply$Lambda1$1$1: (([Lambda1$1$1@{x: [*LIT*]62147}]944362,100001) X ([*LIT*]621953,100000)) -> *11*=[*9*=[*11*=...]422571]449699 @{f}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] apply$Lambda1$1$1: ([Lambda1$1$1@{x: [*LIT*]62147}]944362 X [*LIT*]621953) -> *11*=[*9*=[*11*=...]422571]449699
//│ [mono] f: ([*LIT*]137338) -> *9*=[*11*=[*9*=...]449699]422571
//│ [mono] main$$2: () -> *10*=[*9*=[*11*=[*9*=...]449699]422571]43915


:mono
fun f(x) = f(x)
f(0)
f(1)
//│ |#fun| |f|(|x|)| |#=| |f|(|x|)|↵|f|(|0|)|↵|f|(|1|)|
//│ Parsed: {fun f = x, => f (x,); f (0,); f (1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), App(Var(f), Tup(_: Var(x))))), App(Var(f), Tup(_: IntLit(0))), App(Var(f), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   fun f = x, => f (x,)
//│   Code(List(f (0,)))
//│   Code(List(f (1,)))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$1()
//│ main$$2()
//│ fun f(x) =
//│   f(x)
//│ fun main$$2() =
//│   f(#1)
//│ fun main$$1() =
//│   f(#0)
//│ [mono] ┌───┬─────────────────┐
//│ │ 1 │ main$$1()       │
//│ │ 2 │ main$$2()       │
//│ │ 3 │ fun f(x) =      │
//│ │ 4 │   f(x)          │
//│ │ 5 │ fun main$$2() = │
//│ │ 6 │   f(#1)         │
//│ │ 7 │ fun main$$1() = │
//│ │ 8 │   f(#0)         │
//│ └───┴─────────────────┘
//│ [mono] evaluating main$$2, rests: HashSet(main$$1)
//│ [mono] ========== updating main$$2 ==========
//│ [mono] main$$2: () -> *14*=[*14*=...]114427 @{}
//│ [mono] ┌ EVAL  f(#1)
//│ [mono] │ ┌ EVAL  f
//│ [mono] │ └ EVAL  [f(x) given {}]878353
//│ [mono] │ ┌ EVAL  #1
//│ [mono] │ └ EVAL  [1]317186
//│ [mono] │ ┌ SPEC CALL f with ([1]317186)
//│ [mono] │ │ comparing (([]498318,0)) with (Plain([1]240397))
//│ [mono] │ │ first time encounter f
//│ [mono] │ │ evaluating f, rests: HashSet(main$$1)
//│ [mono] │ │ ========== updating f ==========
//│ [mono] │ │ f: (([1]240397,1)) -> *12*=[*12*=...]683949 @{main$$2}
//│ [mono] │ │ ┌ EVAL  f(x)
//│ [mono] │ │ │ ┌ EVAL  f
//│ [mono] │ │ │ └ EVAL  [f(x) given {}]464149
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [1]240397
//│ [mono] │ │ │ ┌ SPEC CALL f with ([1]240397)
//│ [mono] │ │ │ │ comparing (([1]240397,1)) with (Plain([1]240397))
//│ [mono] │ │ │ └ SPEC CALL [*12*=[*12*=...]683949]736838
//│ [mono] │ │ │ call result: [*12*=[*12*=...]683949]736838
//│ [mono] │ │ │ merging []992352 with [*12*=[*12*=...]683949]736838
//│ [mono] │ │ │ result [*12*=[*12*=...]683949]258386
//│ [mono] │ │ └ EVAL  [*12*=[*12*=...]683949]258386
//│ [mono] │ │ comparing [*12*=...]683949 with [*12*=[*12*=...]683949]258386
//│ [mono] │ │ f: (([1]240397,1)) -> *12*=[*12*=...]258386 @{main$$2, f}
//│ [mono] │ └ SPEC CALL [*12*=[*12*=...]258386]262549
//│ [mono] │ call result: [*12*=[*12*=...]258386]262549
//│ [mono] │ merging []614422 with [*12*=[*12*=...]258386]262549
//│ [mono] │ result [*12*=[*12*=...]258386]136125
//│ [mono] └ EVAL  [*12*=[*12*=...]258386]136125
//│ [mono] comparing [*14*=...]114427 with [*12*=[*12*=...]258386]136125
//│ [mono] main$$2: () -> *14*=[*12*=[*12*=...]258386]136125 @{}
//│ [mono] evaluating main$$1, rests: HashSet()
//│ [mono] ========== updating main$$1 ==========
//│ [mono] main$$1: () -> *13*=[*13*=...]360724 @{}
//│ [mono] ┌ EVAL  f(#0)
//│ [mono] │ ┌ EVAL  f
//│ [mono] │ └ EVAL  [f(x) given {}]311634
//│ [mono] │ ┌ EVAL  #0
//│ [mono] │ └ EVAL  [0]971042
//│ [mono] │ ┌ SPEC CALL f with ([0]971042)
//│ [mono] │ │ comparing (([1]240397,1)) with (Plain([*LIT*]435420))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL [*12*=[*12*=...]258386]981428
//│ [mono] │ call result: [*12*=[*12*=...]258386]981428
//│ [mono] │ merging []487067 with [*12*=[*12*=...]258386]981428
//│ [mono] │ result [*12*=[*12*=...]258386]655301
//│ [mono] └ EVAL  [*12*=[*12*=...]258386]655301
//│ [mono] comparing [*13*=...]360724 with [*12*=[*12*=...]258386]655301
//│ [mono] main$$1: () -> *13*=[*12*=[*12*=...]258386]655301 @{}
//│ [mono] evaluating f, rests: HashSet()
//│ [mono] ========== updating f ==========
//│ [mono] f: (([*LIT*]435420,100000)) -> *12*=[*12*=...]258386 @{main$$2, f, main$$1}
//│ [mono] ┌ EVAL  f(x)
//│ [mono] │ ┌ EVAL  f
//│ [mono] │ └ EVAL  [f(x) given {}]209798
//│ [mono] │ ┌ EVAL  x
//│ [mono] │ └ EVAL  [*LIT*]435420
//│ [mono] │ ┌ SPEC CALL f with ([*LIT*]435420)
//│ [mono] │ │ comparing (([*LIT*]435420,100000)) with (Plain([*LIT*]435420))
//│ [mono] │ └ SPEC CALL [*12*=[*12*=...]258386]550649
//│ [mono] │ call result: [*12*=[*12*=...]258386]550649
//│ [mono] │ merging []375204 with [*12*=[*12*=...]258386]550649
//│ [mono] │ result [*12*=[*12*=...]258386]123356
//│ [mono] └ EVAL  [*12*=[*12*=...]258386]123356
//│ [mono] comparing [*12*=...]258386 with [*12*=[*12*=...]258386]123356
//│ [mono] f: (([*LIT*]435420,100000)) -> *12*=[*12*=...]123356 @{main$$2, f, main$$1}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] f: ([*LIT*]435420) -> *12*=[*12*=...]123356
//│ [mono] main$$2: () -> *14*=[*12*=[*12*=...]123356]136125
//│ [mono] main$$1: () -> *13*=[*12*=[*12*=...]123356]655301

:mono
class Cons(e, tail) {
  fun count() = 1 + tail.count()
}
class Nil() {
  fun count() = 0
}
class Lambda(){
  fun apply(l) = 
    l.count()
}
class Lambda2(a){
  fun apply(l) = 
    (new Cons(a, l)).count()
}
fun foo(x) = 
  x.apply(new Cons(1, new Nil())) + x.apply(new Nil())
foo(new Lambda())
foo(new Lambda2(2))
//│ |#class| |Cons|(|e|,| |tail|)| |{|→|#fun| |count|(||)| |#=| |1| |+| |tail|.count|(||)|←|↵|}|↵|#class| |Nil|(||)| |{|→|#fun| |count|(||)| |#=| |0|←|↵|}|↵|#class| |Lambda|(||)|{|→|#fun| |apply|(|l|)| |#=| |→|l|.count|(||)|←|←|↵|}|↵|#class| |Lambda2|(|a|)|{|→|#fun| |apply|(|l|)| |#=| |→|(|#new| |Cons|(|a|,| |l|)|)|.count|(||)|←|←|↵|}|↵|#fun| |foo|(|x|)| |#=| |→|x|.apply|(|#new| |Cons|(|1|,| |#new| |Nil|(||)|)|)| |+| |x|.apply|(|#new| |Nil|(||)|)|←|↵|foo|(|#new| |Lambda|(||)|)|↵|foo|(|#new| |Lambda2|(|2|)|)|
//│ Parsed: {class Cons(e, tail,) {fun count =  => + (1,) ((tail).count (),)}; class Nil() {fun count =  => 0}; class Lambda() {fun apply = l, => {(l).count ()}}; class Lambda2(a,) {fun apply = l, => {('(' new Cons(a, l,) {}, ')').count ()}}; fun foo = x, => {+ ((x).apply (new Cons(1, new Nil() {},) {},),) ((x).apply (new Nil() {},),)}; foo (new Lambda() {},); foo (new Lambda2(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Cons, (), Tup(_: Var(e), _: Var(tail)), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), App(App(Var(+), Tup(_: IntLit(1))), Tup(_: App(Sel(Var(tail), count), Tup()))))))), NuTypeDef(class, Nil, (), Tup(), (), TypingUnit(NuFunDef(None, count, [], Lam(Tup(), IntLit(0))))), NuTypeDef(class, Lambda, (), Tup(), (), TypingUnit(NuFunDef(None, apply, [], Lam(Tup(_: Var(l)), Blk(...))))), NuTypeDef(class, Lambda2, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, apply, [], Lam(Tup(_: Var(l)), Blk(...))))), NuFunDef(None, foo, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(foo), Tup(_: New(Some((TypeName(Lambda),)), TypingUnit(List())))), App(Var(foo), Tup(_: New(Some((TypeName(Lambda2),2,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   class Cons$1(e, tail,) {fun count =  => + (1,) (((this).tail).count (),)}
//│   class Nil$2() {fun count =  => 0}
//│   class Lambda$3() {fun apply = l, => {(l).count ()}}
//│   class Lambda2$4(a,) {
//│     fun apply = l, => {('(' new Cons$1((this).a, l,) {}, ')').count ()}
//│   }
//│   fun foo = x, => {+ ((x).apply (new Cons$1(1, new Nil$2() {},) {},),) ((x).apply (new Nil$2() {},),)}
//│   Code(List(foo (new Lambda$3() {},)))
//│   Code(List(foo (new Lambda2$4(2,) {},)))
//│ }
//│ Mono:
//│ 
//│ Mono result: 
//│ main$$5()
//│ main$$6()
//│ fun count$Cons$1(this) =
//│   (#1 + this.tail match {case obj: Nil$2 => count$Nil$2(obj); case obj: Cons$1 => count$Cons$1(obj)})
//│ fun apply$Lambda$3(this, l) =
//│   l match {case obj: Cons$1 => count$Cons$1(obj); case obj: Nil$2 => count$Nil$2(obj)}
//│ fun count$Nil$2(this) =
//│   #0
//│ fun foo(x) =
//│   (x match {case obj: Lambda$3 => apply$Lambda$3(obj, new Cons$1 (#1, new Nil$2 () ) ); case obj: Lambda2$4 => apply$Lambda2$4(obj, new Cons$1 (#1, new Nil$2 () ) )} + x match {case obj: Lambda$3 => apply$Lambda$3(obj, new Nil$2 () ); case obj: Lambda2$4 => apply$Lambda2$4(obj, new Nil$2 () )})
//│ fun apply$Lambda2$4(this, l) =
//│   new Cons$1 (this.a, l)  match {case obj: Cons$1 => count$Cons$1(obj)}
//│ fun main$$6() =
//│   foo(new Lambda2$4 (#2) )
//│ fun main$$5() =
//│   foo(new Lambda$3 () )
//│ class Nil$2() {
//│ }
//│ class Lambda2$4(a) {
//│ }
//│ class Cons$1(e, tail) {
//│ }
//│ class Lambda$3() {
//│ }
//│ [mono] ┌────┬───────────────────────────────────────────────────────────────────────┐
//│ │ 1 │ main$$5()                                                             │
//│ │ 2 │ main$$6()                                                             │
//│ │ 3 │ fun foo(x) =                                                          │
//│ │ 4 │   (x.apply(new Cons$1 (#1, new Nil$2 () ) ) + x.apply(new Nil$2 () )) │
//│ │ 5 │ fun main$$6() =                                                       │
//│ │ 6 │   foo(new Lambda2$4 (#2) )                                            │
//│ │ 7 │ fun main$$5() =                                                       │
//│ │ 8 │   foo(new Lambda$3 () )                                               │
//│ │ 9 │ class Nil$2() {                                                       │
//│ │ 10 │ }                                                                     │
//│ │ 11 │ class Lambda2$4(a) {                                                  │
//│ │ 12 │ }                                                                     │
//│ │ 13 │ class Cons$1(e, tail) {                                               │
//│ │ 14 │ }                                                                     │
//│ │ 15 │ class Lambda$3() {                                                    │
//│ │ 16 │ }                                                                     │
//│ └────┴───────────────────────────────────────────────────────────────────────┘
//│ [mono] evaluating main$$6, rests: HashSet(main$$5)
//│ [mono] ========== updating main$$6 ==========
//│ [mono] main$$6: () -> *17*=[*17*=...]135615 @{}
//│ [mono] ┌ EVAL  foo(new Lambda2$4 (#2) )
//│ [mono] │ ┌ EVAL  foo
//│ [mono] │ └ EVAL  [foo(x) given {}]490848
//│ [mono] │ ┌ EVAL  new Lambda2$4 (#2) 
//│ [mono] │ │ ┌ EVAL  #2
//│ [mono] │ │ └ EVAL  [2]752278
//│ [mono] │ └ EVAL  [Lambda2$4@{a: [2]752278}]743793
//│ [mono] │ ┌ SPEC CALL foo with ([Lambda2$4@{a: [2]752278}]743793)
//│ [mono] │ │ comparing (([]205038,0)) with (Plain([Lambda2$4@{a: [2]752278}]622915))
//│ [mono] │ │ first time encounter foo
//│ [mono] │ │ evaluating foo, rests: HashSet(main$$5)
//│ [mono] │ │ ========== updating foo ==========
//│ [mono] │ │ foo: (([Lambda2$4@{a: [2]752278}]622915,2)) -> *15*=[*15*=...]11760 @{main$$6}
//│ [mono] │ │ ┌ EVAL  (x.apply(new Cons$1 (#1, new Nil$2 () ) ) + x.apply(new Nil$2 () ))
//│ [mono] │ │ │ ┌ EVAL  (x.apply(new Cons$1 (#1, new Nil$2 () ) ) + x.apply(new Nil$2 () ))
//│ [mono] │ │ │ │ ┌ EVAL  x.apply(new Cons$1 (#1, new Nil$2 () ) )
//│ [mono] │ │ │ │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ └ EVAL  [Lambda2$4@{a: [2]752278}]622915
//│ [mono] │ │ │ │ │ └ EVAL  [apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]112002}]760449
//│ [mono] │ │ │ │ │ ┌ EVAL  new Cons$1 (#1, new Nil$2 () ) 
//│ [mono] │ │ │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ │ │ └ EVAL  [1]224258
//│ [mono] │ │ │ │ │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ │ │ │ │ └ EVAL  [Nil$2@{}]644816
//│ [mono] │ │ │ │ │ └ EVAL  [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]606578
//│ [mono] │ │ │ │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]112002, [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]606578)
//│ [mono] │ │ │ │ │ │ comparing (([]184127,0), ([]757322,0)) with (Plain([Lambda2$4@{a: [2]752278}]258791), Plain([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571))
//│ [mono] │ │ │ │ │ │ first time encounter apply$Lambda2$4
//│ [mono] │ │ │ │ │ │ evaluating apply$Lambda2$4, rests: HashSet(main$$5)
//│ [mono] │ │ │ │ │ │ ========== updating apply$Lambda2$4 ==========
//│ [mono] │ │ │ │ │ │ apply$Lambda2$4: (([Lambda2$4@{a: [2]752278}]258791,2) X ([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571,3)) -> *18*=[*18*=...]325416 @{foo}
//│ [mono] │ │ │ │ │ │ ┌ EVAL  (new Cons$1 (this.a, l) , ).count()
//│ [mono] │ │ │ │ │ │ │ ┌ EVAL  (new Cons$1 (this.a, l) , ).count()
//│ [mono] │ │ │ │ │ │ │ │ ┌ EVAL  (new Cons$1 (this.a, l) , ).count
//│ [mono] │ │ │ │ │ │ │ │ │ ┌ EVAL  (new Cons$1 (this.a, l) , )
//│ [mono] │ │ │ │ │ │ │ │ │ │ ┌ EVAL  new Cons$1 (this.a, l) 
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this.a
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [Lambda2$4@{a: [2]752278}]258791
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [2]414137
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  l
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571
//│ [mono] │ │ │ │ │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]202264
//│ [mono] │ │ │ │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]202264
//│ [mono] │ │ │ │ │ │ │ │ └ EVAL  [count$Cons$1() given {this: [Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]469034}]762670
//│ [mono] │ │ │ │ │ │ │ │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]469034)
//│ [mono] │ │ │ │ │ │ │ │ │ comparing (([]624201,0)) with (Plain([Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]240592))
//│ [mono] │ │ │ │ │ │ │ │ │ first time encounter count$Cons$1
//│ [mono] │ │ │ │ │ │ │ │ │ evaluating count$Cons$1, rests: HashSet(main$$5)
//│ [mono] │ │ │ │ │ │ │ │ │ ========== updating count$Cons$1 ==========
//│ [mono] │ │ │ │ │ │ │ │ │ count$Cons$1: (([Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]240592,5)) -> *19*=[*19*=...]579205 @{apply$Lambda2$4}
//│ [mono] │ │ │ │ │ │ │ │ │ ┌ EVAL  (#1 + this.tail.count())
//│ [mono] │ │ │ │ │ │ │ │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ │ │ │ │ │ │ │ └ EVAL  [1]754681
//│ [mono] │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this.tail.count()
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this.tail.count
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]240592
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]407077
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ └ EVAL  [count$Cons$1() given {this: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]62302}]807916
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]62302)
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ comparing (([Cons$1@{e: [2]414137, tail: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571}]240592,5)) with (Plain([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965))
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ │ find finer args
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ └ SPEC CALL [*19*=[*19*=...]579205]73107
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ call result: [*19*=[*19*=...]579205]73107
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ merging []606375 with [*19*=[*19*=...]579205]73107
//│ [mono] │ │ │ │ │ │ │ │ │ │ │ result [*19*=[*19*=...]579205]716762
//│ [mono] │ │ │ │ │ │ │ │ │ │ └ EVAL  [*19*=[*19*=...]579205]716762
//│ [mono] │ │ │ │ │ │ │ │ │ └ EVAL  [*LIT*]636435
//│ [mono] │ │ │ │ │ │ │ │ │ comparing [*19*=...]579205 with [*LIT*]636435
//│ [mono] │ │ │ │ │ │ │ │ │ adding these funcs to queue: Set(apply$Lambda2$4, count$Cons$1)
//│ [mono] │ │ │ │ │ │ │ │ │ count$Cons$1: (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) -> *19*=[*LIT*]636435 @{apply$Lambda2$4, count$Cons$1}
//│ [mono] │ │ │ │ │ │ │ │ └ SPEC CALL [*19*=[*LIT*]636435]475732
//│ [mono] │ │ │ │ │ │ │ │ call result: [*19*=[*LIT*]636435]475732
//│ [mono] │ │ │ │ │ │ │ │ merging []889370 with [*19*=[*LIT*]636435]475732
//│ [mono] │ │ │ │ │ │ │ │ result [*19*=[*LIT*]636435]780388
//│ [mono] │ │ │ │ │ │ │ └ EVAL  [*19*=[*LIT*]636435]780388
//│ [mono] │ │ │ │ │ │ └ EVAL  [*19*=[*LIT*]636435]780388
//│ [mono] │ │ │ │ │ │ comparing [*18*=...]325416 with [*19*=[*LIT*]636435]780388
//│ [mono] │ │ │ │ │ │ apply$Lambda2$4: (([Lambda2$4@{a: [2]752278}]258791,2) X ([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571,3)) -> *18*=[*19*=[*LIT*]636435]780388 @{foo}
//│ [mono] │ │ │ │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]636435]780388]749644
//│ [mono] │ │ │ │ │ call result: [*18*=[*19*=[*LIT*]636435]780388]749644
//│ [mono] │ │ │ │ │ merging []80780 with [*18*=[*19*=[*LIT*]636435]780388]749644
//│ [mono] │ │ │ │ │ result [*18*=[*19*=[*LIT*]636435]780388]819398
//│ [mono] │ │ │ │ └ EVAL  [*18*=[*19*=[*LIT*]636435]780388]819398
//│ [mono] │ │ │ │ ┌ EVAL  x.apply(new Nil$2 () )
//│ [mono] │ │ │ │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ │ │ │ └ EVAL  [Lambda2$4@{a: [2]752278}]622915
//│ [mono] │ │ │ │ │ └ EVAL  [apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]577458}]352590
//│ [mono] │ │ │ │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ │ │ │ └ EVAL  [Nil$2@{}]906549
//│ [mono] │ │ │ │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]577458, [Nil$2@{}]906549)
//│ [mono] │ │ │ │ │ │ comparing (([Lambda2$4@{a: [2]752278}]258791,2), ([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]236571,3)) with (Plain([Lambda2$4@{a: [2]752278}]91381), Plain([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016))
//│ [mono] │ │ │ │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]636435]780388]193076
//│ [mono] │ │ │ │ │ call result: [*18*=[*19*=[*LIT*]636435]780388]193076
//│ [mono] │ │ │ │ │ merging []687883 with [*18*=[*19*=[*LIT*]636435]780388]193076
//│ [mono] │ │ │ │ │ result [*18*=[*19*=[*LIT*]636435]780388]314840
//│ [mono] │ │ │ │ └ EVAL  [*18*=[*19*=[*LIT*]636435]780388]314840
//│ [mono] │ │ │ └ EVAL  [*LIT*]67195
//│ [mono] │ │ └ EVAL  [*LIT*]67195
//│ [mono] │ │ comparing [*15*=...]11760 with [*LIT*]67195
//│ [mono] │ │ adding these funcs to queue: Set(main$$6)
//│ [mono] │ │ foo: (([Lambda2$4@{a: [2]752278}]622915,2)) -> *15*=[*LIT*]67195 @{main$$6}
//│ [mono] │ └ SPEC CALL [*15*=[*LIT*]67195]546539
//│ [mono] │ call result: [*15*=[*LIT*]67195]546539
//│ [mono] │ merging []239270 with [*15*=[*LIT*]67195]546539
//│ [mono] │ result [*15*=[*LIT*]67195]203295
//│ [mono] └ EVAL  [*15*=[*LIT*]67195]203295
//│ [mono] comparing [*17*=...]135615 with [*15*=[*LIT*]67195]203295
//│ [mono] main$$6: () -> *17*=[*15*=[*LIT*]67195]203295 @{}
//│ [mono] evaluating count$Cons$1, rests: HashSet(apply$Lambda2$4, main$$6, main$$5)
//│ [mono] ========== updating count$Cons$1 ==========
//│ [mono] count$Cons$1: (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) -> *19*=[*LIT*]636435 @{apply$Lambda2$4, count$Cons$1}
//│ [mono] ┌ EVAL  (#1 + this.tail.count())
//│ [mono] │ ┌ EVAL  #1
//│ [mono] │ └ EVAL  [1]710392
//│ [mono] │ ┌ EVAL  this.tail.count()
//│ [mono] │ │ ┌ EVAL  this.tail.count
//│ [mono] │ │ │ ┌ EVAL  this.tail
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965
//│ [mono] │ │ │ └ EVAL  [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]237888
//│ [mono] │ │ └ EVAL  [count$Cons$1() given {this: [Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]474004} | count$Nil$2() given {this: [Nil$2@{}]615890}]52513
//│ [mono] │ │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]474004)
//│ [mono] │ │ │ comparing (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) with (Plain([Cons$1@{e: [*LIT*]825810, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]451748}]686061))
//│ [mono] │ │ └ SPEC CALL [*19*=[*LIT*]636435]675852
//│ [mono] │ │ call result: [*19*=[*LIT*]636435]675852
//│ [mono] │ │ ┌ SPEC CALL count$Nil$2 with ([Nil$2@{}]615890)
//│ [mono] │ │ │ comparing (([]333536,0)) with (Plain([Nil$2@{}]560462))
//│ [mono] │ │ │ first time encounter count$Nil$2
//│ [mono] │ │ │ evaluating count$Nil$2, rests: HashSet(apply$Lambda2$4, main$$6, main$$5)
//│ [mono] │ │ │ ========== updating count$Nil$2 ==========
//│ [mono] │ │ │ count$Nil$2: (([Nil$2@{}]560462,1)) -> *20*=[*20*=...]763413 @{count$Cons$1}
//│ [mono] │ │ │ ┌ EVAL  #0
//│ [mono] │ │ │ └ EVAL  [0]326453
//│ [mono] │ │ │ comparing [*20*=...]763413 with [0]326453
//│ [mono] │ │ │ count$Nil$2: (([Nil$2@{}]560462,1)) -> *20*=[0]326453 @{count$Cons$1}
//│ [mono] │ │ └ SPEC CALL [*20*=[0]326453]576211
//│ [mono] │ │ call result: [*20*=[0]326453]576211
//│ [mono] │ │ merging []342306 with [*19*=[*LIT*]636435]675852
//│ [mono] │ │ result [*19*=[*LIT*]636435]599657
//│ [mono] │ │ merging [*19*=[*LIT*]636435]599657 with [*20*=[0]326453]576211
//│ [mono] │ │ result [*20*=[0]326453 | *19*=[*LIT*]636435]99068
//│ [mono] │ └ EVAL  [*20*=[0]326453 | *19*=[*LIT*]636435]99068
//│ [mono] └ EVAL  [*LIT*]513374
//│ [mono] comparing [*LIT*]636435 with [*LIT*]513374
//│ [mono] count$Cons$1: (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) -> *19*=[*LIT*]513374 @{apply$Lambda2$4, count$Cons$1}
//│ [mono] evaluating apply$Lambda2$4, rests: HashSet(main$$6, main$$5)
//│ [mono] ========== updating apply$Lambda2$4 ==========
//│ [mono] apply$Lambda2$4: (([Lambda2$4@{a: [2]752278}]91381,2) X ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) -> *18*=[*19*=[*LIT*]513374]780388 @{foo}
//│ [mono] ┌ EVAL  new Cons$1 (this.a, l) .count()
//│ [mono] │ ┌ EVAL  new Cons$1 (this.a, l) .count
//│ [mono] │ │ ┌ EVAL  new Cons$1 (this.a, l) 
//│ [mono] │ │ │ ┌ EVAL  this.a
//│ [mono] │ │ │ │ ┌ EVAL  this
//│ [mono] │ │ │ │ └ EVAL  [Lambda2$4@{a: [2]752278}]91381
//│ [mono] │ │ │ └ EVAL  [2]422643
//│ [mono] │ │ │ ┌ EVAL  l
//│ [mono] │ │ │ └ EVAL  [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [2]422643, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016}]482343
//│ [mono] │ └ EVAL  [count$Cons$1() given {this: [Cons$1@{e: [2]422643, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016}]553308}]479302
//│ [mono] │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [2]422643, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016}]553308)
//│ [mono] │ │ comparing (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) with (Plain([Cons$1@{e: [*LIT*]498010, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]567350}]697741))
//│ [mono] │ └ SPEC CALL [*19*=[*LIT*]513374]918946
//│ [mono] │ call result: [*19*=[*LIT*]513374]918946
//│ [mono] │ merging []317828 with [*19*=[*LIT*]513374]918946
//│ [mono] │ result [*19*=[*LIT*]513374]980184
//│ [mono] └ EVAL  [*19*=[*LIT*]513374]980184
//│ [mono] comparing [*19*=[*LIT*]513374]780388 with [*19*=[*LIT*]513374]980184
//│ [mono] apply$Lambda2$4: (([Lambda2$4@{a: [2]752278}]91381,2) X ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) -> *18*=[*19*=[*LIT*]513374]980184 @{foo}
//│ [mono] evaluating main$$6, rests: HashSet(main$$5)
//│ [mono] ========== updating main$$6 ==========
//│ [mono] main$$6: () -> *17*=[*15*=[*LIT*]67195]203295 @{}
//│ [mono] ┌ EVAL  foo(new Lambda2$4 (#2) )
//│ [mono] │ ┌ EVAL  foo
//│ [mono] │ └ EVAL  [foo(x) given {}]152639
//│ [mono] │ ┌ EVAL  new Lambda2$4 (#2) 
//│ [mono] │ │ ┌ EVAL  #2
//│ [mono] │ │ └ EVAL  [2]386284
//│ [mono] │ └ EVAL  [Lambda2$4@{a: [2]386284}]259571
//│ [mono] │ ┌ SPEC CALL foo with ([Lambda2$4@{a: [2]386284}]259571)
//│ [mono] │ │ comparing (([Lambda2$4@{a: [2]752278}]622915,2)) with (Plain([Lambda2$4@{a: [2]541966}]360855))
//│ [mono] │ └ SPEC CALL [*15*=[*LIT*]67195]902018
//│ [mono] │ call result: [*15*=[*LIT*]67195]902018
//│ [mono] │ merging []617314 with [*15*=[*LIT*]67195]902018
//│ [mono] │ result [*15*=[*LIT*]67195]963429
//│ [mono] └ EVAL  [*15*=[*LIT*]67195]963429
//│ [mono] comparing [*15*=[*LIT*]67195]203295 with [*15*=[*LIT*]67195]963429
//│ [mono] main$$6: () -> *17*=[*15*=[*LIT*]67195]963429 @{}
//│ [mono] evaluating main$$5, rests: HashSet()
//│ [mono] ========== updating main$$5 ==========
//│ [mono] main$$5: () -> *16*=[*16*=...]810726 @{}
//│ [mono] ┌ EVAL  foo(new Lambda$3 () )
//│ [mono] │ ┌ EVAL  foo
//│ [mono] │ └ EVAL  [foo(x) given {}]647833
//│ [mono] │ ┌ EVAL  new Lambda$3 () 
//│ [mono] │ └ EVAL  [Lambda$3@{}]123140
//│ [mono] │ ┌ SPEC CALL foo with ([Lambda$3@{}]123140)
//│ [mono] │ │ comparing (([Lambda2$4@{a: [2]752278}]622915,2)) with (Plain([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780))
//│ [mono] │ │ find finer args
//│ [mono] │ └ SPEC CALL [*15*=[*LIT*]67195]41480
//│ [mono] │ call result: [*15*=[*LIT*]67195]41480
//│ [mono] │ merging []590767 with [*15*=[*LIT*]67195]41480
//│ [mono] │ result [*15*=[*LIT*]67195]298303
//│ [mono] └ EVAL  [*15*=[*LIT*]67195]298303
//│ [mono] comparing [*16*=...]810726 with [*15*=[*LIT*]67195]298303
//│ [mono] main$$5: () -> *16*=[*15*=[*LIT*]67195]298303 @{}
//│ [mono] evaluating foo, rests: HashSet()
//│ [mono] ========== updating foo ==========
//│ [mono] foo: (([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780,3)) -> *15*=[*LIT*]67195 @{main$$6, main$$5}
//│ [mono] ┌ EVAL  (x.apply(new Cons$1 (#1, new Nil$2 () ) ) + x.apply(new Nil$2 () ))
//│ [mono] │ ┌ EVAL  x.apply(new Cons$1 (#1, new Nil$2 () ) )
//│ [mono] │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780
//│ [mono] │ │ └ EVAL  [apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]992279} | apply$Lambda$3(l) given {this: [Lambda$3@{}]793571}]732519
//│ [mono] │ │ ┌ EVAL  new Cons$1 (#1, new Nil$2 () ) 
//│ [mono] │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ └ EVAL  [1]456454
//│ [mono] │ │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ │ └ EVAL  [Nil$2@{}]142364
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]903239
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]992279, [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]903239)
//│ [mono] │ │ │ comparing (([Lambda2$4@{a: [2]752278}]91381,2), ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) with (Plain([Lambda2$4@{a: [2]752278}]138839), Plain([Cons$1@{e: [1]995583, tail: [Nil$2@{}]927154} | Nil$2@{}]504129))
//│ [mono] │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]513374]980184]739668
//│ [mono] │ │ call result: [*18*=[*19*=[*LIT*]513374]980184]739668
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda$3 with ([Lambda$3@{}]793571, [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]903239)
//│ [mono] │ │ │ comparing (([]652955,0), ([]66778,0)) with (Plain([Lambda$3@{}]988452), Plain([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]209615))
//│ [mono] │ │ │ first time encounter apply$Lambda$3
//│ [mono] │ │ │ evaluating apply$Lambda$3, rests: HashSet()
//│ [mono] │ │ │ ========== updating apply$Lambda$3 ==========
//│ [mono] │ │ │ apply$Lambda$3: (([Lambda$3@{}]988452,1) X ([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]209615,3)) -> *21*=[*21*=...]989283 @{foo}
//│ [mono] │ │ │ ┌ EVAL  l.count()
//│ [mono] │ │ │ │ ┌ EVAL  l.count()
//│ [mono] │ │ │ │ │ ┌ EVAL  l.count
//│ [mono] │ │ │ │ │ │ ┌ EVAL  l
//│ [mono] │ │ │ │ │ │ └ EVAL  [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]209615
//│ [mono] │ │ │ │ │ └ EVAL  [count$Cons$1() given {this: [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]477491}]445270
//│ [mono] │ │ │ │ │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]477491)
//│ [mono] │ │ │ │ │ │ comparing (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) with (Plain([Cons$1@{e: [*LIT*]608008, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]782101}]639500))
//│ [mono] │ │ │ │ │ └ SPEC CALL [*19*=[*LIT*]513374]172112
//│ [mono] │ │ │ │ │ call result: [*19*=[*LIT*]513374]172112
//│ [mono] │ │ │ │ │ merging []756915 with [*19*=[*LIT*]513374]172112
//│ [mono] │ │ │ │ │ result [*19*=[*LIT*]513374]286621
//│ [mono] │ │ │ │ └ EVAL  [*19*=[*LIT*]513374]286621
//│ [mono] │ │ │ └ EVAL  [*19*=[*LIT*]513374]286621
//│ [mono] │ │ │ comparing [*21*=...]989283 with [*19*=[*LIT*]513374]286621
//│ [mono] │ │ │ apply$Lambda$3: (([Lambda$3@{}]988452,1) X ([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]209615,3)) -> *21*=[*19*=[*LIT*]513374]286621 @{foo}
//│ [mono] │ │ └ SPEC CALL [*21*=[*19*=[*LIT*]513374]286621]767426
//│ [mono] │ │ call result: [*21*=[*19*=[*LIT*]513374]286621]767426
//│ [mono] │ │ merging []319684 with [*18*=[*19*=[*LIT*]513374]980184]739668
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184]830712
//│ [mono] │ │ merging [*18*=[*19*=[*LIT*]513374]980184]830712 with [*21*=[*19*=[*LIT*]513374]286621]767426
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184 | *21*=[*19*=[*LIT*]513374]286621]77626
//│ [mono] │ └ EVAL  [*18*=[*19*=[*LIT*]513374]980184 | *21*=[*19*=[*LIT*]513374]286621]77626
//│ [mono] │ ┌ EVAL  x.apply(new Nil$2 () )
//│ [mono] │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780
//│ [mono] │ │ └ EVAL  [apply$Lambda$3(l) given {this: [Lambda$3@{}]442930} | apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]808077}]684849
//│ [mono] │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ └ EVAL  [Nil$2@{}]686449
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]808077, [Nil$2@{}]686449)
//│ [mono] │ │ │ comparing (([Lambda2$4@{a: [2]752278}]91381,2), ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) with (Plain([Lambda2$4@{a: [2]752278}]939024), Plain([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]368348))
//│ [mono] │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]513374]980184]590325
//│ [mono] │ │ call result: [*18*=[*19*=[*LIT*]513374]980184]590325
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda$3 with ([Lambda$3@{}]442930, [Nil$2@{}]686449)
//│ [mono] │ │ │ comparing (([Lambda$3@{}]988452,1), ([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]209615,3)) with (Plain([Lambda$3@{}]195071), Plain([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468))
//│ [mono] │ │ │ find finer args
//│ [mono] │ │ └ SPEC CALL [*21*=[*19*=[*LIT*]513374]286621]970626
//│ [mono] │ │ call result: [*21*=[*19*=[*LIT*]513374]286621]970626
//│ [mono] │ │ merging []845011 with [*18*=[*19*=[*LIT*]513374]980184]590325
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184]981314
//│ [mono] │ │ merging [*18*=[*19*=[*LIT*]513374]980184]981314 with [*21*=[*19*=[*LIT*]513374]286621]970626
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184 | *21*=[*19*=[*LIT*]513374]286621]312038
//│ [mono] │ └ EVAL  [*18*=[*19*=[*LIT*]513374]980184 | *21*=[*19*=[*LIT*]513374]286621]312038
//│ [mono] └ EVAL  [*LIT*]52478
//│ [mono] comparing [*LIT*]67195 with [*LIT*]52478
//│ [mono] foo: (([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780,3)) -> *15*=[*LIT*]52478 @{main$$6, main$$5}
//│ [mono] evaluating apply$Lambda$3, rests: HashSet()
//│ [mono] ========== updating apply$Lambda$3 ==========
//│ [mono] apply$Lambda$3: (([Lambda$3@{}]195071,1) X ([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468,4)) -> *21*=[*19*=[*LIT*]513374]286621 @{foo}
//│ [mono] ┌ EVAL  l.count()
//│ [mono] │ ┌ EVAL  l.count
//│ [mono] │ │ ┌ EVAL  l
//│ [mono] │ │ └ EVAL  [Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468
//│ [mono] │ └ EVAL  [count$Nil$2() given {this: [Nil$2@{}]202478} | count$Cons$1() given {this: [Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]305777}]658816
//│ [mono] │ ┌ SPEC CALL count$Nil$2 with ([Nil$2@{}]202478)
//│ [mono] │ │ comparing (([Nil$2@{}]560462,1)) with (Plain([Nil$2@{}]689512))
//│ [mono] │ └ SPEC CALL [*20*=[0]326453]434307
//│ [mono] │ call result: [*20*=[0]326453]434307
//│ [mono] │ ┌ SPEC CALL count$Cons$1 with ([Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]305777)
//│ [mono] │ │ comparing (([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965,100005)) with (Plain([Cons$1@{e: [*LIT*]232010, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]655168}]625967))
//│ [mono] │ └ SPEC CALL [*19*=[*LIT*]513374]232324
//│ [mono] │ call result: [*19*=[*LIT*]513374]232324
//│ [mono] │ merging []923571 with [*20*=[0]326453]434307
//│ [mono] │ result [*20*=[0]326453]909846
//│ [mono] │ merging [*20*=[0]326453]909846 with [*19*=[*LIT*]513374]232324
//│ [mono] │ result [*19*=[*LIT*]513374 | *20*=[0]326453]994788
//│ [mono] └ EVAL  [*19*=[*LIT*]513374 | *20*=[0]326453]994788
//│ [mono] comparing [*19*=[*LIT*]513374]286621 with [*19*=[*LIT*]513374 | *20*=[0]326453]994788
//│ [mono] adding these funcs to queue: Set(foo)
//│ [mono] apply$Lambda$3: (([Lambda$3@{}]195071,1) X ([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468,4)) -> *21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788 @{foo}
//│ [mono] evaluating foo, rests: HashSet()
//│ [mono] ========== updating foo ==========
//│ [mono] foo: (([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780,3)) -> *15*=[*LIT*]52478 @{main$$6, main$$5}
//│ [mono] ┌ EVAL  (x.apply(new Cons$1 (#1, new Nil$2 () ) ) + x.apply(new Nil$2 () ))
//│ [mono] │ ┌ EVAL  x.apply(new Cons$1 (#1, new Nil$2 () ) )
//│ [mono] │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780
//│ [mono] │ │ └ EVAL  [apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]464438} | apply$Lambda$3(l) given {this: [Lambda$3@{}]190192}]291875
//│ [mono] │ │ ┌ EVAL  new Cons$1 (#1, new Nil$2 () ) 
//│ [mono] │ │ │ ┌ EVAL  #1
//│ [mono] │ │ │ └ EVAL  [1]942335
//│ [mono] │ │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ │ └ EVAL  [Nil$2@{}]201541
//│ [mono] │ │ └ EVAL  [Cons$1@{e: [1]942335, tail: [Nil$2@{}]201541}]426752
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]464438, [Cons$1@{e: [1]942335, tail: [Nil$2@{}]201541}]426752)
//│ [mono] │ │ │ comparing (([Lambda2$4@{a: [2]752278}]91381,2), ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) with (Plain([Lambda2$4@{a: [2]752278}]209630), Plain([Cons$1@{e: [1]95172, tail: [Nil$2@{}]958140} | Nil$2@{}]795421))
//│ [mono] │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]513374]980184]78520
//│ [mono] │ │ call result: [*18*=[*19*=[*LIT*]513374]980184]78520
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda$3 with ([Lambda$3@{}]190192, [Cons$1@{e: [1]942335, tail: [Nil$2@{}]201541}]426752)
//│ [mono] │ │ │ comparing (([Lambda$3@{}]195071,1), ([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468,4)) with (Plain([Lambda$3@{}]905090), Plain([Cons$1@{e: [1]541051, tail: [Nil$2@{}]530234} | Nil$2@{}]17701))
//│ [mono] │ │ └ SPEC CALL [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]788726
//│ [mono] │ │ call result: [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]788726
//│ [mono] │ │ merging []853155 with [*18*=[*19*=[*LIT*]513374]980184]78520
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184]259345
//│ [mono] │ │ merging [*18*=[*19*=[*LIT*]513374]980184]259345 with [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]788726
//│ [mono] │ │ result [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788 | *18*=[*19*=[*LIT*]513374]980184]545957
//│ [mono] │ └ EVAL  [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788 | *18*=[*19*=[*LIT*]513374]980184]545957
//│ [mono] │ ┌ EVAL  x.apply(new Nil$2 () )
//│ [mono] │ │ ┌ EVAL  x.apply
//│ [mono] │ │ │ ┌ EVAL  x
//│ [mono] │ │ │ └ EVAL  [Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780
//│ [mono] │ │ └ EVAL  [apply$Lambda$3(l) given {this: [Lambda$3@{}]218234} | apply$Lambda2$4(l) given {this: [Lambda2$4@{a: [2]752278}]851318}]806082
//│ [mono] │ │ ┌ EVAL  new Nil$2 () 
//│ [mono] │ │ └ EVAL  [Nil$2@{}]205827
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda2$4 with ([Lambda2$4@{a: [2]752278}]851318, [Nil$2@{}]205827)
//│ [mono] │ │ │ comparing (([Lambda2$4@{a: [2]752278}]91381,2), ([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016,4)) with (Plain([Lambda2$4@{a: [2]752278}]249616), Plain([Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]796479))
//│ [mono] │ │ └ SPEC CALL [*18*=[*19*=[*LIT*]513374]980184]519713
//│ [mono] │ │ call result: [*18*=[*19*=[*LIT*]513374]980184]519713
//│ [mono] │ │ ┌ SPEC CALL apply$Lambda$3 with ([Lambda$3@{}]218234, [Nil$2@{}]205827)
//│ [mono] │ │ │ comparing (([Lambda$3@{}]195071,1), ([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468,4)) with (Plain([Lambda$3@{}]575409), Plain([Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]107065))
//│ [mono] │ │ └ SPEC CALL [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]183012
//│ [mono] │ │ call result: [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]183012
//│ [mono] │ │ merging []7556 with [*18*=[*19*=[*LIT*]513374]980184]519713
//│ [mono] │ │ result [*18*=[*19*=[*LIT*]513374]980184]657118
//│ [mono] │ │ merging [*18*=[*19*=[*LIT*]513374]980184]657118 with [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788]183012
//│ [mono] │ │ result [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788 | *18*=[*19*=[*LIT*]513374]980184]952944
//│ [mono] │ └ EVAL  [*21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788 | *18*=[*19*=[*LIT*]513374]980184]952944
//│ [mono] └ EVAL  [*LIT*]197099
//│ [mono] comparing [*LIT*]52478 with [*LIT*]197099
//│ [mono] foo: (([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780,3)) -> *15*=[*LIT*]197099 @{main$$6, main$$5}
//│ [mono] 
//│ [mono] ==============final function signatures==================
//│ [mono] count$Cons$1: ([Cons$1@{e: [*LIT*]868503, tail: [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]644463}]473965) -> *19*=[*LIT*]513374
//│ [mono] apply$Lambda$3: ([Lambda$3@{}]195071 X [Nil$2@{} | Cons$1@{e: [1]456454, tail: [Nil$2@{}]142364}]785468) -> *21*=[*19*=[*LIT*]513374 | *20*=[0]326453]994788
//│ [mono] count$Nil$2: ([Nil$2@{}]560462) -> *20*=[0]326453
//│ [mono] foo: ([Lambda$3@{} | Lambda2$4@{a: [2]752278}]149780) -> *15*=[*LIT*]197099
//│ [mono] apply$Lambda2$4: ([Lambda2$4@{a: [2]752278}]91381 X [Nil$2@{} | Cons$1@{e: [1]224258, tail: [Nil$2@{}]644816}]429016) -> *18*=[*19*=[*LIT*]513374]980184
//│ [mono] main$$6: () -> *17*=[*15*=[*LIT*]197099]963429
//│ [mono] main$$5: () -> *16*=[*15*=[*LIT*]197099]298303

// :mono
class E() {
  fun derive(x) = 
    new E
  fun isEmpty() = 
    false
}
class Ep(){
  fun derive(x) = 
    new E
  fun isEmpty() = 
    true
}
class Ch(i){
  fun derive(x) = 
    if x == i then new Ep else new E
  fun isEmpty() = 
    false
}
class A(e1, e2){
  fun derive(x) = 
    new A(e1.derive(x), e2.derive(x))
  fun isEmpty() = 
    e1.isEmpty() || e2.isEmpty()
}
class C(e1, e2){
  fun derive(x) = 
    if e1.isEmpty() then new A(new C(e1.derive(x), e2), e2.derive(x)) else new C(e1.derive(x), e2)
  fun isEmpty() = 
    e1.isEmpty() && e2.isEmpty()
}
(new C(new Ch(1), new A(new Ch(2), new Ch(3)))).derive(0).isEmpty()
//│ |#class| |E|(||)| |{|→|#fun| |derive|(|x|)| |#=| |→|#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|false|←|←|↵|}|↵|#class| |Ep|(||)|{|→|#fun| |derive|(|x|)| |#=| |→|#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|true|←|←|↵|}|↵|#class| |Ch|(|i|)|{|→|#fun| |derive|(|x|)| |#=| |→|#if| |x| |==| |i| |#then| |#new| |Ep| |#else| |#new| |E|←|↵|#fun| |isEmpty|(||)| |#=| |→|false|←|←|↵|}|↵|#class| |A|(|e1|,| |e2|)|{|→|#fun| |derive|(|x|)| |#=| |→|#new| |A|(|e1|.derive|(|x|)|,| |e2|.derive|(|x|)|)|←|↵|#fun| |isEmpty|(||)| |#=| |→|e1|.isEmpty|(||)| |||| |e2|.isEmpty|(||)|←|←|↵|}|↵|#class| |C|(|e1|,| |e2|)|{|→|#fun| |derive|(|x|)| |#=| |→|#if| |e1|.isEmpty|(||)| |#then| |#new| |A|(|#new| |C|(|e1|.derive|(|x|)|,| |e2|)|,| |e2|.derive|(|x|)|)| |#else| |#new| |C|(|e1|.derive|(|x|)|,| |e2|)|←|↵|#fun| |isEmpty|(||)| |#=| |→|e1|.isEmpty|(||)| |&&| |e2|.isEmpty|(||)|←|←|↵|}|↵|(|#new| |C|(|#new| |Ch|(|1|)|,| |#new| |A|(|#new| |Ch|(|2|)|,| |#new| |Ch|(|3|)|)|)|)|.derive|(|0|)|.isEmpty|(||)|
//│ Parsed: {class E() {fun derive = x, => {new E() {}}; fun isEmpty =  => {false}}; class Ep() {fun derive = x, => {new E() {}}; fun isEmpty =  => {true}}; class Ch(i,) {fun derive = x, => {if (== (x,) (i,)) then new Ep() {} else new E() {}}; fun isEmpty =  => {false}}; class A(e1, e2,) {fun derive = x, => {new A((e1).derive (x,), (e2).derive (x,),) {}}; fun isEmpty =  => {|| ((e1).isEmpty (),) ((e2).isEmpty (),)}}; class C(e1, e2,) {fun derive = x, => {if ((e1).isEmpty ()) then new A(new C((e1).derive (x,), e2,) {}, (e2).derive (x,),) {} else new C((e1).derive (x,), e2,) {}}; fun isEmpty =  => {&& ((e1).isEmpty (),) ((e2).isEmpty (),)}}; (('(' new C(new Ch(1,) {}, new A(new Ch(2,) {}, new Ch(3,) {},) {},) {}, ')').derive (0,)).isEmpty ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, E, (), Tup(), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, Ep, (), Tup(), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, Ch, (), Tup(_: Var(i)), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, A, (), Tup(_: Var(e1), _: Var(e2)), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), Blk(...))))), NuTypeDef(class, C, (), Tup(_: Var(e1), _: Var(e2)), (), TypingUnit(NuFunDef(None, derive, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, isEmpty, [], Lam(Tup(), Blk(...))))), App(Sel(App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(C),new Ch(1,) {}, new A(new Ch(2,) {}, new Ch(3,) {},) {},)), TypingUnit(List())))), derive), Tup(_: IntLit(0))), isEmpty), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class E$1() {
//│     fun derive = x, => {new E$1() {}}
//│     fun isEmpty =  => {false}
//│   }
//│   class Ep$2() {
//│     fun derive = x, => {new E$1() {}}
//│     fun isEmpty =  => {true}
//│   }
//│   class Ch$3(i,) {
//│     fun derive = x, => {if (== (x,) ((this).i,)) then new Ep$2() {} else new E$1() {}}
//│     fun isEmpty =  => {false}
//│   }
//│   class A$4(e1, e2,) {
//│     fun derive = x, => {new A$4(((this).e1).derive (x,), ((this).e2).derive (x,),) {}}
//│     fun isEmpty =  => {|| (((this).e1).isEmpty (),) (((this).e2).isEmpty (),)}
//│   }
//│   class C$5(e1, e2,) {
//│     fun derive = x, => {if (((this).e1).isEmpty ()) then new A$4(new C$5(((this).e1).derive (x,), (this).e2,) {}, ((this).e2).derive (x,),) {} else new C$5(((this).e1).derive (x,), (this).e2,) {}}
//│     fun isEmpty =  => {&& (((this).e1).isEmpty (),) (((this).e2).isEmpty (),)}
//│   }
//│   Code(List((('(' new C$5(new Ch$3(1,) {}, new A$4(new Ch$3(2,) {}, new Ch$3(3,) {},) {},) {}, ')').derive (0,)).isEmpty ()))
//│ }


// :mono
class List(l, hasTail)  {}
class Nil(hasTail)  {}
fun gen() = 
  if anyUnknown then new List(gen(), true) else new Nil(false)
gen()
//│ |#class| |List|(|l|,| |hasTail|)| |{||}|↵|#class| |Nil|(|hasTail|)| |{||}|↵|#fun| |gen|(||)| |#=| |→|#if| |anyUnknown| |#then| |#new| |List|(|gen|(||)|,| |true|)| |#else| |#new| |Nil|(|false|)|←|↵|gen|(||)|
//│ Parsed: {class List(l, hasTail,) {}; class Nil(hasTail,) {}; fun gen =  => {if (anyUnknown) then new List(gen (), true,) {} else new Nil(false,) {}}; gen ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, List, (), Tup(_: Var(l), _: Var(hasTail)), (), TypingUnit()), NuTypeDef(class, Nil, (), Tup(_: Var(hasTail)), (), TypingUnit()), NuFunDef(None, gen, [], Lam(Tup(), Blk(...))), App(Var(gen), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class List$1(l, hasTail,) {}
//│   class Nil$2(hasTail,) {}
//│   fun gen =  => {if (anyUnknown) then new List$1(gen (), true,) {} else new Nil$2(false,) {}}
//│   Code(List(gen ()))
//│ }



// :mono
class Foo(x){
  fun bar(y) = x+y
  fun boo(z) = bar(z)+x
}
(new Foo(1)).boo(2)
//│ |#class| |Foo|(|x|)|{|→|#fun| |bar|(|y|)| |#=| |x|+|y|↵|#fun| |boo|(|z|)| |#=| |bar|(|z|)|+|x|←|↵|}|↵|(|#new| |Foo|(|1|)|)|.boo|(|2|)|
//│ Parsed: {class Foo(x,) {fun bar = y, => + (x,) (y,); fun boo = z, => + (bar (z,),) (x,)}; ('(' new Foo(1,) {}, ')').boo (2,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Foo, (), Tup(_: Var(x)), (), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(y)), App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), NuFunDef(None, boo, [], Lam(Tup(_: Var(z)), App(App(Var(+), Tup(_: App(Var(bar), Tup(_: Var(z))))), Tup(_: Var(x))))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(Foo),1,)), TypingUnit(List())))), boo), Tup(_: IntLit(2))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1(x,) {
//│     fun bar = y, => + ((this).x,) (y,)
//│     fun boo = z, => + ((this).bar (z,),) ((this).x,)
//│   }
//│   Code(List(('(' new Foo$1(1,) {}, ')').boo (2,)))
//│ }

// :mono
class OneInt(a){
  fun fac() = 
    if(a > 0) then (new OneInt(a-1)).fac() else 1 
}
(new OneInt(10)).fac()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |fac|(||)| |#=| |→|#if|(|a| |>| |0|)| |#then| |(|#new| |OneInt|(|a|-|1|)|)|.fac|(||)| |#else| |1| |←|←|↵|}|↵|(|#new| |OneInt|(|10|)|)|.fac|(||)|
//│ Parsed: {class OneInt(a,) {fun fac =  => {if ('(' > (a,) (0,), ')') then ('(' new OneInt(- (a,) (1,),) {}, ')').fac () else 1}}; ('(' new OneInt(10,) {}, ')').fac ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, fac, [], Lam(Tup(), Blk(...))))), App(Sel(Bra(rcd = false, Tup(_: New(Some((TypeName(OneInt),10,)), TypingUnit(List())))), fac), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(a,) {
//│     fun fac =  => {if ('(' > ((this).a,) (0,), ')') then ('(' new OneInt$1(- ((this).a,) (1,),) {}, ')').fac () else 1}
//│   }
//│   Code(List(('(' new OneInt$1(10,) {}, ')').fac ()))
//│ }

// :mono
trait AnyFoo {
  fun bar(b): int
}
class FooPlus(#a): AnyFoo {
  fun bar(b) = a + b
}
class FooMinus(#a): AnyFoo {
  fun bar(b) = a - b
}
fun f(x) = x.bar(42)
f(new FooPlus(1))
f(new FooMinus(2))
//│ |#trait| |AnyFoo| |{|→|#fun| |bar|(|b|)|#:| |int|←|↵|}|↵|#class| |FooPlus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |+| |b|←|↵|}|↵|#class| |FooMinus|(|##|a|)|#:| |AnyFoo| |{|→|#fun| |bar|(|b|)| |#=| |a| |-| |b|←|↵|}|↵|#fun| |f|(|x|)| |#=| |x|.bar|(|42|)|↵|f|(|#new| |FooPlus|(|1|)|)|↵|f|(|#new| |FooMinus|(|2|)|)|
//│ Parsed: {trait AnyFoo(): {fun bar: [] -> b -> int}; class FooPlus(#a,): AnyFoo {fun bar = b, => + (a,) (b,)}; class FooMinus(#a,): AnyFoo {fun bar = b, => - (a,) (b,)}; fun f = x, => (x).bar (42,); f (new FooPlus(1,) {},); f (new FooMinus(2,) {},)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(trait, AnyFoo, (), Tup(), (), TypingUnit(NuFunDef(None, bar, [], PolyType(List(),Function(Tuple(List((None,Field(None,TypeName(b))))),TypeName(int)))))), NuTypeDef(class, FooPlus, (), Tup(_: Var(a)), (Var(AnyFoo)), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(b)), App(App(Var(+), Tup(_: Var(a))), Tup(_: Var(b))))))), NuTypeDef(class, FooMinus, (), Tup(_: Var(a)), (Var(AnyFoo)), TypingUnit(NuFunDef(None, bar, [], Lam(Tup(_: Var(b)), App(App(Var(-), Tup(_: Var(a))), Tup(_: Var(b))))))), NuFunDef(None, f, [], Lam(Tup(_: Var(x)), App(Sel(Var(x), bar), Tup(_: IntLit(42))))), App(Var(f), Tup(_: New(Some((TypeName(FooPlus),1,)), TypingUnit(List())))), App(Var(f), Tup(_: New(Some((TypeName(FooMinus),2,)), TypingUnit(List())))))
//│ Lifted:
//│ TypingUnit {
//│   trait AnyFoo$1[b]() {fun bar = b -> int}
//│   class FooPlus$2[b](#a,): AnyFoo$1 () {fun bar = b, => + ((this).a,) (b,)}
//│   class FooMinus$3[b](#a,): AnyFoo$1 () {fun bar = b, => - ((this).a,) (b,)}
//│   fun f = x, => (x).bar (42,)
//│   Code(List(f (new FooPlus$2(1,) {},)))
//│   Code(List(f (new FooMinus$3(2,) {},)))
//│ }

// :mono
fun f(x) = 
  if x > any then 0
  else g(x-1)
fun g(x) = 
  if x > any then g(x-1)
  else f(x-2)
g(1)
//│ |#fun| |f|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |0|↵|#else| |g|(|x|-|1|)|←|↵|#fun| |g|(|x|)| |#=| |→|#if| |x| |>| |any| |#then| |g|(|x|-|1|)|↵|#else| |f|(|x|-|2|)|←|↵|g|(|1|)|
//│ Parsed: {fun f = x, => {if (> (x,) (any,)) then 0 else g (- (x,) (1,),)}; fun g = x, => {if (> (x,) (any,)) then g (- (x,) (1,),) else f (- (x,) (2,),)}; g (1,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x)), Blk(...))), NuFunDef(None, g, [], Lam(Tup(_: Var(x)), Blk(...))), App(Var(g), Tup(_: IntLit(1))))
//│ Lifted:
//│ TypingUnit {
//│   fun f = x, => {if (> (x,) (any,)) then 0 else g (- (x,) (1,),)}
//│   fun g = x, => {if (> (x,) (any,)) then g (- (x,) (1,),) else f (- (x,) (2,),)}
//│   Code(List(g (1,)))
//│ }

// :mono
class OneInt(a){
  fun get = a
}
class OneBool(b){
  fun get = b
}
(if b then new OneInt(1) else new OneBool(true)).get()
//│ |#class| |OneInt|(|a|)|{|→|#fun| |get| |#=| |a|←|↵|}|↵|#class| |OneBool|(|b|)|{|→|#fun| |get| |#=| |b|←|↵|}|↵|(|#if| |b| |#then| |#new| |OneInt|(|1|)| |#else| |#new| |OneBool|(|true|)|)|.get|(||)|
//│ Parsed: {class OneInt(a,) {fun get = a}; class OneBool(b,) {fun get = b}; ('(' if (b) then new OneInt(1,) {} else new OneBool(true,) {}, ')').get ()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, OneInt, (), Tup(_: Var(a)), (), TypingUnit(NuFunDef(None, get, [], Var(a)))), NuTypeDef(class, OneBool, (), Tup(_: Var(b)), (), TypingUnit(NuFunDef(None, get, [], Var(b)))), App(Sel(Bra(rcd = false, Tup(_: If((b) then new OneInt(1,) {}, Some(New(Some((TypeName(OneBool),true,)), TypingUnit(List())))))), get), Tup()))
//│ Lifted:
//│ TypingUnit {
//│   class OneInt$1(a,) {fun get = (this).a}
//│   class OneBool$2(b,) {fun get = (this).b}
//│   Code(List(('(' if (b) then new OneInt$1(1,) {} else new OneBool$2(true,) {}, ')').get ()))
//│ }

// :mono
class Bar(x: int) {
  fun FooMinus(y: int) = x + y
  fun car = foo(2)
}
class Car {
  fun da(b: Bar) = b.foo(2)
}
fun baz(b: Bar) = b.foo(2)
let bar = Bar(42)
baz(bar)
Car().da(Bar(1337))
bar.car
//│ |#class| |Bar|(|x|#:| |int|)| |{|→|#fun| |FooMinus|(|y|#:| |int|)| |#=| |x| |+| |y|↵|#fun| |car| |#=| |foo|(|2|)|←|↵|}|↵|#class| |Car| |{|→|#fun| |da|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|←|↵|}|↵|#fun| |baz|(|b|#:| |Bar|)| |#=| |b|.foo|(|2|)|↵|#let| |bar| |#=| |Bar|(|42|)|↵|baz|(|bar|)|↵|Car|(||)|.da|(|Bar|(|1337|)|)|↵|bar|.car|
//│ Parsed: {class Bar(x: int,) {fun FooMinus = y: int, => + (x,) (y,); fun car = foo (2,)}; class Car() {fun da = b: Bar, => (b).foo (2,)}; fun baz = b: Bar, => (b).foo (2,); let bar = Bar (42,); baz (bar,); (Car ()).da (Bar (1337,),); (bar).car}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Bar, (), Tup(x: Var(int)), (), TypingUnit(NuFunDef(None, FooMinus, [], Lam(Tup(y: Var(int)), App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), NuFunDef(None, car, [], App(Var(foo), Tup(_: IntLit(2)))))), NuTypeDef(class, Car, (), Tup(), (), TypingUnit(NuFunDef(None, da, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))))), NuFunDef(None, baz, [], Lam(Tup(b: Var(Bar)), App(Sel(Var(b), foo), Tup(_: IntLit(2))))), NuFunDef(Some(false), bar, [], App(Var(Bar), Tup(_: IntLit(42)))), App(Var(baz), Tup(_: Var(bar))), App(Sel(App(Var(Car), Tup()), da), Tup(_: App(Var(Bar), Tup(_: IntLit(1337))))), Sel(Var(bar), car))
//│ Lifted:
//│ TypingUnit {
//│   class Bar$1(x: int,) {
//│     fun FooMinus = y: int, => + ((this).x,) (y,)
//│     fun car = foo (2,)
//│   }
//│   class Car$2() {fun da = b: Bar$1, => (b).foo (2,)}
//│   fun baz = b: Bar$1, => (b).foo (2,)
//│   let bar = Bar$1 (42,)
//│   Code(List(baz (bar,)))
//│   Code(List((Car$2 ()).da (Bar$1 (1337,),)))
//│   Code(List((bar).car))
//│ }
