:NewParser
:ParseOnly

fun foo =
  print("ok")
  print("ko")
//│ |#fun| |foo| |#=|→|print|(|"ok"|)|↵|print|(|"ko"|)|←|
//│ Parsed: {fun foo = {print ("ok",); print ("ko",)}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Blk(...)))
//│ Lifted:
//│ TypingUnit {fun foo = {print ("ok",); print ("ko",)}}

class A{
  class B {}
  fun foo(x: B) = (x:B)
}
//│ |#class| |A|{|→|#class| |B| |{||}|↵|#fun| |foo|(|x|#:| |B|)| |#=| |(|x|#:|B|)|←|↵|}|
//│ Parsed: {class A() {class B() {}; fun foo = x: B, => '(' x: B, ')'}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(), (), TypingUnit(NuTypeDef(class, B, (), Tup(), (), TypingUnit()), NuFunDef(None, foo, [], Lam(Tup(x: Var(B)), Bra(rcd = false, Tup(x: Var(B))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A_B$1(par$A,) {}
//│   class A() {fun foo = x, => '(' x, ')'}
//│ }

fun foo =
  fun local(x) =
    class Foo {
      fun bar = x + 1
    }
    Foo().bar
  print of local(0) + local(1)
  print of (local of 0) + local of 1
  fun tmp = 1
  print of local of 0 + local of 1
  fun tmp = 2
//│ |#fun| |foo| |#=|→|#fun| |local|(|x|)| |#=|→|#class| |Foo| |{|→|#fun| |bar| |#=| |x| |+| |1|←|↵|}|↵|Foo|(||)|.bar|←|↵|print| |#of| |local|(|0|)| |+| |local|(|1|)|↵|print| |#of| |(|local| |#of| |0|)| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |1|↵|print| |#of| |local| |#of| |0| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |2|←|
//│ Parsed: {fun foo = {fun local = x, => {class Foo() {fun bar = + (x,) (1,)}; (Foo ()).bar}; print (+ (local (0,),) (local (1,),),); print (+ (local (0,),) (local (1,),),); fun tmp = 1; print (local (+ (0,) (local (1,),),),); fun tmp = 2}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, [], Blk(...)))
//│ Lifted:
//│ TypingUnit {
//│   class Foo(x,) {fun bar = + ((this).x,) (1,)}
//│   fun foo = {fun local = x, => {(Foo (x,)).bar}; fun tmp = 1; fun tmp = 2; print (+ (local (0,),) (local (1,),),); print (+ (local (0,),) (local (1,),),); print (local (+ (0,) (local (1,),),),)}
//│ }

class A(y){}
let f = x => new A(0){fun bar = x+y}
f(0)
//│ |#class| |A|(|y|)|{||}|↵|#let| |f| |#=| |x| |=>| |#new| |A|(|0|)|{|#fun| |bar| |#=| |x|+|y|}|↵|f|(|0|)|
//│ Parsed: {class A(y,) {}; let f = x, => new A(0,) {fun bar = + (x,) (y,)}; f (0,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(y)), (), TypingUnit()), NuFunDef(Some(false), f, [], Lam(Tup(_: Var(x)), New(Some((TypeName(A),0,)), TypingUnit(List(fun bar = + (x,) (y,)))))), App(Var(f), Tup(_: IntLit(0))))
//│ Lifted:
//│ TypingUnit {
//│   class A(y,) {}
//│   class A$1(y, x,): A ((this).y,) {fun bar = + ((this).x,) ((this).y,)}
//│   let f = x, => {new A$1(0, x,) {}}
//│   Code(List(f (0,)))
//│ }

class A(x){
  fun w = x
  fun foo(y) = 
    class B(z){
      fun bar = x+y+z
    }
    new B(0){
      fun bar = w+y+z
    }
}
//│ |#class| |A|(|x|)|{|→|#fun| |w| |#=| |x|↵|#fun| |foo|(|y|)| |#=| |→|#class| |B|(|z|)|{|→|#fun| |bar| |#=| |x|+|y|+|z|←|↵|}|↵|#new| |B|(|0|)|{|→|#fun| |bar| |#=| |w|+|y|+|z|←|↵|}|←|←|↵|}|
//│ Parsed: {class A(x,) {fun w = x; fun foo = y, => {class B(z,) {fun bar = + (+ (x,) (y,),) (z,)}; new B(0,) {fun bar = + (+ (w,) (y,),) (z,)}}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x)), (), TypingUnit(NuFunDef(None, w, [], Var(x)), NuFunDef(None, foo, [], Lam(Tup(_: Var(y)), Blk(...))))))
//│ Lifted:
//│ TypingUnit {
//│   class A_B$1(par$A, z, y,) {
//│     fun bar = + (+ (((this).par$A).x,) ((this).y,),) ((this).z,)
//│   }
//│   class A_B$1$2(par$A, z, y,): A_B$1 ((this).par$A, (this).z, (this).y,) {
//│     fun bar = + (+ (((this).par$A).w,) ((this).y,),) ((this).z,)
//│   }
//│   class A(x,) {
//│     fun w = (this).x
//│     fun foo = y, => {{new A_B$1$2(this, 0, y,) {}}}
//│   }
//│ }

fun f(x,y,z) = 
  class A{
    fun foo = new B
    fun bar1 = x
  }
  class B{
    fun foo = new A
    fun bar2 = y
  }
  class C: A,B{
    fun bar = bar1 + bar2
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#class| |C|#:| |A|,|B|{|→|#fun| |bar| |#=| |bar1| |+| |bar2|←|↵|}|←|
//│ Parsed: {fun f = x, y, z, => {class A() {fun foo = new B() {}; fun bar1 = x}; class B() {fun foo = new A() {}; fun bar2 = y}; class C(): A, B {fun bar = + (bar1,) (bar2,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk(...))))
//│ Lifted:
//│ TypingUnit {
//│   class A(x, y,) {
//│     fun foo = new B((this).y, (this).x,) {}
//│     fun bar1 = (this).x
//│   }
//│   class B(y, x,) {
//│     fun foo = new A((this).x, (this).y,) {}
//│     fun bar2 = (this).y
//│   }
//│   class C(x, y,): A ((this).x, (this).y,), B ((this).y, (this).x,) {fun bar = + ((this).bar1,) ((this).bar2,)}
//│   fun f = x, y, z, => {}
//│ }

fun f(x,y,z) = 
  class C{
    class A{
      fun foo = new B
      fun bar1 = x
    }
    class B{
      fun foo = new A
      fun bar2 = y
    }
    fun boo = (new A).bar1 + B().bar2 + z
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |C|{|→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#fun| |boo| |#=| |(|#new| |A|)|.bar1| |+| |B|(||)|.bar2| |+| |z|←|↵|}|←|
//│ Parsed: {fun f = x, y, z, => {class C() {class A() {fun foo = new B() {}; fun bar1 = x}; class B() {fun foo = new A() {}; fun bar2 = y}; fun boo = + (('(' new A() {}, ')').bar1,) (+ ((B ()).bar2,) (z,),)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, [], Lam(Tup(_: Var(x), _: Var(y), _: Var(z)), Blk(...))))
//│ Lifted:
//│ TypingUnit {
//│   class C_A$1(par$C,) {
//│     fun foo = new C_B$2((this).par$C,) {}
//│     fun bar1 = ((this).par$C).x
//│   }
//│   class C_B$2(par$C,) {
//│     fun foo = new C_A$1((this).par$C,) {}
//│     fun bar2 = ((this).par$C).y
//│   }
//│   class C(x, y, z,) {
//│     fun boo = + (('(' new C_A$1(this,) {}, ')').bar1,) (+ ((C_B$2 (this,)).bar2,) ((this).z,),)
//│   }
//│   fun f = x, y, z, => {}
//│ }
