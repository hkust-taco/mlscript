:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun f(n) = if n == 0 then 0 else g(n - 1)
fun g(m) = if m == 0 then 1 else f(m - 1)
f(4)
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|n|)| |#=| |#if| |n| |==| |0| |#then| |0| |#else| |g|(|n| |-| |1|)|↵|#fun| |g|(|m|)| |#=| |#if| |m| |==| |0| |#then| |1| |#else| |f|(|m| |-| |1|)|↵|f|(|4|)|
//│ Parsed: {class True {}; class False {}; fun f = (n,) => if (==(n,)(0,)) then 0 else g(-(n,)(1,),); fun g = (m,) => if (==(m,)(0,)) then 1 else f(-(m,)(1,),); f(4,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ 
//│ Interpreted:
//│ 0

:interpIR
class True
class False
fun f(n) = if n == 0 then 0 else g(n - 1)
fun g(m) = if m == 0 then 1 else f(m - 1)
f(4)
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|n|)| |#=| |#if| |n| |==| |0| |#then| |0| |#else| |g|(|n| |-| |1|)|↵|#fun| |g|(|m|)| |#=| |#if| |m| |==| |0| |#then| |1| |#else| |f|(|m| |-| |1|)|↵|f|(|4|)|
//│ Parsed: {class True {}; class False {}; fun f = (n,) => if (==(n,)(0,)) then 0 else g(-(n,)(1,),); fun g = (m,) => if (==(m,)(0,)) then 1 else f(-(m,)(1,),); f(4,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(g), Set(j$1), Set(f), Set(j$0))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #17
//│ if x$0 -- #16
//│   true =>
//│     jump j$0(0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #15
//│     let* (x$3) = g(x$2) in -- #14
//│     jump j$0(x$3) -- #13
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0],
//│ 1, 
//│ let x$4 = ==(m$0,0) in -- #35
//│ if x$4 -- #34
//│   true =>
//│     jump j$1(1) -- #23
//│   false =>
//│     let x$6 = -(m$0,1) in -- #33
//│     let* (x$7) = f(x$6) in -- #32
//│     jump j$1(x$7) -- #31
//│ )
//│ Def(3, j$1, [x$5],
//│ 1, 
//│ x$5 -- #21
//│ )
//│ },
//│ let* (x$8) = f(4) in -- #41
//│ x$8 -- #40)
//│ 
//│ Interpreted:
//│ 0
