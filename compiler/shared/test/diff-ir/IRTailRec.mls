:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:interpIR
@tailrec
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |@|tailrec|↵|#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(fact))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = fact_jp(acc$0,n$0) in -- #38
//│ r0 -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = fact_jp(acc$0,n$0) in -- #38
//│ r0 -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:interpIR
@tailrec
class True
class False
fun fact(acc, n) =
  val x = if n > 0 then n - 1
    else 0
  if x <= 0 then
    acc
  else 
    @tailrec fact(n * acc, x) 
fact(1, 5)
//│ |@|tailrec|↵|#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#val| |x| |#=| |#if| |n| |>| |0| |#then| |n| |-| |1|→|#else| |0|←|↵|#if| |x| |<=| |0| |#then|→|acc|←|↵|#else| |→|@|tailrec| |fact|(|n| |*| |acc|,| |x|)| |←|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {let x = if (>(n,)(0,)) then -(n,)(1,) else 0; if (<=(x,)(0,)) then {acc} else {@tailrec fact(*(n,)(acc,), x,)}}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = >(n$0,0) in -- #32
//│ if x$0 -- #31
//│   true =>
//│     let x$6 = -(n$0,1) in -- #28
//│     jump j$0(x$6,acc$0,n$0) -- #27
//│   false =>
//│     jump j$0(0,acc$0,n$0) -- #30
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(j$1), Set(fact))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = _fact_j$0_opt(0,acc$0,n$0,0,0,0) in -- #60
//│ r0 -- #59
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ Def(3, _fact_j$0_opt_jp, [tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ let scrut = ==(2,tailrecBranch$) in -- #57
//│ if scrut -- #56
//│   true =>
//│     let x$2 = <=(j$0_x$1,0) in -- #55
//│     if x$2 -- #54
//│       true =>
//│         jump j$1(j$0_acc$0) -- #51
//│       false =>
//│         let x$4 = *(j$0_n$0,j$0_acc$0) in -- #53
//│         jump _fact_j$0_opt_jp(0,x$4,j$0_x$1,j$0_x$1,j$0_acc$0,j$0_n$0) -- #52
//│   false =>
//│     let x$0 = >(fact_n$0,0) in -- #50
//│     if x$0 -- #49
//│       true =>
//│         let x$6 = -(fact_n$0,1) in -- #47
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,x$6,fact_acc$0,fact_n$0) -- #46
//│       false =>
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,0,fact_acc$0,fact_n$0) -- #48
//│ )
//│ Def(4, _fact_j$0_opt, [tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ jump _fact_j$0_opt_jp(tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0) -- #58
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = _fact_j$0_opt(0,acc$0,n$0,0,0,0) in -- #60
//│ r0 -- #59
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ Def(3, _fact_j$0_opt_jp, [tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ let scrut = ==(2,tailrecBranch$) in -- #57
//│ if scrut -- #56
//│   true =>
//│     let x$2 = <=(j$0_x$1,0) in -- #55
//│     if x$2 -- #54
//│       true =>
//│         jump j$1(j$0_acc$0) -- #51
//│       false =>
//│         let x$4 = *(j$0_n$0,j$0_acc$0) in -- #53
//│         jump _fact_j$0_opt_jp(0,x$4,j$0_x$1,j$0_x$1,j$0_acc$0,j$0_n$0) -- #52
//│   false =>
//│     let x$0 = >(fact_n$0,0) in -- #50
//│     if x$0 -- #49
//│       true =>
//│         let x$6 = -(fact_n$0,1) in -- #47
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,x$6,fact_acc$0,fact_n$0) -- #46
//│       false =>
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,0,fact_acc$0,fact_n$0) -- #48
//│ )
//│ Def(4, _fact_j$0_opt, [tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ jump _fact_j$0_opt_jp(tailrecBranch$,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0) -- #58
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Interpreted:
//│ 120

:noTailRec
:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

:interpIR
class True
class False
fun double(x) = x * 2
@tailrec fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
@tailrec fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|@|tailrec| |#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|@|tailrec| |#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(g, f), Set(double))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch$) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch$) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch$,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

class True
class False
@tailrec fun f(a, b, c) = g(0, 0)
@tailrec fun g(d, e) = h(0, 0, 0, 0)
@tailrec fun h(p, q, r, s) = f(0, 0, 0)
2 
//│ |#class| |True|↵|#class| |False|↵|@|tailrec| |#fun| |f|(|a|,| |b|,| |c|)| |#=| |g|(|0|,| |0|)|↵|@|tailrec| |#fun| |g|(|d|,| |e|)| |#=| |h|(|0|,| |0|,| |0|,| |0|)|↵|@|tailrec| |#fun| |h|(|p|,| |q|,| |r|,| |s|)| |#=| |f|(|0|,| |0|,| |0|)|↵|2| |
//│ Parsed: {class True {}; class False {}; fun f = (a, b, c,) => g(0, 0,); fun g = (d, e,) => h(0, 0, 0, 0,); fun h = (p, q, r, s,) => f(0, 0, 0,); 2}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (x$0) = g(0,0) in -- #7
//│ x$0 -- #6
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (x$1) = h(0,0,0,0) in -- #19
//│ x$1 -- #18
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (x$2) = f(0,0,0) in -- #29
//│ x$2 -- #28
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(h, g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch$) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch$) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, _IdContext, []),ClassInfo(3, _Context, [acc,ptr,field])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch$) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch$) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch$,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)

// TODO: should error, but it seems IR errors are not considered errors by the unit test framework
// :e
class True
class False
fun hello() =
    @tailrec hello()
    2
hello() 
//│ |#class| |True|↵|#class| |False|↵|#fun| |hello|(||)| |#=|→|@|tailrec| |hello|(||)|↵|2|←|↵|hello|(||)| |
//│ Parsed: {class True {}; class False {}; fun hello = () => {@tailrec hello(); 2}; hello()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, hello, [],
//│ 1, 
//│ let* (x$0) = @tailrec hello() in -- #4
//│ 2 -- #3
//│ )
//│ },
//│ let* (x$1) = hello() in -- #8
//│ x$1 -- #7)
//│ 
//│ IR Processing Failed: not a tail call

:interpIR
class True
class False
class Cons(h, t)
class Nil
@tailrec fun addOne(xs) =
  if xs is
    Cons(h, t) then Cons(h + 1, @tailrec addOne(t))
    Nil then Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|@|tailrec| |#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is|→|Cons|(|h|,| |t|)| |#then| |Cons|(|h| |+| |1|,| |@|tailrec| |addOne|(|t|)|)|↵|Nil| |#then| |Nil|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then Cons(+(h,)(1,), @tailrec addOne(t,),); (Nil) then Nil›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #27
//│   Cons =>
//│     let x$1 = xs$0.t in -- #23
//│     let x$2 = xs$0.h in -- #22
//│     let x$3 = +(x$2,1) in -- #21
//│     let* (x$4) = @tailrec addOne(x$1) in -- #20
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #26
//│     jump j$0(x$6) -- #25
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #80
//│ let* (res) = addOne_modcons(idCtx,xs$0) in -- #79
//│ res -- #78
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, _addOne_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #59
//│   _IdContext =>
//│     x -- #58
//│   _Context =>
//│     let field = ctx.field in -- #57
//│     let ptr = ctx.ptr in -- #56
//│     let _ = assign ptr.t := x in -- #55
//│     let acc = ctx.acc in -- #54
//│     acc -- #53
//│ )
//│ Def(3, _addOne_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #65
//│ let ctx2ptr = ctx2.ptr in -- #64
//│ let ctx2field = ctx2.field in -- #63
//│ let* (newAcc) = _addOne_ctx_app(ctx1,ctx2acc) in -- #62
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #61
//│ ret -- #60
//│ )
//│ Def(5, addOne_modcons_jp, [ctx,xs$0],
//│ 1, 
//│ case xs$0 of -- #91
//│   Cons =>
//│     let x$1 = xs$0.t in -- #87
//│     let x$2 = xs$0.h in -- #86
//│     let x$3 = +(x$2,1) in -- #85
//│     let x$5 = Cons(x$3,0) in -- #84
//│     let ctx2 = _Context(x$5,x$5,0) in -- #83
//│     let* (composed) = _addOne_ctx_comp(ctx,ctx2) in -- #82
//│     jump addOne_modcons_jp(composed,x$1) -- #81
//│   Nil =>
//│     let x$6 = Nil() in -- #90
//│     let* (res) = _addOne_ctx_app(ctx,x$6) in -- #89
//│     res -- #88
//│ )
//│ Def(6, addOne_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = addOne_modcons_jp(ctx,xs$0) in -- #93
//│ r0 -- #92
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #80
//│ let* (res) = addOne_modcons(idCtx,xs$0) in -- #79
//│ res -- #78
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, _addOne_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #59
//│   _IdContext =>
//│     x -- #58
//│   _Context =>
//│     let field = ctx.field in -- #57
//│     let ptr = ctx.ptr in -- #56
//│     let _ = assign ptr.t := x in -- #55
//│     let acc = ctx.acc in -- #54
//│     acc -- #53
//│ )
//│ Def(3, _addOne_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #65
//│ let ctx2ptr = ctx2.ptr in -- #64
//│ let ctx2field = ctx2.field in -- #63
//│ let* (newAcc) = _addOne_ctx_app(ctx1,ctx2acc) in -- #62
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #61
//│ ret -- #60
//│ )
//│ Def(5, addOne_modcons_jp, [ctx,xs$0],
//│ 1, 
//│ case xs$0 of -- #91
//│   Cons =>
//│     let x$1 = xs$0.t in -- #87
//│     let x$2 = xs$0.h in -- #86
//│     let x$3 = +(x$2,1) in -- #85
//│     let x$5 = Cons(x$3,0) in -- #84
//│     let ctx2 = _Context(x$5,x$5,0) in -- #83
//│     let* (composed) = _addOne_ctx_comp(ctx,ctx2) in -- #82
//│     jump addOne_modcons_jp(composed,x$1) -- #81
//│   Nil =>
//│     let x$6 = Nil() in -- #90
//│     let* (res) = _addOne_ctx_app(ctx,x$6) in -- #89
//│     res -- #88
//│ )
//│ Def(6, addOne_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = addOne_modcons_jp(ctx,xs$0) in -- #93
//│ r0 -- #92
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:noTailRec
:interpIR
class True
class False
class Zero
class S(x)
fun a(n) =
  if n is
    S(x) then S(@tailrec b(x))
    Zero then S(Zero)
fun b(n) =
  if n is
    S(x) then S(S(@tailrec a(x)))
    Zero then S(S(Zero))
a(S(S(S(Zero))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Zero|↵|#class| |S|(|x|)|↵|#fun| |a|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|@|tailrec| |b|(|x|)|)|↵|Zero| |#then| |S|(|Zero|)|←|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|S|(|@|tailrec| |a|(|x|)|)|)|↵|Zero| |#then| |S|(|S|(|Zero|)|)|←|←|↵|a|(|S|(|S|(|S|(|Zero|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Zero {}; class S(x,) {}; fun a = (n,) => {if n is ‹(S(x,)) then S(@tailrec b(x,),); (Zero) then S(Zero,)›}; fun b = (n,) => {if n is ‹(S(x,)) then S(S(@tailrec a(x,),),); (Zero) then S(S(Zero,),)›}; a(S(S(S(Zero,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #14
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #42
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #14
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #42
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #14
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #42
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Interpreted:
//│ S(S(S(S(S(S(Zero()))))))

:interpIR
class True
class False
class Zero
class S(x)
@tailrec fun a(n) =
  if n is
    S(x) then S(@tailrec b(x))
    Zero then S(Zero)
@tailrec fun b(n) =
  if n is
    S(x) then S(S(@tailrec a(x)))
    Zero then S(S(Zero))
a(S(S(S(Zero))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Zero|↵|#class| |S|(|x|)|↵|@|tailrec| |#fun| |a|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|@|tailrec| |b|(|x|)|)|↵|Zero| |#then| |S|(|Zero|)|←|←|↵|@|tailrec| |#fun| |b|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|S|(|@|tailrec| |a|(|x|)|)|)|↵|Zero| |#then| |S|(|S|(|Zero|)|)|←|←|↵|a|(|S|(|S|(|S|(|Zero|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Zero {}; class S(x,) {}; fun a = (n,) => {if n is ‹(S(x,)) then S(@tailrec b(x,),); (Zero) then S(Zero,)›}; fun b = (n,) => {if n is ‹(S(x,)) then S(S(@tailrec a(x,),),); (Zero) then S(S(Zero,),)›}; a(S(S(S(Zero,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #14
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #42
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x]),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #117
//│ let* (res) = a_modcons(idCtx,n$0) in -- #116
//│ res -- #115
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let idCtx = _IdContext() in -- #103
//│ let* (res) = b_modcons(idCtx,n$1) in -- #102
//│ res -- #101
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #81
//│   _IdContext =>
//│     x -- #80
//│   _Context =>
//│     let field = ctx.field in -- #79
//│     let ptr = ctx.ptr in -- #78
//│     let _ = assign ptr.x := x in -- #77
//│     let acc = ctx.acc in -- #76
//│     acc -- #75
//│ )
//│ Def(5, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #87
//│ let ctx2ptr = ctx2.ptr in -- #86
//│ let ctx2field = ctx2.field in -- #85
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #84
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #83
//│ ret -- #82
//│ )
//│ Def(6, b_modcons, [ctx,n$1],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,ctx,n$1,0,0) in -- #156
//│ r0 -- #155
//│ )
//│ Def(7, a_modcons, [ctx,n$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(7,0,0,ctx,n$0) in -- #158
//│ r0 -- #157
//│ )
//│ Def(8, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0],
//│ 1, 
//│ let scrut = ==(7,tailrecBranch$) in -- #153
//│ if scrut -- #152
//│   true =>
//│     case a_modcons_n$0 of -- #151
//│       S =>
//│         let x$1 = a_modcons_n$0.x in -- #146
//│         let x$3 = S(0) in -- #145
//│         let ctx2 = _Context(x$3,x$3,0) in -- #144
//│         let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #143
//│         jump _b_modcons_a_modcons_opt_jp(6,composed,x$1,a_modcons_ctx,a_modcons_n$0) -- #142
//│       Zero =>
//│         let x$4 = Zero() in -- #150
//│         let x$5 = S(x$4) in -- #149
//│         let* (res) = _b_a_ctx_app(a_modcons_ctx,x$5) in -- #148
//│         res -- #147
//│   false =>
//│     case b_modcons_n$1 of -- #141
//│       S =>
//│         let x$7 = b_modcons_n$1.x in -- #135
//│         let x$9 = S(0) in -- #134
//│         let x$10 = S(x$9) in -- #133
//│         let ctx2 = _Context(x$10,x$9,0) in -- #132
//│         let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #131
//│         jump _b_modcons_a_modcons_opt_jp(7,b_modcons_ctx,b_modcons_n$1,composed,x$7) -- #130
//│       Zero =>
//│         let x$11 = Zero() in -- #140
//│         let x$12 = S(x$11) in -- #139
//│         let x$13 = S(x$12) in -- #138
//│         let* (res) = _b_a_ctx_app(b_modcons_ctx,x$13) in -- #137
//│         res -- #136
//│ )
//│ Def(9, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0) -- #154
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x]),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #117
//│ let* (res) = a_modcons(idCtx,n$0) in -- #116
//│ res -- #115
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let idCtx = _IdContext() in -- #103
//│ let* (res) = b_modcons(idCtx,n$1) in -- #102
//│ res -- #101
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #81
//│   _IdContext =>
//│     x -- #80
//│   _Context =>
//│     let field = ctx.field in -- #79
//│     let ptr = ctx.ptr in -- #78
//│     let _ = assign ptr.x := x in -- #77
//│     let acc = ctx.acc in -- #76
//│     acc -- #75
//│ )
//│ Def(5, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #87
//│ let ctx2ptr = ctx2.ptr in -- #86
//│ let ctx2field = ctx2.field in -- #85
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #84
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #83
//│ ret -- #82
//│ )
//│ Def(6, b_modcons, [ctx,n$1],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,ctx,n$1,0,0) in -- #156
//│ r0 -- #155
//│ )
//│ Def(7, a_modcons, [ctx,n$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(7,0,0,ctx,n$0) in -- #158
//│ r0 -- #157
//│ )
//│ Def(8, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0],
//│ 1, 
//│ let scrut = ==(7,tailrecBranch$) in -- #153
//│ if scrut -- #152
//│   true =>
//│     case a_modcons_n$0 of -- #151
//│       S =>
//│         let x$1 = a_modcons_n$0.x in -- #146
//│         let x$3 = S(0) in -- #145
//│         let ctx2 = _Context(x$3,x$3,0) in -- #144
//│         let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #143
//│         jump _b_modcons_a_modcons_opt_jp(6,composed,x$1,a_modcons_ctx,a_modcons_n$0) -- #142
//│       Zero =>
//│         let x$4 = Zero() in -- #150
//│         let x$5 = S(x$4) in -- #149
//│         let* (res) = _b_a_ctx_app(a_modcons_ctx,x$5) in -- #148
//│         res -- #147
//│   false =>
//│     case b_modcons_n$1 of -- #141
//│       S =>
//│         let x$7 = b_modcons_n$1.x in -- #135
//│         let x$9 = S(0) in -- #134
//│         let x$10 = S(x$9) in -- #133
//│         let ctx2 = _Context(x$10,x$9,0) in -- #132
//│         let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #131
//│         jump _b_modcons_a_modcons_opt_jp(7,b_modcons_ctx,b_modcons_n$1,composed,x$7) -- #130
//│       Zero =>
//│         let x$11 = Zero() in -- #140
//│         let x$12 = S(x$11) in -- #139
//│         let x$13 = S(x$12) in -- #138
//│         let* (res) = _b_a_ctx_app(b_modcons_ctx,x$13) in -- #137
//│         res -- #136
//│ )
//│ Def(9, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,b_modcons_n$1,a_modcons_ctx,a_modcons_n$0) -- #154
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Interpreted:
//│ S(S(S(S(S(S(Zero()))))))

:interpIR
class True
class False
class Cons(h, t)
class Nil
@tailrec fun addOne(xs) =
  if xs is 
    Cons(h, t) then
      val next = @tailrec addOne(t)
      val ret = Cons(h + 1, next)
      val rett = ret
      rett
    Nil then 
      Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|@|tailrec| |#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is| |→|Cons|(|h|,| |t|)| |#then|→|#val| |next| |#=| |@|tailrec| |addOne|(|t|)|↵|#val| |ret| |#=| |Cons|(|h| |+| |1|,| |next|)|↵|#val| |rett| |#=| |ret|↵|rett|←|↵|Nil| |#then| |→|Nil|←|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then {let next = @tailrec addOne(t,); let ret = Cons(+(h,)(1,), next,); let rett = ret; rett}; (Nil) then {Nil}›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #30
//│   Cons =>
//│     let x$1 = xs$0.t in -- #26
//│     let x$2 = xs$0.h in -- #25
//│     let* (x$3) = @tailrec addOne(x$1) in -- #24
//│     let x$4 = +(x$2,1) in -- #23
//│     let x$5 = Cons(x$4,x$3) in -- #22
//│     jump j$0(x$5) -- #21
//│   Nil =>
//│     let x$6 = Nil() in -- #29
//│     jump j$0(x$6) -- #28
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #83
//│ let* (res) = addOne_modcons(idCtx,xs$0) in -- #82
//│ res -- #81
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, _addOne_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #62
//│   _IdContext =>
//│     x -- #61
//│   _Context =>
//│     let field = ctx.field in -- #60
//│     let ptr = ctx.ptr in -- #59
//│     let _ = assign ptr.t := x in -- #58
//│     let acc = ctx.acc in -- #57
//│     acc -- #56
//│ )
//│ Def(3, _addOne_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #68
//│ let ctx2ptr = ctx2.ptr in -- #67
//│ let ctx2field = ctx2.field in -- #66
//│ let* (newAcc) = _addOne_ctx_app(ctx1,ctx2acc) in -- #65
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #64
//│ ret -- #63
//│ )
//│ Def(5, addOne_modcons_jp, [ctx,xs$0],
//│ 1, 
//│ case xs$0 of -- #94
//│   Cons =>
//│     let x$1 = xs$0.t in -- #90
//│     let x$2 = xs$0.h in -- #89
//│     let x$4 = +(x$2,1) in -- #88
//│     let x$5 = Cons(x$4,0) in -- #87
//│     let ctx2 = _Context(x$5,x$5,0) in -- #86
//│     let* (composed) = _addOne_ctx_comp(ctx,ctx2) in -- #85
//│     jump addOne_modcons_jp(composed,x$1) -- #84
//│   Nil =>
//│     let x$6 = Nil() in -- #93
//│     let* (res) = _addOne_ctx_app(ctx,x$6) in -- #92
//│     res -- #91
//│ )
//│ Def(6, addOne_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = addOne_modcons_jp(ctx,xs$0) in -- #96
//│ r0 -- #95
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #83
//│ let* (res) = addOne_modcons(idCtx,xs$0) in -- #82
//│ res -- #81
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, _addOne_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #62
//│   _IdContext =>
//│     x -- #61
//│   _Context =>
//│     let field = ctx.field in -- #60
//│     let ptr = ctx.ptr in -- #59
//│     let _ = assign ptr.t := x in -- #58
//│     let acc = ctx.acc in -- #57
//│     acc -- #56
//│ )
//│ Def(3, _addOne_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #68
//│ let ctx2ptr = ctx2.ptr in -- #67
//│ let ctx2field = ctx2.field in -- #66
//│ let* (newAcc) = _addOne_ctx_app(ctx1,ctx2acc) in -- #65
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #64
//│ ret -- #63
//│ )
//│ Def(5, addOne_modcons_jp, [ctx,xs$0],
//│ 1, 
//│ case xs$0 of -- #94
//│   Cons =>
//│     let x$1 = xs$0.t in -- #90
//│     let x$2 = xs$0.h in -- #89
//│     let x$4 = +(x$2,1) in -- #88
//│     let x$5 = Cons(x$4,0) in -- #87
//│     let ctx2 = _Context(x$5,x$5,0) in -- #86
//│     let* (composed) = _addOne_ctx_comp(ctx,ctx2) in -- #85
//│     jump addOne_modcons_jp(composed,x$1) -- #84
//│   Nil =>
//│     let x$6 = Nil() in -- #93
//│     let* (res) = _addOne_ctx_app(ctx,x$6) in -- #92
//│     res -- #91
//│ )
//│ Def(6, addOne_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = addOne_modcons_jp(ctx,xs$0) in -- #96
//│ r0 -- #95
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:interpIR
class True
class False
class Nil
class Cons(m, n)
@tailrec fun a(x) =
  if x is
    Cons(m, n) then
      if m < 0 then
        Cons(-1, Nil)
      else 
        Cons(m * 4, b(m - 2))
    Nil then Nil
@tailrec fun b(n) =
  if n <= 0 then 
    Cons(0, Nil)
  else 
    a(Cons(n, Nil))
b(16)
//│ |#class| |True|↵|#class| |False|↵|#class| |Nil|↵|#class| |Cons|(|m|,| |n|)|↵|@|tailrec| |#fun| |a|(|x|)| |#=|→|#if| |x| |is|→|Cons|(|m|,| |n|)| |#then|→|#if| |m| |<| |0| |#then|→|Cons|(|-|1|,| |Nil|)|←|↵|#else| |→|Cons|(|m| |*| |4|,| |b|(|m| |-| |2|)|)|←|←|↵|Nil| |#then| |Nil|←|←|↵|@|tailrec| |#fun| |b|(|n|)| |#=|→|#if| |n| |<=| |0| |#then| |→|Cons|(|0|,| |Nil|)|←|↵|#else| |→|a|(|Cons|(|n|,| |Nil|)|)|←|←|↵|b|(|16|)|
//│ Parsed: {class True {}; class False {}; class Nil {}; class Cons(m, n,) {}; fun a = (x,) => {if x is ‹(Cons(m, n,)) then {if (<(m,)(0,)) then {Cons(-1, Nil,)} else {Cons(*(m,)(4,), b(-(m,)(2,),),)}}; (Nil) then Nil›}; fun b = (n,) => {if (<=(n,)(0,)) then {Cons(0, Nil,)} else {a(Cons(n, Nil,),)}}; b(16,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Nil, []),ClassInfo(3, Cons, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ case x$0 of -- #46
//│   Cons =>
//│     let x$2 = x$0.n in -- #42
//│     let x$3 = x$0.m in -- #41
//│     let x$4 = <(x$3,0) in -- #40
//│     if x$4 -- #39
//│       true =>
//│         let x$6 = Nil() in -- #19
//│         let x$7 = Cons(-1,x$6) in -- #18
//│         jump j$1(x$7) -- #17
//│       false =>
//│         let x$8 = *(x$3,4) in -- #38
//│         let x$9 = -(x$3,2) in -- #37
//│         let* (x$10) = b(x$9) in -- #36
//│         let x$11 = Cons(x$8,x$10) in -- #35
//│         jump j$1(x$11) -- #34
//│   Nil =>
//│     let x$12 = Nil() in -- #45
//│     jump j$0(x$12) -- #44
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, j$1, [x$5],
//│ 1, 
//│ jump j$0(x$5) -- #10
//│ )
//│ Def(3, b, [n$0],
//│ 1, 
//│ let x$13 = <=(n$0,0) in -- #75
//│ if x$13 -- #74
//│   true =>
//│     let x$15 = Nil() in -- #59
//│     let x$16 = Cons(0,x$15) in -- #58
//│     jump j$2(x$16) -- #57
//│   false =>
//│     let x$17 = Nil() in -- #73
//│     let x$18 = Cons(n$0,x$17) in -- #72
//│     let* (x$19) = a(x$18) in -- #71
//│     jump j$2(x$19) -- #70
//│ )
//│ Def(4, j$2, [x$14],
//│ 1, 
//│ x$14 -- #50
//│ )
//│ },
//│ let* (x$20) = b(16) in -- #81
//│ x$20 -- #80)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$2), Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Nil, []),ClassInfo(3, Cons, [m,n]),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #129
//│ let* (res) = a_modcons(idCtx,x$0) in -- #128
//│ res -- #127
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, j$1, [x$5],
//│ 1, 
//│ jump j$0(x$5) -- #10
//│ )
//│ Def(3, b, [n$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #107
//│ let* (res) = b_modcons(idCtx,n$0) in -- #106
//│ res -- #105
//│ )
//│ Def(4, j$2, [x$14],
//│ 1, 
//│ x$14 -- #50
//│ )
//│ Def(5, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #88
//│   _IdContext =>
//│     x -- #87
//│   _Context =>
//│     let field = ctx.field in -- #86
//│     let ptr = ctx.ptr in -- #85
//│     let _ = assign ptr.n := x in -- #84
//│     let acc = ctx.acc in -- #83
//│     acc -- #82
//│ )
//│ Def(6, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #94
//│ let ctx2ptr = ctx2.ptr in -- #93
//│ let ctx2field = ctx2.field in -- #92
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #91
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #90
//│ ret -- #89
//│ )
//│ Def(7, b_modcons, [ctx,n$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(7,ctx,n$0,0,0) in -- #170
//│ r0 -- #169
//│ )
//│ Def(8, a_modcons, [ctx,x$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(8,0,0,ctx,x$0) in -- #172
//│ r0 -- #171
//│ )
//│ Def(9, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0],
//│ 1, 
//│ let scrut = ==(8,tailrecBranch$) in -- #167
//│ if scrut -- #166
//│   true =>
//│     case a_modcons_x$0 of -- #165
//│       Cons =>
//│         let x$2 = a_modcons_x$0.n in -- #161
//│         let x$3 = a_modcons_x$0.m in -- #160
//│         let x$4 = <(x$3,0) in -- #159
//│         if x$4 -- #158
//│           true =>
//│             let x$6 = Nil() in -- #151
//│             let x$7 = Cons(-1,x$6) in -- #150
//│             let* (res) = _b_a_ctx_app(a_modcons_ctx,x$7) in -- #149
//│             res -- #148
//│           false =>
//│             let x$8 = *(x$3,4) in -- #157
//│             let x$9 = -(x$3,2) in -- #156
//│             let x$11 = Cons(x$8,0) in -- #155
//│             let ctx2 = _Context(x$11,x$11,0) in -- #154
//│             let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #153
//│             jump _b_modcons_a_modcons_opt_jp(7,composed,x$9,a_modcons_ctx,a_modcons_x$0) -- #152
//│       Nil =>
//│         let x$12 = Nil() in -- #164
//│         let* (res) = _b_a_ctx_app(a_modcons_ctx,x$12) in -- #163
//│         res -- #162
//│   false =>
//│     let x$13 = <=(b_modcons_n$0,0) in -- #147
//│     if x$13 -- #146
//│       true =>
//│         let x$15 = Nil() in -- #142
//│         let x$16 = Cons(0,x$15) in -- #141
//│         let* (res) = _b_a_ctx_app(b_modcons_ctx,x$16) in -- #140
//│         res -- #139
//│       false =>
//│         let x$17 = Nil() in -- #145
//│         let x$18 = Cons(b_modcons_n$0,x$17) in -- #144
//│         jump _b_modcons_a_modcons_opt_jp(8,b_modcons_ctx,b_modcons_n$0,b_modcons_ctx,x$18) -- #143
//│ )
//│ Def(10, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0) -- #168
//│ )
//│ },
//│ let* (x$20) = b(16) in -- #81
//│ x$20 -- #80)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Nil, []),ClassInfo(3, Cons, [m,n]),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #129
//│ let* (res) = a_modcons(idCtx,x$0) in -- #128
//│ res -- #127
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, j$1, [x$5],
//│ 1, 
//│ jump j$0(x$5) -- #10
//│ )
//│ Def(3, b, [n$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #107
//│ let* (res) = b_modcons(idCtx,n$0) in -- #106
//│ res -- #105
//│ )
//│ Def(4, j$2, [x$14],
//│ 1, 
//│ x$14 -- #50
//│ )
//│ Def(5, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #88
//│   _IdContext =>
//│     x -- #87
//│   _Context =>
//│     let field = ctx.field in -- #86
//│     let ptr = ctx.ptr in -- #85
//│     let _ = assign ptr.n := x in -- #84
//│     let acc = ctx.acc in -- #83
//│     acc -- #82
//│ )
//│ Def(6, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #94
//│ let ctx2ptr = ctx2.ptr in -- #93
//│ let ctx2field = ctx2.field in -- #92
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #91
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #90
//│ ret -- #89
//│ )
//│ Def(7, b_modcons, [ctx,n$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(7,ctx,n$0,0,0) in -- #170
//│ r0 -- #169
//│ )
//│ Def(8, a_modcons, [ctx,x$0],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(8,0,0,ctx,x$0) in -- #172
//│ r0 -- #171
//│ )
//│ Def(9, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0],
//│ 1, 
//│ let scrut = ==(8,tailrecBranch$) in -- #167
//│ if scrut -- #166
//│   true =>
//│     case a_modcons_x$0 of -- #165
//│       Cons =>
//│         let x$2 = a_modcons_x$0.n in -- #161
//│         let x$3 = a_modcons_x$0.m in -- #160
//│         let x$4 = <(x$3,0) in -- #159
//│         if x$4 -- #158
//│           true =>
//│             let x$6 = Nil() in -- #151
//│             let x$7 = Cons(-1,x$6) in -- #150
//│             let* (res) = _b_a_ctx_app(a_modcons_ctx,x$7) in -- #149
//│             res -- #148
//│           false =>
//│             let x$8 = *(x$3,4) in -- #157
//│             let x$9 = -(x$3,2) in -- #156
//│             let x$11 = Cons(x$8,0) in -- #155
//│             let ctx2 = _Context(x$11,x$11,0) in -- #154
//│             let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #153
//│             jump _b_modcons_a_modcons_opt_jp(7,composed,x$9,a_modcons_ctx,a_modcons_x$0) -- #152
//│       Nil =>
//│         let x$12 = Nil() in -- #164
//│         let* (res) = _b_a_ctx_app(a_modcons_ctx,x$12) in -- #163
//│         res -- #162
//│   false =>
//│     let x$13 = <=(b_modcons_n$0,0) in -- #147
//│     if x$13 -- #146
//│       true =>
//│         let x$15 = Nil() in -- #142
//│         let x$16 = Cons(0,x$15) in -- #141
//│         let* (res) = _b_a_ctx_app(b_modcons_ctx,x$16) in -- #140
//│         res -- #139
//│       false =>
//│         let x$17 = Nil() in -- #145
//│         let x$18 = Cons(b_modcons_n$0,x$17) in -- #144
//│         jump _b_modcons_a_modcons_opt_jp(8,b_modcons_ctx,b_modcons_n$0,b_modcons_ctx,x$18) -- #143
//│ )
//│ Def(10, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,b_modcons_n$0,a_modcons_ctx,a_modcons_x$0) -- #168
//│ )
//│ },
//│ let* (x$20) = b(16) in -- #81
//│ x$20 -- #80)
//│ 
//│ Interpreted:
//│ Cons(64,Cons(56,Cons(48,Cons(40,Cons(32,Cons(24,Cons(16,Cons(8,Cons(0,Nil())))))))))

:noTailRec
:interpIR
class True
class False
class Cons(h, t)
class Nil
fun foo(xs) =
  if xs is 
    Cons(h, t) then
      if h > 5 then foo(t)
      else 
        val item = if h < 3 then -1 else 100 
        Cons(item, Cons(h, foo(t)))
    Nil then 
      Nil
foo(Cons(1, Cons(6, Cons(7, Cons(4, Cons(2, Cons(3, Cons(9, Nil))))))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#fun| |foo|(|xs|)| |#=|→|#if| |xs| |is| |→|Cons|(|h|,| |t|)| |#then|→|#if| |h| |>| |5| |#then| |foo|(|t|)|↵|#else| |→|#val| |item| |#=| |#if| |h| |<| |3| |#then| |-|1| |#else| |100| |↵|Cons|(|item|,| |Cons|(|h|,| |foo|(|t|)|)|)|←|←|↵|Nil| |#then| |→|Nil|←|←|←|↵|foo|(|Cons|(|1|,| |Cons|(|6|,| |Cons|(|7|,| |Cons|(|4|,| |Cons|(|2|,| |Cons|(|3|,| |Cons|(|9|,| |Nil|)|)|)|)|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun foo = (xs,) => {if xs is ‹(Cons(h, t,)) then {if (>(h,)(5,)) then foo(t,) else {let item = if (<(h,)(3,)) then -1 else 100; Cons(item, Cons(h, foo(t,),),)}}; (Nil) then {Nil}›}; foo(Cons(1, Cons(6, Cons(7, Cons(4, Cons(2, Cons(3, Cons(9, Nil,),),),),),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ case xs$0 of -- #54
//│   Cons =>
//│     let x$1 = xs$0.t in -- #50
//│     let x$2 = xs$0.h in -- #49
//│     let x$3 = >(x$2,5) in -- #48
//│     if x$3 -- #47
//│       true =>
//│         let* (x$5) = foo(x$1) in -- #17
//│         jump j$1(x$5) -- #16
//│       false =>
//│         let x$6 = <(x$2,3) in -- #46
//│         if x$6 -- #45
//│           true =>
//│             jump j$2(-1,x$1,x$2) -- #42
//│           false =>
//│             jump j$2(100,x$1,x$2) -- #44
//│   Nil =>
//│     let x$11 = Nil() in -- #53
//│     jump j$0(x$11) -- #52
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ case xs$0 of -- #54
//│   Cons =>
//│     let x$1 = xs$0.t in -- #50
//│     let x$2 = xs$0.h in -- #49
//│     let x$3 = >(x$2,5) in -- #48
//│     if x$3 -- #47
//│       true =>
//│         let* (x$5) = foo(x$1) in -- #17
//│         jump j$1(x$5) -- #16
//│       false =>
//│         let x$6 = <(x$2,3) in -- #46
//│         if x$6 -- #45
//│           true =>
//│             jump j$2(-1,x$1,x$2) -- #42
//│           false =>
//│             jump j$2(100,x$1,x$2) -- #44
//│   Nil =>
//│     let x$11 = Nil() in -- #53
//│     jump j$0(x$11) -- #52
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ case xs$0 of -- #54
//│   Cons =>
//│     let x$1 = xs$0.t in -- #50
//│     let x$2 = xs$0.h in -- #49
//│     let x$3 = >(x$2,5) in -- #48
//│     if x$3 -- #47
//│       true =>
//│         let* (x$5) = foo(x$1) in -- #17
//│         jump j$1(x$5) -- #16
//│       false =>
//│         let x$6 = <(x$2,3) in -- #46
//│         if x$6 -- #45
//│           true =>
//│             jump j$2(-1,x$1,x$2) -- #42
//│           false =>
//│             jump j$2(100,x$1,x$2) -- #44
//│   Nil =>
//│     let x$11 = Nil() in -- #53
//│     jump j$0(x$11) -- #52
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ 
//│ Interpreted:
//│ Cons(-1,Cons(1,Cons(100,Cons(4,Cons(-1,Cons(2,Cons(100,Cons(3,Nil()))))))))

:interpIR
class True
class False
class Cons(h, t)
class Nil
@tailrec fun foo(xs) =
  if xs is 
    Cons(h, t) then
      if h > 5 then foo(t)
      else 
        val item = if h < 3 then -1 else 100 
        Cons(item, Cons(h, foo(t)))
    Nil then 
      Nil
foo(Cons(1, Cons(6, Cons(7, Cons(4, Cons(2, Cons(3, Cons(9, Nil))))))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|@|tailrec| |#fun| |foo|(|xs|)| |#=|→|#if| |xs| |is| |→|Cons|(|h|,| |t|)| |#then|→|#if| |h| |>| |5| |#then| |foo|(|t|)|↵|#else| |→|#val| |item| |#=| |#if| |h| |<| |3| |#then| |-|1| |#else| |100| |↵|Cons|(|item|,| |Cons|(|h|,| |foo|(|t|)|)|)|←|←|↵|Nil| |#then| |→|Nil|←|←|←|↵|foo|(|Cons|(|1|,| |Cons|(|6|,| |Cons|(|7|,| |Cons|(|4|,| |Cons|(|2|,| |Cons|(|3|,| |Cons|(|9|,| |Nil|)|)|)|)|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun foo = (xs,) => {if xs is ‹(Cons(h, t,)) then {if (>(h,)(5,)) then foo(t,) else {let item = if (<(h,)(3,)) then -1 else 100; Cons(item, Cons(h, foo(t,),),)}}; (Nil) then {Nil}›}; foo(Cons(1, Cons(6, Cons(7, Cons(4, Cons(2, Cons(3, Cons(9, Nil,),),),),),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ case xs$0 of -- #54
//│   Cons =>
//│     let x$1 = xs$0.t in -- #50
//│     let x$2 = xs$0.h in -- #49
//│     let x$3 = >(x$2,5) in -- #48
//│     if x$3 -- #47
//│       true =>
//│         let* (x$5) = foo(x$1) in -- #17
//│         jump j$1(x$5) -- #16
//│       false =>
//│         let x$6 = <(x$2,3) in -- #46
//│         if x$6 -- #45
//│           true =>
//│             jump j$2(-1,x$1,x$2) -- #42
//│           false =>
//│             jump j$2(100,x$1,x$2) -- #44
//│   Nil =>
//│     let x$11 = Nil() in -- #53
//│     jump j$0(x$11) -- #52
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$2), Set(j$1), Set(j$0), Set(foo))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #137
//│ let* (res) = foo_modcons(idCtx,xs$0) in -- #136
//│ res -- #135
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ Def(4, _foo_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #110
//│   _IdContext =>
//│     x -- #109
//│   _Context =>
//│     let field = ctx.field in -- #108
//│     let ptr = ctx.ptr in -- #107
//│     let _ = assign ptr.t := x in -- #106
//│     let acc = ctx.acc in -- #105
//│     acc -- #104
//│ )
//│ Def(5, _foo_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #116
//│ let ctx2ptr = ctx2.ptr in -- #115
//│ let ctx2field = ctx2.field in -- #114
//│ let* (newAcc) = _foo_ctx_app(ctx1,ctx2acc) in -- #113
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #112
//│ ret -- #111
//│ )
//│ Def(7, foo_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = _foo_modcons_j$2_modcons_opt(7,ctx,xs$0,0,0,0,0) in -- #173
//│ r0 -- #172
//│ )
//│ Def(8, _foo_modcons_j$2_modcons_opt_jp, [tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #170
//│ if scrut -- #169
//│   true =>
//│     let x$9 = Cons(j$2_modcons_x$2,0) in -- #168
//│     let x$10 = Cons(j$2_modcons_x$7,x$9) in -- #167
//│     let ctx2 = _Context(x$10,x$9,0) in -- #166
//│     let* (composed) = _foo_ctx_comp(j$2_modcons_ctx,ctx2) in -- #165
//│     jump _foo_modcons_j$2_modcons_opt_jp(7,composed,j$2_modcons_x$1,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #164
//│   false =>
//│     case foo_modcons_xs$0 of -- #163
//│       Cons =>
//│         let x$1 = foo_modcons_xs$0.t in -- #159
//│         let x$2 = foo_modcons_xs$0.h in -- #158
//│         let x$3 = >(x$2,5) in -- #157
//│         if x$3 -- #156
//│           true =>
//│             jump _foo_modcons_j$2_modcons_opt_jp(7,foo_modcons_ctx,x$1,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #151
//│           false =>
//│             let x$6 = <(x$2,3) in -- #155
//│             if x$6 -- #154
//│               true =>
//│                 jump _foo_modcons_j$2_modcons_opt_jp(6,foo_modcons_ctx,foo_modcons_xs$0,foo_modcons_ctx,-1,x$1,x$2) -- #152
//│               false =>
//│                 jump _foo_modcons_j$2_modcons_opt_jp(6,foo_modcons_ctx,foo_modcons_xs$0,foo_modcons_ctx,100,x$1,x$2) -- #153
//│       Nil =>
//│         let x$11 = Nil() in -- #162
//│         let* (res) = _foo_ctx_app(foo_modcons_ctx,x$11) in -- #161
//│         res -- #160
//│ )
//│ Def(9, _foo_modcons_j$2_modcons_opt, [tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2],
//│ 1, 
//│ jump _foo_modcons_j$2_modcons_opt_jp(tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #171
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, []),ClassInfo(4, _IdContext, []),ClassInfo(5, _Context, [acc,ptr,field])}, {
//│ Def(0, foo, [xs$0],
//│ 1, 
//│ let idCtx = _IdContext() in -- #137
//│ let* (res) = foo_modcons(idCtx,xs$0) in -- #136
//│ res -- #135
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, j$1, [x$4],
//│ 1, 
//│ jump j$0(x$4) -- #10
//│ )
//│ Def(3, j$2, [x$7,x$1,x$2],
//│ 1, 
//│ let* (x$8) = foo(x$1) in -- #40
//│ let x$9 = Cons(x$2,x$8) in -- #39
//│ let x$10 = Cons(x$7,x$9) in -- #38
//│ jump j$1(x$10) -- #37
//│ )
//│ Def(4, _foo_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #110
//│   _IdContext =>
//│     x -- #109
//│   _Context =>
//│     let field = ctx.field in -- #108
//│     let ptr = ctx.ptr in -- #107
//│     let _ = assign ptr.t := x in -- #106
//│     let acc = ctx.acc in -- #105
//│     acc -- #104
//│ )
//│ Def(5, _foo_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #116
//│ let ctx2ptr = ctx2.ptr in -- #115
//│ let ctx2field = ctx2.field in -- #114
//│ let* (newAcc) = _foo_ctx_app(ctx1,ctx2acc) in -- #113
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #112
//│ ret -- #111
//│ )
//│ Def(7, foo_modcons, [ctx,xs$0],
//│ 1, 
//│ let* (r0) = _foo_modcons_j$2_modcons_opt(7,ctx,xs$0,0,0,0,0) in -- #173
//│ r0 -- #172
//│ )
//│ Def(8, _foo_modcons_j$2_modcons_opt_jp, [tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #170
//│ if scrut -- #169
//│   true =>
//│     let x$9 = Cons(j$2_modcons_x$2,0) in -- #168
//│     let x$10 = Cons(j$2_modcons_x$7,x$9) in -- #167
//│     let ctx2 = _Context(x$10,x$9,0) in -- #166
//│     let* (composed) = _foo_ctx_comp(j$2_modcons_ctx,ctx2) in -- #165
//│     jump _foo_modcons_j$2_modcons_opt_jp(7,composed,j$2_modcons_x$1,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #164
//│   false =>
//│     case foo_modcons_xs$0 of -- #163
//│       Cons =>
//│         let x$1 = foo_modcons_xs$0.t in -- #159
//│         let x$2 = foo_modcons_xs$0.h in -- #158
//│         let x$3 = >(x$2,5) in -- #157
//│         if x$3 -- #156
//│           true =>
//│             jump _foo_modcons_j$2_modcons_opt_jp(7,foo_modcons_ctx,x$1,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #151
//│           false =>
//│             let x$6 = <(x$2,3) in -- #155
//│             if x$6 -- #154
//│               true =>
//│                 jump _foo_modcons_j$2_modcons_opt_jp(6,foo_modcons_ctx,foo_modcons_xs$0,foo_modcons_ctx,-1,x$1,x$2) -- #152
//│               false =>
//│                 jump _foo_modcons_j$2_modcons_opt_jp(6,foo_modcons_ctx,foo_modcons_xs$0,foo_modcons_ctx,100,x$1,x$2) -- #153
//│       Nil =>
//│         let x$11 = Nil() in -- #162
//│         let* (res) = _foo_ctx_app(foo_modcons_ctx,x$11) in -- #161
//│         res -- #160
//│ )
//│ Def(9, _foo_modcons_j$2_modcons_opt, [tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2],
//│ 1, 
//│ jump _foo_modcons_j$2_modcons_opt_jp(tailrecBranch$,foo_modcons_ctx,foo_modcons_xs$0,j$2_modcons_ctx,j$2_modcons_x$7,j$2_modcons_x$1,j$2_modcons_x$2) -- #171
//│ )
//│ },
//│ let x$12 = Nil() in -- #103
//│ let x$13 = Cons(9,x$12) in -- #102
//│ let x$14 = Cons(3,x$13) in -- #101
//│ let x$15 = Cons(2,x$14) in -- #100
//│ let x$16 = Cons(4,x$15) in -- #99
//│ let x$17 = Cons(7,x$16) in -- #98
//│ let x$18 = Cons(6,x$17) in -- #97
//│ let x$19 = Cons(1,x$18) in -- #96
//│ let* (x$20) = foo(x$19) in -- #95
//│ x$20 -- #94)
//│ 
//│ Interpreted:
//│ Cons(-1,Cons(1,Cons(100,Cons(4,Cons(-1,Cons(2,Cons(100,Cons(3,Nil()))))))))

class True
class False
class A(a, b)
@tailrec
fun a() = A(b(), 1)
fun b() = A(a(), c())
fun c() = A(b(), 1)
a()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(|a|,| |b|)|↵|@|tailrec|↵|#fun| |a|(||)| |#=| |A|(|b|(||)|,| |1|)|↵|#fun| |b|(||)| |#=| |A|(|a|(||)|,| |c|(||)|)|↵|#fun| |c|(||)| |#=| |A|(|b|(||)|,| |1|)|↵|a|(||)|
//│ Parsed: {class True {}; class False {}; class A(a, b,) {}; fun a = () => A(b(), 1,); fun b = () => A(a(), c(),); fun c = () => A(b(), 1,); a()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let* (x$0) = b() in -- #9
//│ let x$1 = A(x$0,1) in -- #8
//│ x$1 -- #7
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let* (x$2) = a() in -- #22
//│ let* (x$3) = c() in -- #21
//│ let x$4 = A(x$2,x$3) in -- #20
//│ x$4 -- #19
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let* (x$5) = b() in -- #32
//│ let x$6 = A(x$5,1) in -- #31
//│ x$6 -- #30
//│ )
//│ },
//│ let* (x$7) = a() in -- #36
//│ x$7 -- #35)
//│ 
//│ IR Processing Failed: at least one function is not tail recursive

class True
class False
class A(a, b)
@tailrec
fun a() = A(b(), 1)
fun b() = A(a(), c())
fun c() = A(0, 1)
a()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(|a|,| |b|)|↵|@|tailrec|↵|#fun| |a|(||)| |#=| |A|(|b|(||)|,| |1|)|↵|#fun| |b|(||)| |#=| |A|(|a|(||)|,| |c|(||)|)|↵|#fun| |c|(||)| |#=| |A|(|0|,| |1|)|↵|a|(||)|
//│ Parsed: {class True {}; class False {}; class A(a, b,) {}; fun a = () => A(b(), 1,); fun b = () => A(a(), c(),); fun c = () => A(0, 1,); a()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let* (x$0) = b() in -- #9
//│ let x$1 = A(x$0,1) in -- #8
//│ x$1 -- #7
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let* (x$2) = a() in -- #22
//│ let* (x$3) = c() in -- #21
//│ let x$4 = A(x$2,x$3) in -- #20
//│ x$4 -- #19
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(b, a), Set(c))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b]),ClassInfo(3, _IdContext, []),ClassInfo(4, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #63
//│ let* (res) = a_modcons(idCtx) in -- #62
//│ res -- #61
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #55
//│ let* (res) = b_modcons(idCtx) in -- #54
//│ res -- #53
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ Def(3, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #40
//│   _IdContext =>
//│     x -- #39
//│   _Context =>
//│     let field = ctx.field in -- #38
//│     let ptr = ctx.ptr in -- #37
//│     let _ = assign ptr.a := x in -- #36
//│     let acc = ctx.acc in -- #35
//│     acc -- #34
//│ )
//│ Def(4, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #46
//│ let ctx2ptr = ctx2.ptr in -- #45
//│ let ctx2field = ctx2.field in -- #44
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #43
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #42
//│ ret -- #41
//│ )
//│ Def(5, b_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(5,ctx,0) in -- #82
//│ r0 -- #81
//│ )
//│ Def(6, a_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,0,ctx) in -- #84
//│ r0 -- #83
//│ )
//│ Def(7, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #79
//│ if scrut -- #78
//│   true =>
//│     let x$1 = A(0,1) in -- #77
//│     let ctx2 = _Context(x$1,x$1,0) in -- #76
//│     let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #75
//│     jump _b_modcons_a_modcons_opt_jp(5,composed,a_modcons_ctx) -- #74
//│   false =>
//│     let* (x$3) = c() in -- #73
//│     let x$4 = A(0,x$3) in -- #72
//│     let ctx2 = _Context(x$4,x$4,0) in -- #71
//│     let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #70
//│     jump _b_modcons_a_modcons_opt_jp(6,b_modcons_ctx,composed) -- #69
//│ )
//│ Def(8, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,a_modcons_ctx) -- #80
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b]),ClassInfo(3, _IdContext, []),ClassInfo(4, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #63
//│ let* (res) = a_modcons(idCtx) in -- #62
//│ res -- #61
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #55
//│ let* (res) = b_modcons(idCtx) in -- #54
//│ res -- #53
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ Def(3, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #40
//│   _IdContext =>
//│     x -- #39
//│   _Context =>
//│     let field = ctx.field in -- #38
//│     let ptr = ctx.ptr in -- #37
//│     let _ = assign ptr.a := x in -- #36
//│     let acc = ctx.acc in -- #35
//│     acc -- #34
//│ )
//│ Def(4, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #46
//│ let ctx2ptr = ctx2.ptr in -- #45
//│ let ctx2field = ctx2.field in -- #44
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #43
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #42
//│ ret -- #41
//│ )
//│ Def(5, b_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(5,ctx,0) in -- #82
//│ r0 -- #81
//│ )
//│ Def(6, a_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,0,ctx) in -- #84
//│ r0 -- #83
//│ )
//│ Def(7, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #79
//│ if scrut -- #78
//│   true =>
//│     let x$1 = A(0,1) in -- #77
//│     let ctx2 = _Context(x$1,x$1,0) in -- #76
//│     let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #75
//│     jump _b_modcons_a_modcons_opt_jp(5,composed,a_modcons_ctx) -- #74
//│   false =>
//│     let* (x$3) = c() in -- #73
//│     let x$4 = A(0,x$3) in -- #72
//│     let ctx2 = _Context(x$4,x$4,0) in -- #71
//│     let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #70
//│     jump _b_modcons_a_modcons_opt_jp(6,b_modcons_ctx,composed) -- #69
//│ )
//│ Def(8, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,a_modcons_ctx) -- #80
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)

class True
class False
class A(a, b)
@tailrec
fun a() = A(b(), 1)
fun b() = A(c(), a())
fun c() = A(0, 1)
a()
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(|a|,| |b|)|↵|@|tailrec|↵|#fun| |a|(||)| |#=| |A|(|b|(||)|,| |1|)|↵|#fun| |b|(||)| |#=| |A|(|c|(||)|,| |a|(||)|)|↵|#fun| |c|(||)| |#=| |A|(|0|,| |1|)|↵|a|(||)|
//│ Parsed: {class True {}; class False {}; class A(a, b,) {}; fun a = () => A(b(), 1,); fun b = () => A(c(), a(),); fun c = () => A(0, 1,); a()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let* (x$0) = b() in -- #9
//│ let x$1 = A(x$0,1) in -- #8
//│ x$1 -- #7
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let* (x$2) = c() in -- #22
//│ let* (x$3) = a() in -- #21
//│ let x$4 = A(x$2,x$3) in -- #20
//│ x$4 -- #19
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(b, a), Set(c))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b]),ClassInfo(3, _IdContext, []),ClassInfo(4, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #69
//│ let* (res) = a_modcons(idCtx) in -- #68
//│ res -- #67
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #61
//│ let* (res) = b_modcons(idCtx) in -- #60
//│ res -- #59
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ Def(3, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #46
//│   _IdContext =>
//│     x -- #45
//│   _Context =>
//│     let field = ctx.field in -- #44
//│     let scrut = ==(1,field) in -- #43
//│     if scrut -- #42
//│       true =>
//│         let ptr = ctx.ptr in -- #41
//│         let _ = assign ptr.a := x in -- #40
//│         let acc = ctx.acc in -- #39
//│         acc -- #38
//│       false =>
//│         let ptr = ctx.ptr in -- #37
//│         let _ = assign ptr.b := x in -- #36
//│         let acc = ctx.acc in -- #35
//│         acc -- #34
//│ )
//│ Def(4, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #52
//│ let ctx2ptr = ctx2.ptr in -- #51
//│ let ctx2field = ctx2.field in -- #50
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #49
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #48
//│ ret -- #47
//│ )
//│ Def(5, b_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(5,ctx,0) in -- #88
//│ r0 -- #87
//│ )
//│ Def(6, a_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,0,ctx) in -- #90
//│ r0 -- #89
//│ )
//│ Def(7, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #85
//│ if scrut -- #84
//│   true =>
//│     let x$1 = A(0,1) in -- #83
//│     let ctx2 = _Context(x$1,x$1,1) in -- #82
//│     let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #81
//│     jump _b_modcons_a_modcons_opt_jp(5,composed,a_modcons_ctx) -- #80
//│   false =>
//│     let* (x$2) = c() in -- #79
//│     let x$4 = A(x$2,0) in -- #78
//│     let ctx2 = _Context(x$4,x$4,0) in -- #77
//│     let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #76
//│     jump _b_modcons_a_modcons_opt_jp(6,b_modcons_ctx,composed) -- #75
//│ )
//│ Def(8, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,a_modcons_ctx) -- #86
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [a,b]),ClassInfo(3, _IdContext, []),ClassInfo(4, _Context, [acc,ptr,field])}, {
//│ Def(0, a, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #69
//│ let* (res) = a_modcons(idCtx) in -- #68
//│ res -- #67
//│ )
//│ Def(1, b, [],
//│ 1, 
//│ let idCtx = _IdContext() in -- #61
//│ let* (res) = b_modcons(idCtx) in -- #60
//│ res -- #59
//│ )
//│ Def(2, c, [],
//│ 1, 
//│ let x$5 = A(0,1) in -- #29
//│ x$5 -- #28
//│ )
//│ Def(3, _b_a_ctx_app, [ctx,x],
//│ 1, 
//│ case ctx of -- #46
//│   _IdContext =>
//│     x -- #45
//│   _Context =>
//│     let field = ctx.field in -- #44
//│     let scrut = ==(1,field) in -- #43
//│     if scrut -- #42
//│       true =>
//│         let ptr = ctx.ptr in -- #41
//│         let _ = assign ptr.a := x in -- #40
//│         let acc = ctx.acc in -- #39
//│         acc -- #38
//│       false =>
//│         let ptr = ctx.ptr in -- #37
//│         let _ = assign ptr.b := x in -- #36
//│         let acc = ctx.acc in -- #35
//│         acc -- #34
//│ )
//│ Def(4, _b_a_ctx_comp, [ctx1,ctx2],
//│ 1, 
//│ let ctx2acc = ctx2.acc in -- #52
//│ let ctx2ptr = ctx2.ptr in -- #51
//│ let ctx2field = ctx2.field in -- #50
//│ let* (newAcc) = _b_a_ctx_app(ctx1,ctx2acc) in -- #49
//│ let ret = _Context(newAcc,ctx2ptr,ctx2field) in -- #48
//│ ret -- #47
//│ )
//│ Def(5, b_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(5,ctx,0) in -- #88
//│ r0 -- #87
//│ )
//│ Def(6, a_modcons, [ctx],
//│ 1, 
//│ let* (r0) = _b_modcons_a_modcons_opt(6,0,ctx) in -- #90
//│ r0 -- #89
//│ )
//│ Def(7, _b_modcons_a_modcons_opt_jp, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ let scrut = ==(6,tailrecBranch$) in -- #85
//│ if scrut -- #84
//│   true =>
//│     let x$1 = A(0,1) in -- #83
//│     let ctx2 = _Context(x$1,x$1,1) in -- #82
//│     let* (composed) = _b_a_ctx_comp(a_modcons_ctx,ctx2) in -- #81
//│     jump _b_modcons_a_modcons_opt_jp(5,composed,a_modcons_ctx) -- #80
//│   false =>
//│     let* (x$2) = c() in -- #79
//│     let x$4 = A(x$2,0) in -- #78
//│     let ctx2 = _Context(x$4,x$4,0) in -- #77
//│     let* (composed) = _b_a_ctx_comp(b_modcons_ctx,ctx2) in -- #76
//│     jump _b_modcons_a_modcons_opt_jp(6,b_modcons_ctx,composed) -- #75
//│ )
//│ Def(8, _b_modcons_a_modcons_opt, [tailrecBranch$,b_modcons_ctx,a_modcons_ctx],
//│ 1, 
//│ jump _b_modcons_a_modcons_opt_jp(tailrecBranch$,b_modcons_ctx,a_modcons_ctx) -- #86
//│ )
//│ },
//│ let* (x$6) = a() in -- #33
//│ x$6 -- #32)
