:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(g, f), Set(double))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #80
//│ r0 -- #79
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #78
//│ r0 -- #77
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #75
//│ if scrut -- #73
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #x
//│     if x$2 -- #x
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #x
//│         jump j$0(x$4) -- #x
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #x
//│         let x$6 = +(f_acc$0,1) in -- #x
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #72
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #x
//│     if x$8 -- #x
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #x
//│         let x$11 = -(0,x$10) in -- #x
//│         jump j$1(x$11) -- #x
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #x
//│         let x$13 = +(g_acc$1,1) in -- #x
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #71
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #76
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #80
//│ r0 -- #79
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #78
//│ r0 -- #77
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #75
//│ if scrut -- #73
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #x
//│     if x$2 -- #x
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #x
//│         jump j$0(x$4) -- #x
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #x
//│         let x$6 = +(f_acc$0,1) in -- #x
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #72
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #x
//│     if x$8 -- #x
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #x
//│         let x$11 = -(0,x$10) in -- #x
//│         jump j$1(x$11) -- #x
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #x
//│         let x$13 = +(g_acc$1,1) in -- #x
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #71
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #76
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

class True
class False
fun f(a, b, c) = g(0, 0)
fun g(d, e) = h(0, 0, 0, 0)
fun h(p, q, r, s) = f(0, 0, 0)
2 
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|a|,| |b|,| |c|)| |#=| |g|(|0|,| |0|)|↵|#fun| |g|(|d|,| |e|)| |#=| |h|(|0|,| |0|,| |0|,| |0|)|↵|#fun| |h|(|p|,| |q|,| |r|,| |s|)| |#=| |f|(|0|,| |0|,| |0|)|↵|2| |
//│ Parsed: {class True {}; class False {}; fun f = (a, b, c,) => g(0, 0,); fun g = (d, e,) => h(0, 0, 0, 0,); fun h = (p, q, r, s,) => f(0, 0, 0,); 2}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (x$0) = g(0,0) in -- #7
//│ x$0 -- #6
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (x$1) = h(0,0,0,0) in -- #19
//│ x$1 -- #18
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (x$2) = f(0,0,0) in -- #29
//│ x$2 -- #28
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(h, g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #36
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #35
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #34
//│     if scrut -- #33
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #32
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #31
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #36
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #35
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #34
//│     if scrut -- #33
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #32
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #31
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)

// TODO: should error, but it seems IR errors are not considered errors by the unit test framework
class True
class False
fun hello() =
    @tailrec hello()
    2
hello()
//│ |#class| |True|↵|#class| |False|↵|#fun| |hello|(||)| |#=|→|@|tailrec| |hello|(||)|↵|2|←|↵|hello|(||)|
//│ Parsed: {class True {}; class False {}; fun hello = () => {@tailrec hello(); 2}; hello()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, hello, [],
//│ 1, 
//│ let* (x$0) = @tailrec hello() in -- #x
//│ 2 -- #3
//│ )
//│ },
//│ let* (x$1) = hello() in -- #8
//│ x$1 -- #7)
//│ 
//│ IR Processing Failed: not a tail call
//│ 
//│ mlscript.compiler.ir.IRError$.apply(IR.scala:14)
//│ mlscript.compiler.optimizer.TailRecOpt.returnFailure$1(TailRecOpt.scala:43)
//│ mlscript.compiler.optimizer.TailRecOpt.getOptimizableCalls(TailRecOpt.scala:54)
//│ mlscript.compiler.optimizer.TailRecOpt.findTailCalls(TailRecOpt.scala:220)
//│ mlscript.compiler.optimizer.TailRecOpt.dfs$1(TailRecOpt.scala:252)
//│ mlscript.compiler.optimizer.TailRecOpt.partitionNodes$$anonfun$1(TailRecOpt.scala:297)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ scala.collection.immutable.Set$Set1.foreach(Set.scala:168)
//│ mlscript.compiler.optimizer.TailRecOpt.partitionNodes(TailRecOpt.scala:297)
//│ mlscript.compiler.optimizer.TailRecOpt.partition(TailRecOpt.scala:440)
//│ mlscript.compiler.optimizer.TailRecOpt.run_debug(TailRecOpt.scala:447)
//│ mlscript.compiler.IRDiffTestCompiler.postProcess(TestIR.scala:28)
//│ mlscript.DiffTests.rec$1(DiffTests.scala:470)
//│ mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1076)
//│ org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ org.scalatest.Transformer.apply(Transformer.scala:22)
//│ org.scalatest.Transformer.apply(Transformer.scala:20)
//│ org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:226)
//│ org.scalatest.TestSuite.withFixture(TestSuite.scala:196)
//│ org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)
//│ mlscript.DiffTests.org$scalatest$concurrent$TimeLimitedTests$$super$withFixture(DiffTests.scala:53)
//│ org.scalatest.concurrent.TimeLimitedTests.$anonfun$withFixture$3(TimeLimitedTests.scala:154)
//│ org.scalatest.enablers.Timed$$anon$1.timeoutAfter(Timed.scala:127)
//│ org.scalatest.concurrent.TimeLimits$.failAfterImpl(TimeLimits.scala:282)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture(TimeLimitedTests.scala:153)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture$(TimeLimitedTests.scala:150)
//│ mlscript.DiffTests.withFixture(DiffTests.scala:53)
//│ org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:224)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:236)
//│ org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:236)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:218)
//│ mlscript.DiffTests.org$scalatest$OneInstancePerTest$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTest(OneInstancePerTest.scala:131)
//│ org.scalatest.OneInstancePerTest.runTest$(OneInstancePerTest.scala:123)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTest(ParallelTestExecution.scala:164)
//│ org.scalatest.ParallelTestExecution.runTest$(ParallelTestExecution.scala:148)
//│ mlscript.DiffTests.runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTests(OneInstancePerTest.scala:181)
//│ org.scalatest.OneInstancePerTest.runTests$(OneInstancePerTest.scala:172)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTests(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTests(ParallelTestExecution.scala:97)
//│ org.scalatest.ParallelTestExecution.runTests$(ParallelTestExecution.scala:79)
//│ mlscript.DiffTests.runTests(DiffTests.scala:53)
//│ org.scalatest.Suite.run(Suite.scala:1114)
//│ org.scalatest.Suite.run$(Suite.scala:1096)
//│ org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1563)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:273)
//│ org.scalatest.SuperEngine.runImpl(Engine.scala:535)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:273)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:272)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$run(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.run(ParallelTestExecution.scala:261)
//│ org.scalatest.ParallelTestExecution.run$(ParallelTestExecution.scala:258)
//│ mlscript.DiffTests.run(DiffTests.scala:53)
//│ org.scalatest.tools.DistributedTestRunnerSuite.run(DistributedTestRunnerSuite.scala:22)
//│ org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:47)
//│ java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
//│ java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
//│ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
//│ java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
//│ java.base/java.lang.Thread.run(Thread.java:840)

:interpIR
class True
class False
class Cons(h, t)
class Nil
fun addOne(xs) =
  if xs is
    Cons(h, t) then Cons(h + 1, @tailrec addOne(t))
    Nil then Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is|→|Cons|(|h|,| |t|)| |#then| |Cons|(|h| |+| |1|,| |@|tailrec| |addOne|(|t|)|)|↵|Nil| |#then| |Nil|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then Cons(+(h,)(1,), @tailrec addOne(t,),); (Nil) then Nil›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #27
//│   Cons =>
//│     let x$1 = xs$0.t in -- #23
//│     let x$2 = xs$0.h in -- #22
//│     let x$3 = +(x$2,1) in -- #21
//│     let* (x$4) = @tailrec addOne(x$1) in -- #x
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #26
//│     jump j$0(x$6) -- #25
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #27
//│   Cons =>
//│     let x$1 = xs$0.t in -- #23
//│     let x$2 = xs$0.h in -- #22
//│     let x$3 = +(x$2,1) in -- #21
//│     let* (x$4) = @tailrec addOne(x$1) in -- #x
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #26
//│     jump j$0(x$6) -- #25
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #27
//│   Cons =>
//│     let x$1 = xs$0.t in -- #23
//│     let x$2 = xs$0.h in -- #22
//│     let x$3 = +(x$2,1) in -- #21
//│     let* (x$4) = @tailrec addOne(x$1) in -- #x
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #26
//│     jump j$0(x$6) -- #25
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:interpIR
class True
class False
class Zero
class S(x)
fun a(n) =
  if n is
    S(x) then S(@tailrec b(x))
    Zero then S(Zero)
fun b(n) =
  if n is
    S(x) then S(S(@tailrec a(x)))
    Zero then S(S(Zero))
a(S(S(S(Zero))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Zero|↵|#class| |S|(|x|)|↵|#fun| |a|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|@|tailrec| |b|(|x|)|)|↵|Zero| |#then| |S|(|Zero|)|←|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|S|(|@|tailrec| |a|(|x|)|)|)|↵|Zero| |#then| |S|(|S|(|Zero|)|)|←|←|↵|a|(|S|(|S|(|S|(|Zero|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Zero {}; class S(x,) {}; fun a = (n,) => {if n is ‹(S(x,)) then S(@tailrec b(x,),); (Zero) then S(Zero,)›}; fun b = (n,) => {if n is ‹(S(x,)) then S(S(@tailrec a(x,),),); (Zero) then S(S(Zero,),)›}; a(S(S(S(Zero,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #x
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #x
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #82
//│ r0 -- #81
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #80
//│ r0 -- #79
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #77
//│ if scrut -- #75
//│   true =>
//│     case a_n$0 of -- #x
//│       S =>
//│         let x$1 = a_n$0.x in -- #x
//│         let* (x$2) = @tailrec b(x$1) in -- #x
//│         let x$3 = S(x$2) in -- #x
//│         jump j$0(x$3) -- #x
//│       Zero =>
//│         let x$4 = Zero() in -- #x
//│         let x$5 = S(x$4) in -- #x
//│         jump j$0(x$5) -- #x
//│   false =>
//│     case b_n$1 of -- #x
//│       S =>
//│         let x$7 = b_n$1.x in -- #x
//│         let* (x$8) = @tailrec a(x$7) in -- #x
//│         let x$9 = S(x$8) in -- #x
//│         let x$10 = S(x$9) in -- #x
//│         jump j$1(x$10) -- #x
//│       Zero =>
//│         let x$11 = Zero() in -- #x
//│         let x$12 = S(x$11) in -- #x
//│         let x$13 = S(x$12) in -- #x
//│         jump j$1(x$13) -- #x
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #78
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #82
//│ r0 -- #81
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #80
//│ r0 -- #79
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #77
//│ if scrut -- #75
//│   true =>
//│     case a_n$0 of -- #x
//│       S =>
//│         let x$1 = a_n$0.x in -- #x
//│         let* (x$2) = @tailrec b(x$1) in -- #x
//│         let x$3 = S(x$2) in -- #x
//│         jump j$0(x$3) -- #x
//│       Zero =>
//│         let x$4 = Zero() in -- #x
//│         let x$5 = S(x$4) in -- #x
//│         jump j$0(x$5) -- #x
//│   false =>
//│     case b_n$1 of -- #x
//│       S =>
//│         let x$7 = b_n$1.x in -- #x
//│         let* (x$8) = @tailrec a(x$7) in -- #x
//│         let x$9 = S(x$8) in -- #x
//│         let x$10 = S(x$9) in -- #x
//│         jump j$1(x$10) -- #x
//│       Zero =>
//│         let x$11 = Zero() in -- #x
//│         let x$12 = S(x$11) in -- #x
//│         let x$13 = S(x$12) in -- #x
//│         jump j$1(x$13) -- #x
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #78
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Interpreted:
//│ S(S(S(S(S(S(Zero()))))))
