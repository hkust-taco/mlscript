:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:interpIR
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(fact))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = fact_jp(acc$0,n$0) in -- #38
//│ r0 -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = fact_jp(acc$0,n$0) in -- #38
//│ r0 -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:interpIR
class True
class False
fun fact(acc, n) =
  val x = if n > 0 then n - 1
    else 0
  if x <= 0 then
    acc
  else 
    @tailrec fact(n * acc, x) 
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#val| |x| |#=| |#if| |n| |>| |0| |#then| |n| |-| |1|→|#else| |0|←|↵|#if| |x| |<=| |0| |#then|→|acc|←|↵|#else| |→|@|tailrec| |fact|(|n| |*| |acc|,| |x|)| |←|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {let x = if (>(n,)(0,)) then -(n,)(1,) else 0; if (<=(x,)(0,)) then {acc} else {@tailrec fact(*(n,)(acc,), x,)}}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = >(n$0,0) in -- #32
//│ if x$0 -- #31
//│   true =>
//│     let x$6 = -(n$0,1) in -- #28
//│     jump j$0(x$6,acc$0,n$0) -- #27
//│   false =>
//│     jump j$0(0,acc$0,n$0) -- #30
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(j$1), Set(fact))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = _fact_j$0_opt(0,acc$0,n$0,0,0,0) in -- #60
//│ r0 -- #59
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ Def(3, _fact_j$0_opt_jp, [tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ let scrut = ==(2,tailrecBranch) in -- #57
//│ if scrut -- #56
//│   true =>
//│     let x$2 = <=(j$0_x$1,0) in -- #55
//│     if x$2 -- #54
//│       true =>
//│         jump j$1(j$0_acc$0) -- #51
//│       false =>
//│         let x$4 = *(j$0_n$0,j$0_acc$0) in -- #53
//│         jump _fact_j$0_opt_jp(0,x$4,j$0_x$1,j$0_x$1,j$0_acc$0,j$0_n$0) -- #52
//│   false =>
//│     let x$0 = >(fact_n$0,0) in -- #50
//│     if x$0 -- #49
//│       true =>
//│         let x$6 = -(fact_n$0,1) in -- #47
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,x$6,fact_acc$0,fact_n$0) -- #46
//│       false =>
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,0,fact_acc$0,fact_n$0) -- #48
//│ )
//│ Def(4, _fact_j$0_opt, [tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ jump _fact_j$0_opt_jp(tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0) -- #58
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let* (r0) = _fact_j$0_opt(0,acc$0,n$0,0,0,0) in -- #60
//│ r0 -- #59
//│ )
//│ Def(1, j$1, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(2, j$0, [x$1,acc$0,n$0],
//│ 1, 
//│ let x$2 = <=(x$1,0) in -- #23
//│ if x$2 -- #22
//│   true =>
//│     jump j$1(acc$0) -- #9
//│   false =>
//│     let x$4 = *(n$0,acc$0) in -- #21
//│     let* (x$5) = @tailrec fact(x$4,x$1) in -- #20
//│     jump j$1(x$5) -- #19
//│ )
//│ Def(3, _fact_j$0_opt_jp, [tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ let scrut = ==(2,tailrecBranch) in -- #57
//│ if scrut -- #56
//│   true =>
//│     let x$2 = <=(j$0_x$1,0) in -- #55
//│     if x$2 -- #54
//│       true =>
//│         jump j$1(j$0_acc$0) -- #51
//│       false =>
//│         let x$4 = *(j$0_n$0,j$0_acc$0) in -- #53
//│         jump _fact_j$0_opt_jp(0,x$4,j$0_x$1,j$0_x$1,j$0_acc$0,j$0_n$0) -- #52
//│   false =>
//│     let x$0 = >(fact_n$0,0) in -- #50
//│     if x$0 -- #49
//│       true =>
//│         let x$6 = -(fact_n$0,1) in -- #47
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,x$6,fact_acc$0,fact_n$0) -- #46
//│       false =>
//│         jump _fact_j$0_opt_jp(2,fact_acc$0,fact_n$0,0,fact_acc$0,fact_n$0) -- #48
//│ )
//│ Def(4, _fact_j$0_opt, [tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0],
//│ 1, 
//│ jump _fact_j$0_opt_jp(tailrecBranch,fact_acc$0,fact_n$0,j$0_x$1,j$0_acc$0,j$0_n$0) -- #58
//│ )
//│ },
//│ let* (x$7) = fact(1,5) in -- #40
//│ x$7 -- #39)
//│ 
//│ Interpreted:
//│ 120

:noTailRec
:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(g, f), Set(double))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

class True
class False
fun f(a, b, c) = g(0, 0)
fun g(d, e) = h(0, 0, 0, 0)
fun h(p, q, r, s) = f(0, 0, 0)
2 
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|a|,| |b|,| |c|)| |#=| |g|(|0|,| |0|)|↵|#fun| |g|(|d|,| |e|)| |#=| |h|(|0|,| |0|,| |0|,| |0|)|↵|#fun| |h|(|p|,| |q|,| |r|,| |s|)| |#=| |f|(|0|,| |0|,| |0|)|↵|2| |
//│ Parsed: {class True {}; class False {}; fun f = (a, b, c,) => g(0, 0,); fun g = (d, e,) => h(0, 0, 0, 0,); fun h = (p, q, r, s,) => f(0, 0, 0,); 2}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (x$0) = g(0,0) in -- #7
//│ x$0 -- #6
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (x$1) = h(0,0,0,0) in -- #19
//│ x$1 -- #18
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (x$2) = f(0,0,0) in -- #29
//│ x$2 -- #28
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(h, g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)

// TODO: should error, but it seems IR errors are not considered errors by the unit test framework
// :e
class True
class False
fun hello() =
    @tailrec hello()
    2
hello()
//│ |#class| |True|↵|#class| |False|↵|#fun| |hello|(||)| |#=|→|@|tailrec| |hello|(||)|↵|2|←|↵|hello|(||)|
//│ Parsed: {class True {}; class False {}; fun hello = () => {@tailrec hello(); 2}; hello()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, hello, [],
//│ 1, 
//│ let* (x$0) = @tailrec hello() in -- #4
//│ 2 -- #3
//│ )
//│ },
//│ let* (x$1) = hello() in -- #8
//│ x$1 -- #7)
//│ 
//│ IR Processing Failed: not a tail call
//│ 
//│ mlscript.compiler.ir.IRError$.apply(IR.scala:14)
//│ mlscript.compiler.optimizer.TailRecOpt.returnFailure$1(TailRecOpt.scala:98)
//│ mlscript.compiler.optimizer.TailRecOpt.discoverOptimizableCalls(TailRecOpt.scala:108)
//│ mlscript.compiler.optimizer.TailRecOpt.discoverCallsCont(TailRecOpt.scala:311)
//│ mlscript.compiler.optimizer.TailRecOpt.discoverCalls(TailRecOpt.scala:316)
//│ mlscript.compiler.optimizer.TailRecOpt.$anonfun$3(TailRecOpt.scala:339)
//│ scala.collection.IterableOnceOps.foldLeft(IterableOnce.scala:646)
//│ scala.collection.IterableOnceOps.foldLeft$(IterableOnce.scala:642)
//│ scala.collection.AbstractIterable.foldLeft(Iterable.scala:926)
//│ mlscript.compiler.optimizer.TailRecOpt.partitionNodes(TailRecOpt.scala:339)
//│ mlscript.compiler.optimizer.TailRecOpt.partition(TailRecOpt.scala:830)
//│ mlscript.compiler.optimizer.TailRecOpt.run_debug(TailRecOpt.scala:837)
//│ mlscript.compiler.IRDiffTestCompiler.postProcess(TestIR.scala:29)
//│ mlscript.DiffTests.rec$1(DiffTests.scala:470)
//│ mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1076)
//│ org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ org.scalatest.Transformer.apply(Transformer.scala:22)
//│ org.scalatest.Transformer.apply(Transformer.scala:20)
//│ org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:226)
//│ org.scalatest.TestSuite.withFixture(TestSuite.scala:196)
//│ org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)
//│ mlscript.DiffTests.org$scalatest$concurrent$TimeLimitedTests$$super$withFixture(DiffTests.scala:53)
//│ org.scalatest.concurrent.TimeLimitedTests.$anonfun$withFixture$3(TimeLimitedTests.scala:154)
//│ org.scalatest.enablers.Timed$$anon$1.timeoutAfter(Timed.scala:127)
//│ org.scalatest.concurrent.TimeLimits$.failAfterImpl(TimeLimits.scala:282)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture(TimeLimitedTests.scala:153)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture$(TimeLimitedTests.scala:150)
//│ mlscript.DiffTests.withFixture(DiffTests.scala:53)
//│ org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:224)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:236)
//│ org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:236)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:218)
//│ mlscript.DiffTests.org$scalatest$OneInstancePerTest$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTest(OneInstancePerTest.scala:131)
//│ org.scalatest.OneInstancePerTest.runTest$(OneInstancePerTest.scala:123)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTest(ParallelTestExecution.scala:164)
//│ org.scalatest.ParallelTestExecution.runTest$(ParallelTestExecution.scala:148)
//│ mlscript.DiffTests.runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTests(OneInstancePerTest.scala:181)
//│ org.scalatest.OneInstancePerTest.runTests$(OneInstancePerTest.scala:172)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTests(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTests(ParallelTestExecution.scala:97)
//│ org.scalatest.ParallelTestExecution.runTests$(ParallelTestExecution.scala:79)
//│ mlscript.DiffTests.runTests(DiffTests.scala:53)
//│ org.scalatest.Suite.run(Suite.scala:1114)
//│ org.scalatest.Suite.run$(Suite.scala:1096)
//│ org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1563)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:273)
//│ org.scalatest.SuperEngine.runImpl(Engine.scala:535)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:273)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:272)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$run(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.run(ParallelTestExecution.scala:261)
//│ org.scalatest.ParallelTestExecution.run$(ParallelTestExecution.scala:258)
//│ mlscript.DiffTests.run(DiffTests.scala:53)
//│ org.scalatest.tools.DistributedTestRunnerSuite.run(DistributedTestRunnerSuite.scala:22)
//│ org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:47)
//│ java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
//│ java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
//│ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
//│ java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
//│ java.base/java.lang.Thread.run(Thread.java:840)

:interpIR
class True
class False
class Cons(h, t)
class Nil
fun addOne(xs) =
  if xs is
    Cons(h, t) then Cons(h + 1, @tailrec addOne(t))
    Nil then Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is|→|Cons|(|h|,| |t|)| |#then| |Cons|(|h| |+| |1|,| |@|tailrec| |addOne|(|t|)|)|↵|Nil| |#then| |Nil|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then Cons(+(h,)(1,), @tailrec addOne(t,),); (Nil) then Nil›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #27
//│   Cons =>
//│     let x$1 = xs$0.t in -- #23
//│     let x$2 = xs$0.h in -- #22
//│     let x$3 = +(x$2,1) in -- #21
//│     let* (x$4) = @tailrec addOne(x$1) in -- #20
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #26
//│     jump j$0(x$6) -- #25
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #61
//│   Cons =>
//│     let x$1 = xs$0.t in -- #58
//│     let x$2 = xs$0.h in -- #57
//│     let x$3 = +(x$2,1) in -- #56
//│     let* (x$4) = @tailrec addOne(x$1) in -- #55
//│     let x$5 = Cons(x$3,x$4) in -- #54
//│     jump j$0(x$5) -- #53
//│   Nil =>
//│     let x$6 = Nil() in -- #60
//│     jump j$0(x$6) -- #59
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (r0) = addOne_jp(xs$0) in -- #63
//│ r0 -- #62
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #61
//│   Cons =>
//│     let x$1 = xs$0.t in -- #58
//│     let x$2 = xs$0.h in -- #57
//│     let x$3 = +(x$2,1) in -- #56
//│     let* (x$4) = @tailrec addOne(x$1) in -- #55
//│     let x$5 = Cons(x$3,x$4) in -- #54
//│     jump j$0(x$5) -- #53
//│   Nil =>
//│     let x$6 = Nil() in -- #60
//│     jump j$0(x$6) -- #59
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (r0) = addOne_jp(xs$0) in -- #63
//│ r0 -- #62
//│ )
//│ },
//│ let x$7 = Nil() in -- #52
//│ let x$8 = Cons(3,x$7) in -- #51
//│ let x$9 = Cons(2,x$8) in -- #50
//│ let x$10 = Cons(1,x$9) in -- #49
//│ let* (x$11) = addOne(x$10) in -- #48
//│ x$11 -- #47)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:interpIR
class True
class False
class Zero
class S(x)
fun a(n) =
  if n is
    S(x) then S(@tailrec b(x))
    Zero then S(Zero)
fun b(n) =
  if n is
    S(x) then S(S(@tailrec a(x)))
    Zero then S(S(Zero))
a(S(S(S(Zero))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Zero|↵|#class| |S|(|x|)|↵|#fun| |a|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|@|tailrec| |b|(|x|)|)|↵|Zero| |#then| |S|(|Zero|)|←|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|S|(|@|tailrec| |a|(|x|)|)|)|↵|Zero| |#then| |S|(|S|(|Zero|)|)|←|←|↵|a|(|S|(|S|(|S|(|Zero|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Zero {}; class S(x,) {}; fun a = (n,) => {if n is ‹(S(x,)) then S(@tailrec b(x,),); (Zero) then S(Zero,)›}; fun b = (n,) => {if n is ‹(S(x,)) then S(S(@tailrec a(x,),),); (Zero) then S(S(Zero,),)›}; a(S(S(S(Zero,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #23
//│   S =>
//│     let x$1 = n$0.x in -- #15
//│     let* (x$2) = @tailrec b(x$1) in -- #14
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #22
//│     let x$5 = S(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #55
//│   S =>
//│     let x$7 = n$1.x in -- #43
//│     let* (x$8) = @tailrec a(x$7) in -- #42
//│     let x$9 = S(x$8) in -- #41
//│     let x$10 = S(x$9) in -- #40
//│     jump j$1(x$10) -- #39
//│   Zero =>
//│     let x$11 = Zero() in -- #54
//│     let x$12 = S(x$11) in -- #53
//│     let x$13 = S(x$12) in -- #52
//│     jump j$1(x$13) -- #51
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #109
//│ r0 -- #108
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #107
//│ r0 -- #106
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #104
//│ if scrut -- #103
//│   true =>
//│     case a_n$0 of -- #102
//│       S =>
//│         let x$1 = a_n$0.x in -- #98
//│         let* (x$2) = @tailrec b(x$1) in -- #97
//│         let x$3 = S(x$2) in -- #96
//│         jump j$0(x$3) -- #95
//│       Zero =>
//│         let x$4 = Zero() in -- #101
//│         let x$5 = S(x$4) in -- #100
//│         jump j$0(x$5) -- #99
//│   false =>
//│     case b_n$1 of -- #94
//│       S =>
//│         let x$7 = b_n$1.x in -- #89
//│         let* (x$8) = @tailrec a(x$7) in -- #88
//│         let x$9 = S(x$8) in -- #87
//│         let x$10 = S(x$9) in -- #86
//│         jump j$1(x$10) -- #85
//│       Zero =>
//│         let x$11 = Zero() in -- #93
//│         let x$12 = S(x$11) in -- #92
//│         let x$13 = S(x$12) in -- #91
//│         jump j$1(x$13) -- #90
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #105
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #109
//│ r0 -- #108
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #107
//│ r0 -- #106
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #25
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #104
//│ if scrut -- #103
//│   true =>
//│     case a_n$0 of -- #102
//│       S =>
//│         let x$1 = a_n$0.x in -- #98
//│         let* (x$2) = @tailrec b(x$1) in -- #97
//│         let x$3 = S(x$2) in -- #96
//│         jump j$0(x$3) -- #95
//│       Zero =>
//│         let x$4 = Zero() in -- #101
//│         let x$5 = S(x$4) in -- #100
//│         jump j$0(x$5) -- #99
//│   false =>
//│     case b_n$1 of -- #94
//│       S =>
//│         let x$7 = b_n$1.x in -- #89
//│         let* (x$8) = @tailrec a(x$7) in -- #88
//│         let x$9 = S(x$8) in -- #87
//│         let x$10 = S(x$9) in -- #86
//│         jump j$1(x$10) -- #85
//│       Zero =>
//│         let x$11 = Zero() in -- #93
//│         let x$12 = S(x$11) in -- #92
//│         let x$13 = S(x$12) in -- #91
//│         jump j$1(x$13) -- #90
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #105
//│ )
//│ },
//│ let x$14 = Zero() in -- #74
//│ let x$15 = S(x$14) in -- #73
//│ let x$16 = S(x$15) in -- #72
//│ let x$17 = S(x$16) in -- #71
//│ let* (x$18) = a(x$17) in -- #70
//│ x$18 -- #69)
//│ 
//│ Interpreted:
//│ S(S(S(S(S(S(Zero()))))))

:interpIR
class True
class False
class Cons(h, t)
class Nil
fun addOne(xs) =
  if xs is 
    Cons(h, t) then
      val next = @tailrec addOne(t)
      val ret = Cons(h + 1, next)
      val rett = ret
      rett
    Nil then 
      Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is| |→|Cons|(|h|,| |t|)| |#then|→|#val| |next| |#=| |@|tailrec| |addOne|(|t|)|↵|#val| |ret| |#=| |Cons|(|h| |+| |1|,| |next|)|↵|#val| |rett| |#=| |ret|↵|rett|←|↵|Nil| |#then| |→|Nil|←|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then {let next = @tailrec addOne(t,); let ret = Cons(+(h,)(1,), next,); let rett = ret; rett}; (Nil) then {Nil}›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #30
//│   Cons =>
//│     let x$1 = xs$0.t in -- #26
//│     let x$2 = xs$0.h in -- #25
//│     let* (x$3) = @tailrec addOne(x$1) in -- #24
//│     let x$4 = +(x$2,1) in -- #23
//│     let x$5 = Cons(x$4,x$3) in -- #22
//│     jump j$0(x$5) -- #21
//│   Nil =>
//│     let x$6 = Nil() in -- #29
//│     jump j$0(x$6) -- #28
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #64
//│   Cons =>
//│     let x$1 = xs$0.t in -- #61
//│     let x$2 = xs$0.h in -- #60
//│     let* (x$3) = @tailrec addOne(x$1) in -- #59
//│     let x$4 = +(x$2,1) in -- #58
//│     let x$5 = Cons(x$4,x$3) in -- #57
//│     jump j$0(x$5) -- #56
//│   Nil =>
//│     let x$6 = Nil() in -- #63
//│     jump j$0(x$6) -- #62
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (r0) = addOne_jp(xs$0) in -- #66
//│ r0 -- #65
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #64
//│   Cons =>
//│     let x$1 = xs$0.t in -- #61
//│     let x$2 = xs$0.h in -- #60
//│     let* (x$3) = @tailrec addOne(x$1) in -- #59
//│     let x$4 = +(x$2,1) in -- #58
//│     let x$5 = Cons(x$4,x$3) in -- #57
//│     jump j$0(x$5) -- #56
//│   Nil =>
//│     let x$6 = Nil() in -- #63
//│     jump j$0(x$6) -- #62
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (r0) = addOne_jp(xs$0) in -- #66
//│ r0 -- #65
//│ )
//│ },
//│ let x$7 = Nil() in -- #55
//│ let x$8 = Cons(3,x$7) in -- #54
//│ let x$9 = Cons(2,x$8) in -- #53
//│ let x$10 = Cons(1,x$9) in -- #52
//│ let* (x$11) = addOne(x$10) in -- #51
//│ x$11 -- #50)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:interpIR
class True
class False
class A(m, n)
fun a(x) =
  if x.n < 0 then A(-1, x.n)
  else A(2, b(x.n - 2))
fun b(n) =
  if n < 0 then A(0, n)
  else a(A(0, n - 1))
b(20)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(|m|,| |n|)|↵|#fun| |a|(|x|)| |#=|→|#if| |x|.n| |<| |0| |#then| |A|(|-|1|,| |x|.n|)|↵|#else| |A|(|2|,| |b|(|x|.n| |-| |2|)|)|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |<| |0| |#then| |A|(|0|,| |n|)|↵|#else| |a|(|A|(|0|,| |n| |-| |1|)|)|←|↵|b|(|20|)|
//│ Parsed: {class True {}; class False {}; class A(m, n,) {}; fun a = (x,) => {if (<((x).n,)(0,)) then A(-1, (x).n,) else A(2, b(-((x).n,)(2,),),)}; fun b = (n,) => {if (<(n,)(0,)) then A(0, n,) else a(A(0, -(n,)(1,),),)}; b(20,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let x$1 = x$0.n in -- #35
//│ let x$2 = <(x$1,0) in -- #34
//│ if x$2 -- #33
//│   true =>
//│     let x$4 = x$0.n in -- #14
//│     let x$5 = A(-1,x$4) in -- #13
//│     jump j$0(x$5) -- #12
//│   false =>
//│     let x$6 = x$0.n in -- #32
//│     let x$7 = -(x$6,2) in -- #31
//│     let* (x$8) = b(x$7) in -- #30
//│     let x$9 = A(2,x$8) in -- #29
//│     jump j$0(x$9) -- #28
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let x$10 = <(n$0,0) in -- #65
//│ if x$10 -- #64
//│   true =>
//│     let x$12 = A(0,n$0) in -- #47
//│     jump j$1(x$12) -- #46
//│   false =>
//│     let x$13 = -(n$0,1) in -- #63
//│     let x$14 = A(0,x$13) in -- #62
//│     let* (x$15) = a(x$14) in -- #61
//│     jump j$1(x$15) -- #60
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,x$0) in -- #103
//│ r0 -- #102
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$0,0) in -- #101
//│ r0 -- #100
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #98
//│ if scrut -- #97
//│   true =>
//│     let x$1 = a_x$0.n in -- #96
//│     let x$2 = <(x$1,0) in -- #95
//│     if x$2 -- #94
//│       true =>
//│         let x$4 = a_x$0.n in -- #88
//│         let x$5 = A(-1,x$4) in -- #87
//│         jump j$0(x$5) -- #86
//│       false =>
//│         let x$6 = a_x$0.n in -- #93
//│         let x$7 = -(x$6,2) in -- #92
//│         let* (x$8) = b(x$7) in -- #91
//│         let x$9 = A(2,x$8) in -- #90
//│         jump j$0(x$9) -- #89
//│   false =>
//│     let x$10 = <(b_n$0,0) in -- #85
//│     if x$10 -- #84
//│       true =>
//│         let x$12 = A(0,b_n$0) in -- #80
//│         jump j$1(x$12) -- #79
//│       false =>
//│         let x$13 = -(b_n$0,1) in -- #83
//│         let x$14 = A(0,x$13) in -- #82
//│         jump _b_a_opt_jp(0,b_n$0,x$14) -- #81
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$0,a_x$0) -- #99
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,x$0) in -- #103
//│ r0 -- #102
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$0,0) in -- #101
//│ r0 -- #100
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #98
//│ if scrut -- #97
//│   true =>
//│     let x$1 = a_x$0.n in -- #96
//│     let x$2 = <(x$1,0) in -- #95
//│     if x$2 -- #94
//│       true =>
//│         let x$4 = a_x$0.n in -- #88
//│         let x$5 = A(-1,x$4) in -- #87
//│         jump j$0(x$5) -- #86
//│       false =>
//│         let x$6 = a_x$0.n in -- #93
//│         let x$7 = -(x$6,2) in -- #92
//│         let* (x$8) = b(x$7) in -- #91
//│         let x$9 = A(2,x$8) in -- #90
//│         jump j$0(x$9) -- #89
//│   false =>
//│     let x$10 = <(b_n$0,0) in -- #85
//│     if x$10 -- #84
//│       true =>
//│         let x$12 = A(0,b_n$0) in -- #80
//│         jump j$1(x$12) -- #79
//│       false =>
//│         let x$13 = -(b_n$0,1) in -- #83
//│         let x$14 = A(0,x$13) in -- #82
//│         jump _b_a_opt_jp(0,b_n$0,x$14) -- #81
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$0,a_x$0) -- #99
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Interpreted:
//│ A(2,A(2,A(2,A(2,A(2,A(2,A(2,A(0,-1))))))))
