:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:interpIR
class True
class False
fun fact(acc, n) =
  if n == 0 then acc
  else fact(acc * n, n - 1)
fact(1, 5)
//│ |#class| |True|↵|#class| |False|↵|#fun| |fact|(|acc|,| |n|)| |#=|→|#if| |n| |==| |0| |#then| |acc|↵|#else| |fact|(|acc| |*| |n|,| |n| |-| |1|)|←|↵|fact|(|1|,| |5|)|
//│ Parsed: {class True {}; class False {}; fun fact = (acc, n,) => {if (==(n,)(0,)) then acc else fact(*(acc,)(n,), -(n,)(1,),)}; fact(1, 5,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, fact, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #20
//│     let x$3 = -(n$0,1) in -- #19
//│     let* (x$4) = fact(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(fact))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (acc$0_,n$0_) = fact_jp(acc$0,n$0) in -- #38
//│ acc$0_,n$0_ -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, fact_jp, [acc$0,n$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #36
//│ if x$0 -- #35
//│   true =>
//│     jump j$0(acc$0) -- #31
//│   false =>
//│     let x$2 = *(acc$0,n$0) in -- #34
//│     let x$3 = -(n$0,1) in -- #33
//│     jump fact_jp(x$2,x$3) -- #32
//│ )
//│ Def(3, fact, [acc$0,n$0],
//│ 1, 
//│ let* (acc$0_,n$0_) = fact_jp(acc$0,n$0) in -- #38
//│ acc$0_,n$0_ -- #37
//│ )
//│ },
//│ let* (x$5) = fact(1,5) in -- #30
//│ x$5 -- #29)
//│ 
//│ Interpreted:
//│ 120

:noTailRec
:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

:interpIR
class True
class False
fun double(x) = x * 2
fun f(n, acc) = if n == 0 then double(acc) else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -double(acc) else f(m - 1, acc + 1)
g(6, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |double|(|x|)| |#=| |x| |*| |2|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |double|(|acc|)| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|double|(|acc|)| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|6|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun double = (x,) => *(x,)(2,); fun f = (n, acc,) => if (==(n,)(0,)) then double(acc,) else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(double(acc,),) else f(-(m,)(1,), +(acc,)(1,),); g(6, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let x$2 = ==(n$0,0) in -- #31
//│ if x$2 -- #30
//│   true =>
//│     let* (x$4) = double(acc$0) in -- #14
//│     jump j$0(x$4) -- #13
//│   false =>
//│     let x$5 = -(n$0,1) in -- #29
//│     let x$6 = +(acc$0,1) in -- #28
//│     let* (x$7) = g(x$5,x$6) in -- #27
//│     jump j$0(x$7) -- #26
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let x$8 = ==(m$0,0) in -- #62
//│ if x$8 -- #61
//│   true =>
//│     let* (x$10) = double(acc$1) in -- #45
//│     let x$11 = -(0,x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│   false =>
//│     let x$12 = -(m$0,1) in -- #60
//│     let x$13 = +(acc$1,1) in -- #59
//│     let* (x$14) = f(x$12,x$13) in -- #58
//│     jump j$1(x$14) -- #57
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(g, f), Set(double))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, double, [x$0],
//│ 1, 
//│ let x$1 = *(x$0,2) in -- #3
//│ x$1 -- #2
//│ )
//│ Def(1, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(1,0,0,n$0,acc$0) in -- #100
//│ r0 -- #99
//│ )
//│ Def(2, j$0, [x$3],
//│ 1, 
//│ x$3 -- #7
//│ )
//│ Def(3, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(3,m$0,acc$1,0,0) in -- #98
//│ r0 -- #97
//│ )
//│ Def(4, j$1, [x$9],
//│ 1, 
//│ x$9 -- #35
//│ )
//│ Def(5, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(1,tailrecBranch) in -- #95
//│ if scrut -- #94
//│   true =>
//│     let x$2 = ==(f_n$0,0) in -- #93
//│     if x$2 -- #92
//│       true =>
//│         let* (x$4) = double(f_acc$0) in -- #88
//│         jump j$0(x$4) -- #87
//│       false =>
//│         let x$5 = -(f_n$0,1) in -- #91
//│         let x$6 = +(f_acc$0,1) in -- #90
//│         jump _g_f_opt_jp(3,x$5,x$6,f_n$0,f_acc$0) -- #89
//│   false =>
//│     let x$8 = ==(g_m$0,0) in -- #86
//│     if x$8 -- #85
//│       true =>
//│         let* (x$10) = double(g_acc$1) in -- #81
//│         let x$11 = -(0,x$10) in -- #80
//│         jump j$1(x$11) -- #79
//│       false =>
//│         let x$12 = -(g_m$0,1) in -- #84
//│         let x$13 = +(g_acc$1,1) in -- #83
//│         jump _g_f_opt_jp(1,g_m$0,g_acc$1,x$12,x$13) -- #82
//│ )
//│ Def(6, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #96
//│ )
//│ },
//│ let* (x$15) = g(6,0) in -- #70
//│ x$15 -- #69)
//│ 
//│ Interpreted:
//│ -12

class True
class False
fun f(a, b, c) = g(0, 0)
fun g(d, e) = h(0, 0, 0, 0)
fun h(p, q, r, s) = f(0, 0, 0)
2 
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|a|,| |b|,| |c|)| |#=| |g|(|0|,| |0|)|↵|#fun| |g|(|d|,| |e|)| |#=| |h|(|0|,| |0|,| |0|,| |0|)|↵|#fun| |h|(|p|,| |q|,| |r|,| |s|)| |#=| |f|(|0|,| |0|,| |0|)|↵|2| |
//│ Parsed: {class True {}; class False {}; fun f = (a, b, c,) => g(0, 0,); fun g = (d, e,) => h(0, 0, 0, 0,); fun h = (p, q, r, s,) => f(0, 0, 0,); 2}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (x$0) = g(0,0) in -- #7
//│ x$0 -- #6
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (x$1) = h(0,0,0,0) in -- #19
//│ x$1 -- #18
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (x$2) = f(0,0,0) in -- #29
//│ x$2 -- #28
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(h, g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #37
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #34
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #36
//│     if scrut -- #35
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #33
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #32
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)

// TODO: should error, but it seems IR errors are not considered errors by the unit test framework
class True
class False
fun hello() =
    @tailrec hello()
    2
hello()
//│ |#class| |True|↵|#class| |False|↵|#fun| |hello|(||)| |#=|→|@|tailrec| |hello|(||)|↵|2|←|↵|hello|(||)|
//│ Parsed: {class True {}; class False {}; fun hello = () => {@tailrec hello(); 2}; hello()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, hello, [],
//│ 1, 
//│ let* (x$0) = @tailrec hello() in -- #5
//│ 2 -- #3
//│ )
//│ },
//│ let* (x$1) = hello() in -- #9
//│ x$1 -- #8)
//│ 
//│ IR Processing Failed: not a tail call
//│ 
//│ mlscript.compiler.ir.IRError$.apply(IR.scala:14)
//│ mlscript.compiler.optimizer.TailRecOpt.returnFailure$1(TailRecOpt.scala:48)
//│ mlscript.compiler.optimizer.TailRecOpt.getOptimizableCalls(TailRecOpt.scala:59)
//│ mlscript.compiler.optimizer.TailRecOpt.findTailCalls(TailRecOpt.scala:225)
//│ mlscript.compiler.optimizer.TailRecOpt.dfs$1(TailRecOpt.scala:257)
//│ mlscript.compiler.optimizer.TailRecOpt.partitionNodes$$anonfun$1(TailRecOpt.scala:302)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)
//│ scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)
//│ scala.collection.immutable.Set$Set1.foreach(Set.scala:168)
//│ mlscript.compiler.optimizer.TailRecOpt.partitionNodes(TailRecOpt.scala:302)
//│ mlscript.compiler.optimizer.TailRecOpt.partition(TailRecOpt.scala:501)
//│ mlscript.compiler.optimizer.TailRecOpt.run_debug(TailRecOpt.scala:508)
//│ mlscript.compiler.IRDiffTestCompiler.postProcess(TestIR.scala:28)
//│ mlscript.DiffTests.rec$1(DiffTests.scala:470)
//│ mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1076)
//│ org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ org.scalatest.Transformer.apply(Transformer.scala:22)
//│ org.scalatest.Transformer.apply(Transformer.scala:20)
//│ org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:226)
//│ org.scalatest.TestSuite.withFixture(TestSuite.scala:196)
//│ org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)
//│ mlscript.DiffTests.org$scalatest$concurrent$TimeLimitedTests$$super$withFixture(DiffTests.scala:53)
//│ org.scalatest.concurrent.TimeLimitedTests.$anonfun$withFixture$3(TimeLimitedTests.scala:154)
//│ org.scalatest.enablers.Timed$$anon$1.timeoutAfter(Timed.scala:127)
//│ org.scalatest.concurrent.TimeLimits$.failAfterImpl(TimeLimits.scala:282)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture(TimeLimitedTests.scala:153)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture$(TimeLimitedTests.scala:150)
//│ mlscript.DiffTests.withFixture(DiffTests.scala:53)
//│ org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:224)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:236)
//│ org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:236)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:218)
//│ mlscript.DiffTests.org$scalatest$OneInstancePerTest$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTest(OneInstancePerTest.scala:131)
//│ org.scalatest.OneInstancePerTest.runTest$(OneInstancePerTest.scala:123)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTest(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTest(ParallelTestExecution.scala:164)
//│ org.scalatest.ParallelTestExecution.runTest$(ParallelTestExecution.scala:148)
//│ mlscript.DiffTests.runTest(DiffTests.scala:53)
//│ org.scalatest.OneInstancePerTest.runTests(OneInstancePerTest.scala:181)
//│ org.scalatest.OneInstancePerTest.runTests$(OneInstancePerTest.scala:172)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTests(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.runTests(ParallelTestExecution.scala:97)
//│ org.scalatest.ParallelTestExecution.runTests$(ParallelTestExecution.scala:79)
//│ mlscript.DiffTests.runTests(DiffTests.scala:53)
//│ org.scalatest.Suite.run(Suite.scala:1114)
//│ org.scalatest.Suite.run$(Suite.scala:1096)
//│ org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1563)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:273)
//│ org.scalatest.SuperEngine.runImpl(Engine.scala:535)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:273)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:272)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$run(DiffTests.scala:53)
//│ org.scalatest.ParallelTestExecution.run(ParallelTestExecution.scala:261)
//│ org.scalatest.ParallelTestExecution.run$(ParallelTestExecution.scala:258)
//│ mlscript.DiffTests.run(DiffTests.scala:53)
//│ org.scalatest.tools.DistributedTestRunnerSuite.run(DistributedTestRunnerSuite.scala:22)
//│ org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:47)
//│ java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)
//│ java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
//│ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
//│ java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
//│ java.base/java.lang.Thread.run(Thread.java:840)

:interpIR
class True
class False
class Cons(h, t)
class Nil
fun addOne(xs) =
  if xs is
    Cons(h, t) then Cons(h + 1, @tailrec addOne(t))
    Nil then Nil
addOne(Cons(1, Cons(2, Cons(3, Nil))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Cons|(|h|,| |t|)|↵|#class| |Nil|↵|#fun| |addOne|(|xs|)| |#=|→|#if| |xs| |is|→|Cons|(|h|,| |t|)| |#then| |Cons|(|h| |+| |1|,| |@|tailrec| |addOne|(|t|)|)|↵|Nil| |#then| |Nil|←|←|↵|addOne|(|Cons|(|1|,| |Cons|(|2|,| |Cons|(|3|,| |Nil|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Cons(h, t,) {}; class Nil {}; fun addOne = (xs,) => {if xs is ‹(Cons(h, t,)) then Cons(+(h,)(1,), @tailrec addOne(t,),); (Nil) then Nil›}; addOne(Cons(1, Cons(2, Cons(3, Nil,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(0, addOne, [xs$0],
//│ 1, 
//│ case xs$0 of -- #28
//│   Cons =>
//│     let x$1 = xs$0.t in -- #24
//│     let x$2 = xs$0.h in -- #23
//│     let x$3 = +(x$2,1) in -- #22
//│     let* (x$4) = @tailrec addOne(x$1) in -- #21
//│     let x$5 = Cons(x$3,x$4) in -- #19
//│     jump j$0(x$5) -- #18
//│   Nil =>
//│     let x$6 = Nil() in -- #27
//│     jump j$0(x$6) -- #26
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ },
//│ let x$7 = Nil() in -- #53
//│ let x$8 = Cons(3,x$7) in -- #52
//│ let x$9 = Cons(2,x$8) in -- #51
//│ let x$10 = Cons(1,x$9) in -- #50
//│ let* (x$11) = addOne(x$10) in -- #49
//│ x$11 -- #48)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$0), Set(addOne))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #62
//│   Cons =>
//│     let x$1 = xs$0.t in -- #59
//│     let x$2 = xs$0.h in -- #58
//│     let x$3 = +(x$2,1) in -- #57
//│     let* (x$4) = @tailrec addOne(x$1) in -- #56
//│     let x$5 = Cons(x$3,x$4) in -- #55
//│     jump j$0(x$5) -- #54
//│   Nil =>
//│     let x$6 = Nil() in -- #61
//│     jump j$0(x$6) -- #60
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (xs$0_) = addOne_jp(xs$0) in -- #64
//│ xs$0_ -- #63
//│ )
//│ },
//│ let x$7 = Nil() in -- #53
//│ let x$8 = Cons(3,x$7) in -- #52
//│ let x$9 = Cons(2,x$8) in -- #51
//│ let x$10 = Cons(1,x$9) in -- #50
//│ let* (x$11) = addOne(x$10) in -- #49
//│ x$11 -- #48)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Cons, [h,t]),ClassInfo(3, Nil, [])}, {
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, addOne_jp, [xs$0],
//│ 1, 
//│ case xs$0 of -- #62
//│   Cons =>
//│     let x$1 = xs$0.t in -- #59
//│     let x$2 = xs$0.h in -- #58
//│     let x$3 = +(x$2,1) in -- #57
//│     let* (x$4) = @tailrec addOne(x$1) in -- #56
//│     let x$5 = Cons(x$3,x$4) in -- #55
//│     jump j$0(x$5) -- #54
//│   Nil =>
//│     let x$6 = Nil() in -- #61
//│     jump j$0(x$6) -- #60
//│ )
//│ Def(3, addOne, [xs$0],
//│ 1, 
//│ let* (xs$0_) = addOne_jp(xs$0) in -- #64
//│ xs$0_ -- #63
//│ )
//│ },
//│ let x$7 = Nil() in -- #53
//│ let x$8 = Cons(3,x$7) in -- #52
//│ let x$9 = Cons(2,x$8) in -- #51
//│ let x$10 = Cons(1,x$9) in -- #50
//│ let* (x$11) = addOne(x$10) in -- #49
//│ x$11 -- #48)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Cons(4,Nil())))

:interpIR
class True
class False
class Zero
class S(x)
fun a(n) =
  if n is
    S(x) then S(@tailrec b(x))
    Zero then S(Zero)
fun b(n) =
  if n is
    S(x) then S(S(@tailrec a(x)))
    Zero then S(S(Zero))
a(S(S(S(Zero))))
//│ |#class| |True|↵|#class| |False|↵|#class| |Zero|↵|#class| |S|(|x|)|↵|#fun| |a|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|@|tailrec| |b|(|x|)|)|↵|Zero| |#then| |S|(|Zero|)|←|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |is|→|S|(|x|)| |#then| |S|(|S|(|@|tailrec| |a|(|x|)|)|)|↵|Zero| |#then| |S|(|S|(|Zero|)|)|←|←|↵|a|(|S|(|S|(|S|(|Zero|)|)|)|)|
//│ Parsed: {class True {}; class False {}; class Zero {}; class S(x,) {}; fun a = (n,) => {if n is ‹(S(x,)) then S(@tailrec b(x,),); (Zero) then S(Zero,)›}; fun b = (n,) => {if n is ‹(S(x,)) then S(S(@tailrec a(x,),),); (Zero) then S(S(Zero,),)›}; a(S(S(S(Zero,),),),)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ case n$0 of -- #24
//│   S =>
//│     let x$1 = n$0.x in -- #16
//│     let* (x$2) = @tailrec b(x$1) in -- #15
//│     let x$3 = S(x$2) in -- #13
//│     jump j$0(x$3) -- #12
//│   Zero =>
//│     let x$4 = Zero() in -- #23
//│     let x$5 = S(x$4) in -- #22
//│     jump j$0(x$5) -- #21
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ case n$1 of -- #57
//│   S =>
//│     let x$7 = n$1.x in -- #45
//│     let* (x$8) = @tailrec a(x$7) in -- #44
//│     let x$9 = S(x$8) in -- #42
//│     let x$10 = S(x$9) in -- #41
//│     jump j$1(x$10) -- #40
//│   Zero =>
//│     let x$11 = Zero() in -- #56
//│     let x$12 = S(x$11) in -- #55
//│     let x$13 = S(x$12) in -- #54
//│     jump j$1(x$13) -- #53
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ },
//│ let x$14 = Zero() in -- #76
//│ let x$15 = S(x$14) in -- #75
//│ let x$16 = S(x$15) in -- #74
//│ let x$17 = S(x$16) in -- #73
//│ let* (x$18) = a(x$17) in -- #72
//│ x$18 -- #71)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #111
//│ r0 -- #110
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #109
//│ r0 -- #108
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #106
//│ if scrut -- #105
//│   true =>
//│     case a_n$0 of -- #104
//│       S =>
//│         let x$1 = a_n$0.x in -- #100
//│         let* (x$2) = @tailrec b(x$1) in -- #99
//│         let x$3 = S(x$2) in -- #98
//│         jump j$0(x$3) -- #97
//│       Zero =>
//│         let x$4 = Zero() in -- #103
//│         let x$5 = S(x$4) in -- #102
//│         jump j$0(x$5) -- #101
//│   false =>
//│     case b_n$1 of -- #96
//│       S =>
//│         let x$7 = b_n$1.x in -- #91
//│         let* (x$8) = @tailrec a(x$7) in -- #90
//│         let x$9 = S(x$8) in -- #89
//│         let x$10 = S(x$9) in -- #88
//│         jump j$1(x$10) -- #87
//│       Zero =>
//│         let x$11 = Zero() in -- #95
//│         let x$12 = S(x$11) in -- #94
//│         let x$13 = S(x$12) in -- #93
//│         jump j$1(x$13) -- #92
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #107
//│ )
//│ },
//│ let x$14 = Zero() in -- #76
//│ let x$15 = S(x$14) in -- #75
//│ let x$16 = S(x$15) in -- #74
//│ let x$17 = S(x$16) in -- #73
//│ let* (x$18) = a(x$17) in -- #72
//│ x$18 -- #71)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Zero, []),ClassInfo(3, S, [x])}, {
//│ Def(0, a, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,n$0) in -- #111
//│ r0 -- #110
//│ )
//│ Def(1, j$0, [x$0],
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, b, [n$1],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$1,0) in -- #109
//│ r0 -- #108
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #106
//│ if scrut -- #105
//│   true =>
//│     case a_n$0 of -- #104
//│       S =>
//│         let x$1 = a_n$0.x in -- #100
//│         let* (x$2) = @tailrec b(x$1) in -- #99
//│         let x$3 = S(x$2) in -- #98
//│         jump j$0(x$3) -- #97
//│       Zero =>
//│         let x$4 = Zero() in -- #103
//│         let x$5 = S(x$4) in -- #102
//│         jump j$0(x$5) -- #101
//│   false =>
//│     case b_n$1 of -- #96
//│       S =>
//│         let x$7 = b_n$1.x in -- #91
//│         let* (x$8) = @tailrec a(x$7) in -- #90
//│         let x$9 = S(x$8) in -- #89
//│         let x$10 = S(x$9) in -- #88
//│         jump j$1(x$10) -- #87
//│       Zero =>
//│         let x$11 = Zero() in -- #95
//│         let x$12 = S(x$11) in -- #94
//│         let x$13 = S(x$12) in -- #93
//│         jump j$1(x$13) -- #92
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$1,a_n$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$1,a_n$0) -- #107
//│ )
//│ },
//│ let x$14 = Zero() in -- #76
//│ let x$15 = S(x$14) in -- #75
//│ let x$16 = S(x$15) in -- #74
//│ let x$17 = S(x$16) in -- #73
//│ let* (x$18) = a(x$17) in -- #72
//│ x$18 -- #71)
//│ 
//│ Interpreted:
//│ S(S(S(S(S(S(Zero()))))))

:interpIR
class True
class False
class A(m, n)
fun a(x) =
  if x.n < 0 then A(-1, x.n)
  else A(2, b(x.n - 2))
fun b(n) =
  if n < 0 then A(0, n)
  else a(A(0, n - 1))
b(20)
//│ |#class| |True|↵|#class| |False|↵|#class| |A|(|m|,| |n|)|↵|#fun| |a|(|x|)| |#=|→|#if| |x|.n| |<| |0| |#then| |A|(|-|1|,| |x|.n|)|↵|#else| |A|(|2|,| |b|(|x|.n| |-| |2|)|)|←|↵|#fun| |b|(|n|)| |#=|→|#if| |n| |<| |0| |#then| |A|(|0|,| |n|)|↵|#else| |a|(|A|(|0|,| |n| |-| |1|)|)|←|↵|b|(|20|)|
//│ Parsed: {class True {}; class False {}; class A(m, n,) {}; fun a = (x,) => {if (<((x).n,)(0,)) then A(-1, (x).n,) else A(2, b(-((x).n,)(2,),),)}; fun b = (n,) => {if (<(n,)(0,)) then A(0, n,) else a(A(0, -(n,)(1,),),)}; b(20,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let x$1 = x$0.n in -- #35
//│ let x$2 = <(x$1,0) in -- #34
//│ if x$2 -- #33
//│   true =>
//│     let x$4 = x$0.n in -- #14
//│     let x$5 = A(-1,x$4) in -- #13
//│     jump j$0(x$5) -- #12
//│   false =>
//│     let x$6 = x$0.n in -- #32
//│     let x$7 = -(x$6,2) in -- #31
//│     let* (x$8) = b(x$7) in -- #30
//│     let x$9 = A(2,x$8) in -- #29
//│     jump j$0(x$9) -- #28
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let x$10 = <(n$0,0) in -- #65
//│ if x$10 -- #64
//│   true =>
//│     let x$12 = A(0,n$0) in -- #47
//│     jump j$1(x$12) -- #46
//│   false =>
//│     let x$13 = -(n$0,1) in -- #63
//│     let x$14 = A(0,x$13) in -- #62
//│     let* (x$15) = a(x$14) in -- #61
//│     jump j$1(x$15) -- #60
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(b, a))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,x$0) in -- #103
//│ r0 -- #102
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$0,0) in -- #101
//│ r0 -- #100
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #98
//│ if scrut -- #97
//│   true =>
//│     let x$1 = a_x$0.n in -- #96
//│     let x$2 = <(x$1,0) in -- #95
//│     if x$2 -- #94
//│       true =>
//│         let x$4 = a_x$0.n in -- #88
//│         let x$5 = A(-1,x$4) in -- #87
//│         jump j$0(x$5) -- #86
//│       false =>
//│         let x$6 = a_x$0.n in -- #93
//│         let x$7 = -(x$6,2) in -- #92
//│         let* (x$8) = b(x$7) in -- #91
//│         let x$9 = A(2,x$8) in -- #90
//│         jump j$0(x$9) -- #89
//│   false =>
//│     let x$10 = <(b_n$0,0) in -- #85
//│     if x$10 -- #84
//│       true =>
//│         let x$12 = A(0,b_n$0) in -- #80
//│         jump j$1(x$12) -- #79
//│       false =>
//│         let x$13 = -(b_n$0,1) in -- #83
//│         let x$14 = A(0,x$13) in -- #82
//│         jump _b_a_opt_jp(0,b_n$0,x$14) -- #81
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$0,a_x$0) -- #99
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, A, [m,n])}, {
//│ Def(0, a, [x$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(0,0,x$0) in -- #103
//│ r0 -- #102
//│ )
//│ Def(1, j$0, [x$3],
//│ 1, 
//│ x$3 -- #4
//│ )
//│ Def(2, b, [n$0],
//│ 1, 
//│ let* (r0) = _b_a_opt(2,n$0,0) in -- #101
//│ r0 -- #100
//│ )
//│ Def(3, j$1, [x$11],
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(4, _b_a_opt_jp, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #98
//│ if scrut -- #97
//│   true =>
//│     let x$1 = a_x$0.n in -- #96
//│     let x$2 = <(x$1,0) in -- #95
//│     if x$2 -- #94
//│       true =>
//│         let x$4 = a_x$0.n in -- #88
//│         let x$5 = A(-1,x$4) in -- #87
//│         jump j$0(x$5) -- #86
//│       false =>
//│         let x$6 = a_x$0.n in -- #93
//│         let x$7 = -(x$6,2) in -- #92
//│         let* (x$8) = b(x$7) in -- #91
//│         let x$9 = A(2,x$8) in -- #90
//│         jump j$0(x$9) -- #89
//│   false =>
//│     let x$10 = <(b_n$0,0) in -- #85
//│     if x$10 -- #84
//│       true =>
//│         let x$12 = A(0,b_n$0) in -- #80
//│         jump j$1(x$12) -- #79
//│       false =>
//│         let x$13 = -(b_n$0,1) in -- #83
//│         let x$14 = A(0,x$13) in -- #82
//│         jump _b_a_opt_jp(0,b_n$0,x$14) -- #81
//│ )
//│ Def(5, _b_a_opt, [tailrecBranch,b_n$0,a_x$0],
//│ 1, 
//│ jump _b_a_opt_jp(tailrecBranch,b_n$0,a_x$0) -- #99
//│ )
//│ },
//│ let* (x$16) = b(20) in -- #71
//│ x$16 -- #70)
//│ 
//│ Interpreted:
//│ A(2,A(2,A(2,A(2,A(2,A(2,A(2,A(0,-1))))))))
