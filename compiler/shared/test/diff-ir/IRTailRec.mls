:NewParser
:ParseOnly
:UseIR

:noTailRec
:interpIR
class True
class False
fun f(n, acc) = if n == 0 then acc else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -acc else f(m - 1, acc + 1)
g(5, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |acc| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|acc| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|5|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun f = (n, acc,) => if (==(n,)(0,)) then acc else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(acc,) else f(-(m,)(1,), +(acc,)(1,),); g(5, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #20
//│     let x$3 = +(acc$0,1) in -- #19
//│     let* (x$4) = g(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let x$5 = ==(m$0,0) in -- #48
//│ if x$5 -- #47
//│   true =>
//│     let x$7 = -(0,acc$1) in -- #31
//│     jump j$1(x$7) -- #30
//│   false =>
//│     let x$8 = -(m$0,1) in -- #46
//│     let x$9 = +(acc$1,1) in -- #45
//│     let* (x$10) = f(x$8,x$9) in -- #44
//│     jump j$1(x$10) -- #43
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #20
//│     let x$3 = +(acc$0,1) in -- #19
//│     let* (x$4) = g(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let x$5 = ==(m$0,0) in -- #48
//│ if x$5 -- #47
//│   true =>
//│     let x$7 = -(0,acc$1) in -- #31
//│     jump j$1(x$7) -- #30
//│   false =>
//│     let x$8 = -(m$0,1) in -- #46
//│     let x$9 = +(acc$1,1) in -- #45
//│     let* (x$10) = f(x$8,x$9) in -- #44
//│     jump j$1(x$10) -- #43
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #20
//│     let x$3 = +(acc$0,1) in -- #19
//│     let* (x$4) = g(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let x$5 = ==(m$0,0) in -- #48
//│ if x$5 -- #47
//│   true =>
//│     let x$7 = -(0,acc$1) in -- #31
//│     jump j$1(x$7) -- #30
//│   false =>
//│     let x$8 = -(m$0,1) in -- #46
//│     let x$9 = +(acc$1,1) in -- #45
//│     let* (x$10) = f(x$8,x$9) in -- #44
//│     jump j$1(x$10) -- #43
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ 
//│ Interpreted:
//│ 5

:interpIR
class True
class False
fun f(n, acc) = if n == 0 then acc else g(n - 1, acc + 1)
fun g(m, acc) = if m == 0 then -acc else f(m - 1, acc + 1)
g(5, 0)
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|n|,| |acc|)| |#=| |#if| |n| |==| |0| |#then| |acc| |#else| |g|(|n| |-| |1|,| |acc| |+| |1|)|↵|#fun| |g|(|m|,| |acc|)| |#=| |#if| |m| |==| |0| |#then| |-|acc| |#else| |f|(|m| |-| |1|,| |acc| |+| |1|)|↵|g|(|5|,| |0|)|
//│ Parsed: {class True {}; class False {}; fun f = (n, acc,) => if (==(n,)(0,)) then acc else g(-(n,)(1,), +(acc,)(1,),); fun g = (m, acc,) => if (==(m,)(0,)) then -(0,)(acc,) else f(-(m,)(1,), +(acc,)(1,),); g(5, 0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #22
//│ if x$0 -- #21
//│   true =>
//│     jump j$0(acc$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #20
//│     let x$3 = +(acc$0,1) in -- #19
//│     let* (x$4) = g(x$2,x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let x$5 = ==(m$0,0) in -- #48
//│ if x$5 -- #47
//│   true =>
//│     let x$7 = -(0,acc$1) in -- #31
//│     jump j$1(x$7) -- #30
//│   false =>
//│     let x$8 = -(m$0,1) in -- #46
//│     let x$9 = +(acc$1,1) in -- #45
//│     let* (x$10) = f(x$8,x$9) in -- #44
//│     jump j$1(x$10) -- #43
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(j$1), Set(j$0), Set(g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(0,0,0,n$0,acc$0) in -- #66
//│ r0 -- #65
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(2,m$0,acc$1,0,0) in -- #64
//│ r0 -- #63
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #61
//│ if scrut -- #59
//│   true =>
//│     let x$0 = ==(f_n$0,0) in -- #x
//│     if x$0 -- #x
//│       true =>
//│         jump j$0(f_acc$0) -- #x
//│       false =>
//│         let x$2 = -(f_n$0,1) in -- #x
//│         let x$3 = +(f_acc$0,1) in -- #x
//│         jump _g_f_opt_jp(2,x$2,x$3,f_n$0,f_acc$0) -- #58
//│   false =>
//│     let x$5 = ==(g_m$0,0) in -- #x
//│     if x$5 -- #x
//│       true =>
//│         let x$7 = -(0,g_acc$1) in -- #x
//│         jump j$1(x$7) -- #x
//│       false =>
//│         let x$8 = -(g_m$0,1) in -- #x
//│         let x$9 = +(g_acc$1,1) in -- #x
//│         jump _g_f_opt_jp(0,g_m$0,g_acc$1,x$8,x$9) -- #57
//│ )
//│ Def(5, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #62
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [n$0,acc$0],
//│ 1, 
//│ let* (r0) = _g_f_opt(0,0,0,n$0,acc$0) in -- #66
//│ r0 -- #65
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, g, [m$0,acc$1],
//│ 1, 
//│ let* (r0) = _g_f_opt(2,m$0,acc$1,0,0) in -- #64
//│ r0 -- #63
//│ )
//│ Def(3, j$1, [x$6],
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, _g_f_opt_jp, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #61
//│ if scrut -- #59
//│   true =>
//│     let x$0 = ==(f_n$0,0) in -- #x
//│     if x$0 -- #x
//│       true =>
//│         jump j$0(f_acc$0) -- #x
//│       false =>
//│         let x$2 = -(f_n$0,1) in -- #x
//│         let x$3 = +(f_acc$0,1) in -- #x
//│         jump _g_f_opt_jp(2,x$2,x$3,f_n$0,f_acc$0) -- #58
//│   false =>
//│     let x$5 = ==(g_m$0,0) in -- #x
//│     if x$5 -- #x
//│       true =>
//│         let x$7 = -(0,g_acc$1) in -- #x
//│         jump j$1(x$7) -- #x
//│       false =>
//│         let x$8 = -(g_m$0,1) in -- #x
//│         let x$9 = +(g_acc$1,1) in -- #x
//│         jump _g_f_opt_jp(0,g_m$0,g_acc$1,x$8,x$9) -- #57
//│ )
//│ Def(5, _g_f_opt, [tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0],
//│ 1, 
//│ jump _g_f_opt_jp(tailrecBranch,g_m$0,g_acc$1,f_n$0,f_acc$0) -- #62
//│ )
//│ },
//│ let* (x$11) = g(5,0) in -- #56
//│ x$11 -- #55)
//│ 
//│ Interpreted:
//│ 5

class True
class False
fun f(a, b, c) = g(0, 0)
fun g(d, e) = h(0, 0, 0, 0)
fun h(p, q, r, s) = f(0, 0, 0)
2 
//│ |#class| |True|↵|#class| |False|↵|#fun| |f|(|a|,| |b|,| |c|)| |#=| |g|(|0|,| |0|)|↵|#fun| |g|(|d|,| |e|)| |#=| |h|(|0|,| |0|,| |0|,| |0|)|↵|#fun| |h|(|p|,| |q|,| |r|,| |s|)| |#=| |f|(|0|,| |0|,| |0|)|↵|2| |
//│ Parsed: {class True {}; class False {}; fun f = (a, b, c,) => g(0, 0,); fun g = (d, e,) => h(0, 0, 0, 0,); fun h = (p, q, r, s,) => f(0, 0, 0,); 2}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (x$0) = g(0,0) in -- #7
//│ x$0 -- #6
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (x$1) = h(0,0,0,0) in -- #19
//│ x$1 -- #18
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (x$2) = f(0,0,0) in -- #29
//│ x$2 -- #28
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Strongly Connected Tail Calls:
//│ List(Set(h, g, f))
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #36
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #35
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #34
//│     if scrut -- #33
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #32
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #31
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, [])}, {
//│ Def(0, f, [a$0,b$0,c$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(0,0,0,0,0,0,0,a$0,b$0,c$0) in -- #45
//│ r0 -- #44
//│ )
//│ Def(1, g, [d$0,e$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(1,0,0,0,0,d$0,e$0,0,0,0) in -- #43
//│ r0 -- #42
//│ )
//│ Def(2, h, [p$0,q$0,r$0,s$0],
//│ 1, 
//│ let* (r0) = _h_g_f_opt(2,p$0,q$0,r$0,s$0,0,0,0,0,0) in -- #41
//│ r0 -- #40
//│ )
//│ Def(3, _h_g_f_opt_jp, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ let scrut = ==(0,tailrecBranch) in -- #38
//│ if scrut -- #36
//│   true =>
//│     jump _h_g_f_opt_jp(1,h_p$0,h_q$0,h_r$0,h_s$0,0,0,f_a$0,f_b$0,f_c$0) -- #35
//│   false =>
//│     let scrut = ==(1,tailrecBranch) in -- #34
//│     if scrut -- #33
//│       true =>
//│         jump _h_g_f_opt_jp(2,0,0,0,0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #32
//│       false =>
//│         jump _h_g_f_opt_jp(0,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,0,0,0) -- #31
//│ )
//│ Def(4, _h_g_f_opt, [tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0],
//│ 1, 
//│ jump _h_g_f_opt_jp(tailrecBranch,h_p$0,h_q$0,h_r$0,h_s$0,g_d$0,g_e$0,f_a$0,f_b$0,f_c$0) -- #39
//│ )
//│ },
//│ 2 -- #30)
