:NewParser
:ParseOnly
:UseIR

:genCpp
:runCpp
:interpIR
module Base {
  fun f() = 1
}
module Child extends Base {
  fun f() = 2
}
fun main() =
  let c = Child()
  Base.f(c)
  Child.f(c)
main()
//│ |#module| |Base| |{|→|#fun| |f|(||)| |#=| |1|←|↵|}|↵|#module| |Child| |#extends| |Base| |{|→|#fun| |f|(||)| |#=| |2|←|↵|}|↵|#fun| |main|(||)| |#=|→|#let| |c| |#=| |Child|(||)|↵|Base|.f|(|c|)|↵|Child|.f|(|c|)|←|↵|main|(||)|
//│ Parsed: {module Base {fun f = () => 1}; module Child: Base {fun f = () => 2}; fun main = () => {let c = Child(); (Base).f(c,); (Child).f(c,)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #21
//│ ),
//│ apply1 -> Def(2, apply1, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply0 -> Def(1, apply0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply4 -> Def(5, apply4, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply3 -> Def(4, apply3, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply2 -> Def(3, apply2, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #18
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Base, [], parents: , methods:
//│ f -> Def(7, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #22
//│ )),
//│ ClassInfo(10, Child, [], parents: Base, methods:
//│ f -> Def(8, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 2 -- #23
//│ ))}, {
//│ Def(0, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Child() in -- #15
//│ let x$2 = Base.f(x$1) in -- #14
//│ let x$3 = Child.f(x$1) in -- #13
//│ x$3 -- #12
//│ )
//│ },
//│ let* (x$0) = main() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #21
//│ ),
//│ apply1 -> Def(2, apply1, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply0 -> Def(1, apply0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply4 -> Def(5, apply4, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply3 -> Def(4, apply3, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply2 -> Def(3, apply2, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #18
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Base, [], parents: , methods:
//│ f -> Def(7, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #22
//│ )),
//│ ClassInfo(10, Child, [], parents: Base, methods:
//│ f -> Def(8, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 2 -- #23
//│ ))}, {
//│ Def(0, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Child() in -- #15
//│ let x$2 = Base.f(x$1) in -- #14
//│ let x$3 = Child.f(x$1) in -- #13
//│ x$3 -- #12
//│ )
//│ },
//│ let* (x$0) = main() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 2
//│ 
//│ 
//│ Execution succeeded: 
//│ 2
