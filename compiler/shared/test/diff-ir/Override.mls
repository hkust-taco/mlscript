:NewParser
:ParseOnly
:UseIR

:genCpp
module Base {
  fun f() = 1
}
module Child extends Base {
  fun f() = 2
}
fun main() =
  let c = Child()
  Base.f(c)
  Child.f(c)
main()
//│ |#module| |Base| |{|→|#fun| |f|(||)| |#=| |1|←|↵|}|↵|#module| |Child| |#extends| |Base| |{|→|#fun| |f|(||)| |#=| |2|←|↵|}|↵|#fun| |main|(||)| |#=|→|#let| |c| |#=| |Child|(||)|↵|Base|.f|(|c|)|↵|Child|.f|(|c|)|←|↵|main|(||)|
//│ Parsed: {module Base {fun f = () => 1}; module Child: Base {fun f = () => 2}; fun main = () => {let c = Child(); (Base).f(c,); (Child).f(c,)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Base, [], parents: , methods:
//│ f -> Def(0, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #0
//│ )),
//│ ClassInfo(10, Child, [], parents: Base, methods:
//│ f -> Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 2 -- #1
//│ ))}, {
//│ Def(2, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Child() in -- #14
//│ let x$1 = Base.f(x$0) in -- #13
//│ let x$2 = Child.f(x$0) in -- #12
//│ x$2 -- #11
//│ )
//│ },
//│ let* (x$3) = main() in -- #17
//│ x$3 -- #16)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Base, [], parents: , methods:
//│ f -> Def(0, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #0
//│ )),
//│ ClassInfo(10, Child, [], parents: Base, methods:
//│ f -> Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 2 -- #1
//│ ))}, {
//│ Def(2, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Child() in -- #14
//│ let x$1 = Base.f(x$0) in -- #13
//│ let x$2 = Child.f(x$0) in -- #12
//│ x$2 -- #11
//│ )
//│ },
//│ let* (x$3) = main() in -- #17
//│ x$3 -- #16)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Base;
//│ struct _mls_Child;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_main();
//│ _mlsValue _mlsMain();
//│ struct _mls_Base: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Base";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Base; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_f(){
//│     _mlsValue _mls_retval;
//│     _mls_retval = _mlsValue::fromIntLit(1);
//│     return _mls_retval;
//│   }
//│ };
//│ struct _mls_Child: public _mls_Base {
//│ 
//│   constexpr static inline const char *typeName = "Child";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Child; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   virtual _mlsValue _mls_f(){
//│     _mlsValue _mls_retval;
//│     _mls_retval = _mlsValue::fromIntLit(2);
//│     return _mls_retval;
//│   }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::create<_mls_Child>();
//│   auto _mls_x_1 = _mlsMethodCall<_mls_Base>(_mls_x_0)->_mls_f();
//│   auto _mls_x_2 = _mlsMethodCall<_mls_Child>(_mls_x_0)->_mls_f();
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_3 = _mls_main();
//│   _mls_retval = _mls_x_3;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
