:NewParser
:ParseOnly
:UseIR

:interpIR
class Pair(x, y)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |mktup2|(|x|,| |y|)| |#=| |mktup|(|x|,| |y|)|↵|#fun| |mktup|(|x|,| |y|)| |#=| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|mktup2|(|1|,| |2|)|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun mktup2 = (x, y,) => mktup(x, y,); fun mktup = (x, y,) => Pair(x, y,); fun foo = () => {mktup2(1, 2,)}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x$0,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = mktup(x$0,y$0) in -- #7
//│ x$1 -- #6
//│ )
//│ Def(1, mktup, [x$2,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Pair(x$2,y$1) in -- #14
//│ x$3 -- #13
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$4) = mktup2(1,2) in -- #22
//│ x$4 -- #21
//│ )
//│ },
//│ let* (x$5) = foo() in -- #26
//│ x$5 -- #25)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x$0,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = mktup(x$0,y$0) in -- #7
//│ x$1 -- #6
//│ )
//│ Def(1, mktup, [x$2,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Pair(x$2,y$1) in -- #14
//│ x$3 -- #13
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$4) = mktup2(1,2) in -- #22
//│ x$4 -- #21
//│ )
//│ },
//│ let* (x$5) = foo() in -- #26
//│ x$5 -- #25)
//│ 
//│ Interpreted:
//│ Pair(1,2)

:interpIR
class Pair(x, y)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|pair|)| |#=|→|#if| |pair| |is|→|Pair|(|x|,| |y|)| |#then| |Pair|(|x|,| |y|)|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |2|)|)|←|↵|bar|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (pair,) => {if pair is ‹(Pair(x, y,)) then Pair(x, y,)›}; fun bar = () => {foo(Pair(1, 2,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair$0 of -- #20
//│   Pair =>
//│     let x$1 = Pair.y(pair$0) in -- #19
//│     let x$2 = Pair.x(pair$0) in -- #18
//│     let x$3 = Pair(x$2,x$1) in -- #17
//│     jump j$0(x$3) -- #16
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = Pair(1,2) in -- #32
//│ let* (x$5) = foo(x$4) in -- #31
//│ x$5 -- #30
//│ )
//│ },
//│ let* (x$6) = bar() in -- #36
//│ x$6 -- #35)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case pair$0 of -- #20
//│   Pair =>
//│     let x$1 = Pair.y(pair$0) in -- #19
//│     let x$2 = Pair.x(pair$0) in -- #18
//│     let x$3 = Pair(x$2,x$1) in -- #17
//│     jump j$0(x$3) -- #16
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = Pair(1,2) in -- #32
//│ let* (x$5) = foo(x$4) in -- #31
//│ x$5 -- #30
//│ )
//│ },
//│ let* (x$6) = bar() in -- #36
//│ x$6 -- #35)
//│ 
//│ Interpreted:
//│ Pair(1,2)



:interpIR
class Pair(x, y) {}
fun silly(pair) =
  let _ = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)| |{||}|↵|#fun| |silly|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#let| |n| |#=| |#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then|→|#if| |pair| |is|→|Pair| |(|x3|,| |x4|)| |#then| |x3| |+| |1|←|←|←|↵|n| |+| |1|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |silly|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun silly = (pair,) => {let _ = 0; let n = if pair is ‹(Pair(x1, x2,)) then {if pair is ‹(Pair(x3, x4,)) then +(x3,)(1,)›}›; +(n,)(1,)}; fun foo = () => {let a = Pair(0, 1,); let b = silly(a,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 0 in -- #37
//│ case pair$0 of -- #36
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #35
//│     let x$4 = Pair.x(pair$0) in -- #34
//│     case pair$0 of -- #33
//│       Pair =>
//│         let x$6 = Pair.y(pair$0) in -- #32
//│         let x$7 = Pair.x(pair$0) in -- #31
//│         let x$8 = +(x$7,1) in -- #30
//│         jump j$1(x$8) -- #29
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = +(x$1,1) in -- #6
//│ x$2 -- #5
//│ )
//│ Def(2, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$0(x$5) -- #17
//│ )
//│ Def(3, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = Pair(0,1) in -- #51
//│ let* (x$10) = silly(x$9) in -- #50
//│ x$10 -- #49
//│ )
//│ },
//│ let* (x$11) = foo() in -- #55
//│ x$11 -- #54)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 0 in -- #37
//│ case pair$0 of -- #36
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #35
//│     let x$4 = Pair.x(pair$0) in -- #34
//│     case pair$0 of -- #33
//│       Pair =>
//│         let x$6 = Pair.y(pair$0) in -- #32
//│         let x$7 = Pair.x(pair$0) in -- #31
//│         let x$8 = +(x$7,1) in -- #30
//│         jump j$1(x$8) -- #29
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = +(x$1,1) in -- #6
//│ x$2 -- #5
//│ )
//│ Def(2, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$0(x$5) -- #17
//│ )
//│ Def(3, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = Pair(0,1) in -- #51
//│ let* (x$10) = silly(x$9) in -- #50
//│ x$10 -- #49
//│ )
//│ },
//│ let* (x$11) = foo() in -- #55
//│ x$11 -- #54)
//│ 
//│ Interpreted:
//│ 2




:interpIR
class Pair(x, y)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |c| |#=| |2|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x1| |+| |c|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |inc_fst|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let c = 2; if pair is ‹(Pair(x1, x2,)) then +(x1,)(c,)›}; fun foo = () => {let a = Pair(0, 1,); let b = inc_fst(a,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 2 in -- #19
//│ case pair$0 of -- #18
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #17
//│     let x$3 = Pair.x(pair$0) in -- #16
//│     let x$4 = +(x$3,x$0) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #2
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$5 = Pair(0,1) in -- #33
//│ let* (x$6) = inc_fst(x$5) in -- #32
//│ x$6 -- #31
//│ )
//│ },
//│ let* (x$7) = foo() in -- #37
//│ x$7 -- #36)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 2 in -- #19
//│ case pair$0 of -- #18
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #17
//│     let x$3 = Pair.x(pair$0) in -- #16
//│     let x$4 = +(x$3,x$0) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #2
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$5 = Pair(0,1) in -- #33
//│ let* (x$6) = inc_fst(x$5) in -- #32
//│ x$6 -- #31
//│ )
//│ },
//│ let* (x$7) = foo() in -- #37
//│ x$7 -- #36)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class Pair(x, y)
fun inc_fst(pair) =
  let _ = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x2| |+| |1|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |b| |#=| |inc_fst|(|Pair|(|0|,| |1|)|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let _ = 0; if pair is ‹(Pair(x1, x2,)) then +(x2,)(1,)›}; fun foo = () => {let b = inc_fst(Pair(0, 1,),); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 0 in -- #19
//│ case pair$0 of -- #18
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #17
//│     let x$3 = Pair.x(pair$0) in -- #16
//│     let x$4 = +(x$2,1) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #2
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$5 = Pair(0,1) in -- #32
//│ let* (x$6) = inc_fst(x$5) in -- #31
//│ x$6 -- #30
//│ )
//│ },
//│ let* (x$7) = foo() in -- #36
//│ x$7 -- #35)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 0 in -- #19
//│ case pair$0 of -- #18
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #17
//│     let x$3 = Pair.x(pair$0) in -- #16
//│     let x$4 = +(x$2,1) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #2
//│ )
//│ Def(2, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$5 = Pair(0,1) in -- #32
//│ let* (x$6) = inc_fst(x$5) in -- #31
//│ x$6 -- #30
//│ )
//│ },
//│ let* (x$7) = foo() in -- #36
//│ x$7 -- #35)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class Left(x)
class Right(y)
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ |#class| |Left|(|x|)|↵|#class| |Right|(|y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |t| |#=| |#if| |a| |is|→|Left|(|x|)| |#then| |Left|(|x| |+| |1|)|↵|Right|(|y|)| |#then| |Right|(|b|)|←|↵|#if| |t| |is|→|Left|(|x|)| |#then| |x|↵|Right|(|y|)| |#then| |y|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Right|(|2|)|,| |2|)|←|↵|bar|(||)|
//│ Parsed: {class Left(x,) {}; class Right(y,) {}; fun foo = (a, b,) => {let t = if a is ‹(Left(x,)) then Left(+(x,)(1,),); (Right(y,)) then Right(b,)›; if t is ‹(Left(x,)) then x; (Right(y,)) then y›}; fun bar = () => {foo(Right(2,), 2,)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a$0 of -- #44
//│   Left =>
//│     let x$4 = Left.x(a$0) in -- #32
//│     let x$5 = +(x$4,1) in -- #31
//│     let x$6 = Left(x$5) in -- #30
//│     jump j$0(x$6) -- #29
//│   Right =>
//│     let x$7 = Right.y(a$0) in -- #43
//│     let x$8 = Right(b$0) in -- #42
//│     jump j$0(x$8) -- #41
//│ )
//│ Def(1, j$1, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #18
//│   Left =>
//│     let x$2 = Left.x(x$0) in -- #10
//│     jump j$1(x$2) -- #9
//│   Right =>
//│     let x$3 = Right.y(x$0) in -- #17
//│     jump j$1(x$3) -- #16
//│ )
//│ Def(3, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = Right(2) in -- #56
//│ let* (x$10) = foo(x$9,2) in -- #55
//│ x$10 -- #54
//│ )
//│ },
//│ let* (x$11) = bar() in -- #60
//│ x$11 -- #59)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a$0 of -- #44
//│   Left =>
//│     let x$4 = Left.x(a$0) in -- #32
//│     let x$5 = +(x$4,1) in -- #31
//│     let x$6 = Left(x$5) in -- #30
//│     jump j$0(x$6) -- #29
//│   Right =>
//│     let x$7 = Right.y(a$0) in -- #43
//│     let x$8 = Right(b$0) in -- #42
//│     jump j$0(x$8) -- #41
//│ )
//│ Def(1, j$1, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #18
//│   Left =>
//│     let x$2 = Left.x(x$0) in -- #10
//│     jump j$1(x$2) -- #9
//│   Right =>
//│     let x$3 = Right.y(x$0) in -- #17
//│     jump j$1(x$3) -- #16
//│ )
//│ Def(3, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = Right(2) in -- #56
//│ let* (x$10) = foo(x$9,2) in -- #55
//│ x$10 -- #54
//│ )
//│ },
//│ let* (x$11) = bar() in -- #60
//│ x$11 -- #59)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class True
class False
class Pair(x, y)
fun foo(a) = Pair.x(a) + Pair.y(a)
fun bar() =
  foo(Pair(1, 0))
bar()
//│ |#class| |True|↵|#class| |False|↵|#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|)| |#=| |Pair|.x|(|a|)| |+| |Pair|.y|(|a|)|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |0|)|)|←|↵|bar|(||)|
//│ Parsed: {class True {}; class False {}; class Pair(x, y,) {}; fun foo = (a,) => +((Pair).x(a,),)((Pair).y(a,),); fun bar = () => {foo(Pair(1, 0,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair.x(a$0) in -- #11
//│ let x$1 = Pair.y(a$0) in -- #10
//│ let x$2 = +(x$0,x$1) in -- #9
//│ x$2 -- #8
//│ )
//│ Def(1, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Pair(1,0) in -- #23
//│ let* (x$4) = foo(x$3) in -- #22
//│ x$4 -- #21
//│ )
//│ },
//│ let* (x$5) = bar() in -- #27
//│ x$5 -- #26)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair.x(a$0) in -- #11
//│ let x$1 = Pair.y(a$0) in -- #10
//│ let x$2 = +(x$0,x$1) in -- #9
//│ x$2 -- #8
//│ )
//│ Def(1, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Pair(1,0) in -- #23
//│ let* (x$4) = foo(x$3) in -- #22
//│ x$4 -- #21
//│ )
//│ },
//│ let* (x$5) = bar() in -- #27
//│ x$5 -- #26)
//│ 
//│ Interpreted:
//│ 1


:interpIR
class C1(x, y)
class C2(z)
fun foo(a) = if a is
  C1(x, y) then x
  C2(z) then z
fun bar() =
  foo(C1(0, 1))
bar()
//│ |#class| |C1|(|x|,| |y|)|↵|#class| |C2|(|z|)|↵|#fun| |foo|(|a|)| |#=| |#if| |a| |is|→|C1|(|x|,| |y|)| |#then| |x|↵|C2|(|z|)| |#then| |z|←|↵|#fun| |bar|(||)| |#=|→|foo|(|C1|(|0|,| |1|)|)|←|↵|bar|(||)|
//│ Parsed: {class C1(x, y,) {}; class C2(z,) {}; fun foo = (a,) => if a is ‹(C1(x, y,)) then x; (C2(z,)) then z›; fun bar = () => {foo(C1(0, 1,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a$0 of -- #21
//│   C1 =>
//│     let x$1 = C1.y(a$0) in -- #13
//│     let x$2 = C1.x(a$0) in -- #12
//│     jump j$0(x$2) -- #11
//│   C2 =>
//│     let x$3 = C2.z(a$0) in -- #20
//│     jump j$0(x$3) -- #19
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = C1(0,1) in -- #33
//│ let* (x$5) = foo(x$4) in -- #32
//│ x$5 -- #31
//│ )
//│ },
//│ let* (x$6) = bar() in -- #37
//│ x$6 -- #36)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case a$0 of -- #21
//│   C1 =>
//│     let x$1 = C1.y(a$0) in -- #13
//│     let x$2 = C1.x(a$0) in -- #12
//│     jump j$0(x$2) -- #11
//│   C2 =>
//│     let x$3 = C2.z(a$0) in -- #20
//│     jump j$0(x$3) -- #19
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = C1(0,1) in -- #33
//│ let* (x$5) = foo(x$4) in -- #32
//│ x$5 -- #31
//│ )
//│ },
//│ let* (x$6) = bar() in -- #37
//│ x$6 -- #36)
//│ 
//│ Interpreted:
//│ 0

:interpIR
class Pair(x, y)
fun foo(a, b) =
  let x1 = Pair.x(a)
  let y1 = Pair.y(a)
  let x2 = Pair.x(b)
  let y2 = Pair.y(b)
  x1 + y1 + x2 + y2
fun bar(c) =
  foo(Pair(0, 1), c)
  foo(c, Pair(2, 3))
  foo(Pair(0, 1), Pair(2, 3))
fun baz() =
  bar(Pair(4,5))
baz()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |x1| |#=| |Pair|.x|(|a|)|↵|#let| |y1| |#=| |Pair|.y|(|a|)|↵|#let| |x2| |#=| |Pair|.x|(|b|)|↵|#let| |y2| |#=| |Pair|.y|(|b|)|↵|x1| |+| |y1| |+| |x2| |+| |y2|←|↵|#fun| |bar|(|c|)| |#=|→|foo|(|Pair|(|0|,| |1|)|,| |c|)|↵|foo|(|c|,| |Pair|(|2|,| |3|)|)|↵|foo|(|Pair|(|0|,| |1|)|,| |Pair|(|2|,| |3|)|)|←|↵|#fun| |baz|(||)| |#=|→|bar|(|Pair|(|4|,|5|)|)|←|↵|baz|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (a, b,) => {let x1 = (Pair).x(a,); let y1 = (Pair).y(a,); let x2 = (Pair).x(b,); let y2 = (Pair).y(b,); +(+(+(x1,)(y1,),)(x2,),)(y2,)}; fun bar = (c,) => {foo(Pair(0, 1,), c,); foo(c, Pair(2, 3,),); foo(Pair(0, 1,), Pair(2, 3,),)}; fun baz = () => {bar(Pair(4, 5,),)}; baz()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair.x(a$0) in -- #29
//│ let x$1 = Pair.y(a$0) in -- #28
//│ let x$2 = Pair.x(b$0) in -- #27
//│ let x$3 = Pair.y(b$0) in -- #26
//│ let x$4 = +(x$0,x$1) in -- #25
//│ let x$5 = +(x$4,x$2) in -- #24
//│ let x$6 = +(x$5,x$3) in -- #23
//│ x$6 -- #22
//│ )
//│ Def(1, bar, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = Pair(0,1) in -- #77
//│ let* (x$8) = foo(x$7,c$0) in -- #76
//│ let x$9 = Pair(2,3) in -- #75
//│ let* (x$10) = foo(c$0,x$9) in -- #74
//│ let x$11 = Pair(0,1) in -- #73
//│ let x$12 = Pair(2,3) in -- #72
//│ let* (x$13) = foo(x$11,x$12) in -- #71
//│ x$13 -- #70
//│ )
//│ Def(2, baz, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$14 = Pair(4,5) in -- #89
//│ let* (x$15) = bar(x$14) in -- #88
//│ x$15 -- #87
//│ )
//│ },
//│ let* (x$16) = baz() in -- #93
//│ x$16 -- #92)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair.x(a$0) in -- #29
//│ let x$1 = Pair.y(a$0) in -- #28
//│ let x$2 = Pair.x(b$0) in -- #27
//│ let x$3 = Pair.y(b$0) in -- #26
//│ let x$4 = +(x$0,x$1) in -- #25
//│ let x$5 = +(x$4,x$2) in -- #24
//│ let x$6 = +(x$5,x$3) in -- #23
//│ x$6 -- #22
//│ )
//│ Def(1, bar, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = Pair(0,1) in -- #77
//│ let* (x$8) = foo(x$7,c$0) in -- #76
//│ let x$9 = Pair(2,3) in -- #75
//│ let* (x$10) = foo(c$0,x$9) in -- #74
//│ let x$11 = Pair(0,1) in -- #73
//│ let x$12 = Pair(2,3) in -- #72
//│ let* (x$13) = foo(x$11,x$12) in -- #71
//│ x$13 -- #70
//│ )
//│ Def(2, baz, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$14 = Pair(4,5) in -- #89
//│ let* (x$15) = bar(x$14) in -- #88
//│ x$15 -- #87
//│ )
//│ },
//│ let* (x$16) = baz() in -- #93
//│ x$16 -- #92)
//│ 
//│ Interpreted:
//│ 6

:interpIR
class Pair(x, y)
fun foo() =
  let p = Pair(0, 1)
  let b = Pair.x(p)
  b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|#let| |p| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |Pair|.x|(|p|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = () => {let p = Pair(0, 1,); let b = (Pair).x(p,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair(0,1) in -- #12
//│ let x$1 = Pair.x(x$0) in -- #11
//│ x$1 -- #10
//│ )
//│ },
//│ let* (x$2) = foo() in -- #16
//│ x$2 -- #15)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Pair(0,1) in -- #12
//│ let x$1 = Pair.x(x$0) in -- #11
//│ x$1 -- #10
//│ )
//│ },
//│ let* (x$2) = foo() in -- #16
//│ x$2 -- #15)
//│ 
//│ Interpreted:
//│ 0

:interpIR
class S(s)
class O
fun foo() =
  bar(S(O))
fun bar(x) =
  baz(x)
fun baz(x) =
  if x is
    S(s) then s
    O then x
foo()
//│ |#class| |S|(|s|)|↵|#class| |O|↵|#fun| |foo|(||)| |#=|→|bar|(|S|(|O|)|)|←|↵|#fun| |bar|(|x|)| |#=|→|baz|(|x|)|←|↵|#fun| |baz|(|x|)| |#=|→|#if| |x| |is|→|S|(|s|)| |#then| |s|↵|O| |#then| |x|←|←|↵|foo|(||)|
//│ Parsed: {class S(s,) {}; class O {}; fun foo = () => {bar(S(O,),)}; fun bar = (x,) => {baz(x,)}; fun baz = (x,) => {if x is ‹(S(s,)) then s; (O) then x›}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, S, [s]),ClassInfo(1, O, [])}, {
//│ Def(0, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = O() in -- #10
//│ let x$1 = S(x$0) in -- #9
//│ let* (x$2) = bar(x$1) in -- #8
//│ x$2 -- #7
//│ )
//│ Def(1, bar, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$4) = baz(x$3) in -- #16
//│ x$4 -- #15
//│ )
//│ Def(2, baz, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #28
//│   S =>
//│     let x$7 = S.s(x$5) in -- #25
//│     jump j$0(x$7) -- #24
//│   O =>
//│     jump j$0(x$5) -- #27
//│ )
//│ Def(3, j$0, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ },
//│ let* (x$8) = foo() in -- #32
//│ x$8 -- #31)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, S, [s]),ClassInfo(1, O, [])}, {
//│ Def(0, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = O() in -- #10
//│ let x$1 = S(x$0) in -- #9
//│ let* (x$2) = bar(x$1) in -- #8
//│ x$2 -- #7
//│ )
//│ Def(1, bar, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$4) = baz(x$3) in -- #16
//│ x$4 -- #15
//│ )
//│ Def(2, baz, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #28
//│   S =>
//│     let x$7 = S.s(x$5) in -- #25
//│     jump j$0(x$7) -- #24
//│   O =>
//│     jump j$0(x$5) -- #27
//│ )
//│ Def(3, j$0, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ },
//│ let* (x$8) = foo() in -- #32
//│ x$8 -- #31)
//│ 
//│ Interpreted:
//│ O()
