:NewParser
:ParseOnly
:UseIR
:NoTailRec

:interpIR
class Pair(x, y)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |mktup2|(|x|,| |y|)| |#=| |mktup|(|x|,| |y|)|↵|#fun| |mktup|(|x|,| |y|)| |#=| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|mktup2|(|1|,| |2|)|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun mktup2 = (x, y,) => mktup(x, y,); fun mktup = (x, y,) => Pair(x, y,); fun foo = () => {mktup2(1, 2,)}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #29
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #25
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #24
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #28
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #27
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #26
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, mktup2, [x$1,y$0],
//│ 1, 
//│ let* (x$2) = mktup(x$1,y$0) in -- #9
//│ x$2 -- #8
//│ )
//│ Def(1, mktup, [x$3,y$1],
//│ 1, 
//│ let x$4 = Pair(x$3,y$1) in -- #16
//│ x$4 -- #15
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let* (x$5) = mktup2(1,2) in -- #23
//│ x$5 -- #22
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #29
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #25
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #24
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #28
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #27
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #26
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, mktup2, [x$1,y$0],
//│ 1, 
//│ let* (x$2) = mktup(x$1,y$0) in -- #9
//│ x$2 -- #8
//│ )
//│ Def(1, mktup, [x$3,y$1],
//│ 1, 
//│ let x$4 = Pair(x$3,y$1) in -- #16
//│ x$4 -- #15
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let* (x$5) = mktup2(1,2) in -- #23
//│ x$5 -- #22
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ Pair(1,2)

:interpIR
class Pair(x, y)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|pair|)| |#=|→|#if| |pair| |is|→|Pair|(|x|,| |y|)| |#then| |Pair|(|x|,| |y|)|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |2|)|)|←|↵|bar|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (pair,) => {if pair is ‹(Pair(x, y,)) then Pair(x, y,)›}; fun bar = () => {foo(Pair(1, 2,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #38
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #37
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [pair$0],
//│ 1, 
//│ case pair$0 of -- #23
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #22
//│     let x$3 = Pair.x(pair$0) in -- #21
//│     let x$4 = Pair(x$3,x$2) in -- #20
//│     jump j$0(x$4) -- #19
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #4
//│ )
//│ Def(2, bar, [],
//│ 1, 
//│ let x$5 = Pair(1,2) in -- #34
//│ let* (x$6) = foo(x$5) in -- #33
//│ x$6 -- #32
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #38
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #37
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [pair$0],
//│ 1, 
//│ case pair$0 of -- #23
//│   Pair =>
//│     let x$2 = Pair.y(pair$0) in -- #22
//│     let x$3 = Pair.x(pair$0) in -- #21
//│     let x$4 = Pair(x$3,x$2) in -- #20
//│     jump j$0(x$4) -- #19
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #4
//│ )
//│ Def(2, bar, [],
//│ 1, 
//│ let x$5 = Pair(1,2) in -- #34
//│ let* (x$6) = foo(x$5) in -- #33
//│ x$6 -- #32
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ Pair(1,2)



:interpIR
class Pair(x, y) {}
fun silly(pair) =
  let _ = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)| |{||}|↵|#fun| |silly|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#let| |n| |#=| |#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then|→|#if| |pair| |is|→|Pair| |(|x3|,| |x4|)| |#then| |x3| |+| |1|←|←|←|↵|n| |+| |1|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |silly|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun silly = (pair,) => {let _ = 0; let n = if pair is ‹(Pair(x1, x2,)) then {if pair is ‹(Pair(x3, x4,)) then +(x3,)(1,)›}›; +(n,)(1,)}; fun foo = () => {let a = Pair(0, 1,); let b = silly(a,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #59
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #55
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #54
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #58
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #57
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #56
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, silly, [pair$0],
//│ 1, 
//│ let x$1 = 0 in -- #40
//│ case pair$0 of -- #39
//│   Pair =>
//│     let x$4 = Pair.y(pair$0) in -- #38
//│     let x$5 = Pair.x(pair$0) in -- #37
//│     case pair$0 of -- #36
//│       Pair =>
//│         let x$7 = Pair.y(pair$0) in -- #35
//│         let x$8 = Pair.x(pair$0) in -- #34
//│         let x$9 = +(x$8,1) in -- #33
//│         jump j$1(x$9) -- #32
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ let x$3 = +(x$2,1) in -- #9
//│ x$3 -- #8
//│ )
//│ Def(2, j$1, [x$6],
//│ 1, 
//│ jump j$0(x$6) -- #20
//│ )
//│ Def(3, foo, [],
//│ 1, 
//│ let x$10 = Pair(0,1) in -- #53
//│ let* (x$11) = silly(x$10) in -- #52
//│ x$11 -- #51
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #59
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #55
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #54
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #58
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #57
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #56
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, silly, [pair$0],
//│ 1, 
//│ let x$1 = 0 in -- #40
//│ case pair$0 of -- #39
//│   Pair =>
//│     let x$4 = Pair.y(pair$0) in -- #38
//│     let x$5 = Pair.x(pair$0) in -- #37
//│     case pair$0 of -- #36
//│       Pair =>
//│         let x$7 = Pair.y(pair$0) in -- #35
//│         let x$8 = Pair.x(pair$0) in -- #34
//│         let x$9 = +(x$8,1) in -- #33
//│         jump j$1(x$9) -- #32
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ let x$3 = +(x$2,1) in -- #9
//│ x$3 -- #8
//│ )
//│ Def(2, j$1, [x$6],
//│ 1, 
//│ jump j$0(x$6) -- #20
//│ )
//│ Def(3, foo, [],
//│ 1, 
//│ let x$10 = Pair(0,1) in -- #53
//│ let* (x$11) = silly(x$10) in -- #52
//│ x$11 -- #51
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 2




:interpIR
class Pair(x, y)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |c| |#=| |2|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x1| |+| |c|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |inc_fst|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let c = 2; if pair is ‹(Pair(x1, x2,)) then +(x1,)(c,)›}; fun foo = () => {let a = Pair(0, 1,); let b = inc_fst(a,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #41
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #37
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #38
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, inc_fst, [pair$0],
//│ 1, 
//│ let x$1 = 2 in -- #22
//│ case pair$0 of -- #21
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #20
//│     let x$4 = Pair.x(pair$0) in -- #19
//│     let x$5 = +(x$4,x$1) in -- #18
//│     jump j$0(x$5) -- #17
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ x$2 -- #5
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let x$6 = Pair(0,1) in -- #35
//│ let* (x$7) = inc_fst(x$6) in -- #34
//│ x$7 -- #33
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #41
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #37
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #38
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, inc_fst, [pair$0],
//│ 1, 
//│ let x$1 = 2 in -- #22
//│ case pair$0 of -- #21
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #20
//│     let x$4 = Pair.x(pair$0) in -- #19
//│     let x$5 = +(x$4,x$1) in -- #18
//│     jump j$0(x$5) -- #17
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ x$2 -- #5
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let x$6 = Pair(0,1) in -- #35
//│ let* (x$7) = inc_fst(x$6) in -- #34
//│ x$7 -- #33
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class Pair(x, y)
fun inc_fst(pair) =
  let _ = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x2| |+| |1|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |b| |#=| |inc_fst|(|Pair|(|0|,| |1|)|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let _ = 0; if pair is ‹(Pair(x1, x2,)) then +(x2,)(1,)›}; fun foo = () => {let b = inc_fst(Pair(0, 1,),); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #38
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #37
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, inc_fst, [pair$0],
//│ 1, 
//│ let x$1 = 0 in -- #22
//│ case pair$0 of -- #21
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #20
//│     let x$4 = Pair.x(pair$0) in -- #19
//│     let x$5 = +(x$3,1) in -- #18
//│     jump j$0(x$5) -- #17
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ x$2 -- #5
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let x$6 = Pair(0,1) in -- #34
//│ let* (x$7) = inc_fst(x$6) in -- #33
//│ x$7 -- #32
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #38
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #37
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, inc_fst, [pair$0],
//│ 1, 
//│ let x$1 = 0 in -- #22
//│ case pair$0 of -- #21
//│   Pair =>
//│     let x$3 = Pair.y(pair$0) in -- #20
//│     let x$4 = Pair.x(pair$0) in -- #19
//│     let x$5 = +(x$3,1) in -- #18
//│     jump j$0(x$5) -- #17
//│ )
//│ Def(1, j$0, [x$2],
//│ 1, 
//│ x$2 -- #5
//│ )
//│ Def(2, foo, [],
//│ 1, 
//│ let x$6 = Pair(0,1) in -- #34
//│ let* (x$7) = inc_fst(x$6) in -- #33
//│ x$7 -- #32
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class Left(x)
class Right(y)
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ |#class| |Left|(|x|)|↵|#class| |Right|(|y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |t| |#=| |#if| |a| |is|→|Left|(|x|)| |#then| |Left|(|x| |+| |1|)|↵|Right|(|y|)| |#then| |Right|(|b|)|←|↵|#if| |t| |is|→|Left|(|x|)| |#then| |x|↵|Right|(|y|)| |#then| |y|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Right|(|2|)|,| |2|)|←|↵|bar|(||)|
//│ Parsed: {class Left(x,) {}; class Right(y,) {}; fun foo = (a, b,) => {let t = if a is ‹(Left(x,)) then Left(+(x,)(1,),); (Right(y,)) then Right(b,)›; if t is ‹(Left(x,)) then x; (Right(y,)) then y›}; fun bar = () => {foo(Right(2,), 2,)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #64
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #60
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #59
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #63
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #62
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #61
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Left, [x], parents: , methods:
//│ ),
//│ ClassInfo(10, Right, [y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0,b$0],
//│ 1, 
//│ case a$0 of -- #47
//│   Left =>
//│     let x$5 = Left.x(a$0) in -- #35
//│     let x$6 = +(x$5,1) in -- #34
//│     let x$7 = Left(x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│   Right =>
//│     let x$8 = Right.y(a$0) in -- #46
//│     let x$9 = Right(b$0) in -- #45
//│     jump j$0(x$9) -- #44
//│ )
//│ Def(1, j$1, [x$2],
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, j$0, [x$1],
//│ 1, 
//│ case x$1 of -- #21
//│   Left =>
//│     let x$3 = Left.x(x$1) in -- #13
//│     jump j$1(x$3) -- #12
//│   Right =>
//│     let x$4 = Right.y(x$1) in -- #20
//│     jump j$1(x$4) -- #19
//│ )
//│ Def(3, bar, [],
//│ 1, 
//│ let x$10 = Right(2) in -- #58
//│ let* (x$11) = foo(x$10,2) in -- #57
//│ x$11 -- #56
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #64
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #60
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #59
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #63
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #62
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #61
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Left, [x], parents: , methods:
//│ ),
//│ ClassInfo(10, Right, [y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0,b$0],
//│ 1, 
//│ case a$0 of -- #47
//│   Left =>
//│     let x$5 = Left.x(a$0) in -- #35
//│     let x$6 = +(x$5,1) in -- #34
//│     let x$7 = Left(x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│   Right =>
//│     let x$8 = Right.y(a$0) in -- #46
//│     let x$9 = Right(b$0) in -- #45
//│     jump j$0(x$9) -- #44
//│ )
//│ Def(1, j$1, [x$2],
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, j$0, [x$1],
//│ 1, 
//│ case x$1 of -- #21
//│   Left =>
//│     let x$3 = Left.x(x$1) in -- #13
//│     jump j$1(x$3) -- #12
//│   Right =>
//│     let x$4 = Right.y(x$1) in -- #20
//│     jump j$1(x$4) -- #19
//│ )
//│ Def(3, bar, [],
//│ 1, 
//│ let x$10 = Right(2) in -- #58
//│ let* (x$11) = foo(x$10,2) in -- #57
//│ x$11 -- #56
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 2

:interpIR
class True
class False
class Pair(x, y)
fun foo(a) = Pair.x(a) + Pair.y(a)
fun bar() =
  foo(Pair(1, 0))
bar()
//│ |#class| |True|↵|#class| |False|↵|#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|)| |#=| |Pair|.x|(|a|)| |+| |Pair|.y|(|a|)|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |0|)|)|←|↵|bar|(||)|
//│ Parsed: {class True {}; class False {}; class Pair(x, y,) {}; fun foo = (a,) => +((Pair).x(a,),)((Pair).y(a,),); fun bar = () => {foo(Pair(1, 0,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(7, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #31
//│ ),
//│ apply1 -> Def(3, apply1, [x0$0],
//│ 1, 
//│ 0 -- #27
//│ ),
//│ apply0 -> Def(2, apply0, [],
//│ 1, 
//│ 0 -- #26
//│ ),
//│ apply4 -> Def(6, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #30
//│ ),
//│ apply3 -> Def(5, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #29
//│ ),
//│ apply2 -> Def(4, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #28
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, True, [], parents: , methods:
//│ ),
//│ ClassInfo(10, False, [], parents: , methods:
//│ ),
//│ ClassInfo(11, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0],
//│ 1, 
//│ let x$1 = Pair.x(a$0) in -- #14
//│ let x$2 = Pair.y(a$0) in -- #13
//│ let x$3 = +(x$1,x$2) in -- #12
//│ x$3 -- #11
//│ )
//│ Def(1, bar, [],
//│ 1, 
//│ let x$4 = Pair(1,0) in -- #25
//│ let* (x$5) = foo(x$4) in -- #24
//│ x$5 -- #23
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(7, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #31
//│ ),
//│ apply1 -> Def(3, apply1, [x0$0],
//│ 1, 
//│ 0 -- #27
//│ ),
//│ apply0 -> Def(2, apply0, [],
//│ 1, 
//│ 0 -- #26
//│ ),
//│ apply4 -> Def(6, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #30
//│ ),
//│ apply3 -> Def(5, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #29
//│ ),
//│ apply2 -> Def(4, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #28
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, True, [], parents: , methods:
//│ ),
//│ ClassInfo(10, False, [], parents: , methods:
//│ ),
//│ ClassInfo(11, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0],
//│ 1, 
//│ let x$1 = Pair.x(a$0) in -- #14
//│ let x$2 = Pair.y(a$0) in -- #13
//│ let x$3 = +(x$1,x$2) in -- #12
//│ x$3 -- #11
//│ )
//│ Def(1, bar, [],
//│ 1, 
//│ let x$4 = Pair(1,0) in -- #25
//│ let* (x$5) = foo(x$4) in -- #24
//│ x$5 -- #23
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 1


:interpIR
class C1(x, y)
class C2(z)
fun foo(a) = if a is
  C1(x, y) then x
  C2(z) then z
fun bar() =
  foo(C1(0, 1))
bar()
//│ |#class| |C1|(|x|,| |y|)|↵|#class| |C2|(|z|)|↵|#fun| |foo|(|a|)| |#=| |#if| |a| |is|→|C1|(|x|,| |y|)| |#then| |x|↵|C2|(|z|)| |#then| |z|←|↵|#fun| |bar|(||)| |#=|→|foo|(|C1|(|0|,| |1|)|)|←|↵|bar|(||)|
//│ Parsed: {class C1(x, y,) {}; class C2(z,) {}; fun foo = (a,) => if a is ‹(C1(x, y,)) then x; (C2(z,)) then z›; fun bar = () => {foo(C1(0, 1,),)}; bar()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #41
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #37
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #38
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, C1, [x,y], parents: , methods:
//│ ),
//│ ClassInfo(10, C2, [z], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0],
//│ 1, 
//│ case a$0 of -- #24
//│   C1 =>
//│     let x$2 = C1.y(a$0) in -- #16
//│     let x$3 = C1.x(a$0) in -- #15
//│     jump j$0(x$3) -- #14
//│   C2 =>
//│     let x$4 = C2.z(a$0) in -- #23
//│     jump j$0(x$4) -- #22
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #4
//│ )
//│ Def(2, bar, [],
//│ 1, 
//│ let x$5 = C1(0,1) in -- #35
//│ let* (x$6) = foo(x$5) in -- #34
//│ x$6 -- #33
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #41
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #37
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #36
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #40
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #39
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #38
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, C1, [x,y], parents: , methods:
//│ ),
//│ ClassInfo(10, C2, [z], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0],
//│ 1, 
//│ case a$0 of -- #24
//│   C1 =>
//│     let x$2 = C1.y(a$0) in -- #16
//│     let x$3 = C1.x(a$0) in -- #15
//│     jump j$0(x$3) -- #14
//│   C2 =>
//│     let x$4 = C2.z(a$0) in -- #23
//│     jump j$0(x$4) -- #22
//│ )
//│ Def(1, j$0, [x$1],
//│ 1, 
//│ x$1 -- #4
//│ )
//│ Def(2, bar, [],
//│ 1, 
//│ let x$5 = C1(0,1) in -- #35
//│ let* (x$6) = foo(x$5) in -- #34
//│ x$6 -- #33
//│ )
//│ },
//│ let* (x$0) = bar() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 0

:interpIR
class Pair(x, y)
fun foo(a, b) =
  let x1 = Pair.x(a)
  let y1 = Pair.y(a)
  let x2 = Pair.x(b)
  let y2 = Pair.y(b)
  x1 + y1 + x2 + y2
fun bar(c) =
  foo(Pair(0, 1), c)
  foo(c, Pair(2, 3))
  foo(Pair(0, 1), Pair(2, 3))
fun baz() =
  bar(Pair(4,5))
baz()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |x1| |#=| |Pair|.x|(|a|)|↵|#let| |y1| |#=| |Pair|.y|(|a|)|↵|#let| |x2| |#=| |Pair|.x|(|b|)|↵|#let| |y2| |#=| |Pair|.y|(|b|)|↵|x1| |+| |y1| |+| |x2| |+| |y2|←|↵|#fun| |bar|(|c|)| |#=|→|foo|(|Pair|(|0|,| |1|)|,| |c|)|↵|foo|(|c|,| |Pair|(|2|,| |3|)|)|↵|foo|(|Pair|(|0|,| |1|)|,| |Pair|(|2|,| |3|)|)|←|↵|#fun| |baz|(||)| |#=|→|bar|(|Pair|(|4|,|5|)|)|←|↵|baz|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (a, b,) => {let x1 = (Pair).x(a,); let y1 = (Pair).y(a,); let x2 = (Pair).x(b,); let y2 = (Pair).y(b,); +(+(+(x1,)(y1,),)(x2,),)(y2,)}; fun bar = (c,) => {foo(Pair(0, 1,), c,); foo(c, Pair(2, 3,),); foo(Pair(0, 1,), Pair(2, 3,),)}; fun baz = () => {bar(Pair(4, 5,),)}; baz()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #94
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #90
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #89
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #93
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #92
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #91
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0,b$0],
//│ 1, 
//│ let x$1 = Pair.x(a$0) in -- #32
//│ let x$2 = Pair.y(a$0) in -- #31
//│ let x$3 = Pair.x(b$0) in -- #30
//│ let x$4 = Pair.y(b$0) in -- #29
//│ let x$5 = +(x$1,x$2) in -- #28
//│ let x$6 = +(x$5,x$3) in -- #27
//│ let x$7 = +(x$6,x$4) in -- #26
//│ x$7 -- #25
//│ )
//│ Def(1, bar, [c$0],
//│ 1, 
//│ let x$8 = Pair(0,1) in -- #77
//│ let* (x$9) = foo(x$8,c$0) in -- #76
//│ let x$10 = Pair(2,3) in -- #75
//│ let* (x$11) = foo(c$0,x$10) in -- #74
//│ let x$12 = Pair(0,1) in -- #73
//│ let x$13 = Pair(2,3) in -- #72
//│ let* (x$14) = foo(x$12,x$13) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(2, baz, [],
//│ 1, 
//│ let x$15 = Pair(4,5) in -- #88
//│ let* (x$16) = bar(x$15) in -- #87
//│ x$16 -- #86
//│ )
//│ },
//│ let* (x$0) = baz() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(8, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #94
//│ ),
//│ apply1 -> Def(4, apply1, [x0$0],
//│ 1, 
//│ 0 -- #90
//│ ),
//│ apply0 -> Def(3, apply0, [],
//│ 1, 
//│ 0 -- #89
//│ ),
//│ apply4 -> Def(7, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #93
//│ ),
//│ apply3 -> Def(6, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #92
//│ ),
//│ apply2 -> Def(5, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #91
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [a$0,b$0],
//│ 1, 
//│ let x$1 = Pair.x(a$0) in -- #32
//│ let x$2 = Pair.y(a$0) in -- #31
//│ let x$3 = Pair.x(b$0) in -- #30
//│ let x$4 = Pair.y(b$0) in -- #29
//│ let x$5 = +(x$1,x$2) in -- #28
//│ let x$6 = +(x$5,x$3) in -- #27
//│ let x$7 = +(x$6,x$4) in -- #26
//│ x$7 -- #25
//│ )
//│ Def(1, bar, [c$0],
//│ 1, 
//│ let x$8 = Pair(0,1) in -- #77
//│ let* (x$9) = foo(x$8,c$0) in -- #76
//│ let x$10 = Pair(2,3) in -- #75
//│ let* (x$11) = foo(c$0,x$10) in -- #74
//│ let x$12 = Pair(0,1) in -- #73
//│ let x$13 = Pair(2,3) in -- #72
//│ let* (x$14) = foo(x$12,x$13) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(2, baz, [],
//│ 1, 
//│ let x$15 = Pair(4,5) in -- #88
//│ let* (x$16) = bar(x$15) in -- #87
//│ x$16 -- #86
//│ )
//│ },
//│ let* (x$0) = baz() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 6

:interpIR
class Pair(x, y)
fun foo() =
  let p = Pair(0, 1)
  let b = Pair.x(p)
  b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|#let| |p| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |Pair|.x|(|p|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = () => {let p = Pair(0, 1,); let b = (Pair).x(p,); b}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #21
//│ ),
//│ apply1 -> Def(2, apply1, [x0$0],
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply0 -> Def(1, apply0, [],
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply4 -> Def(5, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply3 -> Def(4, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply2 -> Def(3, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #18
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [],
//│ 1, 
//│ let x$1 = Pair(0,1) in -- #15
//│ let x$2 = Pair.x(x$1) in -- #14
//│ x$2 -- #13
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #21
//│ ),
//│ apply1 -> Def(2, apply1, [x0$0],
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply0 -> Def(1, apply0, [],
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply4 -> Def(5, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply3 -> Def(4, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply2 -> Def(3, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #18
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Pair, [x,y], parents: , methods:
//│ )}, {
//│ Def(0, foo, [],
//│ 1, 
//│ let x$1 = Pair(0,1) in -- #15
//│ let x$2 = Pair.x(x$1) in -- #14
//│ x$2 -- #13
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ 0

:interpIR
class S(s)
class O
fun foo() =
  bar(S(O))
fun bar(x) =
  baz(x)
fun baz(x) =
  if x is
    S(s) then s
    O then x
foo()
//│ |#class| |S|(|s|)|↵|#class| |O|↵|#fun| |foo|(||)| |#=|→|bar|(|S|(|O|)|)|←|↵|#fun| |bar|(|x|)| |#=|→|baz|(|x|)|←|↵|#fun| |baz|(|x|)| |#=|→|#if| |x| |is|→|S|(|s|)| |#then| |s|↵|O| |#then| |x|←|←|↵|foo|(||)|
//│ Parsed: {class S(s,) {}; class O {}; fun foo = () => {bar(S(O,),)}; fun bar = (x,) => {baz(x,)}; fun baz = (x,) => {if x is ‹(S(s,)) then s; (O) then x›}; foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #31
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #30
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #34
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #33
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #32
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, S, [s], parents: , methods:
//│ ),
//│ ClassInfo(10, O, [], parents: , methods:
//│ )}, {
//│ Def(0, foo, [],
//│ 1, 
//│ let x$1 = O() in -- #12
//│ let x$2 = S(x$1) in -- #11
//│ let* (x$3) = bar(x$2) in -- #10
//│ x$3 -- #9
//│ )
//│ Def(1, bar, [x$4],
//│ 1, 
//│ let* (x$5) = baz(x$4) in -- #17
//│ x$5 -- #16
//│ )
//│ Def(2, baz, [x$6],
//│ 1, 
//│ case x$6 of -- #29
//│   S =>
//│     let x$8 = S.s(x$6) in -- #26
//│     jump j$0(x$8) -- #25
//│   O =>
//│     jump j$0(x$6) -- #28
//│ )
//│ Def(3, j$0, [x$7],
//│ 1, 
//│ x$7 -- #19
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(9, apply5, [x0$4,x1$3,x2$2,x3$1,x4$0],
//│ 1, 
//│ 0 -- #35
//│ ),
//│ apply1 -> Def(5, apply1, [x0$0],
//│ 1, 
//│ 0 -- #31
//│ ),
//│ apply0 -> Def(4, apply0, [],
//│ 1, 
//│ 0 -- #30
//│ ),
//│ apply4 -> Def(8, apply4, [x0$3,x1$2,x2$1,x3$0],
//│ 1, 
//│ 0 -- #34
//│ ),
//│ apply3 -> Def(7, apply3, [x0$2,x1$1,x2$0],
//│ 1, 
//│ 0 -- #33
//│ ),
//│ apply2 -> Def(6, apply2, [x0$1,x1$0],
//│ 1, 
//│ 0 -- #32
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, S, [s], parents: , methods:
//│ ),
//│ ClassInfo(10, O, [], parents: , methods:
//│ )}, {
//│ Def(0, foo, [],
//│ 1, 
//│ let x$1 = O() in -- #12
//│ let x$2 = S(x$1) in -- #11
//│ let* (x$3) = bar(x$2) in -- #10
//│ x$3 -- #9
//│ )
//│ Def(1, bar, [x$4],
//│ 1, 
//│ let* (x$5) = baz(x$4) in -- #17
//│ x$5 -- #16
//│ )
//│ Def(2, baz, [x$6],
//│ 1, 
//│ case x$6 of -- #29
//│   S =>
//│     let x$8 = S.s(x$6) in -- #26
//│     jump j$0(x$8) -- #25
//│   O =>
//│     jump j$0(x$6) -- #28
//│ )
//│ Def(3, j$0, [x$7],
//│ 1, 
//│ x$7 -- #19
//│ )
//│ },
//│ let* (x$0) = foo() in -- #2
//│ x$0 -- #1)
//│ 
//│ Interpreted:
//│ O()
