:NewParser
:ParseOnly
:UseIR

:interpIR
:genCpp
module Demo {
  fun x() = 1
}
fun main() =
  let d1 = Demo()
  Demo.x(d1)
main()
//│ |#module| |Demo| |{|→|#fun| |x|(||)| |#=| |1|←|↵|}|↵|#fun| |main|(||)| |#=|→|#let| |d1| |#=| |Demo|(||)|↵|Demo|.x|(|d1|)|←|↵|main|(||)|
//│ Parsed: {module Demo {fun x = () => 1}; fun main = () => {let d1 = Demo(); (Demo).x(d1,)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Demo, [], parents: , methods:
//│ x -> Def(0, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #0
//│ ))}, {
//│ Def(1, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Demo() in -- #8
//│ let x$1 = Demo.x(x$0) in -- #7
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$2) = main() in -- #11
//│ x$2 -- #10)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Demo, [], parents: , methods:
//│ x -> Def(0, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 1 -- #0
//│ ))}, {
//│ Def(1, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = Demo() in -- #8
//│ let x$1 = Demo.x(x$0) in -- #7
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$2) = main() in -- #11
//│ x$2 -- #10)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Demo;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_main();
//│ _mlsValue _mlsMain();
//│ struct _mls_Demo: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Demo";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Demo; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ _mlsValue _mls_x(){
//│     _mlsValue _mls_retval;
//│     _mls_retval = _mlsValue::fromIntLit(1);
//│     return _mls_retval;
//│   }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::create<_mls_Demo>();
//│   auto _mls_x_1 = _mlsMethodCall<_mls_Demo>(_mls_x_0)->_mls_x();
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_main();
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
