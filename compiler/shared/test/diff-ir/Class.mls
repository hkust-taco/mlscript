:NewParser
:ParseOnly
:UseIR

:genCpp
:runCpp
module Fn extends Callable {
  fun apply1(x) = builtin("println", x)
}
class Fn2(a) extends Callable {
  fun apply1(x) =
    builtin("println", a)
    builtin("println", x)
}
class Demo(n) {
  fun x() = n
}
fun f(fn) = fn(1)
fun main() =
  let d1 = Demo(2)
  Demo.x(d1)
  let print = Fn()
  Fn.apply1(print, 3)
  f(print)
  let print2 = Fn2(4)
  Fn2.apply1(print2, 5)
  print2(6)
  f(print2)
main()
//│ |#module| |Fn| |#extends| |Callable| |{|→|#fun| |apply1|(|x|)| |#=| |builtin|(|"println"|,| |x|)|←|↵|}|↵|#class| |Fn2|(|a|)| |#extends| |Callable| |{|→|#fun| |apply1|(|x|)| |#=|→|builtin|(|"println"|,| |a|)|↵|builtin|(|"println"|,| |x|)|←|←|↵|}|↵|#class| |Demo|(|n|)| |{|→|#fun| |x|(||)| |#=| |n|←|↵|}|↵|#fun| |f|(|fn|)| |#=| |fn|(|1|)|↵|#fun| |main|(||)| |#=|→|#let| |d1| |#=| |Demo|(|2|)|↵|Demo|.x|(|d1|)|↵|#let| |print| |#=| |Fn|(||)|↵|Fn|.apply1|(|print|,| |3|)|↵|f|(|print|)|↵|#let| |print2| |#=| |Fn2|(|4|)|↵|Fn2|.apply1|(|print2|,| |5|)|↵|print2|(|6|)|↵|f|(|print2|)|←|↵|main|(||)|
//│ Parsed: {module Fn: Callable {fun apply1 = (x,) => builtin("println", x,)}; class Fn2(a,): Callable {fun apply1 = (x,) => {builtin("println", a,); builtin("println", x,)}}; class Demo(n,) {fun x = () => n}; fun f = (fn,) => fn(1,); fun main = () => {let d1 = Demo(2,); (Demo).x(d1,); let print = Fn(); (Fn).apply1(print, 3,); f(print,); let print2 = Fn2(4,); (Fn2).apply1(print2, 5,); print2(6,); f(print2,)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Fn, [], parents: Callable, methods:
//│ apply1 -> Def(0, apply1, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$1) = builtin(println,x$0) in -- #7
//│ x$1 -- #6
//│ )),
//│ ClassInfo(10, Fn2, [a], parents: Callable, methods:
//│ apply1 -> Def(1, apply1, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$3) = builtin(println,a) in -- #23
//│ let** (x$4) = builtin(println,x$2) in -- #22
//│ x$4 -- #21
//│ )),
//│ ClassInfo(11, Demo, [n], parents: , methods:
//│ x -> Def(2, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ n -- #24
//│ ))}, {
//│ Def(3, f, [fn$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$5) = fn$0(1) in -- #30
//│ x$5 -- #29
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$6 = Demo(2) in -- #78
//│ let x$7 = Demo.x(x$6) in -- #77
//│ let x$8 = Fn() in -- #76
//│ let x$9 = Fn.apply1(x$8,3) in -- #75
//│ let* (x$10) = f(x$8) in -- #74
//│ let x$11 = Fn2(4) in -- #73
//│ let x$12 = Fn2.apply1(x$11,5) in -- #72
//│ let** (x$13) = x$11(6) in -- #71
//│ let* (x$14) = f(x$11) in -- #70
//│ x$14 -- #69
//│ )
//│ },
//│ let* (x$15) = main() in -- #81
//│ x$15 -- #80)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Fn, [], parents: Callable, methods:
//│ apply1 -> Def(0, apply1, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$1) = builtin(println,x$0) in -- #7
//│ x$1 -- #6
//│ )),
//│ ClassInfo(10, Fn2, [a], parents: Callable, methods:
//│ apply1 -> Def(1, apply1, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$3) = builtin(println,a) in -- #23
//│ let** (x$4) = builtin(println,x$2) in -- #22
//│ x$4 -- #21
//│ )),
//│ ClassInfo(11, Demo, [n], parents: , methods:
//│ x -> Def(2, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ n -- #24
//│ ))}, {
//│ Def(3, f, [fn$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$5) = fn$0(1) in -- #30
//│ x$5 -- #29
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$6 = Demo(2) in -- #78
//│ let x$7 = Demo.x(x$6) in -- #77
//│ let x$8 = Fn() in -- #76
//│ let x$9 = Fn.apply1(x$8,3) in -- #75
//│ let* (x$10) = f(x$8) in -- #74
//│ let x$11 = Fn2(4) in -- #73
//│ let x$12 = Fn2.apply1(x$11,5) in -- #72
//│ let** (x$13) = x$11(6) in -- #71
//│ let* (x$14) = f(x$11) in -- #70
//│ x$14 -- #69
//│ )
//│ },
//│ let* (x$15) = main() in -- #81
//│ x$15 -- #80)
//│ 
//│ 
//│ Execution succeeded: 
//│ 3
//│ 1
//│ 4
//│ 5
//│ 4
//│ 6
//│ 4
//│ 1
//│ Unit
