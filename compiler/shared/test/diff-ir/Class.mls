:NewParser
:ParseOnly
:UseIR

:genCpp
:runCpp
module Fn extends Callable {
  fun apply1(x) = builtin("println", x)
}
class Fn2(a) extends Callable {
  fun apply1(x) =
    builtin("println", a)
    builtin("println", x)
}
class Demo(n) {
  fun x() = n
}
fun f(fn) = fn(1)
fun main() =
  let d1 = Demo(2)
  Demo.x(d1)
  let print = Fn()
  Fn.apply1(print, 3)
  f(print)
  let print2 = Fn2(4)
  Fn2.apply1(print2, 5)
  print2(6)
  f(print2)
main()
//│ |#module| |Fn| |#extends| |Callable| |{|→|#fun| |apply1|(|x|)| |#=| |builtin|(|"println"|,| |x|)|←|↵|}|↵|#class| |Fn2|(|a|)| |#extends| |Callable| |{|→|#fun| |apply1|(|x|)| |#=|→|builtin|(|"println"|,| |a|)|↵|builtin|(|"println"|,| |x|)|←|←|↵|}|↵|#class| |Demo|(|n|)| |{|→|#fun| |x|(||)| |#=| |n|←|↵|}|↵|#fun| |f|(|fn|)| |#=| |fn|(|1|)|↵|#fun| |main|(||)| |#=|→|#let| |d1| |#=| |Demo|(|2|)|↵|Demo|.x|(|d1|)|↵|#let| |print| |#=| |Fn|(||)|↵|Fn|.apply1|(|print|,| |3|)|↵|f|(|print|)|↵|#let| |print2| |#=| |Fn2|(|4|)|↵|Fn2|.apply1|(|print2|,| |5|)|↵|print2|(|6|)|↵|f|(|print2|)|←|↵|main|(||)|
//│ Parsed: {module Fn: Callable {fun apply1 = (x,) => builtin("println", x,)}; class Fn2(a,): Callable {fun apply1 = (x,) => {builtin("println", a,); builtin("println", x,)}}; class Demo(n,) {fun x = () => n}; fun f = (fn,) => fn(1,); fun main = () => {let d1 = Demo(2,); (Demo).x(d1,); let print = Fn(); (Fn).apply1(print, 3,); f(print,); let print2 = Fn2(4,); (Fn2).apply1(print2, 5,); print2(6,); f(print2,)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Fn, [], parents: Callable, methods:
//│ apply1 -> Def(2, apply1, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$12) = builtin(println,x$11) in -- #64
//│ x$12 -- #63
//│ )),
//│ ClassInfo(10, Fn2, [a], parents: Callable, methods:
//│ apply1 -> Def(3, apply1, [x$13], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$14) = builtin(println,a) in -- #80
//│ let** (x$15) = builtin(println,x$13) in -- #79
//│ x$15 -- #78
//│ )),
//│ ClassInfo(11, Demo, [n], parents: , methods:
//│ x -> Def(4, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ n -- #81
//│ ))}, {
//│ Def(0, f, [fn$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$1) = fn$0(1) in -- #8
//│ x$1 -- #7
//│ )
//│ Def(1, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Demo(2) in -- #56
//│ let x$3 = Demo.x(x$2) in -- #55
//│ let x$4 = Fn() in -- #54
//│ let x$5 = Fn.apply1(x$4,3) in -- #53
//│ let* (x$6) = f(x$4) in -- #52
//│ let x$7 = Fn2(4) in -- #51
//│ let x$8 = Fn2.apply1(x$7,5) in -- #50
//│ let** (x$9) = x$7(6) in -- #49
//│ let* (x$10) = f(x$7) in -- #48
//│ x$10 -- #47
//│ )
//│ },
//│ let* (x$0) = main() in -- #2
//│ x$0 -- #1)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Fn, [], parents: Callable, methods:
//│ apply1 -> Def(2, apply1, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$12) = builtin(println,x$11) in -- #64
//│ x$12 -- #63
//│ )),
//│ ClassInfo(10, Fn2, [a], parents: Callable, methods:
//│ apply1 -> Def(3, apply1, [x$13], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$14) = builtin(println,a) in -- #80
//│ let** (x$15) = builtin(println,x$13) in -- #79
//│ x$15 -- #78
//│ )),
//│ ClassInfo(11, Demo, [n], parents: , methods:
//│ x -> Def(4, x, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ n -- #81
//│ ))}, {
//│ Def(0, f, [fn$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$1) = fn$0(1) in -- #8
//│ x$1 -- #7
//│ )
//│ Def(1, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Demo(2) in -- #56
//│ let x$3 = Demo.x(x$2) in -- #55
//│ let x$4 = Fn() in -- #54
//│ let x$5 = Fn.apply1(x$4,3) in -- #53
//│ let* (x$6) = f(x$4) in -- #52
//│ let x$7 = Fn2(4) in -- #51
//│ let x$8 = Fn2.apply1(x$7,5) in -- #50
//│ let** (x$9) = x$7(6) in -- #49
//│ let* (x$10) = f(x$7) in -- #48
//│ x$10 -- #47
//│ )
//│ },
//│ let* (x$0) = main() in -- #2
//│ x$0 -- #1)
//│ 
//│ 
//│ Execution succeeded: 
//│ 3
//│ 1
//│ 4
//│ 5
//│ 4
//│ 6
//│ 4
//│ 1
//│ Unit
