:NewParser
:ParseOnly
:UseIR

:interpIR
:genCpp
module List
class Cons(h, t) extends List
module Nil extends List
module Option
class Some(x) extends Option
module None extends Option
class Box(inner)
fun map(f, xs) =
  if xs is
    Nil then Nil
    Cons(h, t) then Cons(Box.inner(f)(h), map(f, t))
fun inc(x) = x + 1
fun testMap() =
  let xs = Cons(1, Cons(2, Nil))
  let ys = map(Box(inc), xs)
  ys
testMap()
//│ |#module| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#module| |Nil| |#extends| |List|↵|#module| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#module| |None| |#extends| |Option|↵|#class| |Box|(|inner|)|↵|#fun| |map|(|f|,| |xs|)| |#=|→|#if| |xs| |is|→|Nil| |#then| |Nil|↵|Cons|(|h|,| |t|)| |#then| |Cons|(|Box|.inner|(|f|)|(|h|)|,| |map|(|f|,| |t|)|)|←|←|↵|#fun| |inc|(|x|)| |#=| |x| |+| |1|↵|#fun| |testMap|(||)| |#=|→|#let| |xs| |#=| |Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|↵|#let| |ys| |#=| |map|(|Box|(|inc|)|,| |xs|)|↵|ys|←|↵|testMap|(||)|
//│ Parsed: {module List {}; class Cons(h, t,): List {}; module Nil: List {}; module Option {}; class Some(x,): Option {}; module None: Option {}; class Box(inner,) {}; fun map = (f, xs,) => {if xs is ‹(Nil) then Nil; (Cons(h, t,)) then Cons((Box).inner(f,)(h,), map(f, t,),)›}; fun inc = (x,) => +(x,)(1,); fun testMap = () => {let xs = Cons(1, Cons(2, Nil,),); let ys = map(Box(inc,), xs,); ys}; testMap()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, List, []),ClassInfo(1, Cons, [h,t]),ClassInfo(2, Nil, []),ClassInfo(3, Option, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, []),ClassInfo(6, Box, [inner])}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #39
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #38
//│     let x$3 = Cons.h(xs$0) in -- #37
//│     let x$4 = Box.inner(f$0) in -- #36
//│     let List(x$5) = x$4(x$3) in -- #35
//│     let* (x$6) = map(f$0,x$2) in -- #34
//│     let x$7 = Cons(x$5,x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #43
//│ x$9 -- #42
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #70
//│ let x$11 = Cons(2,x$10) in -- #69
//│ let x$12 = Cons(1,x$11) in -- #68
//│ let x$13 = Box(inc) in -- #67
//│ let* (x$14) = map(x$13,x$12) in -- #66
//│ x$14 -- #65
//│ )
//│ },
//│ let* (x$15) = testMap() in -- #74
//│ x$15 -- #73)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, List, []),ClassInfo(1, Cons, [h,t]),ClassInfo(2, Nil, []),ClassInfo(3, Option, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, []),ClassInfo(6, Box, [inner])}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #39
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #38
//│     let x$3 = Cons.h(xs$0) in -- #37
//│     let x$4 = Box.inner(f$0) in -- #36
//│     let List(x$5) = x$4(x$3) in -- #35
//│     let* (x$6) = map(f$0,x$2) in -- #34
//│     let x$7 = Cons(x$5,x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #43
//│ x$9 -- #42
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #70
//│ let x$11 = Cons(2,x$10) in -- #69
//│ let x$12 = Cons(1,x$11) in -- #68
//│ let x$13 = Box(inc) in -- #67
//│ let* (x$14) = map(x$13,x$12) in -- #66
//│ x$14 -- #65
//│ )
//│ },
//│ let* (x$15) = testMap() in -- #74
//│ x$15 -- #73)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Nil()))
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ struct _mls_Option;
//│ struct _mls_List;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_map;
//│ struct _mls_inc;
//│ struct _mls_testMap;
//│ struct _mls_j_0;
//│ _mlsValue _mls_map(_mlsValue, _mlsValue);
//│ _mlsValue _mls_inc(_mlsValue);
//│ _mlsValue _mls_testMap();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = 6;
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = 6; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = 3;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = 3;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = 0;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = 0;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = 4;
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = 4; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = 5;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = 5;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = 2;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = 2;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = 1;
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = 1; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_map: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<map>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_map mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_map(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_inc: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<inc>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_inc mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_inc(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_testMap: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testMap>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testMap mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_testMap();
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_map(_mlsValue _mls_f_0, _mlsValue _mls_xs_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_0)){
//│     auto _mls_x_2 = _mlsValue::as<_mls_Cons>(_mls_xs_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::as<_mls_Cons>(_mls_xs_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::as<_mls_Box>(_mls_f_0)->_mls_inner;
//│     auto _mls_x_5 = _mlsCall(_mls_x_4, _mls_x_3);
//│     auto _mls_x_6 = _mls_map(_mls_f_0, _mls_x_2);
//│     auto _mls_x_7 = _mlsValue::create<_mls_Cons>(_mls_x_5, _mls_x_6);
//│     _mls_retval = _mls_j_0(_mls_x_7);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_inc(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_testMap(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_11 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_10);
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_11);
//│   auto _mls_x_13 = _mlsValue::create<_mls_Box>(_mlsValue::create<_mlsFn__mls_inc>());
//│   auto _mls_x_14 = _mls_map(_mls_x_13, _mls_x_12);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_testMap();
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }


:interpIR
:genCpp
module C
fun testChar(x) =
  if x is
    char"a" then 1
    char"b" then 2
testChar(char"a")
//│ |#module| |C|↵|#fun| |testChar|(|x|)| |#=|→|#if| |x| |is|→|char"a"| |#then| |1|↵|char"b"| |#then| |2|←|←|↵|testChar|(|char"a"|)|
//│ Parsed: {module C {}; fun testChar = (x,) => {if x is ‹(char"a") then 1; (char"b") then 2›}; testChar(char"a",)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #12
//│ x$2 -- #11)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #12
//│ x$2 -- #11)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ struct _mls_testChar;
//│ struct _mls_j_0;
//│ _mlsValue _mls_testChar(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = 0;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = 0;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_testChar: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testChar>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testChar mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_testChar(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_testChar(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 97)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 98)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testChar(_mlsValue::fromIntLit(97));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }

:interpIR
:genCpp
module C
fun testMatch(x) =
  if x is
    0 then 1
    1 then 2
    C then 3
testMatch(0)
//│ |#module| |C|↵|#fun| |testMatch|(|x|)| |#=|→|#if| |x| |is|→|0| |#then| |1|↵|1| |#then| |2|↵|C| |#then| |3|←|←|↵|testMatch|(|0|)|
//│ Parsed: {module C {}; fun testMatch = (x,) => {if x is ‹(0) then 1; (1) then 2; (C) then 3›}; testMatch(0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #14
//│ x$2 -- #13)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #14
//│ x$2 -- #13)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ struct _mls_testMatch;
//│ struct _mls_j_0;
//│ _mlsValue _mls_testMatch(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = 0;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = 0;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_testMatch: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testMatch>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testMatch mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_testMatch(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_testMatch(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 1)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else if (_mlsValue::isValueOf<_mls_C>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(3));
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testMatch(_mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }

:interpIR
:genCpp
class Box(inner) 
fun unbox(x) = Box.inner(x)
fun f() =
  let a = Box(1)
  let b = unbox(a) + 1
  b
f()
//│ |#class| |Box|(|inner|)| |↵|#fun| |unbox|(|x|)| |#=| |Box|.inner|(|x|)|↵|#fun| |f|(||)| |#=|→|#let| |a| |#=| |Box|(|1|)|↵|#let| |b| |#=| |unbox|(|a|)| |+| |1|↵|b|←|↵|f|(||)|
//│ Parsed: {class Box(inner,) {}; fun unbox = (x,) => (Box).inner(x,); fun f = () => {let a = Box(1,); let b = +(unbox(a,),)(1,); b}; f()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Box, [inner])}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #19
//│ let* (x$3) = unbox(x$2) in -- #18
//│ let x$4 = +(x$3,1) in -- #17
//│ x$4 -- #16
//│ )
//│ },
//│ let* (x$5) = f() in -- #23
//│ x$5 -- #22)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Box, [inner])}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #19
//│ let* (x$3) = unbox(x$2) in -- #18
//│ let x$4 = +(x$3,1) in -- #17
//│ x$4 -- #16
//│ )
//│ },
//│ let* (x$5) = f() in -- #23
//│ x$5 -- #22)
//│ 
//│ Interpreted:
//│ 2
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ struct _mls_unbox;
//│ struct _mls_f;
//│ _mlsValue _mls_unbox(_mlsValue);
//│ _mlsValue _mls_f();
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = 0;
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = 0; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_unbox: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<unbox>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_unbox mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_unbox(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_f();
//│   }
//│ };
//│ _mlsValue _mls_unbox(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = _mlsValue::as<_mls_Box>(_mls_x_0)->_mls_inner;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mlsValue::create<_mls_Box>(_mlsValue::fromIntLit(1));
//│   auto _mls_x_3 = _mls_unbox(_mls_x_2);
//│   auto _mls_x_4 = (_mls_x_3+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_5 = _mls_f();
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }
