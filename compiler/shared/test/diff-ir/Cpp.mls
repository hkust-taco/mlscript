:NewParser
:ParseOnly
:UseIR

:interpIR
:genCpp
module True
module False
module List
class Cons(h, t) extends List
module Nil extends List
module Option
class Some(x) extends Option
module None extends Option
class Pair2(x, y)
class Pair3(x, y, z)
fun error() =
  builtin("error")
fun z_of_int(x) =
  builtin("z_of_int", x)
fun z_to_int(x) =
  builtin("z_to_int", x)
fun z_add(x, y) =
  builtin("z_add", x, y)
fun z_sub(x, y) =
  builtin("z_sub", x, y)
fun z_div(x, y) =
  builtin("z_div", x, y)
fun z_mul(x, y) =
  builtin("z_mul", x, y)
fun z_mod(x, y) =
  builtin("z_mod", x, y)
fun z_lt(x, y) =
  builtin("z_lt", x, y)
fun z_leq(x, y) =
  builtin("z_leq", x, y)
fun z_equal(x, y) =
  builtin("z_equal", x, y)
fun z_gt(x, y) =
  builtin("z_gt", x, y)
fun z_geq(x, y) =
  builtin("z_geq", x, y)
fun map(f,ls) =
  if ls is
    Cons (h, t) then
      Cons (f(h), map(f,t))
    Nil then
      Nil
fun filter(f, ls) =
  if ls is
    Cons (h, t) then
      if f(h) then
        Cons (h, filter(f, t))
      else
        (filter(f, t))
    Nil then
      Nil
fun foldl(f, i, ls) =
  if ls is
    Cons (h, t) then
      foldl(f, f(i, h), t)
    Nil then
      i
fun foldr(f, i, ls) =
  if ls is
    Cons (h, t) then
      f(h, foldr(f, i, t))
    Nil then
      i
fun zip(xs, ys) =
  if xs is
    Cons (hx, tx) then
      if ys is
        Cons (hy, ty) then
          Cons (Pair2 (hx, hy), zip(tx, ty))
        Nil then
          Nil
    Nil then
      Nil
fun zipWith(f, xs, ys) =
  if xs is
    Cons (hx, tx) then
      if ys is
        Cons (hy, ty) then
          Cons (f(hx, hy), zipWith(f, tx, ty))
        Nil then
          Nil
    Nil then
      Nil
fun head(ls) =
  if ls is
    Cons (h, t) then
      h
    Nil then
      error()
fun tail(ls) =
  if ls is
    Cons (h, t) then
      t
    Nil then
      error()
fun enumFromTo(a, b) =
  if a <= b then
    Cons (a, enumFromTo(a + 1, b))
  else
    (Nil)
fun enumFromThenTo(a, t, b) =
  if a <= b then
    Cons (a, enumFromThenTo(t, 2 * t - a, b))
  else
    (Nil)
fun take(n, ls) =
  if n > 0 then
    if ls is
      Cons (h, t) then
        Cons (h, take(n - 1, t))
      Nil then
        Nil
  else
    (Nil)
fun length(ls) =
  if ls is
    Cons (h, t) then
      1 + (length(t))
    Nil then
      0
fun mappend(xs, ys) =
  if xs is
    Cons (h, t) then
      Cons (h, mappend(t, ys))
    Nil then
      ys
fun sum(ls) =
  sumAux(ls, 0)
fun sumAux(ls, a) =
  if ls is
    Nil then
      a
    Cons (h, t) then
      sumAux(t, a + h)
fun atIndex(n, ls) =
  if n < 0 then
    error()
  else
    if ls is
      Cons (h, t) then
        if n == 0 then
          h
        else
          (atIndex(n - 1, t))
      Nil then
        error()
fun concat(lss) =
  if lss is
    Cons (h, t) then
      mappend(h, concat(t))
    Nil then
      Nil
fun reverse(ls) =
  reverse_helper(ls, Nil)
fun reverse_helper(ls, a) =
  if ls is
    Cons (h, t) then
      reverse_helper(t, Cons (h, a))
    Nil then
      a
fun const10000() =
  z_of_int(10000)
fun f1(f1_arg1) =
  if f1_arg1 is
    Pair2 (f1_Pair2_0, f1_Pair2_1) then
      Pair3 (f1_Pair2_0, f1_Pair2_1, gcdE(f1_Pair2_0, f1_Pair2_1))
fun quotRem(quotRem_arg1, quotRem_arg2) =
  Pair2 (z_div(quotRem_arg1, quotRem_arg2), z_mod(quotRem_arg1, quotRem_arg2))
fun max'(max'_arg1) =
  if max'_arg1 is
    Cons (max'_Cons_0, max'_Cons_1) then
      if max'_Cons_1 is
        Nil then
          max'_Cons_0
        Cons (max'_Cons_0, max'_Cons_1) then
          if z_lt(max'_Cons_0, max'_Cons_0) then
            max'(Cons (max'_Cons_0, max'_Cons_1))
          else
            (max'(Cons (max'_Cons_0, max'_Cons_1)))
fun g(g_arg1, g_arg2) =
  if g_arg1 is
    Pair3 (g_Pair3_0, g_Pair3_1, g_Pair3_2) then
      if g_arg2 is
        Pair3 (g_Pair3_0, g_Pair3_1, g_Pair3_2) then
          if z_equal(g_Pair3_2, const0()) then
            Pair3 (g_Pair3_2, g_Pair3_0, g_Pair3_1)
          else
            let matchIdent = quotRem(g_Pair3_2, g_Pair3_2)
            if matchIdent is
              Pair2 (g_Pair2_0, g_Pair2_1) then
                g(Pair3 (g_Pair3_0, g_Pair3_1, g_Pair3_2), Pair3 (z_sub(g_Pair3_0, z_mul(g_Pair2_0, g_Pair3_0)), z_sub(g_Pair3_1, z_mul(g_Pair2_0, g_Pair3_1)), g_Pair2_1))
fun abs(abs_arg1) =
  if z_lt(abs_arg1, const0()) then
    z_sub(const0(), abs_arg1)
  else
    abs_arg1
fun f2(f2_arg1) =
  if f2_arg1 is
    Pair3 (f2_Pair3_0, f2_Pair3_1, f2_Pair3_2) then
      if f2_Pair3_2 is
        Pair3 (f2_Pair3_0, f2_Pair3_1, f2_Pair3_2) then
          abs(z_add(z_add(f2_Pair3_0, f2_Pair3_1), f2_Pair3_2))
fun const0() =
  z_of_int(0)
fun gcdE(gcdE_arg1, gcdE_arg2) =
  if z_equal(gcdE_arg1, const0()) then
    Pair3 (gcdE_arg2, const0(), const1())
  else
    (g(Pair3 (const1(), const0(), gcdE_arg1), Pair3 (const0(), const1(), gcdE_arg2)))
fun const1() =
  z_of_int(1)
fun const5000() =
  z_of_int(5000)
fun z_enumFromTo(z_enumFromTo_arg1, z_enumFromTo_arg2) =
  if z_leq(z_enumFromTo_arg1, z_enumFromTo_arg2) then
    Cons (z_enumFromTo_arg1, z_enumFromTo(z_add(z_enumFromTo_arg1, const1()), z_enumFromTo_arg2))
  else
    (Nil)
// fun testGcd_nofib(testGcd_nofib_arg1) =
//   test(testGcd_nofib_arg1)
// fun test(test_arg1) =
//   let ns = z_enumFromTo(const5000(), z_add(const5000(), test_arg1))
//   let ms = z_enumFromTo(const10000()(), z_add(const10000()() + test_arg1))
//   let tripls = map(f1, let listcomp_fun = listcomp_fun_para =>
//     if listcomp_fun_para is
//       Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then
//         let listcomp_fun = listcomp_fun_para =>
//           if listcomp_fun_para is
//             Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then
//               Cons (Pair2 (listcomp_fun_ls_h, listcomp_fun_ls_h), listcomp_fun(listcomp_fun_ls_t))
//             Nil then
//               listcomp_fun(listcomp_fun_ls_t)
//         listcomp_fun(ms)
//       Nil then
//         Nil
//   listcomp_fun(ns))
//   let rs = map(f2, tripls)
//   max'(rs)
fun main() =
  0
  //testGcd_nofib(primId(z_of_int(400)))
main()
//│ |#module| |True|↵|#module| |False|↵|#module| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#module| |Nil| |#extends| |List|↵|#module| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#module| |None| |#extends| |Option|↵|#class| |Pair2|(|x|,| |y|)|↵|#class| |Pair3|(|x|,| |y|,| |z|)|↵|#fun| |error|(||)| |#=|→|builtin|(|"error"|)|←|↵|#fun| |z_of_int|(|x|)| |#=|→|builtin|(|"z_of_int"|,| |x|)|←|↵|#fun| |z_to_int|(|x|)| |#=|→|builtin|(|"z_to_int"|,| |x|)|←|↵|#fun| |z_add|(|x|,| |y|)| |#=|→|builtin|(|"z_add"|,| |x|,| |y|)|←|↵|#fun| |z_sub|(|x|,| |y|)| |#=|→|builtin|(|"z_sub"|,| |x|,| |y|)|←|↵|#fun| |z_div|(|x|,| |y|)| |#=|→|builtin|(|"z_div"|,| |x|,| |y|)|←|↵|#fun| |z_mul|(|x|,| |y|)| |#=|→|builtin|(|"z_mul"|,| |x|,| |y|)|←|↵|#fun| |z_mod|(|x|,| |y|)| |#=|→|builtin|(|"z_mod"|,| |x|,| |y|)|←|↵|#fun| |z_lt|(|x|,| |y|)| |#=|→|builtin|(|"z_lt"|,| |x|,| |y|)|←|↵|#fun| |z_leq|(|x|,| |y|)| |#=|→|builtin|(|"z_leq"|,| |x|,| |y|)|←|↵|#fun| |z_equal|(|x|,| |y|)| |#=|→|builtin|(|"z_equal"|,| |x|,| |y|)|←|↵|#fun| |z_gt|(|x|,| |y|)| |#=|→|builtin|(|"z_gt"|,| |x|,| |y|)|←|↵|#fun| |z_geq|(|x|,| |y|)| |#=|→|builtin|(|"z_geq"|,| |x|,| |y|)|←|↵|#fun| |map|(|f|,|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|f|(|h|)|,| |map|(|f|,|t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |filter|(|f|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|#if| |f|(|h|)| |#then|→|Cons| |(|h|,| |filter|(|f|,| |t|)|)|←|↵|#else|→|(|filter|(|f|,| |t|)|)|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |foldl|(|f|,| |i|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|foldl|(|f|,| |f|(|i|,| |h|)|,| |t|)|←|↵|Nil| |#then|→|i|←|←|←|↵|#fun| |foldr|(|f|,| |i|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|f|(|h|,| |foldr|(|f|,| |i|,| |t|)|)|←|↵|Nil| |#then|→|i|←|←|←|↵|#fun| |zip|(|xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|hx|,| |tx|)| |#then|→|#if| |ys| |is|→|Cons| |(|hy|,| |ty|)| |#then|→|Cons| |(|Pair2| |(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |zipWith|(|f|,| |xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|hx|,| |tx|)| |#then|→|#if| |ys| |is|→|Cons| |(|hy|,| |ty|)| |#then|→|Cons| |(|f|(|hx|,| |hy|)|,| |zipWith|(|f|,| |tx|,| |ty|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |head|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|h|←|↵|Nil| |#then|→|error|(||)|←|←|←|↵|#fun| |tail|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|t|←|↵|Nil| |#then|→|error|(||)|←|←|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=|→|#if| |a| |<=| |b| |#then|→|Cons| |(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |enumFromThenTo|(|a|,| |t|,| |b|)| |#=|→|#if| |a| |<=| |b| |#then|→|Cons| |(|a|,| |enumFromThenTo|(|t|,| |2| |*| |t| |-| |a|,| |b|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |take|(|n|,| |ls|)| |#=|→|#if| |n| |>| |0| |#then|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|h|,| |take|(|n| |-| |1|,| |t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |length|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|1| |+| |(|length|(|t|)|)|←|↵|Nil| |#then|→|0|←|←|←|↵|#fun| |mappend|(|xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|h|,| |mappend|(|t|,| |ys|)|)|←|↵|Nil| |#then|→|ys|←|←|←|↵|#fun| |sum|(|ls|)| |#=|→|sumAux|(|ls|,| |0|)|←|↵|#fun| |sumAux|(|ls|,| |a|)| |#=|→|#if| |ls| |is|→|Nil| |#then|→|a|←|↵|Cons| |(|h|,| |t|)| |#then|→|sumAux|(|t|,| |a| |+| |h|)|←|←|←|↵|#fun| |atIndex|(|n|,| |ls|)| |#=|→|#if| |n| |<| |0| |#then|→|error|(||)|←|↵|#else|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|#if| |n| |==| |0| |#then|→|h|←|↵|#else|→|(|atIndex|(|n| |-| |1|,| |t|)|)|←|←|↵|Nil| |#then|→|error|(||)|←|←|←|←|↵|#fun| |concat|(|lss|)| |#=|→|#if| |lss| |is|→|Cons| |(|h|,| |t|)| |#then|→|mappend|(|h|,| |concat|(|t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |reverse|(|ls|)| |#=|→|reverse_helper|(|ls|,| |Nil|)|←|↵|#fun| |reverse_helper|(|ls|,| |a|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|reverse_helper|(|t|,| |Cons| |(|h|,| |a|)|)|←|↵|Nil| |#then|→|a|←|←|←|↵|#fun| |const10000|(||)| |#=|→|z_of_int|(|10000|)|←|↵|#fun| |f1|(|f1_arg1|)| |#=|→|#if| |f1_arg1| |is|→|Pair2| |(|f1_Pair2_0|,| |f1_Pair2_1|)| |#then|→|Pair3| |(|f1_Pair2_0|,| |f1_Pair2_1|,| |gcdE|(|f1_Pair2_0|,| |f1_Pair2_1|)|)|←|←|←|↵|#fun| |quotRem|(|quotRem_arg1|,| |quotRem_arg2|)| |#=|→|Pair2| |(|z_div|(|quotRem_arg1|,| |quotRem_arg2|)|,| |z_mod|(|quotRem_arg1|,| |quotRem_arg2|)|)|←|↵|#fun| |max'|(|max'_arg1|)| |#=|→|#if| |max'_arg1| |is|→|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)| |#then|→|#if| |max'_Cons_1| |is|→|Nil| |#then|→|max'_Cons_0|←|↵|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)| |#then|→|#if| |z_lt|(|max'_Cons_0|,| |max'_Cons_0|)| |#then|→|max'|(|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)|)|←|↵|#else|→|(|max'|(|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)|)|)|←|←|←|←|←|←|↵|#fun| |g|(|g_arg1|,| |g_arg2|)| |#=|→|#if| |g_arg1| |is|→|Pair3| |(|g_Pair3_0|,| |g_Pair3_1|,| |g_Pair3_2|)| |#then|→|#if| |g_arg2| |is|→|Pair3| |(|g_Pair3_0|,| |g_Pair3_1|,| |g_Pair3_2|)| |#then|→|#if| |z_equal|(|g_Pair3_2|,| |const0|(||)|)| |#then|→|Pair3| |(|g_Pair3_2|,| |g_Pair3_0|,| |g_Pair3_1|)|←|↵|#else|→|#let| |matchIdent| |#=| |quotRem|(|g_Pair3_2|,| |g_Pair3_2|)|↵|#if| |matchIdent| |is|→|Pair2| |(|g_Pair2_0|,| |g_Pair2_1|)| |#then|→|g|(|Pair3| |(|g_Pair3_0|,| |g_Pair3_1|,| |g_Pair3_2|)|,| |Pair3| |(|z_sub|(|g_Pair3_0|,| |z_mul|(|g_Pair2_0|,| |g_Pair3_0|)|)|,| |z_sub|(|g_Pair3_1|,| |z_mul|(|g_Pair2_0|,| |g_Pair3_1|)|)|,| |g_Pair2_1|)|)|←|←|←|←|←|←|←|←|↵|#fun| |abs|(|abs_arg1|)| |#=|→|#if| |z_lt|(|abs_arg1|,| |const0|(||)|)| |#then|→|z_sub|(|const0|(||)|,| |abs_arg1|)|←|↵|#else|→|abs_arg1|←|←|↵|#fun| |f2|(|f2_arg1|)| |#=|→|#if| |f2_arg1| |is|→|Pair3| |(|f2_Pair3_0|,| |f2_Pair3_1|,| |f2_Pair3_2|)| |#then|→|#if| |f2_Pair3_2| |is|→|Pair3| |(|f2_Pair3_0|,| |f2_Pair3_1|,| |f2_Pair3_2|)| |#then|→|abs|(|z_add|(|z_add|(|f2_Pair3_0|,| |f2_Pair3_1|)|,| |f2_Pair3_2|)|)|←|←|←|←|←|↵|#fun| |const0|(||)| |#=|→|z_of_int|(|0|)|←|↵|#fun| |gcdE|(|gcdE_arg1|,| |gcdE_arg2|)| |#=|→|#if| |z_equal|(|gcdE_arg1|,| |const0|(||)|)| |#then|→|Pair3| |(|gcdE_arg2|,| |const0|(||)|,| |const1|(||)|)|←|↵|#else|→|(|g|(|Pair3| |(|const1|(||)|,| |const0|(||)|,| |gcdE_arg1|)|,| |Pair3| |(|const0|(||)|,| |const1|(||)|,| |gcdE_arg2|)|)|)|←|←|↵|#fun| |const1|(||)| |#=|→|z_of_int|(|1|)|←|↵|#fun| |const5000|(||)| |#=|→|z_of_int|(|5000|)|←|↵|#fun| |z_enumFromTo|(|z_enumFromTo_arg1|,| |z_enumFromTo_arg2|)| |#=|→|#if| |z_leq|(|z_enumFromTo_arg1|,| |z_enumFromTo_arg2|)| |#then|→|Cons| |(|z_enumFromTo_arg1|,| |z_enumFromTo|(|z_add|(|z_enumFromTo_arg1|,| |const1|(||)|)|,| |z_enumFromTo_arg2|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|/* fun testGcd_nofib(testGcd_nofib_arg1) =*/|↵|/*   test(testGcd_nofib_arg1)*/|↵|/* fun test(test_arg1) =*/|↵|/*   let ns = z_enumFromTo(const5000(), z_add(const5000(), test_arg1))*/|↵|/*   let ms = z_enumFromTo(const10000()(), z_add(const10000()() + test_arg1))*/|↵|/*   let tripls = map(f1, let listcomp_fun = listcomp_fun_para =>*/|↵|/*     if listcomp_fun_para is*/|↵|/*       Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then*/|↵|/*         let listcomp_fun = listcomp_fun_para =>*/|↵|/*           if listcomp_fun_para is*/|↵|/*             Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then*/|↵|/*               Cons (Pair2 (listcomp_fun_ls_h, listcomp_fun_ls_h), listcomp_fun(listcomp_fun_ls_t))*/|↵|/*             Nil then*/|↵|/*               listcomp_fun(listcomp_fun_ls_t)*/|↵|/*         listcomp_fun(ms)*/|↵|/*       Nil then*/|↵|/*         Nil*/|↵|/*   listcomp_fun(ns))*/|↵|/*   let rs = map(f2, tripls)*/|↵|/*   max'(rs)*/|↵|#fun| |main|(||)| |#=|→|0|↵|/*testGcd_nofib(primId(z_of_int(400)))*/|←|↵|main|(||)|
//│ Parsed: {module True {}; module False {}; module List {}; class Cons(h, t,): List {}; module Nil: List {}; module Option {}; class Some(x,): Option {}; module None: Option {}; class Pair2(x, y,) {}; class Pair3(x, y, z,) {}; fun error = () => {builtin("error",)}; fun z_of_int = (x,) => {builtin("z_of_int", x,)}; fun z_to_int = (x,) => {builtin("z_to_int", x,)}; fun z_add = (x, y,) => {builtin("z_add", x, y,)}; fun z_sub = (x, y,) => {builtin("z_sub", x, y,)}; fun z_div = (x, y,) => {builtin("z_div", x, y,)}; fun z_mul = (x, y,) => {builtin("z_mul", x, y,)}; fun z_mod = (x, y,) => {builtin("z_mod", x, y,)}; fun z_lt = (x, y,) => {builtin("z_lt", x, y,)}; fun z_leq = (x, y,) => {builtin("z_leq", x, y,)}; fun z_equal = (x, y,) => {builtin("z_equal", x, y,)}; fun z_gt = (x, y,) => {builtin("z_gt", x, y,)}; fun z_geq = (x, y,) => {builtin("z_geq", x, y,)}; fun map = (f, ls,) => {if ls is ‹(Cons(h, t,)) then {Cons(f(h,), map(f, t,),)}; (Nil) then {Nil}›}; fun filter = (f, ls,) => {if ls is ‹(Cons(h, t,)) then {if (f(h,)) then {Cons(h, filter(f, t,),)} else {'(' filter(f, t,) ')'}}; (Nil) then {Nil}›}; fun foldl = (f, i, ls,) => {if ls is ‹(Cons(h, t,)) then {foldl(f, f(i, h,), t,)}; (Nil) then {i}›}; fun foldr = (f, i, ls,) => {if ls is ‹(Cons(h, t,)) then {f(h, foldr(f, i, t,),)}; (Nil) then {i}›}; fun zip = (xs, ys,) => {if xs is ‹(Cons(hx, tx,)) then {if ys is ‹(Cons(hy, ty,)) then {Cons(Pair2(hx, hy,), zip(tx, ty,),)}; (Nil) then {Nil}›}; (Nil) then {Nil}›}; fun zipWith = (f, xs, ys,) => {if xs is ‹(Cons(hx, tx,)) then {if ys is ‹(Cons(hy, ty,)) then {Cons(f(hx, hy,), zipWith(f, tx, ty,),)}; (Nil) then {Nil}›}; (Nil) then {Nil}›}; fun head = (ls,) => {if ls is ‹(Cons(h, t,)) then {h}; (Nil) then {error()}›}; fun tail = (ls,) => {if ls is ‹(Cons(h, t,)) then {t}; (Nil) then {error()}›}; fun enumFromTo = (a, b,) => {if (<=(a,)(b,)) then {Cons(a, enumFromTo(+(a,)(1,), b,),)} else {'(' Nil ')'}}; fun enumFromThenTo = (a, t, b,) => {if (<=(a,)(b,)) then {Cons(a, enumFromThenTo(t, -(*(2,)(t,),)(a,), b,),)} else {'(' Nil ')'}}; fun take = (n, ls,) => {if (>(n,)(0,)) then {if ls is ‹(Cons(h, t,)) then {Cons(h, take(-(n,)(1,), t,),)}; (Nil) then {Nil}›} else {'(' Nil ')'}}; fun length = (ls,) => {if ls is ‹(Cons(h, t,)) then {+(1,)('(' length(t,) ')',)}; (Nil) then {0}›}; fun mappend = (xs, ys,) => {if xs is ‹(Cons(h, t,)) then {Cons(h, mappend(t, ys,),)}; (Nil) then {ys}›}; fun sum = (ls,) => {sumAux(ls, 0,)}; fun sumAux = (ls, a,) => {if ls is ‹(Nil) then {a}; (Cons(h, t,)) then {sumAux(t, +(a,)(h,),)}›}; fun atIndex = (n, ls,) => {if (<(n,)(0,)) then {error()} else {if ls is ‹(Cons(h, t,)) then {if (==(n,)(0,)) then {h} else {'(' atIndex(-(n,)(1,), t,) ')'}}; (Nil) then {error()}›}}; fun concat = (lss,) => {if lss is ‹(Cons(h, t,)) then {mappend(h, concat(t,),)}; (Nil) then {Nil}›}; fun reverse = (ls,) => {reverse_helper(ls, Nil,)}; fun reverse_helper = (ls, a,) => {if ls is ‹(Cons(h, t,)) then {reverse_helper(t, Cons(h, a,),)}; (Nil) then {a}›}; fun const10000 = () => {z_of_int(10000,)}; fun f1 = (f1_arg1,) => {if f1_arg1 is ‹(Pair2(f1_Pair2_0, f1_Pair2_1,)) then {Pair3(f1_Pair2_0, f1_Pair2_1, gcdE(f1_Pair2_0, f1_Pair2_1,),)}›}; fun quotRem = (quotRem_arg1, quotRem_arg2,) => {Pair2(z_div(quotRem_arg1, quotRem_arg2,), z_mod(quotRem_arg1, quotRem_arg2,),)}; fun max' = (max'_arg1,) => {if max'_arg1 is ‹(Cons(max'_Cons_0, max'_Cons_1,)) then {if max'_Cons_1 is ‹(Nil) then {max'_Cons_0}; (Cons(max'_Cons_0, max'_Cons_1,)) then {if (z_lt(max'_Cons_0, max'_Cons_0,)) then {max'(Cons(max'_Cons_0, max'_Cons_1,),)} else {'(' max'(Cons(max'_Cons_0, max'_Cons_1,),) ')'}}›}›}; fun g = (g_arg1, g_arg2,) => {if g_arg1 is ‹(Pair3(g_Pair3_0, g_Pair3_1, g_Pair3_2,)) then {if g_arg2 is ‹(Pair3(g_Pair3_0, g_Pair3_1, g_Pair3_2,)) then {if (z_equal(g_Pair3_2, const0(),)) then {Pair3(g_Pair3_2, g_Pair3_0, g_Pair3_1,)} else {let matchIdent = quotRem(g_Pair3_2, g_Pair3_2,); if matchIdent is ‹(Pair2(g_Pair2_0, g_Pair2_1,)) then {g(Pair3(g_Pair3_0, g_Pair3_1, g_Pair3_2,), Pair3(z_sub(g_Pair3_0, z_mul(g_Pair2_0, g_Pair3_0,),), z_sub(g_Pair3_1, z_mul(g_Pair2_0, g_Pair3_1,),), g_Pair2_1,),)}›}}›}›}; fun abs = (abs_arg1,) => {if (z_lt(abs_arg1, const0(),)) then {z_sub(const0(), abs_arg1,)} else {abs_arg1}}; fun f2 = (f2_arg1,) => {if f2_arg1 is ‹(Pair3(f2_Pair3_0, f2_Pair3_1, f2_Pair3_2,)) then {if f2_Pair3_2 is ‹(Pair3(f2_Pair3_0, f2_Pair3_1, f2_Pair3_2,)) then {abs(z_add(z_add(f2_Pair3_0, f2_Pair3_1,), f2_Pair3_2,),)}›}›}; fun const0 = () => {z_of_int(0,)}; fun gcdE = (gcdE_arg1, gcdE_arg2,) => {if (z_equal(gcdE_arg1, const0(),)) then {Pair3(gcdE_arg2, const0(), const1(),)} else {'(' g(Pair3(const1(), const0(), gcdE_arg1,), Pair3(const0(), const1(), gcdE_arg2,),) ')'}}; fun const1 = () => {z_of_int(1,)}; fun const5000 = () => {z_of_int(5000,)}; fun z_enumFromTo = (z_enumFromTo_arg1, z_enumFromTo_arg2,) => {if (z_leq(z_enumFromTo_arg1, z_enumFromTo_arg2,)) then {Cons(z_enumFromTo_arg1, z_enumFromTo(z_add(z_enumFromTo_arg1, const1(),), z_enumFromTo_arg2,),)} else {'(' Nil ')'}}; fun main = () => {0}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, List, []),ClassInfo(3, Cons, [h,t]),ClassInfo(4, Nil, []),ClassInfo(5, Option, []),ClassInfo(6, Some, [x]),ClassInfo(7, None, []),ClassInfo(8, Pair2, [x,y]),ClassInfo(9, Pair3, [x,y,z])}, {
//│ Def(0, error, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$0) = builtin(error) in -- #5
//│ x$0 -- #4
//│ )
//│ Def(1, z_of_int, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$2) = builtin(z_of_int,x$1) in -- #13
//│ x$2 -- #12
//│ )
//│ Def(2, z_to_int, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$4) = builtin(z_to_int,x$3) in -- #21
//│ x$4 -- #20
//│ )
//│ Def(3, z_add, [x$5,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$6) = builtin(z_add,x$5,y$0) in -- #31
//│ x$6 -- #30
//│ )
//│ Def(4, z_sub, [x$7,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$8) = builtin(z_sub,x$7,y$1) in -- #41
//│ x$8 -- #40
//│ )
//│ Def(5, z_div, [x$9,y$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$10) = builtin(z_div,x$9,y$2) in -- #51
//│ x$10 -- #50
//│ )
//│ Def(6, z_mul, [x$11,y$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$12) = builtin(z_mul,x$11,y$3) in -- #61
//│ x$12 -- #60
//│ )
//│ Def(7, z_mod, [x$13,y$4], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$14) = builtin(z_mod,x$13,y$4) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(8, z_lt, [x$15,y$5], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$16) = builtin(z_lt,x$15,y$5) in -- #81
//│ x$16 -- #80
//│ )
//│ Def(9, z_leq, [x$17,y$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$18) = builtin(z_leq,x$17,y$6) in -- #91
//│ x$18 -- #90
//│ )
//│ Def(10, z_equal, [x$19,y$7], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$20) = builtin(z_equal,x$19,y$7) in -- #101
//│ x$20 -- #100
//│ )
//│ Def(11, z_gt, [x$21,y$8], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$22) = builtin(z_gt,x$21,y$8) in -- #111
//│ x$22 -- #110
//│ )
//│ Def(12, z_geq, [x$23,y$9], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$24) = builtin(z_geq,x$23,y$9) in -- #121
//│ x$24 -- #120
//│ )
//│ Def(13, map, [f$0,ls$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$0 of -- #157
//│   Cons =>
//│     let x$26 = Cons.t(ls$0) in -- #153
//│     let x$27 = Cons.h(ls$0) in -- #152
//│     let List(x$28) = f$0(x$27) in -- #151
//│     let* (x$29) = map(f$0,x$26) in -- #150
//│     let x$30 = Cons(x$28,x$29) in -- #149
//│     jump j$0(x$30) -- #148
//│   Nil =>
//│     let x$31 = Nil() in -- #156
//│     jump j$0(x$31) -- #155
//│ )
//│ Def(14, j$0, [x$25], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$25 -- #123
//│ )
//│ Def(15, filter, [f$1,ls$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$1 of -- #206
//│   Cons =>
//│     let x$33 = Cons.t(ls$1) in -- #202
//│     let x$34 = Cons.h(ls$1) in -- #201
//│     let List(x$35) = f$1(x$34) in -- #200
//│     if x$35 -- #199
//│       true =>
//│         let* (x$37) = filter(f$1,x$33) in -- #189
//│         let x$38 = Cons(x$34,x$37) in -- #188
//│         jump j$2(x$38) -- #187
//│       false =>
//│         let* (x$39) = filter(f$1,x$33) in -- #198
//│         jump j$2(x$39) -- #197
//│   Nil =>
//│     let x$40 = Nil() in -- #205
//│     jump j$1(x$40) -- #204
//│ )
//│ Def(16, j$1, [x$32], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$32 -- #159
//│ )
//│ Def(17, j$2, [x$36], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$36) -- #174
//│ )
//│ Def(18, foldl, [f$2,i$0,ls$2], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$2 of -- #239
//│   Cons =>
//│     let x$42 = Cons.t(ls$2) in -- #236
//│     let x$43 = Cons.h(ls$2) in -- #235
//│     let List(x$44) = f$2(i$0,x$43) in -- #234
//│     let* (x$45) = foldl(f$2,x$44,x$42) in -- #233
//│     jump j$3(x$45) -- #232
//│   Nil =>
//│     jump j$3(i$0) -- #238
//│ )
//│ Def(19, j$3, [x$41], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$41 -- #208
//│ )
//│ Def(20, foldr, [f$3,i$1,ls$3], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$3 of -- #272
//│   Cons =>
//│     let x$47 = Cons.t(ls$3) in -- #269
//│     let x$48 = Cons.h(ls$3) in -- #268
//│     let* (x$49) = foldr(f$3,i$1,x$47) in -- #267
//│     let List(x$50) = f$3(x$48,x$49) in -- #266
//│     jump j$4(x$50) -- #265
//│   Nil =>
//│     jump j$4(i$1) -- #271
//│ )
//│ Def(21, j$4, [x$46], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$46 -- #241
//│ )
//│ Def(22, zip, [xs$0,ys$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #326
//│   Cons =>
//│     let x$52 = Cons.t(xs$0) in -- #322
//│     let x$53 = Cons.h(xs$0) in -- #321
//│     case ys$0 of -- #320
//│       Cons =>
//│         let x$55 = Cons.t(ys$0) in -- #316
//│         let x$56 = Cons.h(ys$0) in -- #315
//│         let x$57 = Pair2(x$53,x$56) in -- #314
//│         let* (x$58) = zip(x$52,x$55) in -- #313
//│         let x$59 = Cons(x$57,x$58) in -- #312
//│         jump j$6(x$59) -- #311
//│       Nil =>
//│         let x$60 = Nil() in -- #319
//│         jump j$6(x$60) -- #318
//│   Nil =>
//│     let x$61 = Nil() in -- #325
//│     jump j$5(x$61) -- #324
//│ )
//│ Def(23, j$5, [x$51], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$51 -- #274
//│ )
//│ Def(24, j$6, [x$54], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$5(x$54) -- #285
//│ )
//│ Def(25, zipWith, [f$4,xs$1,ys$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$1 of -- #383
//│   Cons =>
//│     let x$63 = Cons.t(xs$1) in -- #379
//│     let x$64 = Cons.h(xs$1) in -- #378
//│     case ys$1 of -- #377
//│       Cons =>
//│         let x$66 = Cons.t(ys$1) in -- #373
//│         let x$67 = Cons.h(ys$1) in -- #372
//│         let List(x$68) = f$4(x$64,x$67) in -- #371
//│         let* (x$69) = zipWith(f$4,x$63,x$66) in -- #370
//│         let x$70 = Cons(x$68,x$69) in -- #369
//│         jump j$8(x$70) -- #368
//│       Nil =>
//│         let x$71 = Nil() in -- #376
//│         jump j$8(x$71) -- #375
//│   Nil =>
//│     let x$72 = Nil() in -- #382
//│     jump j$7(x$72) -- #381
//│ )
//│ Def(26, j$7, [x$62], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$62 -- #328
//│ )
//│ Def(27, j$8, [x$65], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$7(x$65) -- #339
//│ )
//│ Def(28, head, [ls$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$4 of -- #403
//│   Cons =>
//│     let x$74 = Cons.t(ls$4) in -- #397
//│     let x$75 = Cons.h(ls$4) in -- #396
//│     jump j$9(x$75) -- #395
//│   Nil =>
//│     let* (x$76) = error() in -- #402
//│     jump j$9(x$76) -- #401
//│ )
//│ Def(29, j$9, [x$73], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$73 -- #385
//│ )
//│ Def(30, tail, [ls$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$5 of -- #423
//│   Cons =>
//│     let x$78 = Cons.t(ls$5) in -- #417
//│     let x$79 = Cons.h(ls$5) in -- #416
//│     jump j$10(x$78) -- #415
//│   Nil =>
//│     let* (x$80) = error() in -- #422
//│     jump j$10(x$80) -- #421
//│ )
//│ Def(31, j$10, [x$77], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$77 -- #405
//│ )
//│ Def(32, enumFromTo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$81 = <=(a$0,b$0) in -- #450
//│ if x$81 -- #449
//│   true =>
//│     let x$83 = +(a$0,1) in -- #445
//│     let* (x$84) = enumFromTo(x$83,b$0) in -- #444
//│     let x$85 = Cons(a$0,x$84) in -- #443
//│     jump j$11(x$85) -- #442
//│   false =>
//│     let x$86 = Nil() in -- #448
//│     jump j$11(x$86) -- #447
//│ )
//│ Def(33, j$11, [x$82], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$82 -- #427
//│ )
//│ Def(34, enumFromThenTo, [a$1,t$0,b$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$87 = <=(a$1,b$1) in -- #482
//│ if x$87 -- #481
//│   true =>
//│     let x$89 = *(2,t$0) in -- #477
//│     let x$90 = -(x$89,a$1) in -- #476
//│     let* (x$91) = enumFromThenTo(t$0,x$90,b$1) in -- #475
//│     let x$92 = Cons(a$1,x$91) in -- #474
//│     jump j$12(x$92) -- #473
//│   false =>
//│     let x$93 = Nil() in -- #480
//│     jump j$12(x$93) -- #479
//│ )
//│ Def(35, j$12, [x$88], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$88 -- #454
//│ )
//│ Def(36, take, [n$0,ls$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$94 = >(n$0,0) in -- #526
//│ if x$94 -- #525
//│   true =>
//│     case ls$6 of -- #521
//│       Cons =>
//│         let x$97 = Cons.t(ls$6) in -- #517
//│         let x$98 = Cons.h(ls$6) in -- #516
//│         let x$99 = -(n$0,1) in -- #515
//│         let* (x$100) = take(x$99,x$97) in -- #514
//│         let x$101 = Cons(x$98,x$100) in -- #513
//│         jump j$14(x$101) -- #512
//│       Nil =>
//│         let x$102 = Nil() in -- #520
//│         jump j$14(x$102) -- #519
//│   false =>
//│     let x$103 = Nil() in -- #524
//│     jump j$13(x$103) -- #523
//│ )
//│ Def(37, j$13, [x$95], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$95 -- #486
//│ )
//│ Def(38, j$14, [x$96], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$13(x$96) -- #489
//│ )
//│ Def(39, length, [ls$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$7 of -- #551
//│   Cons =>
//│     let x$105 = Cons.t(ls$7) in -- #548
//│     let x$106 = Cons.h(ls$7) in -- #547
//│     let* (x$107) = length(x$105) in -- #546
//│     let x$108 = +(1,x$107) in -- #545
//│     jump j$15(x$108) -- #544
//│   Nil =>
//│     jump j$15(0) -- #550
//│ )
//│ Def(40, j$15, [x$104], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$104 -- #528
//│ )
//│ Def(41, mappend, [xs$2,ys$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$2 of -- #581
//│   Cons =>
//│     let x$110 = Cons.t(xs$2) in -- #578
//│     let x$111 = Cons.h(xs$2) in -- #577
//│     let* (x$112) = mappend(x$110,ys$2) in -- #576
//│     let x$113 = Cons(x$111,x$112) in -- #575
//│     jump j$16(x$113) -- #574
//│   Nil =>
//│     jump j$16(ys$2) -- #580
//│ )
//│ Def(42, j$16, [x$109], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$109 -- #553
//│ )
//│ Def(43, sum, [ls$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$114) = sumAux(ls$8,0) in -- #589
//│ x$114 -- #588
//│ )
//│ Def(44, sumAux, [ls$9,a$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$9 of -- #616
//│   Nil =>
//│     jump j$17(a$2) -- #593
//│   Cons =>
//│     let x$116 = Cons.t(ls$9) in -- #615
//│     let x$117 = Cons.h(ls$9) in -- #614
//│     let x$118 = +(a$2,x$117) in -- #613
//│     let* (x$119) = sumAux(x$116,x$118) in -- #612
//│     jump j$17(x$119) -- #611
//│ )
//│ Def(45, j$17, [x$115], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$115 -- #591
//│ )
//│ Def(46, atIndex, [n$1,ls$10], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$120 = <(n$1,0) in -- #667
//│ if x$120 -- #666
//│   true =>
//│     let* (x$122) = error() in -- #625
//│     jump j$18(x$122) -- #624
//│   false =>
//│     case ls$10 of -- #665
//│       Cons =>
//│         let x$124 = Cons.t(ls$10) in -- #659
//│         let x$125 = Cons.h(ls$10) in -- #658
//│         let x$126 = ==(n$1,0) in -- #657
//│         if x$126 -- #656
//│           true =>
//│             jump j$20(x$125) -- #643
//│           false =>
//│             let x$128 = -(n$1,1) in -- #655
//│             let* (x$129) = atIndex(x$128,x$124) in -- #654
//│             jump j$20(x$129) -- #653
//│       Nil =>
//│         let* (x$130) = error() in -- #664
//│         jump j$19(x$130) -- #663
//│ )
//│ Def(47, j$18, [x$121], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$121 -- #620
//│ )
//│ Def(48, j$19, [x$123], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$18(x$123) -- #628
//│ )
//│ Def(49, j$20, [x$127], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$19(x$127) -- #641
//│ )
//│ Def(50, concat, [lss$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case lss$0 of -- #697
//│   Cons =>
//│     let x$132 = Cons.t(lss$0) in -- #693
//│     let x$133 = Cons.h(lss$0) in -- #692
//│     let* (x$134) = concat(x$132) in -- #691
//│     let* (x$135) = mappend(x$133,x$134) in -- #690
//│     jump j$21(x$135) -- #689
//│   Nil =>
//│     let x$136 = Nil() in -- #696
//│     jump j$21(x$136) -- #695
//│ )
//│ Def(51, j$21, [x$131], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$131 -- #669
//│ )
//│ Def(52, reverse, [ls$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$137 = Nil() in -- #706
//│ let* (x$138) = reverse_helper(ls$11,x$137) in -- #705
//│ x$138 -- #704
//│ )
//│ Def(53, reverse_helper, [ls$12,a$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$12 of -- #736
//│   Cons =>
//│     let x$140 = Cons.t(ls$12) in -- #733
//│     let x$141 = Cons.h(ls$12) in -- #732
//│     let x$142 = Cons(x$141,a$3) in -- #731
//│     let* (x$143) = reverse_helper(x$140,x$142) in -- #730
//│     jump j$22(x$143) -- #729
//│   Nil =>
//│     jump j$22(a$3) -- #735
//│ )
//│ Def(54, j$22, [x$139], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$139 -- #708
//│ )
//│ Def(55, const10000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$144) = z_of_int(10000) in -- #742
//│ x$144 -- #741
//│ )
//│ Def(56, f1, [f1_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f1_arg1$0 of -- #772
//│   Pair2 =>
//│     let x$146 = Pair2.y(f1_arg1$0) in -- #771
//│     let x$147 = Pair2.x(f1_arg1$0) in -- #770
//│     let* (x$148) = gcdE(x$147,x$146) in -- #769
//│     let x$149 = Pair3(x$147,x$146,x$148) in -- #768
//│     jump j$23(x$149) -- #767
//│ )
//│ Def(57, j$23, [x$145], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$145 -- #744
//│ )
//│ Def(58, quotRem, [quotRem_arg1$0,quotRem_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$150) = z_div(quotRem_arg1$0,quotRem_arg2$0) in -- #793
//│ let* (x$151) = z_mod(quotRem_arg1$0,quotRem_arg2$0) in -- #792
//│ let x$152 = Pair2(x$150,x$151) in -- #791
//│ x$152 -- #790
//│ )
//│ Def(59, max', [max'_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case max'_arg1$0 of -- #859
//│   Cons =>
//│     let x$154 = Cons.t(max'_arg1$0) in -- #858
//│     let x$155 = Cons.h(max'_arg1$0) in -- #857
//│     case x$154 of -- #856
//│       Nil =>
//│         jump j$25(x$155) -- #808
//│       Cons =>
//│         let x$157 = Cons.t(x$154) in -- #855
//│         let x$158 = Cons.h(x$154) in -- #854
//│         let* (x$159) = z_lt(x$158,x$158) in -- #853
//│         if x$159 -- #852
//│           true =>
//│             let x$161 = Cons(x$158,x$157) in -- #838
//│             let* (x$162) = max'(x$161) in -- #837
//│             jump j$26(x$162) -- #836
//│           false =>
//│             let x$163 = Cons(x$158,x$157) in -- #851
//│             let* (x$164) = max'(x$163) in -- #850
//│             jump j$26(x$164) -- #849
//│ )
//│ Def(60, j$24, [x$153], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$153 -- #795
//│ )
//│ Def(61, j$25, [x$156], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$24(x$156) -- #806
//│ )
//│ Def(62, j$26, [x$160], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$25(x$160) -- #825
//│ )
//│ Def(63, g, [g_arg1$0,g_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case g_arg1$0 of -- #995
//│   Pair3 =>
//│     let x$166 = Pair3.z(g_arg1$0) in -- #994
//│     let x$167 = Pair3.y(g_arg1$0) in -- #993
//│     let x$168 = Pair3.x(g_arg1$0) in -- #992
//│     case g_arg2$0 of -- #991
//│       Pair3 =>
//│         let x$170 = Pair3.z(g_arg2$0) in -- #990
//│         let x$171 = Pair3.y(g_arg2$0) in -- #989
//│         let x$172 = Pair3.x(g_arg2$0) in -- #988
//│         let* (x$173) = const0() in -- #987
//│         let* (x$174) = z_equal(x$170,x$173) in -- #986
//│         if x$174 -- #985
//│           true =>
//│             let x$176 = Pair3(x$170,x$172,x$171) in -- #909
//│             jump j$29(x$176) -- #908
//│           false =>
//│             let* (x$177) = quotRem(x$170,x$170) in -- #984
//│             case x$177 of -- #983
//│               Pair2 =>
//│                 let x$179 = Pair2.y(x$177) in -- #982
//│                 let x$180 = Pair2.x(x$177) in -- #981
//│                 let x$181 = Pair3(x$172,x$171,x$170) in -- #980
//│                 let* (x$182) = z_mul(x$180,x$172) in -- #979
//│                 let* (x$183) = z_sub(x$172,x$182) in -- #978
//│                 let* (x$184) = z_mul(x$180,x$171) in -- #977
//│                 let* (x$185) = z_sub(x$171,x$184) in -- #976
//│                 let x$186 = Pair3(x$183,x$185,x$179) in -- #975
//│                 let* (x$187) = g(x$181,x$186) in -- #974
//│                 jump j$30(x$187) -- #973
//│ )
//│ Def(64, j$27, [x$165], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$165 -- #861
//│ )
//│ Def(65, j$28, [x$169], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$27(x$169) -- #876
//│ )
//│ Def(66, j$29, [x$175], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$28(x$175) -- #899
//│ )
//│ Def(67, j$30, [x$178], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$29(x$178) -- #919
//│ )
//│ Def(68, abs, [abs_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$188) = const0() in -- #1022
//│ let* (x$189) = z_lt(abs_arg1$0,x$188) in -- #1021
//│ if x$189 -- #1020
//│   true =>
//│     let* (x$191) = const0() in -- #1017
//│     let* (x$192) = z_sub(x$191,abs_arg1$0) in -- #1016
//│     jump j$31(x$192) -- #1015
//│   false =>
//│     jump j$31(abs_arg1$0) -- #1019
//│ )
//│ Def(69, j$31, [x$190], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$190 -- #1005
//│ )
//│ Def(70, f2, [f2_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f2_arg1$0 of -- #1080
//│   Pair3 =>
//│     let x$194 = Pair3.z(f2_arg1$0) in -- #1079
//│     let x$195 = Pair3.y(f2_arg1$0) in -- #1078
//│     let x$196 = Pair3.x(f2_arg1$0) in -- #1077
//│     case x$194 of -- #1076
//│       Pair3 =>
//│         let x$198 = Pair3.z(x$194) in -- #1075
//│         let x$199 = Pair3.y(x$194) in -- #1074
//│         let x$200 = Pair3.x(x$194) in -- #1073
//│         let* (x$201) = z_add(x$200,x$199) in -- #1072
//│         let* (x$202) = z_add(x$201,x$198) in -- #1071
//│         let* (x$203) = abs(x$202) in -- #1070
//│         jump j$33(x$203) -- #1069
//│ )
//│ Def(71, j$32, [x$193], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$193 -- #1024
//│ )
//│ Def(72, j$33, [x$197], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$32(x$197) -- #1039
//│ )
//│ Def(73, const0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$204) = z_of_int(0) in -- #1086
//│ x$204 -- #1085
//│ )
//│ Def(74, gcdE, [gcdE_arg1$0,gcdE_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$205) = const0() in -- #1152
//│ let* (x$206) = z_equal(gcdE_arg1$0,x$205) in -- #1151
//│ if x$206 -- #1150
//│   true =>
//│     let* (x$208) = const0() in -- #1112
//│     let* (x$209) = const1() in -- #1111
//│     let x$210 = Pair3(gcdE_arg2$0,x$208,x$209) in -- #1110
//│     jump j$34(x$210) -- #1109
//│   false =>
//│     let* (x$211) = const1() in -- #1149
//│     let* (x$212) = const0() in -- #1148
//│     let x$213 = Pair3(x$211,x$212,gcdE_arg1$0) in -- #1147
//│     let* (x$214) = const0() in -- #1146
//│     let* (x$215) = const1() in -- #1145
//│     let x$216 = Pair3(x$214,x$215,gcdE_arg2$0) in -- #1144
//│     let* (x$217) = g(x$213,x$216) in -- #1143
//│     jump j$34(x$217) -- #1142
//│ )
//│ Def(75, j$34, [x$207], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$207 -- #1096
//│ )
//│ Def(76, const1, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$218) = z_of_int(1) in -- #1158
//│ x$218 -- #1157
//│ )
//│ Def(77, const5000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$219) = z_of_int(5000) in -- #1164
//│ x$219 -- #1163
//│ )
//│ Def(78, z_enumFromTo, [z_enumFromTo_arg1$0,z_enumFromTo_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$220) = z_leq(z_enumFromTo_arg1$0,z_enumFromTo_arg2$0) in -- #1202
//│ if x$220 -- #1201
//│   true =>
//│     let* (x$222) = const1() in -- #1197
//│     let* (x$223) = z_add(z_enumFromTo_arg1$0,x$222) in -- #1196
//│     let* (x$224) = z_enumFromTo(x$223,z_enumFromTo_arg2$0) in -- #1195
//│     let x$225 = Cons(z_enumFromTo_arg1$0,x$224) in -- #1194
//│     jump j$35(x$225) -- #1193
//│   false =>
//│     let x$226 = Nil() in -- #1200
//│     jump j$35(x$226) -- #1199
//│ )
//│ Def(79, j$35, [x$221], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$221 -- #1172
//│ )
//│ Def(80, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #1203
//│ )
//│ },
//│ let* (x$227) = main() in -- #1207
//│ x$227 -- #1206)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, List, []),ClassInfo(3, Cons, [h,t]),ClassInfo(4, Nil, []),ClassInfo(5, Option, []),ClassInfo(6, Some, [x]),ClassInfo(7, None, []),ClassInfo(8, Pair2, [x,y]),ClassInfo(9, Pair3, [x,y,z])}, {
//│ Def(0, error, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$0) = builtin(error) in -- #5
//│ x$0 -- #4
//│ )
//│ Def(1, z_of_int, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$2) = builtin(z_of_int,x$1) in -- #13
//│ x$2 -- #12
//│ )
//│ Def(2, z_to_int, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$4) = builtin(z_to_int,x$3) in -- #21
//│ x$4 -- #20
//│ )
//│ Def(3, z_add, [x$5,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$6) = builtin(z_add,x$5,y$0) in -- #31
//│ x$6 -- #30
//│ )
//│ Def(4, z_sub, [x$7,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$8) = builtin(z_sub,x$7,y$1) in -- #41
//│ x$8 -- #40
//│ )
//│ Def(5, z_div, [x$9,y$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$10) = builtin(z_div,x$9,y$2) in -- #51
//│ x$10 -- #50
//│ )
//│ Def(6, z_mul, [x$11,y$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$12) = builtin(z_mul,x$11,y$3) in -- #61
//│ x$12 -- #60
//│ )
//│ Def(7, z_mod, [x$13,y$4], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$14) = builtin(z_mod,x$13,y$4) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(8, z_lt, [x$15,y$5], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$16) = builtin(z_lt,x$15,y$5) in -- #81
//│ x$16 -- #80
//│ )
//│ Def(9, z_leq, [x$17,y$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$18) = builtin(z_leq,x$17,y$6) in -- #91
//│ x$18 -- #90
//│ )
//│ Def(10, z_equal, [x$19,y$7], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$20) = builtin(z_equal,x$19,y$7) in -- #101
//│ x$20 -- #100
//│ )
//│ Def(11, z_gt, [x$21,y$8], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$22) = builtin(z_gt,x$21,y$8) in -- #111
//│ x$22 -- #110
//│ )
//│ Def(12, z_geq, [x$23,y$9], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let List(x$24) = builtin(z_geq,x$23,y$9) in -- #121
//│ x$24 -- #120
//│ )
//│ Def(13, map, [f$0,ls$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$0 of -- #157
//│   Cons =>
//│     let x$26 = Cons.t(ls$0) in -- #153
//│     let x$27 = Cons.h(ls$0) in -- #152
//│     let List(x$28) = f$0(x$27) in -- #151
//│     let* (x$29) = map(f$0,x$26) in -- #150
//│     let x$30 = Cons(x$28,x$29) in -- #149
//│     jump j$0(x$30) -- #148
//│   Nil =>
//│     let x$31 = Nil() in -- #156
//│     jump j$0(x$31) -- #155
//│ )
//│ Def(14, j$0, [x$25], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$25 -- #123
//│ )
//│ Def(15, filter, [f$1,ls$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$1 of -- #206
//│   Cons =>
//│     let x$33 = Cons.t(ls$1) in -- #202
//│     let x$34 = Cons.h(ls$1) in -- #201
//│     let List(x$35) = f$1(x$34) in -- #200
//│     if x$35 -- #199
//│       true =>
//│         let* (x$37) = filter(f$1,x$33) in -- #189
//│         let x$38 = Cons(x$34,x$37) in -- #188
//│         jump j$2(x$38) -- #187
//│       false =>
//│         let* (x$39) = filter(f$1,x$33) in -- #198
//│         jump j$2(x$39) -- #197
//│   Nil =>
//│     let x$40 = Nil() in -- #205
//│     jump j$1(x$40) -- #204
//│ )
//│ Def(16, j$1, [x$32], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$32 -- #159
//│ )
//│ Def(17, j$2, [x$36], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$36) -- #174
//│ )
//│ Def(18, foldl, [f$2,i$0,ls$2], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$2 of -- #239
//│   Cons =>
//│     let x$42 = Cons.t(ls$2) in -- #236
//│     let x$43 = Cons.h(ls$2) in -- #235
//│     let List(x$44) = f$2(i$0,x$43) in -- #234
//│     let* (x$45) = foldl(f$2,x$44,x$42) in -- #233
//│     jump j$3(x$45) -- #232
//│   Nil =>
//│     jump j$3(i$0) -- #238
//│ )
//│ Def(19, j$3, [x$41], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$41 -- #208
//│ )
//│ Def(20, foldr, [f$3,i$1,ls$3], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$3 of -- #272
//│   Cons =>
//│     let x$47 = Cons.t(ls$3) in -- #269
//│     let x$48 = Cons.h(ls$3) in -- #268
//│     let* (x$49) = foldr(f$3,i$1,x$47) in -- #267
//│     let List(x$50) = f$3(x$48,x$49) in -- #266
//│     jump j$4(x$50) -- #265
//│   Nil =>
//│     jump j$4(i$1) -- #271
//│ )
//│ Def(21, j$4, [x$46], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$46 -- #241
//│ )
//│ Def(22, zip, [xs$0,ys$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #326
//│   Cons =>
//│     let x$52 = Cons.t(xs$0) in -- #322
//│     let x$53 = Cons.h(xs$0) in -- #321
//│     case ys$0 of -- #320
//│       Cons =>
//│         let x$55 = Cons.t(ys$0) in -- #316
//│         let x$56 = Cons.h(ys$0) in -- #315
//│         let x$57 = Pair2(x$53,x$56) in -- #314
//│         let* (x$58) = zip(x$52,x$55) in -- #313
//│         let x$59 = Cons(x$57,x$58) in -- #312
//│         jump j$6(x$59) -- #311
//│       Nil =>
//│         let x$60 = Nil() in -- #319
//│         jump j$6(x$60) -- #318
//│   Nil =>
//│     let x$61 = Nil() in -- #325
//│     jump j$5(x$61) -- #324
//│ )
//│ Def(23, j$5, [x$51], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$51 -- #274
//│ )
//│ Def(24, j$6, [x$54], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$5(x$54) -- #285
//│ )
//│ Def(25, zipWith, [f$4,xs$1,ys$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$1 of -- #383
//│   Cons =>
//│     let x$63 = Cons.t(xs$1) in -- #379
//│     let x$64 = Cons.h(xs$1) in -- #378
//│     case ys$1 of -- #377
//│       Cons =>
//│         let x$66 = Cons.t(ys$1) in -- #373
//│         let x$67 = Cons.h(ys$1) in -- #372
//│         let List(x$68) = f$4(x$64,x$67) in -- #371
//│         let* (x$69) = zipWith(f$4,x$63,x$66) in -- #370
//│         let x$70 = Cons(x$68,x$69) in -- #369
//│         jump j$8(x$70) -- #368
//│       Nil =>
//│         let x$71 = Nil() in -- #376
//│         jump j$8(x$71) -- #375
//│   Nil =>
//│     let x$72 = Nil() in -- #382
//│     jump j$7(x$72) -- #381
//│ )
//│ Def(26, j$7, [x$62], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$62 -- #328
//│ )
//│ Def(27, j$8, [x$65], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$7(x$65) -- #339
//│ )
//│ Def(28, head, [ls$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$4 of -- #403
//│   Cons =>
//│     let x$74 = Cons.t(ls$4) in -- #397
//│     let x$75 = Cons.h(ls$4) in -- #396
//│     jump j$9(x$75) -- #395
//│   Nil =>
//│     let* (x$76) = error() in -- #402
//│     jump j$9(x$76) -- #401
//│ )
//│ Def(29, j$9, [x$73], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$73 -- #385
//│ )
//│ Def(30, tail, [ls$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$5 of -- #423
//│   Cons =>
//│     let x$78 = Cons.t(ls$5) in -- #417
//│     let x$79 = Cons.h(ls$5) in -- #416
//│     jump j$10(x$78) -- #415
//│   Nil =>
//│     let* (x$80) = error() in -- #422
//│     jump j$10(x$80) -- #421
//│ )
//│ Def(31, j$10, [x$77], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$77 -- #405
//│ )
//│ Def(32, enumFromTo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$81 = <=(a$0,b$0) in -- #450
//│ if x$81 -- #449
//│   true =>
//│     let x$83 = +(a$0,1) in -- #445
//│     let* (x$84) = enumFromTo(x$83,b$0) in -- #444
//│     let x$85 = Cons(a$0,x$84) in -- #443
//│     jump j$11(x$85) -- #442
//│   false =>
//│     let x$86 = Nil() in -- #448
//│     jump j$11(x$86) -- #447
//│ )
//│ Def(33, j$11, [x$82], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$82 -- #427
//│ )
//│ Def(34, enumFromThenTo, [a$1,t$0,b$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$87 = <=(a$1,b$1) in -- #482
//│ if x$87 -- #481
//│   true =>
//│     let x$89 = *(2,t$0) in -- #477
//│     let x$90 = -(x$89,a$1) in -- #476
//│     let* (x$91) = enumFromThenTo(t$0,x$90,b$1) in -- #475
//│     let x$92 = Cons(a$1,x$91) in -- #474
//│     jump j$12(x$92) -- #473
//│   false =>
//│     let x$93 = Nil() in -- #480
//│     jump j$12(x$93) -- #479
//│ )
//│ Def(35, j$12, [x$88], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$88 -- #454
//│ )
//│ Def(36, take, [n$0,ls$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$94 = >(n$0,0) in -- #526
//│ if x$94 -- #525
//│   true =>
//│     case ls$6 of -- #521
//│       Cons =>
//│         let x$97 = Cons.t(ls$6) in -- #517
//│         let x$98 = Cons.h(ls$6) in -- #516
//│         let x$99 = -(n$0,1) in -- #515
//│         let* (x$100) = take(x$99,x$97) in -- #514
//│         let x$101 = Cons(x$98,x$100) in -- #513
//│         jump j$14(x$101) -- #512
//│       Nil =>
//│         let x$102 = Nil() in -- #520
//│         jump j$14(x$102) -- #519
//│   false =>
//│     let x$103 = Nil() in -- #524
//│     jump j$13(x$103) -- #523
//│ )
//│ Def(37, j$13, [x$95], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$95 -- #486
//│ )
//│ Def(38, j$14, [x$96], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$13(x$96) -- #489
//│ )
//│ Def(39, length, [ls$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$7 of -- #551
//│   Cons =>
//│     let x$105 = Cons.t(ls$7) in -- #548
//│     let x$106 = Cons.h(ls$7) in -- #547
//│     let* (x$107) = length(x$105) in -- #546
//│     let x$108 = +(1,x$107) in -- #545
//│     jump j$15(x$108) -- #544
//│   Nil =>
//│     jump j$15(0) -- #550
//│ )
//│ Def(40, j$15, [x$104], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$104 -- #528
//│ )
//│ Def(41, mappend, [xs$2,ys$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$2 of -- #581
//│   Cons =>
//│     let x$110 = Cons.t(xs$2) in -- #578
//│     let x$111 = Cons.h(xs$2) in -- #577
//│     let* (x$112) = mappend(x$110,ys$2) in -- #576
//│     let x$113 = Cons(x$111,x$112) in -- #575
//│     jump j$16(x$113) -- #574
//│   Nil =>
//│     jump j$16(ys$2) -- #580
//│ )
//│ Def(42, j$16, [x$109], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$109 -- #553
//│ )
//│ Def(43, sum, [ls$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$114) = sumAux(ls$8,0) in -- #589
//│ x$114 -- #588
//│ )
//│ Def(44, sumAux, [ls$9,a$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$9 of -- #616
//│   Nil =>
//│     jump j$17(a$2) -- #593
//│   Cons =>
//│     let x$116 = Cons.t(ls$9) in -- #615
//│     let x$117 = Cons.h(ls$9) in -- #614
//│     let x$118 = +(a$2,x$117) in -- #613
//│     let* (x$119) = sumAux(x$116,x$118) in -- #612
//│     jump j$17(x$119) -- #611
//│ )
//│ Def(45, j$17, [x$115], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$115 -- #591
//│ )
//│ Def(46, atIndex, [n$1,ls$10], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$120 = <(n$1,0) in -- #667
//│ if x$120 -- #666
//│   true =>
//│     let* (x$122) = error() in -- #625
//│     jump j$18(x$122) -- #624
//│   false =>
//│     case ls$10 of -- #665
//│       Cons =>
//│         let x$124 = Cons.t(ls$10) in -- #659
//│         let x$125 = Cons.h(ls$10) in -- #658
//│         let x$126 = ==(n$1,0) in -- #657
//│         if x$126 -- #656
//│           true =>
//│             jump j$20(x$125) -- #643
//│           false =>
//│             let x$128 = -(n$1,1) in -- #655
//│             let* (x$129) = atIndex(x$128,x$124) in -- #654
//│             jump j$20(x$129) -- #653
//│       Nil =>
//│         let* (x$130) = error() in -- #664
//│         jump j$19(x$130) -- #663
//│ )
//│ Def(47, j$18, [x$121], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$121 -- #620
//│ )
//│ Def(48, j$19, [x$123], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$18(x$123) -- #628
//│ )
//│ Def(49, j$20, [x$127], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$19(x$127) -- #641
//│ )
//│ Def(50, concat, [lss$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case lss$0 of -- #697
//│   Cons =>
//│     let x$132 = Cons.t(lss$0) in -- #693
//│     let x$133 = Cons.h(lss$0) in -- #692
//│     let* (x$134) = concat(x$132) in -- #691
//│     let* (x$135) = mappend(x$133,x$134) in -- #690
//│     jump j$21(x$135) -- #689
//│   Nil =>
//│     let x$136 = Nil() in -- #696
//│     jump j$21(x$136) -- #695
//│ )
//│ Def(51, j$21, [x$131], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$131 -- #669
//│ )
//│ Def(52, reverse, [ls$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$137 = Nil() in -- #706
//│ let* (x$138) = reverse_helper(ls$11,x$137) in -- #705
//│ x$138 -- #704
//│ )
//│ Def(53, reverse_helper, [ls$12,a$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$12 of -- #736
//│   Cons =>
//│     let x$140 = Cons.t(ls$12) in -- #733
//│     let x$141 = Cons.h(ls$12) in -- #732
//│     let x$142 = Cons(x$141,a$3) in -- #731
//│     let* (x$143) = reverse_helper(x$140,x$142) in -- #730
//│     jump j$22(x$143) -- #729
//│   Nil =>
//│     jump j$22(a$3) -- #735
//│ )
//│ Def(54, j$22, [x$139], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$139 -- #708
//│ )
//│ Def(55, const10000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$144) = z_of_int(10000) in -- #742
//│ x$144 -- #741
//│ )
//│ Def(56, f1, [f1_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f1_arg1$0 of -- #772
//│   Pair2 =>
//│     let x$146 = Pair2.y(f1_arg1$0) in -- #771
//│     let x$147 = Pair2.x(f1_arg1$0) in -- #770
//│     let* (x$148) = gcdE(x$147,x$146) in -- #769
//│     let x$149 = Pair3(x$147,x$146,x$148) in -- #768
//│     jump j$23(x$149) -- #767
//│ )
//│ Def(57, j$23, [x$145], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$145 -- #744
//│ )
//│ Def(58, quotRem, [quotRem_arg1$0,quotRem_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$150) = z_div(quotRem_arg1$0,quotRem_arg2$0) in -- #793
//│ let* (x$151) = z_mod(quotRem_arg1$0,quotRem_arg2$0) in -- #792
//│ let x$152 = Pair2(x$150,x$151) in -- #791
//│ x$152 -- #790
//│ )
//│ Def(59, max', [max'_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case max'_arg1$0 of -- #859
//│   Cons =>
//│     let x$154 = Cons.t(max'_arg1$0) in -- #858
//│     let x$155 = Cons.h(max'_arg1$0) in -- #857
//│     case x$154 of -- #856
//│       Nil =>
//│         jump j$25(x$155) -- #808
//│       Cons =>
//│         let x$157 = Cons.t(x$154) in -- #855
//│         let x$158 = Cons.h(x$154) in -- #854
//│         let* (x$159) = z_lt(x$158,x$158) in -- #853
//│         if x$159 -- #852
//│           true =>
//│             let x$161 = Cons(x$158,x$157) in -- #838
//│             let* (x$162) = max'(x$161) in -- #837
//│             jump j$26(x$162) -- #836
//│           false =>
//│             let x$163 = Cons(x$158,x$157) in -- #851
//│             let* (x$164) = max'(x$163) in -- #850
//│             jump j$26(x$164) -- #849
//│ )
//│ Def(60, j$24, [x$153], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$153 -- #795
//│ )
//│ Def(61, j$25, [x$156], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$24(x$156) -- #806
//│ )
//│ Def(62, j$26, [x$160], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$25(x$160) -- #825
//│ )
//│ Def(63, g, [g_arg1$0,g_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case g_arg1$0 of -- #995
//│   Pair3 =>
//│     let x$166 = Pair3.z(g_arg1$0) in -- #994
//│     let x$167 = Pair3.y(g_arg1$0) in -- #993
//│     let x$168 = Pair3.x(g_arg1$0) in -- #992
//│     case g_arg2$0 of -- #991
//│       Pair3 =>
//│         let x$170 = Pair3.z(g_arg2$0) in -- #990
//│         let x$171 = Pair3.y(g_arg2$0) in -- #989
//│         let x$172 = Pair3.x(g_arg2$0) in -- #988
//│         let* (x$173) = const0() in -- #987
//│         let* (x$174) = z_equal(x$170,x$173) in -- #986
//│         if x$174 -- #985
//│           true =>
//│             let x$176 = Pair3(x$170,x$172,x$171) in -- #909
//│             jump j$29(x$176) -- #908
//│           false =>
//│             let* (x$177) = quotRem(x$170,x$170) in -- #984
//│             case x$177 of -- #983
//│               Pair2 =>
//│                 let x$179 = Pair2.y(x$177) in -- #982
//│                 let x$180 = Pair2.x(x$177) in -- #981
//│                 let x$181 = Pair3(x$172,x$171,x$170) in -- #980
//│                 let* (x$182) = z_mul(x$180,x$172) in -- #979
//│                 let* (x$183) = z_sub(x$172,x$182) in -- #978
//│                 let* (x$184) = z_mul(x$180,x$171) in -- #977
//│                 let* (x$185) = z_sub(x$171,x$184) in -- #976
//│                 let x$186 = Pair3(x$183,x$185,x$179) in -- #975
//│                 let* (x$187) = g(x$181,x$186) in -- #974
//│                 jump j$30(x$187) -- #973
//│ )
//│ Def(64, j$27, [x$165], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$165 -- #861
//│ )
//│ Def(65, j$28, [x$169], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$27(x$169) -- #876
//│ )
//│ Def(66, j$29, [x$175], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$28(x$175) -- #899
//│ )
//│ Def(67, j$30, [x$178], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$29(x$178) -- #919
//│ )
//│ Def(68, abs, [abs_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$188) = const0() in -- #1022
//│ let* (x$189) = z_lt(abs_arg1$0,x$188) in -- #1021
//│ if x$189 -- #1020
//│   true =>
//│     let* (x$191) = const0() in -- #1017
//│     let* (x$192) = z_sub(x$191,abs_arg1$0) in -- #1016
//│     jump j$31(x$192) -- #1015
//│   false =>
//│     jump j$31(abs_arg1$0) -- #1019
//│ )
//│ Def(69, j$31, [x$190], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$190 -- #1005
//│ )
//│ Def(70, f2, [f2_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f2_arg1$0 of -- #1080
//│   Pair3 =>
//│     let x$194 = Pair3.z(f2_arg1$0) in -- #1079
//│     let x$195 = Pair3.y(f2_arg1$0) in -- #1078
//│     let x$196 = Pair3.x(f2_arg1$0) in -- #1077
//│     case x$194 of -- #1076
//│       Pair3 =>
//│         let x$198 = Pair3.z(x$194) in -- #1075
//│         let x$199 = Pair3.y(x$194) in -- #1074
//│         let x$200 = Pair3.x(x$194) in -- #1073
//│         let* (x$201) = z_add(x$200,x$199) in -- #1072
//│         let* (x$202) = z_add(x$201,x$198) in -- #1071
//│         let* (x$203) = abs(x$202) in -- #1070
//│         jump j$33(x$203) -- #1069
//│ )
//│ Def(71, j$32, [x$193], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$193 -- #1024
//│ )
//│ Def(72, j$33, [x$197], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$32(x$197) -- #1039
//│ )
//│ Def(73, const0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$204) = z_of_int(0) in -- #1086
//│ x$204 -- #1085
//│ )
//│ Def(74, gcdE, [gcdE_arg1$0,gcdE_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$205) = const0() in -- #1152
//│ let* (x$206) = z_equal(gcdE_arg1$0,x$205) in -- #1151
//│ if x$206 -- #1150
//│   true =>
//│     let* (x$208) = const0() in -- #1112
//│     let* (x$209) = const1() in -- #1111
//│     let x$210 = Pair3(gcdE_arg2$0,x$208,x$209) in -- #1110
//│     jump j$34(x$210) -- #1109
//│   false =>
//│     let* (x$211) = const1() in -- #1149
//│     let* (x$212) = const0() in -- #1148
//│     let x$213 = Pair3(x$211,x$212,gcdE_arg1$0) in -- #1147
//│     let* (x$214) = const0() in -- #1146
//│     let* (x$215) = const1() in -- #1145
//│     let x$216 = Pair3(x$214,x$215,gcdE_arg2$0) in -- #1144
//│     let* (x$217) = g(x$213,x$216) in -- #1143
//│     jump j$34(x$217) -- #1142
//│ )
//│ Def(75, j$34, [x$207], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$207 -- #1096
//│ )
//│ Def(76, const1, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$218) = z_of_int(1) in -- #1158
//│ x$218 -- #1157
//│ )
//│ Def(77, const5000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$219) = z_of_int(5000) in -- #1164
//│ x$219 -- #1163
//│ )
//│ Def(78, z_enumFromTo, [z_enumFromTo_arg1$0,z_enumFromTo_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$220) = z_leq(z_enumFromTo_arg1$0,z_enumFromTo_arg2$0) in -- #1202
//│ if x$220 -- #1201
//│   true =>
//│     let* (x$222) = const1() in -- #1197
//│     let* (x$223) = z_add(z_enumFromTo_arg1$0,x$222) in -- #1196
//│     let* (x$224) = z_enumFromTo(x$223,z_enumFromTo_arg2$0) in -- #1195
//│     let x$225 = Cons(z_enumFromTo_arg1$0,x$224) in -- #1194
//│     jump j$35(x$225) -- #1193
//│   false =>
//│     let x$226 = Nil() in -- #1200
//│     jump j$35(x$226) -- #1199
//│ )
//│ Def(79, j$35, [x$221], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$221 -- #1172
//│ )
//│ Def(80, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #1203
//│ )
//│ },
//│ let* (x$227) = main() in -- #1207
//│ x$227 -- #1206)
//│ 
//│ Interpreted:
//│ 0
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Pair2;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_Pair3;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_g;
//│ struct _mls_zipWith;
//│ struct _mls_main;
//│ struct _mls_zip;
//│ struct _mls_j_35;
//│ struct _mls_j_31;
//│ struct _mls_j_9;
//│ struct _mls_concat;
//│ struct _mls_tail;
//│ struct _mls_j_23;
//│ struct _mls_j_21;
//│ struct _mls_z_leq;
//│ struct _mls_j_15;
//│ struct _mls_j_5;
//│ struct _mls_z_equal;
//│ struct _mls_z_geq;
//│ struct _mls_const0;
//│ struct _mls_j_4;
//│ struct _mls_head;
//│ struct _mls_j_1;
//│ struct _mls_take;
//│ struct _mls_j_13;
//│ struct _mls_gcdE;
//│ struct _mls_map;
//│ struct _mls_j_17;
//│ struct _mls_z_add;
//│ struct _mls_j_27;
//│ struct _mls_j_16;
//│ struct _mls_z_mod;
//│ struct _mls_j_24;
//│ struct _mls_length;
//│ struct _mls_j_14;
//│ struct _mls_z_lt;
//│ struct _mls_sum;
//│ struct _mls_const1;
//│ struct _mls_foldr;
//│ struct _mls_z_sub;
//│ struct _mls_j_12;
//│ struct _mls_quotRem;
//│ struct _mls_sumAux;
//│ struct _mls_abs;
//│ struct _mls_j_20;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_j_3;
//│ struct _mls_mappend;
//│ struct _mls_z_of_int;
//│ struct _mls_j_29;
//│ struct _mls_enumFromTo;
//│ struct _mls_j_26;
//│ struct _mls_z_to_int;
//│ struct _mls_j_34;
//│ struct _mls_filter;
//│ struct _mls_max_;
//│ struct _mls_j_6;
//│ struct _mls_j_19;
//│ struct _mls_atIndex;
//│ struct _mls_j_28;
//│ struct _mls_error;
//│ struct _mls_foldl;
//│ struct _mls_j_18;
//│ struct _mls_reverse_helper;
//│ struct _mls_enumFromThenTo;
//│ struct _mls_f1;
//│ struct _mls_f2;
//│ struct _mls_j_10;
//│ struct _mls_j_7;
//│ struct _mls_j_32;
//│ struct _mls_j_33;
//│ struct _mls_reverse;
//│ struct _mls_z_mul;
//│ struct _mls_z_div;
//│ struct _mls_j_25;
//│ struct _mls_j_30;
//│ struct _mls_j_11;
//│ struct _mls_z_enumFromTo;
//│ struct _mls_z_gt;
//│ struct _mls_j_22;
//│ struct _mls_j_8;
//│ struct _mls_const5000;
//│ struct _mls_const10000;
//│ _mlsValue _mls_zipWith(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_error();
//│ _mlsValue _mls_z_equal(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_enumFromTo(_mlsValue, _mlsValue);
//│ _mlsValue _mls_enumFromTo(_mlsValue, _mlsValue);
//│ _mlsValue _mls_reverse(_mlsValue);
//│ _mlsValue _mls_j_35(_mlsValue);
//│ _mlsValue _mls_j_24(_mlsValue);
//│ _mlsValue _mls_j_33(_mlsValue);
//│ _mlsValue _mls_foldr(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_mappend(_mlsValue, _mlsValue);
//│ _mlsValue _mls_sum(_mlsValue);
//│ _mlsValue _mls_j_6(_mlsValue);
//│ _mlsValue _mls_j_17(_mlsValue);
//│ _mlsValue _mls_j_28(_mlsValue);
//│ _mlsValue _mls_zip(_mlsValue, _mlsValue);
//│ _mlsValue _mls_map(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_geq(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_5(_mlsValue);
//│ _mlsValue _mls_tail(_mlsValue);
//│ _mlsValue _mls_j_19(_mlsValue);
//│ _mlsValue _mls_z_add(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_4(_mlsValue);
//│ _mlsValue _mls_const10000();
//│ _mlsValue _mls_j_34(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_14(_mlsValue);
//│ _mlsValue _mls_j_12(_mlsValue);
//│ _mlsValue _mls_j_11(_mlsValue);
//│ _mlsValue _mls_j_9(_mlsValue);
//│ _mlsValue _mls_z_leq(_mlsValue, _mlsValue);
//│ _mlsValue _mls_quotRem(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_mul(_mlsValue, _mlsValue);
//│ _mlsValue _mls_atIndex(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_31(_mlsValue);
//│ _mlsValue _mls_j_25(_mlsValue);
//│ _mlsValue _mls_z_gt(_mlsValue, _mlsValue);
//│ _mlsValue _mls_gcdE(_mlsValue, _mlsValue);
//│ _mlsValue _mls_sumAux(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_26(_mlsValue);
//│ _mlsValue _mls_z_sub(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_29(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_z_to_int(_mlsValue);
//│ _mlsValue _mls_length(_mlsValue);
//│ _mlsValue _mls_f2(_mlsValue);
//│ _mlsValue _mls_foldl(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_const5000();
//│ _mlsValue _mls_j_23(_mlsValue);
//│ _mlsValue _mls_const1();
//│ _mlsValue _mls_concat(_mlsValue);
//│ _mlsValue _mls_j_8(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_j_32(_mlsValue);
//│ _mlsValue _mls_j_30(_mlsValue);
//│ _mlsValue _mls_f1(_mlsValue);
//│ _mlsValue _mls_j_18(_mlsValue);
//│ _mlsValue _mls_max_(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_15(_mlsValue);
//│ _mlsValue _mls_z_mod(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_21(_mlsValue);
//│ _mlsValue _mls_j_10(_mlsValue);
//│ _mlsValue _mls_z_lt(_mlsValue, _mlsValue);
//│ _mlsValue _mls_enumFromThenTo(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_j_27(_mlsValue);
//│ _mlsValue _mls_j_13(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_const0();
//│ _mlsValue _mls_g(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_7(_mlsValue);
//│ _mlsValue _mls_abs(_mlsValue);
//│ _mlsValue _mls_head(_mlsValue);
//│ _mlsValue _mls_z_div(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_20(_mlsValue);
//│ _mlsValue _mls_j_22(_mlsValue);
//│ _mlsValue _mls_reverse_helper(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_16(_mlsValue);
//│ _mlsValue _mls_z_of_int(_mlsValue);
//│ _mlsValue _mls_filter(_mlsValue, _mlsValue);
//│ _mlsValue _mls_take(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Pair2: public _mlsObject {
//│   _mlsValue _mls_x;
//│   _mlsValue _mls_y;
//│   constexpr static inline const char *typeName = "Pair2";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print(); std::printf(", "); this->_mls_y.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x); _mlsValue::destroy(this->_mls_y);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x, _mlsValue _mls_y) { auto _mlsVal = new (std::align_val_t(align)) _mls_Pair2; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x; _mlsVal->_mls_y = _mls_y;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Pair3: public _mlsObject {
//│   _mlsValue _mls_x;
//│   _mlsValue _mls_y;
//│   _mlsValue _mls_z;
//│   constexpr static inline const char *typeName = "Pair3";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print(); std::printf(", "); this->_mls_y.print(); std::printf(", "); this->_mls_z.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x); _mlsValue::destroy(this->_mls_y); _mlsValue::destroy(this->_mls_z);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x, _mlsValue _mls_y, _mlsValue _mls_z) { auto _mlsVal = new (std::align_val_t(align)) _mls_Pair3; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x; _mlsVal->_mls_y = _mls_y; _mlsVal->_mls_z = _mls_z;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_sumAux: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<sumAux>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_sumAux mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_sumAux(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_16: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$16>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_16 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_16(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_leq: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_leq>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_leq mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_leq(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_6: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$6>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_6 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_6(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_13: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$13>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_13 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_13(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_9: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$9>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_9 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_9(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_23: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$23>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_23 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_23(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_33: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$33>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_33 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_33(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_of_int: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_of_int>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_of_int mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_z_of_int(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_equal: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_equal>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_equal mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_equal(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_z_div: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_div>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_div mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_div(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_z_gt: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_gt>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_gt mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_gt(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_19: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$19>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_19 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_19(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_enumFromTo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_enumFromTo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_enumFromTo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_enumFromTo(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_29: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$29>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_29 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_29(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_to_int: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_to_int>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_to_int mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_z_to_int(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_const10000: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<const10000>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_const10000 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_const10000();
//│   }
//│ };
//│ struct _mlsFn__mls_gcdE: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<gcdE>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_gcdE mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_gcdE(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_atIndex: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<atIndex>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_atIndex mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_atIndex(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_5: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$5>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_5 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_5(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_f2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_15: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$15>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_15 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_15(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_11: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$11>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_11 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_11(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_error: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<error>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_error mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_error();
//│   }
//│ };
//│ struct _mlsFn__mls_const0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<const0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_const0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_const0();
//│   }
//│ };
//│ struct _mlsFn__mls_take: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<take>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_take mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_take(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_enumFromTo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<enumFromTo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_enumFromTo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_enumFromTo(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_foldl: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foldl>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foldl mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply3(_mlsValue arg0, _mlsValue arg1, _mlsValue arg2) override{
//│     return _mls_foldl(arg0, arg1, arg2);
//│   }
//│ };
//│ struct _mlsFn__mls_g: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<g>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_g mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_g(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_const1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<const1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_const1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_const1();
//│   }
//│ };
//│ struct _mlsFn__mls_map: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<map>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_map mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_map(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_8: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$8>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_8 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_8(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_10: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$10>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_10 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_10(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_quotRem: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<quotRem>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_quotRem mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_quotRem(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_mappend: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<mappend>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_mappend mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_mappend(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_z_add: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_add>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_add mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_add(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_z_lt: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_lt>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_lt mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_lt(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_17: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$17>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_17 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_17(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_24: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$24>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_24 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_24(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_20: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$20>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_20 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_20(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_mul: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_mul>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_mul mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_mul(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_4: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$4>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_4 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_4(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_28: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$28>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_28 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_28(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_14: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$14>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_14 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_14(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_zipWith: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<zipWith>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_zipWith mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply3(_mlsValue arg0, _mlsValue arg1, _mlsValue arg2) override{
//│     return _mls_zipWith(arg0, arg1, arg2);
//│   }
//│ };
//│ struct _mlsFn__mls_j_30: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$30>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_30 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_30(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_foldr: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foldr>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foldr mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply3(_mlsValue arg0, _mlsValue arg1, _mlsValue arg2) override{
//│     return _mls_foldr(arg0, arg1, arg2);
//│   }
//│ };
//│ struct _mlsFn__mls_j_35: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$35>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_35 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_35(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_abs: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<abs>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_abs mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_abs(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_reverse: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<reverse>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_reverse mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_reverse(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_concat: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<concat>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_concat mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_concat(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_7: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$7>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_7 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_7(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_max_: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<max'>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_max_ mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_max_(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_const5000: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<const5000>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_const5000 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_const5000();
//│   }
//│ };
//│ struct _mlsFn__mls_z_sub: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_sub>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_sub mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_sub(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_25: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$25>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_25 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_25(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_31: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$31>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_31 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_31(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_f1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_z_geq: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_geq>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_geq mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_geq(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_head: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<head>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_head mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_head(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_zip: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<zip>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_zip mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_zip(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_22: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$22>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_22 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_22(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_32: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$32>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_32 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_32(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_27: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$27>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_27 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_27(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_21: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$21>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_21 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_21(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_tail: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<tail>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_tail mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_tail(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_length: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<length>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_length mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_length(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_26: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$26>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_26 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_26(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_12: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$12>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_12 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_12(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_18: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$18>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_18 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_18(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_34: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$34>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_34 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_34(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_filter: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<filter>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_filter mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_filter(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_sum: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<sum>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_sum mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_sum(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ struct _mlsFn__mls_enumFromThenTo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<enumFromThenTo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_enumFromThenTo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply3(_mlsValue arg0, _mlsValue arg1, _mlsValue arg2) override{
//│     return _mls_enumFromThenTo(arg0, arg1, arg2);
//│   }
//│ };
//│ struct _mlsFn__mls_z_mod: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<z_mod>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_z_mod mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_z_mod(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_reverse_helper: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<reverse_helper>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_reverse_helper mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_reverse_helper(arg0, arg1);
//│   }
//│ };
//│ _mlsValue _mls_j_25(_mlsValue _mls_x_156){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_24(_mls_x_156);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_error(){
//│   _mlsValue _mls_retval;
//│   throw std::runtime_error("Error");
//│   auto _mls_x_0 = _mlsValue::never();
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foldr(_mlsValue _mls_f_3, _mlsValue _mls_i_1, _mlsValue _mls_ls_3){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_3)){
//│     auto _mls_x_47 = _mlsValue::cast<_mls_Cons>(_mls_ls_3)->_mls_t;
//│     auto _mls_x_48 = _mlsValue::cast<_mls_Cons>(_mls_ls_3)->_mls_h;
//│     auto _mls_x_49 = _mls_foldr(_mls_f_3, _mls_i_1, _mls_x_47);
//│     auto _mls_x_50 = _mlsCall(_mls_f_3, _mls_x_48, _mls_x_49);
//│     _mls_retval = _mls_j_4(_mls_x_50);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_3)){
//│     _mls_retval = _mls_j_4(_mls_i_1);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_to_int(_mlsValue _mls_x_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = _mls_builtin_z_to_int(_mls_x_3);
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_41){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_41;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_35(_mlsValue _mls_x_221){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_221;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_28(_mlsValue _mls_x_169){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_27(_mls_x_169);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_max_(_mlsValue _mls_max__arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_max__arg1_0)){
//│     auto _mls_x_154 = _mlsValue::cast<_mls_Cons>(_mls_max__arg1_0)->_mls_t;
//│     auto _mls_x_155 = _mlsValue::cast<_mls_Cons>(_mls_max__arg1_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Nil>(_mls_x_154)){
//│       _mls_retval = _mls_j_25(_mls_x_155);
//│     } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_x_154)){
//│       auto _mls_x_157 = _mlsValue::cast<_mls_Cons>(_mls_x_154)->_mls_t;
//│       auto _mls_x_158 = _mlsValue::cast<_mls_Cons>(_mls_x_154)->_mls_h;
//│       auto _mls_x_159 = _mls_z_lt(_mls_x_158, _mls_x_158);
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_159)){
//│         auto _mls_x_161 = _mlsValue::create<_mls_Cons>(_mls_x_158, _mls_x_157);
//│         auto _mls_x_162 = _mls_max_(_mls_x_161);
//│         _mls_retval = _mls_j_26(_mls_x_162);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_159)){
//│         auto _mls_x_163 = _mlsValue::create<_mls_Cons>(_mls_x_158, _mls_x_157);
//│         auto _mls_x_164 = _mls_max_(_mls_x_163);
//│         _mls_retval = _mls_j_26(_mls_x_164);
//│       } else _mlsNonExhaustiveMatch();
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_6(_mlsValue _mls_x_54){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_5(_mls_x_54);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_mul(_mlsValue _mls_x_11, _mlsValue _mls_y_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_builtin_z_mul(_mls_x_11, _mls_y_3);
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_33(_mlsValue _mls_x_197){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_32(_mls_x_197);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_36){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_1(_mls_x_36);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_length(_mlsValue _mls_ls_7){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_7)){
//│     auto _mls_x_105 = _mlsValue::cast<_mls_Cons>(_mls_ls_7)->_mls_t;
//│     auto _mls_x_106 = _mlsValue::cast<_mls_Cons>(_mls_ls_7)->_mls_h;
//│     auto _mls_x_107 = _mls_length(_mls_x_105);
//│     auto _mls_x_108 = (_mlsValue::fromIntLit(1)+_mls_x_107);
//│     _mls_retval = _mls_j_15(_mls_x_108);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_7)){
//│     _mls_retval = _mls_j_15(_mlsValue::fromIntLit(0));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_atIndex(_mlsValue _mls_n_1, _mlsValue _mls_ls_10){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_120 = (_mls_n_1<_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_120)){
//│     auto _mls_x_122 = _mls_error();
//│     _mls_retval = _mls_j_18(_mls_x_122);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_120)){
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_10)){
//│       auto _mls_x_124 = _mlsValue::cast<_mls_Cons>(_mls_ls_10)->_mls_t;
//│       auto _mls_x_125 = _mlsValue::cast<_mls_Cons>(_mls_ls_10)->_mls_h;
//│       auto _mls_x_126 = (_mls_n_1==_mlsValue::fromIntLit(0));
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_126)){
//│         _mls_retval = _mls_j_20(_mls_x_125);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_126)){
//│         auto _mls_x_128 = (_mls_n_1-_mlsValue::fromIntLit(1));
//│         auto _mls_x_129 = _mls_atIndex(_mls_x_128, _mls_x_124);
//│         _mls_retval = _mls_j_20(_mls_x_129);
//│       } else _mlsNonExhaustiveMatch();
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_10)){
//│       auto _mls_x_130 = _mls_error();
//│       _mls_retval = _mls_j_19(_mls_x_130);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_zipWith(_mlsValue _mls_f_4, _mlsValue _mls_xs_1, _mlsValue _mls_ys_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_1)){
//│     auto _mls_x_63 = _mlsValue::cast<_mls_Cons>(_mls_xs_1)->_mls_t;
//│     auto _mls_x_64 = _mlsValue::cast<_mls_Cons>(_mls_xs_1)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ys_1)){
//│       auto _mls_x_66 = _mlsValue::cast<_mls_Cons>(_mls_ys_1)->_mls_t;
//│       auto _mls_x_67 = _mlsValue::cast<_mls_Cons>(_mls_ys_1)->_mls_h;
//│       auto _mls_x_68 = _mlsCall(_mls_f_4, _mls_x_64, _mls_x_67);
//│       auto _mls_x_69 = _mls_zipWith(_mls_f_4, _mls_x_63, _mls_x_66);
//│       auto _mls_x_70 = _mlsValue::create<_mls_Cons>(_mls_x_68, _mls_x_69);
//│       _mls_retval = _mls_j_8(_mls_x_70);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ys_1)){
//│       auto _mls_x_71 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_8(_mls_x_71);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_1)){
//│     auto _mls_x_72 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_7(_mls_x_72);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_11(_mlsValue _mls_x_82){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_82;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_15(_mlsValue _mls_x_104){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_104;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_19(_mlsValue _mls_x_123){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_18(_mls_x_123);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_filter(_mlsValue _mls_f_1, _mlsValue _mls_ls_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_1)){
//│     auto _mls_x_33 = _mlsValue::cast<_mls_Cons>(_mls_ls_1)->_mls_t;
//│     auto _mls_x_34 = _mlsValue::cast<_mls_Cons>(_mls_ls_1)->_mls_h;
//│     auto _mls_x_35 = _mlsCall(_mls_f_1, _mls_x_34);
//│     if (_mlsValue::isValueOf<_mls_True>(_mls_x_35)){
//│       auto _mls_x_37 = _mls_filter(_mls_f_1, _mls_x_33);
//│       auto _mls_x_38 = _mlsValue::create<_mls_Cons>(_mls_x_34, _mls_x_37);
//│       _mls_retval = _mls_j_2(_mls_x_38);
//│     } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_35)){
//│       auto _mls_x_39 = _mls_filter(_mls_f_1, _mls_x_33);
//│       _mls_retval = _mls_j_2(_mls_x_39);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_1)){
//│     auto _mls_x_40 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_1(_mls_x_40);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_tail(_mlsValue _mls_ls_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_5)){
//│     auto _mls_x_78 = _mlsValue::cast<_mls_Cons>(_mls_ls_5)->_mls_t;
//│     auto _mls_x_79 = _mlsValue::cast<_mls_Cons>(_mls_ls_5)->_mls_h;
//│     _mls_retval = _mls_j_10(_mls_x_78);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_5)){
//│     auto _mls_x_80 = _mls_error();
//│     _mls_retval = _mls_j_10(_mls_x_80);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_32(_mlsValue _mls_x_193){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_193;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_enumFromThenTo(_mlsValue _mls_a_1, _mlsValue _mls_t_0, _mlsValue _mls_b_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_87 = (_mls_a_1<=_mls_b_1);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_87)){
//│     auto _mls_x_89 = (_mlsValue::fromIntLit(2)*_mls_t_0);
//│     auto _mls_x_90 = (_mls_x_89-_mls_a_1);
//│     auto _mls_x_91 = _mls_enumFromThenTo(_mls_t_0, _mls_x_90, _mls_b_1);
//│     auto _mls_x_92 = _mlsValue::create<_mls_Cons>(_mls_a_1, _mls_x_91);
//│     _mls_retval = _mls_j_12(_mls_x_92);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_87)){
//│     auto _mls_x_93 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_12(_mls_x_93);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_27(_mlsValue _mls_x_165){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_165;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_mod(_mlsValue _mls_x_13, _mlsValue _mls_y_4){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_14 = _mls_builtin_z_mod(_mls_x_13, _mls_y_4);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_10(_mlsValue _mls_x_77){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_77;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_leq(_mlsValue _mls_x_17, _mlsValue _mls_y_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_18 = _mls_builtin_z_leq(_mls_x_17, _mls_y_6);
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_22(_mlsValue _mls_x_139){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_139;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_25){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_23(_mlsValue _mls_x_145){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_145;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_20(_mlsValue _mls_x_127){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_19(_mls_x_127);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_equal(_mlsValue _mls_x_19, _mlsValue _mls_y_7){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_builtin_z_equal(_mls_x_19, _mls_y_7);
//│   _mls_retval = _mls_x_20;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_lt(_mlsValue _mls_x_15, _mlsValue _mls_y_5){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_builtin_z_lt(_mls_x_15, _mls_y_5);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_18(_mlsValue _mls_x_121){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_121;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_26(_mlsValue _mls_x_160){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_25(_mls_x_160);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_g(_mlsValue _mls_g_arg1_0, _mlsValue _mls_g_arg2_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Pair3>(_mls_g_arg1_0)){
//│     auto _mls_x_166 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg1_0)->_mls_z;
//│     auto _mls_x_167 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg1_0)->_mls_y;
//│     auto _mls_x_168 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg1_0)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Pair3>(_mls_g_arg2_0)){
//│       auto _mls_x_170 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg2_0)->_mls_z;
//│       auto _mls_x_171 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg2_0)->_mls_y;
//│       auto _mls_x_172 = _mlsValue::cast<_mls_Pair3>(_mls_g_arg2_0)->_mls_x;
//│       auto _mls_x_173 = _mls_const0();
//│       auto _mls_x_174 = _mls_z_equal(_mls_x_170, _mls_x_173);
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_174)){
//│         auto _mls_x_176 = _mlsValue::create<_mls_Pair3>(_mls_x_170, _mls_x_172, _mls_x_171);
//│         _mls_retval = _mls_j_29(_mls_x_176);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_174)){
//│         auto _mls_x_177 = _mls_quotRem(_mls_x_170, _mls_x_170);
//│         if (_mlsValue::isValueOf<_mls_Pair2>(_mls_x_177)){
//│           auto _mls_x_179 = _mlsValue::cast<_mls_Pair2>(_mls_x_177)->_mls_y;
//│           auto _mls_x_180 = _mlsValue::cast<_mls_Pair2>(_mls_x_177)->_mls_x;
//│           auto _mls_x_181 = _mlsValue::create<_mls_Pair3>(_mls_x_172, _mls_x_171, _mls_x_170);
//│           auto _mls_x_182 = _mls_z_mul(_mls_x_180, _mls_x_172);
//│           auto _mls_x_183 = _mls_z_sub(_mls_x_172, _mls_x_182);
//│           auto _mls_x_184 = _mls_z_mul(_mls_x_180, _mls_x_171);
//│           auto _mls_x_185 = _mls_z_sub(_mls_x_171, _mls_x_184);
//│           auto _mls_x_186 = _mlsValue::create<_mls_Pair3>(_mls_x_183, _mls_x_185, _mls_x_179);
//│           auto _mls_x_187 = _mls_g(_mls_x_181, _mls_x_186);
//│           _mls_retval = _mls_j_30(_mls_x_187);
//│         } else _mlsNonExhaustiveMatch();
//│       } else _mlsNonExhaustiveMatch();
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_24(_mlsValue _mls_x_153){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_153;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_quotRem(_mlsValue _mls_quotRem_arg1_0, _mlsValue _mls_quotRem_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_150 = _mls_z_div(_mls_quotRem_arg1_0, _mls_quotRem_arg2_0);
//│   auto _mls_x_151 = _mls_z_mod(_mls_quotRem_arg1_0, _mls_quotRem_arg2_0);
//│   auto _mls_x_152 = _mlsValue::create<_mls_Pair2>(_mls_x_150, _mls_x_151);
//│   _mls_retval = _mls_x_152;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_enumFromTo(_mlsValue _mls_z_enumFromTo_arg1_0, _mlsValue _mls_z_enumFromTo_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_220 = _mls_z_leq(_mls_z_enumFromTo_arg1_0, _mls_z_enumFromTo_arg2_0);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_220)){
//│     auto _mls_x_222 = _mls_const1();
//│     auto _mls_x_223 = _mls_z_add(_mls_z_enumFromTo_arg1_0, _mls_x_222);
//│     auto _mls_x_224 = _mls_z_enumFromTo(_mls_x_223, _mls_z_enumFromTo_arg2_0);
//│     auto _mls_x_225 = _mlsValue::create<_mls_Cons>(_mls_z_enumFromTo_arg1_0, _mls_x_224);
//│     _mls_retval = _mls_j_35(_mls_x_225);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_220)){
//│     auto _mls_x_226 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_35(_mls_x_226);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_sum(_mlsValue _mls_ls_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_114 = _mls_sumAux(_mls_ls_8, _mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_114;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_reverse(_mlsValue _mls_ls_11){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_137 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_138 = _mls_reverse_helper(_mls_ls_11, _mls_x_137);
//│   _mls_retval = _mls_x_138;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_34(_mlsValue _mls_x_207){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_207;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_16(_mlsValue _mls_x_109){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_109;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_sumAux(_mlsValue _mls_ls_9, _mlsValue _mls_a_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_9)){
//│     _mls_retval = _mls_j_17(_mls_a_2);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_9)){
//│     auto _mls_x_116 = _mlsValue::cast<_mls_Cons>(_mls_ls_9)->_mls_t;
//│     auto _mls_x_117 = _mlsValue::cast<_mls_Cons>(_mls_ls_9)->_mls_h;
//│     auto _mls_x_118 = (_mls_a_2+_mls_x_117);
//│     auto _mls_x_119 = _mls_sumAux(_mls_x_116, _mls_x_118);
//│     _mls_retval = _mls_j_17(_mls_x_119);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_29(_mlsValue _mls_x_175){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_28(_mls_x_175);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_12(_mlsValue _mls_x_88){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_88;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f2(_mlsValue _mls_f2_arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Pair3>(_mls_f2_arg1_0)){
//│     auto _mls_x_194 = _mlsValue::cast<_mls_Pair3>(_mls_f2_arg1_0)->_mls_z;
//│     auto _mls_x_195 = _mlsValue::cast<_mls_Pair3>(_mls_f2_arg1_0)->_mls_y;
//│     auto _mls_x_196 = _mlsValue::cast<_mls_Pair3>(_mls_f2_arg1_0)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Pair3>(_mls_x_194)){
//│       auto _mls_x_198 = _mlsValue::cast<_mls_Pair3>(_mls_x_194)->_mls_z;
//│       auto _mls_x_199 = _mlsValue::cast<_mls_Pair3>(_mls_x_194)->_mls_y;
//│       auto _mls_x_200 = _mlsValue::cast<_mls_Pair3>(_mls_x_194)->_mls_x;
//│       auto _mls_x_201 = _mls_z_add(_mls_x_200, _mls_x_199);
//│       auto _mls_x_202 = _mls_z_add(_mls_x_201, _mls_x_198);
//│       auto _mls_x_203 = _mls_abs(_mls_x_202);
//│       _mls_retval = _mls_j_33(_mls_x_203);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const5000(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_219 = _mls_z_of_int(_mlsValue::fromIntLit(5000));
//│   _mls_retval = _mls_x_219;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_4(_mlsValue _mls_x_46){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_46;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_concat(_mlsValue _mls_lss_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_lss_0)){
//│     auto _mls_x_132 = _mlsValue::cast<_mls_Cons>(_mls_lss_0)->_mls_t;
//│     auto _mls_x_133 = _mlsValue::cast<_mls_Cons>(_mls_lss_0)->_mls_h;
//│     auto _mls_x_134 = _mls_concat(_mls_x_132);
//│     auto _mls_x_135 = _mls_mappend(_mls_x_133, _mls_x_134);
//│     _mls_retval = _mls_j_21(_mls_x_135);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_lss_0)){
//│     auto _mls_x_136 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_21(_mls_x_136);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const0(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_204 = _mls_z_of_int(_mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_204;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_map(_mlsValue _mls_f_0, _mlsValue _mls_ls_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_0)){
//│     auto _mls_x_26 = _mlsValue::cast<_mls_Cons>(_mls_ls_0)->_mls_t;
//│     auto _mls_x_27 = _mlsValue::cast<_mls_Cons>(_mls_ls_0)->_mls_h;
//│     auto _mls_x_28 = _mlsCall(_mls_f_0, _mls_x_27);
//│     auto _mls_x_29 = _mls_map(_mls_f_0, _mls_x_26);
//│     auto _mls_x_30 = _mlsValue::create<_mls_Cons>(_mls_x_28, _mls_x_29);
//│     _mls_retval = _mls_j_0(_mls_x_30);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_0)){
//│     auto _mls_x_31 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_31);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_enumFromTo(_mlsValue _mls_a_0, _mlsValue _mls_b_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_81 = (_mls_a_0<=_mls_b_0);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_81)){
//│     auto _mls_x_83 = (_mls_a_0+_mlsValue::fromIntLit(1));
//│     auto _mls_x_84 = _mls_enumFromTo(_mls_x_83, _mls_b_0);
//│     auto _mls_x_85 = _mlsValue::create<_mls_Cons>(_mls_a_0, _mls_x_84);
//│     _mls_retval = _mls_j_11(_mls_x_85);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_81)){
//│     auto _mls_x_86 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_11(_mls_x_86);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_31(_mlsValue _mls_x_190){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_190;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_geq(_mlsValue _mls_x_23, _mlsValue _mls_y_9){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_24 = _mls_builtin_z_geq(_mls_x_23, _mls_y_9);
//│   _mls_retval = _mls_x_24;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head(_mlsValue _mls_ls_4){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_4)){
//│     auto _mls_x_74 = _mlsValue::cast<_mls_Cons>(_mls_ls_4)->_mls_t;
//│     auto _mls_x_75 = _mlsValue::cast<_mls_Cons>(_mls_ls_4)->_mls_h;
//│     _mls_retval = _mls_j_9(_mls_x_75);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_4)){
//│     auto _mls_x_76 = _mls_error();
//│     _mls_retval = _mls_j_9(_mls_x_76);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_div(_mlsValue _mls_x_9, _mlsValue _mls_y_2){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mls_builtin_z_div(_mls_x_9, _mls_y_2);
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_14(_mlsValue _mls_x_96){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_13(_mls_x_96);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_5(_mlsValue _mls_x_51){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_51;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_17(_mlsValue _mls_x_115){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_115;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_32){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_32;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_take(_mlsValue _mls_n_0, _mlsValue _mls_ls_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_94 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_94)){
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_6)){
//│       auto _mls_x_97 = _mlsValue::cast<_mls_Cons>(_mls_ls_6)->_mls_t;
//│       auto _mls_x_98 = _mlsValue::cast<_mls_Cons>(_mls_ls_6)->_mls_h;
//│       auto _mls_x_99 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│       auto _mls_x_100 = _mls_take(_mls_x_99, _mls_x_97);
//│       auto _mls_x_101 = _mlsValue::create<_mls_Cons>(_mls_x_98, _mls_x_100);
//│       _mls_retval = _mls_j_14(_mls_x_101);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_6)){
//│       auto _mls_x_102 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_14(_mls_x_102);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_94)){
//│     auto _mls_x_103 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_13(_mls_x_103);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f1(_mlsValue _mls_f1_arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Pair2>(_mls_f1_arg1_0)){
//│     auto _mls_x_146 = _mlsValue::cast<_mls_Pair2>(_mls_f1_arg1_0)->_mls_y;
//│     auto _mls_x_147 = _mlsValue::cast<_mls_Pair2>(_mls_f1_arg1_0)->_mls_x;
//│     auto _mls_x_148 = _mls_gcdE(_mls_x_147, _mls_x_146);
//│     auto _mls_x_149 = _mlsValue::create<_mls_Pair3>(_mls_x_147, _mls_x_146, _mls_x_148);
//│     _mls_retval = _mls_j_23(_mls_x_149);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_abs(_mlsValue _mls_abs_arg1_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_188 = _mls_const0();
//│   auto _mls_x_189 = _mls_z_lt(_mls_abs_arg1_0, _mls_x_188);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_189)){
//│     auto _mls_x_191 = _mls_const0();
//│     auto _mls_x_192 = _mls_z_sub(_mls_x_191, _mls_abs_arg1_0);
//│     _mls_retval = _mls_j_31(_mls_x_192);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_189)){
//│     _mls_retval = _mls_j_31(_mls_abs_arg1_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_reverse_helper(_mlsValue _mls_ls_12, _mlsValue _mls_a_3){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_12)){
//│     auto _mls_x_140 = _mlsValue::cast<_mls_Cons>(_mls_ls_12)->_mls_t;
//│     auto _mls_x_141 = _mlsValue::cast<_mls_Cons>(_mls_ls_12)->_mls_h;
//│     auto _mls_x_142 = _mlsValue::create<_mls_Cons>(_mls_x_141, _mls_a_3);
//│     auto _mls_x_143 = _mls_reverse_helper(_mls_x_140, _mls_x_142);
//│     _mls_retval = _mls_j_22(_mls_x_143);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_12)){
//│     _mls_retval = _mls_j_22(_mls_a_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_21(_mlsValue _mls_x_131){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_131;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_gt(_mlsValue _mls_x_21, _mlsValue _mls_y_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_22 = _mls_builtin_z_gt(_mls_x_21, _mls_y_8);
//│   _mls_retval = _mls_x_22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_7(_mlsValue _mls_x_62){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_62;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_gcdE(_mlsValue _mls_gcdE_arg1_0, _mlsValue _mls_gcdE_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_205 = _mls_const0();
//│   auto _mls_x_206 = _mls_z_equal(_mls_gcdE_arg1_0, _mls_x_205);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_206)){
//│     auto _mls_x_208 = _mls_const0();
//│     auto _mls_x_209 = _mls_const1();
//│     auto _mls_x_210 = _mlsValue::create<_mls_Pair3>(_mls_gcdE_arg2_0, _mls_x_208, _mls_x_209);
//│     _mls_retval = _mls_j_34(_mls_x_210);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_206)){
//│     auto _mls_x_211 = _mls_const1();
//│     auto _mls_x_212 = _mls_const0();
//│     auto _mls_x_213 = _mlsValue::create<_mls_Pair3>(_mls_x_211, _mls_x_212, _mls_gcdE_arg1_0);
//│     auto _mls_x_214 = _mls_const0();
//│     auto _mls_x_215 = _mls_const1();
//│     auto _mls_x_216 = _mlsValue::create<_mls_Pair3>(_mls_x_214, _mls_x_215, _mls_gcdE_arg2_0);
//│     auto _mls_x_217 = _mls_g(_mls_x_213, _mls_x_216);
//│     _mls_retval = _mls_j_34(_mls_x_217);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_13(_mlsValue _mls_x_95){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_95;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_8(_mlsValue _mls_x_65){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_7(_mls_x_65);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foldl(_mlsValue _mls_f_2, _mlsValue _mls_i_0, _mlsValue _mls_ls_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_2)){
//│     auto _mls_x_42 = _mlsValue::cast<_mls_Cons>(_mls_ls_2)->_mls_t;
//│     auto _mls_x_43 = _mlsValue::cast<_mls_Cons>(_mls_ls_2)->_mls_h;
//│     auto _mls_x_44 = _mlsCall(_mls_f_2, _mls_i_0, _mls_x_43);
//│     auto _mls_x_45 = _mls_foldl(_mls_f_2, _mls_x_44, _mls_x_42);
//│     _mls_retval = _mls_j_3(_mls_x_45);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_2)){
//│     _mls_retval = _mls_j_3(_mls_i_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_of_int(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_builtin_z_of_int(_mls_x_1);
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::fromIntLit(0);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_30(_mlsValue _mls_x_178){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_29(_mls_x_178);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_sub(_mlsValue _mls_x_7, _mlsValue _mls_y_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_8 = _mls_builtin_z_sub(_mls_x_7, _mls_y_1);
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const10000(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_144 = _mls_z_of_int(_mlsValue::fromIntLit(10000));
//│   _mls_retval = _mls_x_144;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mappend(_mlsValue _mls_xs_2, _mlsValue _mls_ys_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_2)){
//│     auto _mls_x_110 = _mlsValue::cast<_mls_Cons>(_mls_xs_2)->_mls_t;
//│     auto _mls_x_111 = _mlsValue::cast<_mls_Cons>(_mls_xs_2)->_mls_h;
//│     auto _mls_x_112 = _mls_mappend(_mls_x_110, _mls_ys_2);
//│     auto _mls_x_113 = _mlsValue::create<_mls_Cons>(_mls_x_111, _mls_x_112);
//│     _mls_retval = _mls_j_16(_mls_x_113);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_2)){
//│     _mls_retval = _mls_j_16(_mls_ys_2);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const1(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_218 = _mls_z_of_int(_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_218;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_add(_mlsValue _mls_x_5, _mlsValue _mls_y_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_6 = _mls_builtin_z_add(_mls_x_5, _mls_y_0);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_9(_mlsValue _mls_x_73){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_73;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_zip(_mlsValue _mls_xs_0, _mlsValue _mls_ys_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_0)){
//│     auto _mls_x_52 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_t;
//│     auto _mls_x_53 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ys_0)){
//│       auto _mls_x_55 = _mlsValue::cast<_mls_Cons>(_mls_ys_0)->_mls_t;
//│       auto _mls_x_56 = _mlsValue::cast<_mls_Cons>(_mls_ys_0)->_mls_h;
//│       auto _mls_x_57 = _mlsValue::create<_mls_Pair2>(_mls_x_53, _mls_x_56);
//│       auto _mls_x_58 = _mls_zip(_mls_x_52, _mls_x_55);
//│       auto _mls_x_59 = _mlsValue::create<_mls_Cons>(_mls_x_57, _mls_x_58);
//│       _mls_retval = _mls_j_6(_mls_x_59);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ys_0)){
//│       auto _mls_x_60 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_6(_mls_x_60);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_0)){
//│     auto _mls_x_61 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_5(_mls_x_61);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_227 = _mls_main();
//│   _mls_retval = _mls_x_227;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }

:interpIR
:genCpp
module List
class Cons(h, t) extends List
module Nil extends List
module Option
class Some(x) extends Option
module None extends Option
class Box(inner)
fun map(f, xs) =
  if xs is
    Nil then Nil
    Cons(h, t) then Cons(Box.inner(f)(h), map(f, t))
fun inc(x) = x + 1
fun testMap() =
  let xs = Cons(1, Cons(2, Nil))
  let ys = map(Box(inc), xs)
  ys
testMap()
//│ |#module| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#module| |Nil| |#extends| |List|↵|#module| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#module| |None| |#extends| |Option|↵|#class| |Box|(|inner|)|↵|#fun| |map|(|f|,| |xs|)| |#=|→|#if| |xs| |is|→|Nil| |#then| |Nil|↵|Cons|(|h|,| |t|)| |#then| |Cons|(|Box|.inner|(|f|)|(|h|)|,| |map|(|f|,| |t|)|)|←|←|↵|#fun| |inc|(|x|)| |#=| |x| |+| |1|↵|#fun| |testMap|(||)| |#=|→|#let| |xs| |#=| |Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|↵|#let| |ys| |#=| |map|(|Box|(|inc|)|,| |xs|)|↵|ys|←|↵|testMap|(||)|
//│ Parsed: {module List {}; class Cons(h, t,): List {}; module Nil: List {}; module Option {}; class Some(x,): Option {}; module None: Option {}; class Box(inner,) {}; fun map = (f, xs,) => {if xs is ‹(Nil) then Nil; (Cons(h, t,)) then Cons((Box).inner(f,)(h,), map(f, t,),)›}; fun inc = (x,) => +(x,)(1,); fun testMap = () => {let xs = Cons(1, Cons(2, Nil,),); let ys = map(Box(inc,), xs,); ys}; testMap()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, List, []),ClassInfo(1, Cons, [h,t]),ClassInfo(2, Nil, []),ClassInfo(3, Option, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, []),ClassInfo(6, Box, [inner])}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #39
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #38
//│     let x$3 = Cons.h(xs$0) in -- #37
//│     let x$4 = Box.inner(f$0) in -- #36
//│     let List(x$5) = x$4(x$3) in -- #35
//│     let* (x$6) = map(f$0,x$2) in -- #34
//│     let x$7 = Cons(x$5,x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #43
//│ x$9 -- #42
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #70
//│ let x$11 = Cons(2,x$10) in -- #69
//│ let x$12 = Cons(1,x$11) in -- #68
//│ let x$13 = Box(inc) in -- #67
//│ let* (x$14) = map(x$13,x$12) in -- #66
//│ x$14 -- #65
//│ )
//│ },
//│ let* (x$15) = testMap() in -- #74
//│ x$15 -- #73)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, List, []),ClassInfo(1, Cons, [h,t]),ClassInfo(2, Nil, []),ClassInfo(3, Option, []),ClassInfo(4, Some, [x]),ClassInfo(5, None, []),ClassInfo(6, Box, [inner])}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #39
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #38
//│     let x$3 = Cons.h(xs$0) in -- #37
//│     let x$4 = Box.inner(f$0) in -- #36
//│     let List(x$5) = x$4(x$3) in -- #35
//│     let* (x$6) = map(f$0,x$2) in -- #34
//│     let x$7 = Cons(x$5,x$6) in -- #33
//│     jump j$0(x$7) -- #32
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #43
//│ x$9 -- #42
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #70
//│ let x$11 = Cons(2,x$10) in -- #69
//│ let x$12 = Cons(1,x$11) in -- #68
//│ let x$13 = Box(inc) in -- #67
//│ let* (x$14) = map(x$13,x$12) in -- #66
//│ x$14 -- #65
//│ )
//│ },
//│ let* (x$15) = testMap() in -- #74
//│ x$15 -- #73)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Nil()))
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ struct _mls_Option;
//│ struct _mls_List;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_map;
//│ struct _mls_inc;
//│ struct _mls_testMap;
//│ struct _mls_j_0;
//│ _mlsValue _mls_map(_mlsValue, _mlsValue);
//│ _mlsValue _mls_inc(_mlsValue);
//│ _mlsValue _mls_testMap();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_map: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<map>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_map mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_map(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_inc: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<inc>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_inc mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_inc(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_testMap: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testMap>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testMap mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_testMap();
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_map(_mlsValue _mls_f_0, _mlsValue _mls_xs_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_0)){
//│     auto _mls_x_2 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::cast<_mls_Box>(_mls_f_0)->_mls_inner;
//│     auto _mls_x_5 = _mlsCall(_mls_x_4, _mls_x_3);
//│     auto _mls_x_6 = _mls_map(_mls_f_0, _mls_x_2);
//│     auto _mls_x_7 = _mlsValue::create<_mls_Cons>(_mls_x_5, _mls_x_6);
//│     _mls_retval = _mls_j_0(_mls_x_7);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_inc(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_testMap(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_11 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_10);
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_11);
//│   auto _mls_x_13 = _mlsValue::create<_mls_Box>(_mlsValue::create<_mlsFn__mls_inc>());
//│   auto _mls_x_14 = _mls_map(_mls_x_13, _mls_x_12);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_testMap();
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }


:interpIR
:genCpp
module C
fun testChar(x) =
  if x is
    char"a" then 1
    char"b" then 2
testChar(char"a")
//│ |#module| |C|↵|#fun| |testChar|(|x|)| |#=|→|#if| |x| |is|→|char"a"| |#then| |1|↵|char"b"| |#then| |2|←|←|↵|testChar|(|char"a"|)|
//│ Parsed: {module C {}; fun testChar = (x,) => {if x is ‹(char"a") then 1; (char"b") then 2›}; testChar(char"a",)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #12
//│ x$2 -- #11)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #12
//│ x$2 -- #11)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ struct _mls_testChar;
//│ struct _mls_j_0;
//│ _mlsValue _mls_testChar(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_testChar: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testChar>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testChar mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_testChar(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_testChar(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 97)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 98)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testChar(_mlsValue::fromIntLit(97));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }

:interpIR
:genCpp
module C
fun testMatch(x) =
  if x is
    0 then 1
    1 then 2
    C then 3
testMatch(0)
//│ |#module| |C|↵|#fun| |testMatch|(|x|)| |#=|→|#if| |x| |is|→|0| |#then| |1|↵|1| |#then| |2|↵|C| |#then| |3|←|←|↵|testMatch|(|0|)|
//│ Parsed: {module C {}; fun testMatch = (x,) => {if x is ‹(0) then 1; (1) then 2; (C) then 3›}; testMatch(0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #14
//│ x$2 -- #13)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [])}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #14
//│ x$2 -- #13)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ struct _mls_testMatch;
//│ struct _mls_j_0;
//│ _mlsValue _mls_testMatch(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_testMatch: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<testMatch>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_testMatch mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_testMatch(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_testMatch(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 1)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else if (_mlsValue::isValueOf<_mls_C>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(3));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testMatch(_mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }

:interpIR
:genCpp
class Box(inner) 
fun unbox(x) = Box.inner(x)
fun f() =
  let a = Box(1)
  let b = unbox(a) + 1
  b
f()
//│ |#class| |Box|(|inner|)| |↵|#fun| |unbox|(|x|)| |#=| |Box|.inner|(|x|)|↵|#fun| |f|(||)| |#=|→|#let| |a| |#=| |Box|(|1|)|↵|#let| |b| |#=| |unbox|(|a|)| |+| |1|↵|b|←|↵|f|(||)|
//│ Parsed: {class Box(inner,) {}; fun unbox = (x,) => (Box).inner(x,); fun f = () => {let a = Box(1,); let b = +(unbox(a,),)(1,); b}; f()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Box, [inner])}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #19
//│ let* (x$3) = unbox(x$2) in -- #18
//│ let x$4 = +(x$3,1) in -- #17
//│ x$4 -- #16
//│ )
//│ },
//│ let* (x$5) = f() in -- #23
//│ x$5 -- #22)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Box, [inner])}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #19
//│ let* (x$3) = unbox(x$2) in -- #18
//│ let x$4 = +(x$3,1) in -- #17
//│ x$4 -- #16
//│ )
//│ },
//│ let* (x$5) = f() in -- #23
//│ x$5 -- #22)
//│ 
//│ Interpreted:
//│ 2
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ struct _mls_unbox;
//│ struct _mls_f;
//│ _mlsValue _mls_unbox(_mlsValue);
//│ _mlsValue _mls_f();
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_unbox: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<unbox>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_unbox mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_unbox(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_f();
//│   }
//│ };
//│ _mlsValue _mls_unbox(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = _mlsValue::cast<_mls_Box>(_mls_x_0)->_mls_inner;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mlsValue::create<_mls_Box>(_mlsValue::fromIntLit(1));
//│   auto _mls_x_3 = _mls_unbox(_mls_x_2);
//│   auto _mls_x_4 = (_mls_x_3+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_5 = _mls_f();
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ int main() { auto res = _mlsMain(); res.print(); }
