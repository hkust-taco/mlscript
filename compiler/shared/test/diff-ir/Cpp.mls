:NewParser
:ParseOnly
:UseIR

:interpIR
:genCpp
module True
module False
module List
class Cons(h, t) extends List
module Nil extends List
module Option
class Some(x) extends Option
module None extends Option
class Tuple2(x, y)
class Tuple3(x, y, z)
fun error() =
  builtin("error")
fun z_of_int(x) =
  builtin("z_of_int", x)
fun z_to_int(x) =
  builtin("z_to_int", x)
fun z_add(x, y) =
  builtin("z_add", x, y)
fun z_sub(x, y) =
  builtin("z_sub", x, y)
fun z_div(x, y) =
  builtin("z_div", x, y)
fun z_mul(x, y) =
  builtin("z_mul", x, y)
fun z_mod(x, y) =
  builtin("z_mod", x, y)
fun z_lt(x, y) =
  builtin("z_lt", x, y)
fun z_leq(x, y) =
  builtin("z_leq", x, y)
fun z_equal(x, y) =
  builtin("z_equal", x, y)
fun z_gt(x, y) =
  builtin("z_gt", x, y)
fun z_geq(x, y) =
  builtin("z_geq", x, y)
fun map(f,ls) =
  if ls is
    Cons (h, t) then
      Cons (f(h), map(f,t))
    Nil then
      Nil
fun filter(f, ls) =
  if ls is
    Cons (h, t) then
      if f(h) then
        Cons (h, filter(f, t))
      else
        (filter(f, t))
    Nil then
      Nil
fun foldl(f, i, ls) =
  if ls is
    Cons (h, t) then
      foldl(f, f(i, h), t)
    Nil then
      i
fun foldr(f, i, ls) =
  if ls is
    Cons (h, t) then
      f(h, foldr(f, i, t))
    Nil then
      i
fun zip(xs, ys) =
  if xs is
    Cons (hx, tx) then
      if ys is
        Cons (hy, ty) then
          Cons (Tuple2 (hx, hy), zip(tx, ty))
        Nil then
          Nil
    Nil then
      Nil
fun zipWith(f, xs, ys) =
  if xs is
    Cons (hx, tx) then
      if ys is
        Cons (hy, ty) then
          Cons (f(hx, hy), zipWith(f, tx, ty))
        Nil then
          Nil
    Nil then
      Nil
fun head(ls) =
  if ls is
    Cons (h, t) then
      h
    Nil then
      error()
fun tail(ls) =
  if ls is
    Cons (h, t) then
      t
    Nil then
      error()
fun enumFromTo(a, b) =
  if a <= b then
    Cons (a, enumFromTo(a + 1, b))
  else
    (Nil)
fun enumFromThenTo(a, t, b) =
  if a <= b then
    Cons (a, enumFromThenTo(t, 2 * t - a, b))
  else
    (Nil)
fun take(n, ls) =
  if n > 0 then
    if ls is
      Cons (h, t) then
        Cons (h, take(n - 1, t))
      Nil then
        Nil
  else
    (Nil)
fun length(ls) =
  if ls is
    Cons (h, t) then
      1 + (length(t))
    Nil then
      0
fun mappend(xs, ys) =
  if xs is
    Cons (h, t) then
      Cons (h, mappend(t, ys))
    Nil then
      ys
fun sum(ls) =
  sumAux(ls, 0)
fun sumAux(ls, a) =
  if ls is
    Nil then
      a
    Cons (h, t) then
      sumAux(t, a + h)
fun atIndex(n, ls) =
  if n < 0 then
    error()
  else
    if ls is
      Cons (h, t) then
        if n == 0 then
          h
        else
          (atIndex(n - 1, t))
      Nil then
        error()
fun concat(lss) =
  if lss is
    Cons (h, t) then
      mappend(h, concat(t))
    Nil then
      Nil
fun reverse(ls) =
  reverse_helper(ls, Nil)
fun reverse_helper(ls, a) =
  if ls is
    Cons (h, t) then
      reverse_helper(t, Cons (h, a))
    Nil then
      a
fun const10000() =
  z_of_int(10000)
fun f1(f1_arg1) =
  if f1_arg1 is
    Tuple2 (f1_Tuple2_0, f1_Tuple2_1) then
      Tuple3 (f1_Tuple2_0, f1_Tuple2_1, gcdE(f1_Tuple2_0, f1_Tuple2_1))
fun quotRem(quotRem_arg1, quotRem_arg2) =
  Tuple2 (z_div(quotRem_arg1, quotRem_arg2), z_mod(quotRem_arg1, quotRem_arg2))
fun max'(max'_arg1) =
  if max'_arg1 is
    Cons (max'_Cons_0, max'_Cons_1) then
      if max'_Cons_1 is
        Nil then
          max'_Cons_0
        Cons (max'_Cons_0, max'_Cons_1) then
          if z_lt(max'_Cons_0, max'_Cons_0) then
            max'(Cons (max'_Cons_0, max'_Cons_1))
          else
            (max'(Cons (max'_Cons_0, max'_Cons_1)))
fun g(g_arg1, g_arg2) =
  if g_arg1 is
    Tuple3 (g_Tuple3_0, g_Tuple3_1, g_Tuple3_2) then
      if g_arg2 is
        Tuple3 (g_Tuple3_0, g_Tuple3_1, g_Tuple3_2) then
          if z_equal(g_Tuple3_2, const0()) then
            Tuple3 (g_Tuple3_2, g_Tuple3_0, g_Tuple3_1)
          else
            let matchIdent = quotRem(g_Tuple3_2, g_Tuple3_2)
            if matchIdent is
              Tuple2 (g_Tuple2_0, g_Tuple2_1) then
                g(Tuple3 (g_Tuple3_0, g_Tuple3_1, g_Tuple3_2), Tuple3 (z_sub(g_Tuple3_0, z_mul(g_Tuple2_0, g_Tuple3_0)), z_sub(g_Tuple3_1, z_mul(g_Tuple2_0, g_Tuple3_1)), g_Tuple2_1))
fun abs(abs_arg1) =
  if z_lt(abs_arg1, const0()) then
    z_sub(const0(), abs_arg1)
  else
    abs_arg1
fun f2(f2_arg1) =
  if f2_arg1 is
    Tuple3 (f2_Tuple3_0, f2_Tuple3_1, f2_Tuple3_2) then
      if f2_Tuple3_2 is
        Tuple3 (f2_Tuple3_0, f2_Tuple3_1, f2_Tuple3_2) then
          abs(z_add(z_add(f2_Tuple3_0, f2_Tuple3_1), f2_Tuple3_2))
fun const0() =
  z_of_int(0)
fun gcdE(gcdE_arg1, gcdE_arg2) =
  if z_equal(gcdE_arg1, const0()) then
    Tuple3 (gcdE_arg2, const0(), const1())
  else
    (g(Tuple3 (const1(), const0(), gcdE_arg1), Tuple3 (const0(), const1(), gcdE_arg2)))
fun const1() =
  z_of_int(1)
fun const5000() =
  z_of_int(5000)
fun z_enumFromTo(z_enumFromTo_arg1, z_enumFromTo_arg2) =
  if z_leq(z_enumFromTo_arg1, z_enumFromTo_arg2) then
    Cons (z_enumFromTo_arg1, z_enumFromTo(z_add(z_enumFromTo_arg1, const1()), z_enumFromTo_arg2))
  else
    (Nil)
// fun testGcd_nofib(testGcd_nofib_arg1) =
//   test(testGcd_nofib_arg1)
// fun test(test_arg1) =
//   let ns = z_enumFromTo(const5000(), z_add(const5000(), test_arg1))
//   let ms = z_enumFromTo(const10000()(), z_add(const10000()() + test_arg1))
//   let tripls = map(f1, let listcomp_fun = listcomp_fun_para =>
//     if listcomp_fun_para is
//       Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then
//         let listcomp_fun = listcomp_fun_para =>
//           if listcomp_fun_para is
//             Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then
//               Cons (Tuple2 (listcomp_fun_ls_h, listcomp_fun_ls_h), listcomp_fun(listcomp_fun_ls_t))
//             Nil then
//               listcomp_fun(listcomp_fun_ls_t)
//         listcomp_fun(ms)
//       Nil then
//         Nil
//   listcomp_fun(ns))
//   let rs = map(f2, tripls)
//   max'(rs)
fun main() =
  0
  //testGcd_nofib(primId(z_of_int(400)))
main()
//│ |#module| |True|↵|#module| |False|↵|#module| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#module| |Nil| |#extends| |List|↵|#module| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#module| |None| |#extends| |Option|↵|#class| |Tuple2|(|x|,| |y|)|↵|#class| |Tuple3|(|x|,| |y|,| |z|)|↵|#fun| |error|(||)| |#=|→|builtin|(|"error"|)|←|↵|#fun| |z_of_int|(|x|)| |#=|→|builtin|(|"z_of_int"|,| |x|)|←|↵|#fun| |z_to_int|(|x|)| |#=|→|builtin|(|"z_to_int"|,| |x|)|←|↵|#fun| |z_add|(|x|,| |y|)| |#=|→|builtin|(|"z_add"|,| |x|,| |y|)|←|↵|#fun| |z_sub|(|x|,| |y|)| |#=|→|builtin|(|"z_sub"|,| |x|,| |y|)|←|↵|#fun| |z_div|(|x|,| |y|)| |#=|→|builtin|(|"z_div"|,| |x|,| |y|)|←|↵|#fun| |z_mul|(|x|,| |y|)| |#=|→|builtin|(|"z_mul"|,| |x|,| |y|)|←|↵|#fun| |z_mod|(|x|,| |y|)| |#=|→|builtin|(|"z_mod"|,| |x|,| |y|)|←|↵|#fun| |z_lt|(|x|,| |y|)| |#=|→|builtin|(|"z_lt"|,| |x|,| |y|)|←|↵|#fun| |z_leq|(|x|,| |y|)| |#=|→|builtin|(|"z_leq"|,| |x|,| |y|)|←|↵|#fun| |z_equal|(|x|,| |y|)| |#=|→|builtin|(|"z_equal"|,| |x|,| |y|)|←|↵|#fun| |z_gt|(|x|,| |y|)| |#=|→|builtin|(|"z_gt"|,| |x|,| |y|)|←|↵|#fun| |z_geq|(|x|,| |y|)| |#=|→|builtin|(|"z_geq"|,| |x|,| |y|)|←|↵|#fun| |map|(|f|,|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|f|(|h|)|,| |map|(|f|,|t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |filter|(|f|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|#if| |f|(|h|)| |#then|→|Cons| |(|h|,| |filter|(|f|,| |t|)|)|←|↵|#else|→|(|filter|(|f|,| |t|)|)|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |foldl|(|f|,| |i|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|foldl|(|f|,| |f|(|i|,| |h|)|,| |t|)|←|↵|Nil| |#then|→|i|←|←|←|↵|#fun| |foldr|(|f|,| |i|,| |ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|f|(|h|,| |foldr|(|f|,| |i|,| |t|)|)|←|↵|Nil| |#then|→|i|←|←|←|↵|#fun| |zip|(|xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|hx|,| |tx|)| |#then|→|#if| |ys| |is|→|Cons| |(|hy|,| |ty|)| |#then|→|Cons| |(|Tuple2| |(|hx|,| |hy|)|,| |zip|(|tx|,| |ty|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |zipWith|(|f|,| |xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|hx|,| |tx|)| |#then|→|#if| |ys| |is|→|Cons| |(|hy|,| |ty|)| |#then|→|Cons| |(|f|(|hx|,| |hy|)|,| |zipWith|(|f|,| |tx|,| |ty|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |head|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|h|←|↵|Nil| |#then|→|error|(||)|←|←|←|↵|#fun| |tail|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|t|←|↵|Nil| |#then|→|error|(||)|←|←|←|↵|#fun| |enumFromTo|(|a|,| |b|)| |#=|→|#if| |a| |<=| |b| |#then|→|Cons| |(|a|,| |enumFromTo|(|a| |+| |1|,| |b|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |enumFromThenTo|(|a|,| |t|,| |b|)| |#=|→|#if| |a| |<=| |b| |#then|→|Cons| |(|a|,| |enumFromThenTo|(|t|,| |2| |*| |t| |-| |a|,| |b|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |take|(|n|,| |ls|)| |#=|→|#if| |n| |>| |0| |#then|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|h|,| |take|(|n| |-| |1|,| |t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#else|→|(|Nil|)|←|←|↵|#fun| |length|(|ls|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|1| |+| |(|length|(|t|)|)|←|↵|Nil| |#then|→|0|←|←|←|↵|#fun| |mappend|(|xs|,| |ys|)| |#=|→|#if| |xs| |is|→|Cons| |(|h|,| |t|)| |#then|→|Cons| |(|h|,| |mappend|(|t|,| |ys|)|)|←|↵|Nil| |#then|→|ys|←|←|←|↵|#fun| |sum|(|ls|)| |#=|→|sumAux|(|ls|,| |0|)|←|↵|#fun| |sumAux|(|ls|,| |a|)| |#=|→|#if| |ls| |is|→|Nil| |#then|→|a|←|↵|Cons| |(|h|,| |t|)| |#then|→|sumAux|(|t|,| |a| |+| |h|)|←|←|←|↵|#fun| |atIndex|(|n|,| |ls|)| |#=|→|#if| |n| |<| |0| |#then|→|error|(||)|←|↵|#else|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|#if| |n| |==| |0| |#then|→|h|←|↵|#else|→|(|atIndex|(|n| |-| |1|,| |t|)|)|←|←|↵|Nil| |#then|→|error|(||)|←|←|←|←|↵|#fun| |concat|(|lss|)| |#=|→|#if| |lss| |is|→|Cons| |(|h|,| |t|)| |#then|→|mappend|(|h|,| |concat|(|t|)|)|←|↵|Nil| |#then|→|Nil|←|←|←|↵|#fun| |reverse|(|ls|)| |#=|→|reverse_helper|(|ls|,| |Nil|)|←|↵|#fun| |reverse_helper|(|ls|,| |a|)| |#=|→|#if| |ls| |is|→|Cons| |(|h|,| |t|)| |#then|→|reverse_helper|(|t|,| |Cons| |(|h|,| |a|)|)|←|↵|Nil| |#then|→|a|←|←|←|↵|#fun| |const10000|(||)| |#=|→|z_of_int|(|10000|)|←|↵|#fun| |f1|(|f1_arg1|)| |#=|→|#if| |f1_arg1| |is|→|Tuple2| |(|f1_Tuple2_0|,| |f1_Tuple2_1|)| |#then|→|Tuple3| |(|f1_Tuple2_0|,| |f1_Tuple2_1|,| |gcdE|(|f1_Tuple2_0|,| |f1_Tuple2_1|)|)|←|←|←|↵|#fun| |quotRem|(|quotRem_arg1|,| |quotRem_arg2|)| |#=|→|Tuple2| |(|z_div|(|quotRem_arg1|,| |quotRem_arg2|)|,| |z_mod|(|quotRem_arg1|,| |quotRem_arg2|)|)|←|↵|#fun| |max'|(|max'_arg1|)| |#=|→|#if| |max'_arg1| |is|→|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)| |#then|→|#if| |max'_Cons_1| |is|→|Nil| |#then|→|max'_Cons_0|←|↵|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)| |#then|→|#if| |z_lt|(|max'_Cons_0|,| |max'_Cons_0|)| |#then|→|max'|(|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)|)|←|↵|#else|→|(|max'|(|Cons| |(|max'_Cons_0|,| |max'_Cons_1|)|)|)|←|←|←|←|←|←|↵|#fun| |g|(|g_arg1|,| |g_arg2|)| |#=|→|#if| |g_arg1| |is|→|Tuple3| |(|g_Tuple3_0|,| |g_Tuple3_1|,| |g_Tuple3_2|)| |#then|→|#if| |g_arg2| |is|→|Tuple3| |(|g_Tuple3_0|,| |g_Tuple3_1|,| |g_Tuple3_2|)| |#then|→|#if| |z_equal|(|g_Tuple3_2|,| |const0|(||)|)| |#then|→|Tuple3| |(|g_Tuple3_2|,| |g_Tuple3_0|,| |g_Tuple3_1|)|←|↵|#else|→|#let| |matchIdent| |#=| |quotRem|(|g_Tuple3_2|,| |g_Tuple3_2|)|↵|#if| |matchIdent| |is|→|Tuple2| |(|g_Tuple2_0|,| |g_Tuple2_1|)| |#then|→|g|(|Tuple3| |(|g_Tuple3_0|,| |g_Tuple3_1|,| |g_Tuple3_2|)|,| |Tuple3| |(|z_sub|(|g_Tuple3_0|,| |z_mul|(|g_Tuple2_0|,| |g_Tuple3_0|)|)|,| |z_sub|(|g_Tuple3_1|,| |z_mul|(|g_Tuple2_0|,| |g_Tuple3_1|)|)|,| |g_Tuple2_1|)|)|←|←|←|←|←|←|←|←|↵|#fun| |abs|(|abs_arg1|)| |#=|→|#if| |z_lt|(|abs_arg1|,| |const0|(||)|)| |#then|→|z_sub|(|const0|(||)|,| |abs_arg1|)|←|↵|#else|→|abs_arg1|←|←|↵|#fun| |f2|(|f2_arg1|)| |#=|→|#if| |f2_arg1| |is|→|Tuple3| |(|f2_Tuple3_0|,| |f2_Tuple3_1|,| |f2_Tuple3_2|)| |#then|→|#if| |f2_Tuple3_2| |is|→|Tuple3| |(|f2_Tuple3_0|,| |f2_Tuple3_1|,| |f2_Tuple3_2|)| |#then|→|abs|(|z_add|(|z_add|(|f2_Tuple3_0|,| |f2_Tuple3_1|)|,| |f2_Tuple3_2|)|)|←|←|←|←|←|↵|#fun| |const0|(||)| |#=|→|z_of_int|(|0|)|←|↵|#fun| |gcdE|(|gcdE_arg1|,| |gcdE_arg2|)| |#=|→|#if| |z_equal|(|gcdE_arg1|,| |const0|(||)|)| |#then|→|Tuple3| |(|gcdE_arg2|,| |const0|(||)|,| |const1|(||)|)|←|↵|#else|→|(|g|(|Tuple3| |(|const1|(||)|,| |const0|(||)|,| |gcdE_arg1|)|,| |Tuple3| |(|const0|(||)|,| |const1|(||)|,| |gcdE_arg2|)|)|)|←|←|↵|#fun| |const1|(||)| |#=|→|z_of_int|(|1|)|←|↵|#fun| |const5000|(||)| |#=|→|z_of_int|(|5000|)|←|↵|#fun| |z_enumFromTo|(|z_enumFromTo_arg1|,| |z_enumFromTo_arg2|)| |#=|→|#if| |z_leq|(|z_enumFromTo_arg1|,| |z_enumFromTo_arg2|)| |#then|→|Cons| |(|z_enumFromTo_arg1|,| |z_enumFromTo|(|z_add|(|z_enumFromTo_arg1|,| |const1|(||)|)|,| |z_enumFromTo_arg2|)|)|←|↵|#else|→|(|Nil|)|←|←|↵|/* fun testGcd_nofib(testGcd_nofib_arg1) =*/|↵|/*   test(testGcd_nofib_arg1)*/|↵|/* fun test(test_arg1) =*/|↵|/*   let ns = z_enumFromTo(const5000(), z_add(const5000(), test_arg1))*/|↵|/*   let ms = z_enumFromTo(const10000()(), z_add(const10000()() + test_arg1))*/|↵|/*   let tripls = map(f1, let listcomp_fun = listcomp_fun_para =>*/|↵|/*     if listcomp_fun_para is*/|↵|/*       Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then*/|↵|/*         let listcomp_fun = listcomp_fun_para =>*/|↵|/*           if listcomp_fun_para is*/|↵|/*             Cons (listcomp_fun_ls_h, listcomp_fun_ls_t) then*/|↵|/*               Cons (Tuple2 (listcomp_fun_ls_h, listcomp_fun_ls_h), listcomp_fun(listcomp_fun_ls_t))*/|↵|/*             Nil then*/|↵|/*               listcomp_fun(listcomp_fun_ls_t)*/|↵|/*         listcomp_fun(ms)*/|↵|/*       Nil then*/|↵|/*         Nil*/|↵|/*   listcomp_fun(ns))*/|↵|/*   let rs = map(f2, tripls)*/|↵|/*   max'(rs)*/|↵|#fun| |main|(||)| |#=|→|0|↵|/*testGcd_nofib(primId(z_of_int(400)))*/|←|↵|main|(||)|
//│ Parsed: {module True {}; module False {}; module List {}; class Cons(h, t,): List {}; module Nil: List {}; module Option {}; class Some(x,): Option {}; module None: Option {}; class Tuple2(x, y,) {}; class Tuple3(x, y, z,) {}; fun error = () => {builtin("error",)}; fun z_of_int = (x,) => {builtin("z_of_int", x,)}; fun z_to_int = (x,) => {builtin("z_to_int", x,)}; fun z_add = (x, y,) => {builtin("z_add", x, y,)}; fun z_sub = (x, y,) => {builtin("z_sub", x, y,)}; fun z_div = (x, y,) => {builtin("z_div", x, y,)}; fun z_mul = (x, y,) => {builtin("z_mul", x, y,)}; fun z_mod = (x, y,) => {builtin("z_mod", x, y,)}; fun z_lt = (x, y,) => {builtin("z_lt", x, y,)}; fun z_leq = (x, y,) => {builtin("z_leq", x, y,)}; fun z_equal = (x, y,) => {builtin("z_equal", x, y,)}; fun z_gt = (x, y,) => {builtin("z_gt", x, y,)}; fun z_geq = (x, y,) => {builtin("z_geq", x, y,)}; fun map = (f, ls,) => {if ls is ‹(Cons(h, t,)) then {Cons(f(h,), map(f, t,),)}; (Nil) then {Nil}›}; fun filter = (f, ls,) => {if ls is ‹(Cons(h, t,)) then {if (f(h,)) then {Cons(h, filter(f, t,),)} else {'(' filter(f, t,) ')'}}; (Nil) then {Nil}›}; fun foldl = (f, i, ls,) => {if ls is ‹(Cons(h, t,)) then {foldl(f, f(i, h,), t,)}; (Nil) then {i}›}; fun foldr = (f, i, ls,) => {if ls is ‹(Cons(h, t,)) then {f(h, foldr(f, i, t,),)}; (Nil) then {i}›}; fun zip = (xs, ys,) => {if xs is ‹(Cons(hx, tx,)) then {if ys is ‹(Cons(hy, ty,)) then {Cons(Tuple2(hx, hy,), zip(tx, ty,),)}; (Nil) then {Nil}›}; (Nil) then {Nil}›}; fun zipWith = (f, xs, ys,) => {if xs is ‹(Cons(hx, tx,)) then {if ys is ‹(Cons(hy, ty,)) then {Cons(f(hx, hy,), zipWith(f, tx, ty,),)}; (Nil) then {Nil}›}; (Nil) then {Nil}›}; fun head = (ls,) => {if ls is ‹(Cons(h, t,)) then {h}; (Nil) then {error()}›}; fun tail = (ls,) => {if ls is ‹(Cons(h, t,)) then {t}; (Nil) then {error()}›}; fun enumFromTo = (a, b,) => {if (<=(a,)(b,)) then {Cons(a, enumFromTo(+(a,)(1,), b,),)} else {'(' Nil ')'}}; fun enumFromThenTo = (a, t, b,) => {if (<=(a,)(b,)) then {Cons(a, enumFromThenTo(t, -(*(2,)(t,),)(a,), b,),)} else {'(' Nil ')'}}; fun take = (n, ls,) => {if (>(n,)(0,)) then {if ls is ‹(Cons(h, t,)) then {Cons(h, take(-(n,)(1,), t,),)}; (Nil) then {Nil}›} else {'(' Nil ')'}}; fun length = (ls,) => {if ls is ‹(Cons(h, t,)) then {+(1,)('(' length(t,) ')',)}; (Nil) then {0}›}; fun mappend = (xs, ys,) => {if xs is ‹(Cons(h, t,)) then {Cons(h, mappend(t, ys,),)}; (Nil) then {ys}›}; fun sum = (ls,) => {sumAux(ls, 0,)}; fun sumAux = (ls, a,) => {if ls is ‹(Nil) then {a}; (Cons(h, t,)) then {sumAux(t, +(a,)(h,),)}›}; fun atIndex = (n, ls,) => {if (<(n,)(0,)) then {error()} else {if ls is ‹(Cons(h, t,)) then {if (==(n,)(0,)) then {h} else {'(' atIndex(-(n,)(1,), t,) ')'}}; (Nil) then {error()}›}}; fun concat = (lss,) => {if lss is ‹(Cons(h, t,)) then {mappend(h, concat(t,),)}; (Nil) then {Nil}›}; fun reverse = (ls,) => {reverse_helper(ls, Nil,)}; fun reverse_helper = (ls, a,) => {if ls is ‹(Cons(h, t,)) then {reverse_helper(t, Cons(h, a,),)}; (Nil) then {a}›}; fun const10000 = () => {z_of_int(10000,)}; fun f1 = (f1_arg1,) => {if f1_arg1 is ‹(Tuple2(f1_Tuple2_0, f1_Tuple2_1,)) then {Tuple3(f1_Tuple2_0, f1_Tuple2_1, gcdE(f1_Tuple2_0, f1_Tuple2_1,),)}›}; fun quotRem = (quotRem_arg1, quotRem_arg2,) => {Tuple2(z_div(quotRem_arg1, quotRem_arg2,), z_mod(quotRem_arg1, quotRem_arg2,),)}; fun max' = (max'_arg1,) => {if max'_arg1 is ‹(Cons(max'_Cons_0, max'_Cons_1,)) then {if max'_Cons_1 is ‹(Nil) then {max'_Cons_0}; (Cons(max'_Cons_0, max'_Cons_1,)) then {if (z_lt(max'_Cons_0, max'_Cons_0,)) then {max'(Cons(max'_Cons_0, max'_Cons_1,),)} else {'(' max'(Cons(max'_Cons_0, max'_Cons_1,),) ')'}}›}›}; fun g = (g_arg1, g_arg2,) => {if g_arg1 is ‹(Tuple3(g_Tuple3_0, g_Tuple3_1, g_Tuple3_2,)) then {if g_arg2 is ‹(Tuple3(g_Tuple3_0, g_Tuple3_1, g_Tuple3_2,)) then {if (z_equal(g_Tuple3_2, const0(),)) then {Tuple3(g_Tuple3_2, g_Tuple3_0, g_Tuple3_1,)} else {let matchIdent = quotRem(g_Tuple3_2, g_Tuple3_2,); if matchIdent is ‹(Tuple2(g_Tuple2_0, g_Tuple2_1,)) then {g(Tuple3(g_Tuple3_0, g_Tuple3_1, g_Tuple3_2,), Tuple3(z_sub(g_Tuple3_0, z_mul(g_Tuple2_0, g_Tuple3_0,),), z_sub(g_Tuple3_1, z_mul(g_Tuple2_0, g_Tuple3_1,),), g_Tuple2_1,),)}›}}›}›}; fun abs = (abs_arg1,) => {if (z_lt(abs_arg1, const0(),)) then {z_sub(const0(), abs_arg1,)} else {abs_arg1}}; fun f2 = (f2_arg1,) => {if f2_arg1 is ‹(Tuple3(f2_Tuple3_0, f2_Tuple3_1, f2_Tuple3_2,)) then {if f2_Tuple3_2 is ‹(Tuple3(f2_Tuple3_0, f2_Tuple3_1, f2_Tuple3_2,)) then {abs(z_add(z_add(f2_Tuple3_0, f2_Tuple3_1,), f2_Tuple3_2,),)}›}›}; fun const0 = () => {z_of_int(0,)}; fun gcdE = (gcdE_arg1, gcdE_arg2,) => {if (z_equal(gcdE_arg1, const0(),)) then {Tuple3(gcdE_arg2, const0(), const1(),)} else {'(' g(Tuple3(const1(), const0(), gcdE_arg1,), Tuple3(const0(), const1(), gcdE_arg2,),) ')'}}; fun const1 = () => {z_of_int(1,)}; fun const5000 = () => {z_of_int(5000,)}; fun z_enumFromTo = (z_enumFromTo_arg1, z_enumFromTo_arg2,) => {if (z_leq(z_enumFromTo_arg1, z_enumFromTo_arg2,)) then {Cons(z_enumFromTo_arg1, z_enumFromTo(z_add(z_enumFromTo_arg1, const1(),), z_enumFromTo_arg2,),)} else {'(' Nil ')'}}; fun main = () => {0}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, List, [], parents: , methods:
//│ ),
//│ ClassInfo(3, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(4, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(5, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(6, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(7, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(8, Tuple2, [x,y], parents: , methods:
//│ ),
//│ ClassInfo(9, Tuple3, [x,y,z], parents: , methods:
//│ )}, {
//│ Def(0, error, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$0) = builtin(error) in -- #5
//│ x$0 -- #4
//│ )
//│ Def(1, z_of_int, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$2) = builtin(z_of_int,x$1) in -- #13
//│ x$2 -- #12
//│ )
//│ Def(2, z_to_int, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$4) = builtin(z_to_int,x$3) in -- #21
//│ x$4 -- #20
//│ )
//│ Def(3, z_add, [x$5,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$6) = builtin(z_add,x$5,y$0) in -- #31
//│ x$6 -- #30
//│ )
//│ Def(4, z_sub, [x$7,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$8) = builtin(z_sub,x$7,y$1) in -- #41
//│ x$8 -- #40
//│ )
//│ Def(5, z_div, [x$9,y$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$10) = builtin(z_div,x$9,y$2) in -- #51
//│ x$10 -- #50
//│ )
//│ Def(6, z_mul, [x$11,y$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$12) = builtin(z_mul,x$11,y$3) in -- #61
//│ x$12 -- #60
//│ )
//│ Def(7, z_mod, [x$13,y$4], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$14) = builtin(z_mod,x$13,y$4) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(8, z_lt, [x$15,y$5], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$16) = builtin(z_lt,x$15,y$5) in -- #81
//│ x$16 -- #80
//│ )
//│ Def(9, z_leq, [x$17,y$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$18) = builtin(z_leq,x$17,y$6) in -- #91
//│ x$18 -- #90
//│ )
//│ Def(10, z_equal, [x$19,y$7], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$20) = builtin(z_equal,x$19,y$7) in -- #101
//│ x$20 -- #100
//│ )
//│ Def(11, z_gt, [x$21,y$8], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$22) = builtin(z_gt,x$21,y$8) in -- #111
//│ x$22 -- #110
//│ )
//│ Def(12, z_geq, [x$23,y$9], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$24) = builtin(z_geq,x$23,y$9) in -- #121
//│ x$24 -- #120
//│ )
//│ Def(13, map, [f$0,ls$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$0 of -- #156
//│   Cons =>
//│     let x$26 = Cons.t(ls$0) in -- #152
//│     let x$27 = Cons.h(ls$0) in -- #151
//│     let** (x$28) = f$0(x$27) in -- #150
//│     let* (x$29) = map(f$0,x$26) in -- #149
//│     let x$30 = Cons(x$28,x$29) in -- #148
//│     jump j$0(x$30) -- #147
//│   Nil =>
//│     let x$31 = Nil() in -- #155
//│     jump j$0(x$31) -- #154
//│ )
//│ Def(14, j$0, [x$25], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$25 -- #123
//│ )
//│ Def(15, filter, [f$1,ls$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$1 of -- #203
//│   Cons =>
//│     let x$33 = Cons.t(ls$1) in -- #199
//│     let x$34 = Cons.h(ls$1) in -- #198
//│     let** (x$35) = f$1(x$34) in -- #197
//│     if x$35 -- #196
//│       true =>
//│         let* (x$37) = filter(f$1,x$33) in -- #187
//│         let x$38 = Cons(x$34,x$37) in -- #186
//│         jump j$2(x$38) -- #185
//│       false =>
//│         let* (x$39) = filter(f$1,x$33) in -- #195
//│         jump j$2(x$39) -- #194
//│   Nil =>
//│     let x$40 = Nil() in -- #202
//│     jump j$1(x$40) -- #201
//│ )
//│ Def(16, j$1, [x$32], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$32 -- #158
//│ )
//│ Def(17, j$2, [x$36], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$36) -- #173
//│ )
//│ Def(18, foldl, [f$2,i$0,ls$2], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$2 of -- #235
//│   Cons =>
//│     let x$42 = Cons.t(ls$2) in -- #232
//│     let x$43 = Cons.h(ls$2) in -- #231
//│     let** (x$44) = f$2(i$0,x$43) in -- #230
//│     let* (x$45) = foldl(f$2,x$44,x$42) in -- #229
//│     jump j$3(x$45) -- #228
//│   Nil =>
//│     jump j$3(i$0) -- #234
//│ )
//│ Def(19, j$3, [x$41], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$41 -- #205
//│ )
//│ Def(20, foldr, [f$3,i$1,ls$3], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$3 of -- #267
//│   Cons =>
//│     let x$47 = Cons.t(ls$3) in -- #264
//│     let x$48 = Cons.h(ls$3) in -- #263
//│     let* (x$49) = foldr(f$3,i$1,x$47) in -- #262
//│     let** (x$50) = f$3(x$48,x$49) in -- #261
//│     jump j$4(x$50) -- #260
//│   Nil =>
//│     jump j$4(i$1) -- #266
//│ )
//│ Def(21, j$4, [x$46], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$46 -- #237
//│ )
//│ Def(22, zip, [xs$0,ys$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #320
//│   Cons =>
//│     let x$52 = Cons.t(xs$0) in -- #316
//│     let x$53 = Cons.h(xs$0) in -- #315
//│     case ys$0 of -- #314
//│       Cons =>
//│         let x$55 = Cons.t(ys$0) in -- #310
//│         let x$56 = Cons.h(ys$0) in -- #309
//│         let x$57 = Tuple2(x$53,x$56) in -- #308
//│         let* (x$58) = zip(x$52,x$55) in -- #307
//│         let x$59 = Cons(x$57,x$58) in -- #306
//│         jump j$6(x$59) -- #305
//│       Nil =>
//│         let x$60 = Nil() in -- #313
//│         jump j$6(x$60) -- #312
//│   Nil =>
//│     let x$61 = Nil() in -- #319
//│     jump j$5(x$61) -- #318
//│ )
//│ Def(23, j$5, [x$51], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$51 -- #269
//│ )
//│ Def(24, j$6, [x$54], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$5(x$54) -- #280
//│ )
//│ Def(25, zipWith, [f$4,xs$1,ys$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$1 of -- #376
//│   Cons =>
//│     let x$63 = Cons.t(xs$1) in -- #372
//│     let x$64 = Cons.h(xs$1) in -- #371
//│     case ys$1 of -- #370
//│       Cons =>
//│         let x$66 = Cons.t(ys$1) in -- #366
//│         let x$67 = Cons.h(ys$1) in -- #365
//│         let** (x$68) = f$4(x$64,x$67) in -- #364
//│         let* (x$69) = zipWith(f$4,x$63,x$66) in -- #363
//│         let x$70 = Cons(x$68,x$69) in -- #362
//│         jump j$8(x$70) -- #361
//│       Nil =>
//│         let x$71 = Nil() in -- #369
//│         jump j$8(x$71) -- #368
//│   Nil =>
//│     let x$72 = Nil() in -- #375
//│     jump j$7(x$72) -- #374
//│ )
//│ Def(26, j$7, [x$62], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$62 -- #322
//│ )
//│ Def(27, j$8, [x$65], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$7(x$65) -- #333
//│ )
//│ Def(28, head, [ls$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$4 of -- #395
//│   Cons =>
//│     let x$74 = Cons.t(ls$4) in -- #390
//│     let x$75 = Cons.h(ls$4) in -- #389
//│     jump j$9(x$75) -- #388
//│   Nil =>
//│     let* (x$76) = error() in -- #394
//│     jump j$9(x$76) -- #393
//│ )
//│ Def(29, j$9, [x$73], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$73 -- #378
//│ )
//│ Def(30, tail, [ls$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$5 of -- #414
//│   Cons =>
//│     let x$78 = Cons.t(ls$5) in -- #409
//│     let x$79 = Cons.h(ls$5) in -- #408
//│     jump j$10(x$78) -- #407
//│   Nil =>
//│     let* (x$80) = error() in -- #413
//│     jump j$10(x$80) -- #412
//│ )
//│ Def(31, j$10, [x$77], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$77 -- #397
//│ )
//│ Def(32, enumFromTo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$81 = <=(a$0,b$0) in -- #440
//│ if x$81 -- #439
//│   true =>
//│     let x$83 = +(a$0,1) in -- #435
//│     let* (x$84) = enumFromTo(x$83,b$0) in -- #434
//│     let x$85 = Cons(a$0,x$84) in -- #433
//│     jump j$11(x$85) -- #432
//│   false =>
//│     let x$86 = Nil() in -- #438
//│     jump j$11(x$86) -- #437
//│ )
//│ Def(33, j$11, [x$82], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$82 -- #418
//│ )
//│ Def(34, enumFromThenTo, [a$1,t$0,b$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$87 = <=(a$1,b$1) in -- #471
//│ if x$87 -- #470
//│   true =>
//│     let x$89 = *(2,t$0) in -- #466
//│     let x$90 = -(x$89,a$1) in -- #465
//│     let* (x$91) = enumFromThenTo(t$0,x$90,b$1) in -- #464
//│     let x$92 = Cons(a$1,x$91) in -- #463
//│     jump j$12(x$92) -- #462
//│   false =>
//│     let x$93 = Nil() in -- #469
//│     jump j$12(x$93) -- #468
//│ )
//│ Def(35, j$12, [x$88], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$88 -- #444
//│ )
//│ Def(36, take, [n$0,ls$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$94 = >(n$0,0) in -- #514
//│ if x$94 -- #513
//│   true =>
//│     case ls$6 of -- #509
//│       Cons =>
//│         let x$97 = Cons.t(ls$6) in -- #505
//│         let x$98 = Cons.h(ls$6) in -- #504
//│         let x$99 = -(n$0,1) in -- #503
//│         let* (x$100) = take(x$99,x$97) in -- #502
//│         let x$101 = Cons(x$98,x$100) in -- #501
//│         jump j$14(x$101) -- #500
//│       Nil =>
//│         let x$102 = Nil() in -- #508
//│         jump j$14(x$102) -- #507
//│   false =>
//│     let x$103 = Nil() in -- #512
//│     jump j$13(x$103) -- #511
//│ )
//│ Def(37, j$13, [x$95], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$95 -- #475
//│ )
//│ Def(38, j$14, [x$96], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$13(x$96) -- #478
//│ )
//│ Def(39, length, [ls$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$7 of -- #538
//│   Cons =>
//│     let x$105 = Cons.t(ls$7) in -- #535
//│     let x$106 = Cons.h(ls$7) in -- #534
//│     let* (x$107) = length(x$105) in -- #533
//│     let x$108 = +(1,x$107) in -- #532
//│     jump j$15(x$108) -- #531
//│   Nil =>
//│     jump j$15(0) -- #537
//│ )
//│ Def(40, j$15, [x$104], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$104 -- #516
//│ )
//│ Def(41, mappend, [xs$2,ys$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$2 of -- #567
//│   Cons =>
//│     let x$110 = Cons.t(xs$2) in -- #564
//│     let x$111 = Cons.h(xs$2) in -- #563
//│     let* (x$112) = mappend(x$110,ys$2) in -- #562
//│     let x$113 = Cons(x$111,x$112) in -- #561
//│     jump j$16(x$113) -- #560
//│   Nil =>
//│     jump j$16(ys$2) -- #566
//│ )
//│ Def(42, j$16, [x$109], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$109 -- #540
//│ )
//│ Def(43, sum, [ls$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$114) = sumAux(ls$8,0) in -- #574
//│ x$114 -- #573
//│ )
//│ Def(44, sumAux, [ls$9,a$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$9 of -- #600
//│   Nil =>
//│     jump j$17(a$2) -- #578
//│   Cons =>
//│     let x$116 = Cons.t(ls$9) in -- #599
//│     let x$117 = Cons.h(ls$9) in -- #598
//│     let x$118 = +(a$2,x$117) in -- #597
//│     let* (x$119) = sumAux(x$116,x$118) in -- #596
//│     jump j$17(x$119) -- #595
//│ )
//│ Def(45, j$17, [x$115], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$115 -- #576
//│ )
//│ Def(46, atIndex, [n$1,ls$10], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$120 = <(n$1,0) in -- #648
//│ if x$120 -- #647
//│   true =>
//│     let* (x$122) = error() in -- #608
//│     jump j$18(x$122) -- #607
//│   false =>
//│     case ls$10 of -- #646
//│       Cons =>
//│         let x$124 = Cons.t(ls$10) in -- #641
//│         let x$125 = Cons.h(ls$10) in -- #640
//│         let x$126 = ==(n$1,0) in -- #639
//│         if x$126 -- #638
//│           true =>
//│             jump j$20(x$125) -- #626
//│           false =>
//│             let x$128 = -(n$1,1) in -- #637
//│             let* (x$129) = atIndex(x$128,x$124) in -- #636
//│             jump j$20(x$129) -- #635
//│       Nil =>
//│         let* (x$130) = error() in -- #645
//│         jump j$19(x$130) -- #644
//│ )
//│ Def(47, j$18, [x$121], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$121 -- #604
//│ )
//│ Def(48, j$19, [x$123], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$18(x$123) -- #611
//│ )
//│ Def(49, j$20, [x$127], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$19(x$127) -- #624
//│ )
//│ Def(50, concat, [lss$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case lss$0 of -- #676
//│   Cons =>
//│     let x$132 = Cons.t(lss$0) in -- #672
//│     let x$133 = Cons.h(lss$0) in -- #671
//│     let* (x$134) = concat(x$132) in -- #670
//│     let* (x$135) = mappend(x$133,x$134) in -- #669
//│     jump j$21(x$135) -- #668
//│   Nil =>
//│     let x$136 = Nil() in -- #675
//│     jump j$21(x$136) -- #674
//│ )
//│ Def(51, j$21, [x$131], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$131 -- #650
//│ )
//│ Def(52, reverse, [ls$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$137 = Nil() in -- #684
//│ let* (x$138) = reverse_helper(ls$11,x$137) in -- #683
//│ x$138 -- #682
//│ )
//│ Def(53, reverse_helper, [ls$12,a$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$12 of -- #713
//│   Cons =>
//│     let x$140 = Cons.t(ls$12) in -- #710
//│     let x$141 = Cons.h(ls$12) in -- #709
//│     let x$142 = Cons(x$141,a$3) in -- #708
//│     let* (x$143) = reverse_helper(x$140,x$142) in -- #707
//│     jump j$22(x$143) -- #706
//│   Nil =>
//│     jump j$22(a$3) -- #712
//│ )
//│ Def(54, j$22, [x$139], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$139 -- #686
//│ )
//│ Def(55, const10000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$144) = z_of_int(10000) in -- #718
//│ x$144 -- #717
//│ )
//│ Def(56, f1, [f1_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f1_arg1$0 of -- #747
//│   Tuple2 =>
//│     let x$146 = Tuple2.y(f1_arg1$0) in -- #746
//│     let x$147 = Tuple2.x(f1_arg1$0) in -- #745
//│     let* (x$148) = gcdE(x$147,x$146) in -- #744
//│     let x$149 = Tuple3(x$147,x$146,x$148) in -- #743
//│     jump j$23(x$149) -- #742
//│ )
//│ Def(57, j$23, [x$145], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$145 -- #720
//│ )
//│ Def(58, quotRem, [quotRem_arg1$0,quotRem_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$150) = z_div(quotRem_arg1$0,quotRem_arg2$0) in -- #766
//│ let* (x$151) = z_mod(quotRem_arg1$0,quotRem_arg2$0) in -- #765
//│ let x$152 = Tuple2(x$150,x$151) in -- #764
//│ x$152 -- #763
//│ )
//│ Def(59, max', [max'_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case max'_arg1$0 of -- #829
//│   Cons =>
//│     let x$154 = Cons.t(max'_arg1$0) in -- #828
//│     let x$155 = Cons.h(max'_arg1$0) in -- #827
//│     case x$154 of -- #826
//│       Nil =>
//│         jump j$25(x$155) -- #781
//│       Cons =>
//│         let x$157 = Cons.t(x$154) in -- #825
//│         let x$158 = Cons.h(x$154) in -- #824
//│         let* (x$159) = z_lt(x$158,x$158) in -- #823
//│         if x$159 -- #822
//│           true =>
//│             let x$161 = Cons(x$158,x$157) in -- #809
//│             let* (x$162) = max'(x$161) in -- #808
//│             jump j$26(x$162) -- #807
//│           false =>
//│             let x$163 = Cons(x$158,x$157) in -- #821
//│             let* (x$164) = max'(x$163) in -- #820
//│             jump j$26(x$164) -- #819
//│ )
//│ Def(60, j$24, [x$153], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$153 -- #768
//│ )
//│ Def(61, j$25, [x$156], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$24(x$156) -- #779
//│ )
//│ Def(62, j$26, [x$160], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$25(x$160) -- #797
//│ )
//│ Def(63, g, [g_arg1$0,g_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case g_arg1$0 of -- #957
//│   Tuple3 =>
//│     let x$166 = Tuple3.z(g_arg1$0) in -- #956
//│     let x$167 = Tuple3.y(g_arg1$0) in -- #955
//│     let x$168 = Tuple3.x(g_arg1$0) in -- #954
//│     case g_arg2$0 of -- #953
//│       Tuple3 =>
//│         let x$170 = Tuple3.z(g_arg2$0) in -- #952
//│         let x$171 = Tuple3.y(g_arg2$0) in -- #951
//│         let x$172 = Tuple3.x(g_arg2$0) in -- #950
//│         let* (x$173) = const0() in -- #949
//│         let* (x$174) = z_equal(x$170,x$173) in -- #948
//│         if x$174 -- #947
//│           true =>
//│             let x$176 = Tuple3(x$170,x$172,x$171) in -- #877
//│             jump j$29(x$176) -- #876
//│           false =>
//│             let* (x$177) = quotRem(x$170,x$170) in -- #946
//│             case x$177 of -- #945
//│               Tuple2 =>
//│                 let x$179 = Tuple2.y(x$177) in -- #944
//│                 let x$180 = Tuple2.x(x$177) in -- #943
//│                 let x$181 = Tuple3(x$172,x$171,x$170) in -- #942
//│                 let* (x$182) = z_mul(x$180,x$172) in -- #941
//│                 let* (x$183) = z_sub(x$172,x$182) in -- #940
//│                 let* (x$184) = z_mul(x$180,x$171) in -- #939
//│                 let* (x$185) = z_sub(x$171,x$184) in -- #938
//│                 let x$186 = Tuple3(x$183,x$185,x$179) in -- #937
//│                 let* (x$187) = g(x$181,x$186) in -- #936
//│                 jump j$30(x$187) -- #935
//│ )
//│ Def(64, j$27, [x$165], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$165 -- #831
//│ )
//│ Def(65, j$28, [x$169], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$27(x$169) -- #846
//│ )
//│ Def(66, j$29, [x$175], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$28(x$175) -- #867
//│ )
//│ Def(67, j$30, [x$178], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$29(x$178) -- #886
//│ )
//│ Def(68, abs, [abs_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$188) = const0() in -- #980
//│ let* (x$189) = z_lt(abs_arg1$0,x$188) in -- #979
//│ if x$189 -- #978
//│   true =>
//│     let* (x$191) = const0() in -- #975
//│     let* (x$192) = z_sub(x$191,abs_arg1$0) in -- #974
//│     jump j$31(x$192) -- #973
//│   false =>
//│     jump j$31(abs_arg1$0) -- #977
//│ )
//│ Def(69, j$31, [x$190], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$190 -- #965
//│ )
//│ Def(70, f2, [f2_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f2_arg1$0 of -- #1035
//│   Tuple3 =>
//│     let x$194 = Tuple3.z(f2_arg1$0) in -- #1034
//│     let x$195 = Tuple3.y(f2_arg1$0) in -- #1033
//│     let x$196 = Tuple3.x(f2_arg1$0) in -- #1032
//│     case x$194 of -- #1031
//│       Tuple3 =>
//│         let x$198 = Tuple3.z(x$194) in -- #1030
//│         let x$199 = Tuple3.y(x$194) in -- #1029
//│         let x$200 = Tuple3.x(x$194) in -- #1028
//│         let* (x$201) = z_add(x$200,x$199) in -- #1027
//│         let* (x$202) = z_add(x$201,x$198) in -- #1026
//│         let* (x$203) = abs(x$202) in -- #1025
//│         jump j$33(x$203) -- #1024
//│ )
//│ Def(71, j$32, [x$193], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$193 -- #982
//│ )
//│ Def(72, j$33, [x$197], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$32(x$197) -- #997
//│ )
//│ Def(73, const0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$204) = z_of_int(0) in -- #1040
//│ x$204 -- #1039
//│ )
//│ Def(74, gcdE, [gcdE_arg1$0,gcdE_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$205) = const0() in -- #1097
//│ let* (x$206) = z_equal(gcdE_arg1$0,x$205) in -- #1096
//│ if x$206 -- #1095
//│   true =>
//│     let* (x$208) = const0() in -- #1062
//│     let* (x$209) = const1() in -- #1061
//│     let x$210 = Tuple3(gcdE_arg2$0,x$208,x$209) in -- #1060
//│     jump j$34(x$210) -- #1059
//│   false =>
//│     let* (x$211) = const1() in -- #1094
//│     let* (x$212) = const0() in -- #1093
//│     let x$213 = Tuple3(x$211,x$212,gcdE_arg1$0) in -- #1092
//│     let* (x$214) = const0() in -- #1091
//│     let* (x$215) = const1() in -- #1090
//│     let x$216 = Tuple3(x$214,x$215,gcdE_arg2$0) in -- #1089
//│     let* (x$217) = g(x$213,x$216) in -- #1088
//│     jump j$34(x$217) -- #1087
//│ )
//│ Def(75, j$34, [x$207], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$207 -- #1048
//│ )
//│ Def(76, const1, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$218) = z_of_int(1) in -- #1102
//│ x$218 -- #1101
//│ )
//│ Def(77, const5000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$219) = z_of_int(5000) in -- #1107
//│ x$219 -- #1106
//│ )
//│ Def(78, z_enumFromTo, [z_enumFromTo_arg1$0,z_enumFromTo_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$220) = z_leq(z_enumFromTo_arg1$0,z_enumFromTo_arg2$0) in -- #1141
//│ if x$220 -- #1140
//│   true =>
//│     let* (x$222) = const1() in -- #1136
//│     let* (x$223) = z_add(z_enumFromTo_arg1$0,x$222) in -- #1135
//│     let* (x$224) = z_enumFromTo(x$223,z_enumFromTo_arg2$0) in -- #1134
//│     let x$225 = Cons(z_enumFromTo_arg1$0,x$224) in -- #1133
//│     jump j$35(x$225) -- #1132
//│   false =>
//│     let x$226 = Nil() in -- #1139
//│     jump j$35(x$226) -- #1138
//│ )
//│ Def(79, j$35, [x$221], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$221 -- #1114
//│ )
//│ Def(80, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #1142
//│ )
//│ },
//│ let* (x$227) = main() in -- #1145
//│ x$227 -- #1144)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, List, [], parents: , methods:
//│ ),
//│ ClassInfo(3, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(4, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(5, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(6, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(7, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(8, Tuple2, [x,y], parents: , methods:
//│ ),
//│ ClassInfo(9, Tuple3, [x,y,z], parents: , methods:
//│ )}, {
//│ Def(0, error, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$0) = builtin(error) in -- #5
//│ x$0 -- #4
//│ )
//│ Def(1, z_of_int, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$2) = builtin(z_of_int,x$1) in -- #13
//│ x$2 -- #12
//│ )
//│ Def(2, z_to_int, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$4) = builtin(z_to_int,x$3) in -- #21
//│ x$4 -- #20
//│ )
//│ Def(3, z_add, [x$5,y$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$6) = builtin(z_add,x$5,y$0) in -- #31
//│ x$6 -- #30
//│ )
//│ Def(4, z_sub, [x$7,y$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$8) = builtin(z_sub,x$7,y$1) in -- #41
//│ x$8 -- #40
//│ )
//│ Def(5, z_div, [x$9,y$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$10) = builtin(z_div,x$9,y$2) in -- #51
//│ x$10 -- #50
//│ )
//│ Def(6, z_mul, [x$11,y$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$12) = builtin(z_mul,x$11,y$3) in -- #61
//│ x$12 -- #60
//│ )
//│ Def(7, z_mod, [x$13,y$4], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$14) = builtin(z_mod,x$13,y$4) in -- #71
//│ x$14 -- #70
//│ )
//│ Def(8, z_lt, [x$15,y$5], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$16) = builtin(z_lt,x$15,y$5) in -- #81
//│ x$16 -- #80
//│ )
//│ Def(9, z_leq, [x$17,y$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$18) = builtin(z_leq,x$17,y$6) in -- #91
//│ x$18 -- #90
//│ )
//│ Def(10, z_equal, [x$19,y$7], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$20) = builtin(z_equal,x$19,y$7) in -- #101
//│ x$20 -- #100
//│ )
//│ Def(11, z_gt, [x$21,y$8], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$22) = builtin(z_gt,x$21,y$8) in -- #111
//│ x$22 -- #110
//│ )
//│ Def(12, z_geq, [x$23,y$9], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let** (x$24) = builtin(z_geq,x$23,y$9) in -- #121
//│ x$24 -- #120
//│ )
//│ Def(13, map, [f$0,ls$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$0 of -- #156
//│   Cons =>
//│     let x$26 = Cons.t(ls$0) in -- #152
//│     let x$27 = Cons.h(ls$0) in -- #151
//│     let** (x$28) = f$0(x$27) in -- #150
//│     let* (x$29) = map(f$0,x$26) in -- #149
//│     let x$30 = Cons(x$28,x$29) in -- #148
//│     jump j$0(x$30) -- #147
//│   Nil =>
//│     let x$31 = Nil() in -- #155
//│     jump j$0(x$31) -- #154
//│ )
//│ Def(14, j$0, [x$25], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$25 -- #123
//│ )
//│ Def(15, filter, [f$1,ls$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$1 of -- #203
//│   Cons =>
//│     let x$33 = Cons.t(ls$1) in -- #199
//│     let x$34 = Cons.h(ls$1) in -- #198
//│     let** (x$35) = f$1(x$34) in -- #197
//│     if x$35 -- #196
//│       true =>
//│         let* (x$37) = filter(f$1,x$33) in -- #187
//│         let x$38 = Cons(x$34,x$37) in -- #186
//│         jump j$2(x$38) -- #185
//│       false =>
//│         let* (x$39) = filter(f$1,x$33) in -- #195
//│         jump j$2(x$39) -- #194
//│   Nil =>
//│     let x$40 = Nil() in -- #202
//│     jump j$1(x$40) -- #201
//│ )
//│ Def(16, j$1, [x$32], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$32 -- #158
//│ )
//│ Def(17, j$2, [x$36], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$36) -- #173
//│ )
//│ Def(18, foldl, [f$2,i$0,ls$2], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$2 of -- #235
//│   Cons =>
//│     let x$42 = Cons.t(ls$2) in -- #232
//│     let x$43 = Cons.h(ls$2) in -- #231
//│     let** (x$44) = f$2(i$0,x$43) in -- #230
//│     let* (x$45) = foldl(f$2,x$44,x$42) in -- #229
//│     jump j$3(x$45) -- #228
//│   Nil =>
//│     jump j$3(i$0) -- #234
//│ )
//│ Def(19, j$3, [x$41], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$41 -- #205
//│ )
//│ Def(20, foldr, [f$3,i$1,ls$3], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$3 of -- #267
//│   Cons =>
//│     let x$47 = Cons.t(ls$3) in -- #264
//│     let x$48 = Cons.h(ls$3) in -- #263
//│     let* (x$49) = foldr(f$3,i$1,x$47) in -- #262
//│     let** (x$50) = f$3(x$48,x$49) in -- #261
//│     jump j$4(x$50) -- #260
//│   Nil =>
//│     jump j$4(i$1) -- #266
//│ )
//│ Def(21, j$4, [x$46], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$46 -- #237
//│ )
//│ Def(22, zip, [xs$0,ys$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #320
//│   Cons =>
//│     let x$52 = Cons.t(xs$0) in -- #316
//│     let x$53 = Cons.h(xs$0) in -- #315
//│     case ys$0 of -- #314
//│       Cons =>
//│         let x$55 = Cons.t(ys$0) in -- #310
//│         let x$56 = Cons.h(ys$0) in -- #309
//│         let x$57 = Tuple2(x$53,x$56) in -- #308
//│         let* (x$58) = zip(x$52,x$55) in -- #307
//│         let x$59 = Cons(x$57,x$58) in -- #306
//│         jump j$6(x$59) -- #305
//│       Nil =>
//│         let x$60 = Nil() in -- #313
//│         jump j$6(x$60) -- #312
//│   Nil =>
//│     let x$61 = Nil() in -- #319
//│     jump j$5(x$61) -- #318
//│ )
//│ Def(23, j$5, [x$51], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$51 -- #269
//│ )
//│ Def(24, j$6, [x$54], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$5(x$54) -- #280
//│ )
//│ Def(25, zipWith, [f$4,xs$1,ys$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$1 of -- #376
//│   Cons =>
//│     let x$63 = Cons.t(xs$1) in -- #372
//│     let x$64 = Cons.h(xs$1) in -- #371
//│     case ys$1 of -- #370
//│       Cons =>
//│         let x$66 = Cons.t(ys$1) in -- #366
//│         let x$67 = Cons.h(ys$1) in -- #365
//│         let** (x$68) = f$4(x$64,x$67) in -- #364
//│         let* (x$69) = zipWith(f$4,x$63,x$66) in -- #363
//│         let x$70 = Cons(x$68,x$69) in -- #362
//│         jump j$8(x$70) -- #361
//│       Nil =>
//│         let x$71 = Nil() in -- #369
//│         jump j$8(x$71) -- #368
//│   Nil =>
//│     let x$72 = Nil() in -- #375
//│     jump j$7(x$72) -- #374
//│ )
//│ Def(26, j$7, [x$62], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$62 -- #322
//│ )
//│ Def(27, j$8, [x$65], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$7(x$65) -- #333
//│ )
//│ Def(28, head, [ls$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$4 of -- #395
//│   Cons =>
//│     let x$74 = Cons.t(ls$4) in -- #390
//│     let x$75 = Cons.h(ls$4) in -- #389
//│     jump j$9(x$75) -- #388
//│   Nil =>
//│     let* (x$76) = error() in -- #394
//│     jump j$9(x$76) -- #393
//│ )
//│ Def(29, j$9, [x$73], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$73 -- #378
//│ )
//│ Def(30, tail, [ls$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$5 of -- #414
//│   Cons =>
//│     let x$78 = Cons.t(ls$5) in -- #409
//│     let x$79 = Cons.h(ls$5) in -- #408
//│     jump j$10(x$78) -- #407
//│   Nil =>
//│     let* (x$80) = error() in -- #413
//│     jump j$10(x$80) -- #412
//│ )
//│ Def(31, j$10, [x$77], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$77 -- #397
//│ )
//│ Def(32, enumFromTo, [a$0,b$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$81 = <=(a$0,b$0) in -- #440
//│ if x$81 -- #439
//│   true =>
//│     let x$83 = +(a$0,1) in -- #435
//│     let* (x$84) = enumFromTo(x$83,b$0) in -- #434
//│     let x$85 = Cons(a$0,x$84) in -- #433
//│     jump j$11(x$85) -- #432
//│   false =>
//│     let x$86 = Nil() in -- #438
//│     jump j$11(x$86) -- #437
//│ )
//│ Def(33, j$11, [x$82], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$82 -- #418
//│ )
//│ Def(34, enumFromThenTo, [a$1,t$0,b$1], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$87 = <=(a$1,b$1) in -- #471
//│ if x$87 -- #470
//│   true =>
//│     let x$89 = *(2,t$0) in -- #466
//│     let x$90 = -(x$89,a$1) in -- #465
//│     let* (x$91) = enumFromThenTo(t$0,x$90,b$1) in -- #464
//│     let x$92 = Cons(a$1,x$91) in -- #463
//│     jump j$12(x$92) -- #462
//│   false =>
//│     let x$93 = Nil() in -- #469
//│     jump j$12(x$93) -- #468
//│ )
//│ Def(35, j$12, [x$88], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$88 -- #444
//│ )
//│ Def(36, take, [n$0,ls$6], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$94 = >(n$0,0) in -- #514
//│ if x$94 -- #513
//│   true =>
//│     case ls$6 of -- #509
//│       Cons =>
//│         let x$97 = Cons.t(ls$6) in -- #505
//│         let x$98 = Cons.h(ls$6) in -- #504
//│         let x$99 = -(n$0,1) in -- #503
//│         let* (x$100) = take(x$99,x$97) in -- #502
//│         let x$101 = Cons(x$98,x$100) in -- #501
//│         jump j$14(x$101) -- #500
//│       Nil =>
//│         let x$102 = Nil() in -- #508
//│         jump j$14(x$102) -- #507
//│   false =>
//│     let x$103 = Nil() in -- #512
//│     jump j$13(x$103) -- #511
//│ )
//│ Def(37, j$13, [x$95], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$95 -- #475
//│ )
//│ Def(38, j$14, [x$96], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$13(x$96) -- #478
//│ )
//│ Def(39, length, [ls$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$7 of -- #538
//│   Cons =>
//│     let x$105 = Cons.t(ls$7) in -- #535
//│     let x$106 = Cons.h(ls$7) in -- #534
//│     let* (x$107) = length(x$105) in -- #533
//│     let x$108 = +(1,x$107) in -- #532
//│     jump j$15(x$108) -- #531
//│   Nil =>
//│     jump j$15(0) -- #537
//│ )
//│ Def(40, j$15, [x$104], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$104 -- #516
//│ )
//│ Def(41, mappend, [xs$2,ys$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$2 of -- #567
//│   Cons =>
//│     let x$110 = Cons.t(xs$2) in -- #564
//│     let x$111 = Cons.h(xs$2) in -- #563
//│     let* (x$112) = mappend(x$110,ys$2) in -- #562
//│     let x$113 = Cons(x$111,x$112) in -- #561
//│     jump j$16(x$113) -- #560
//│   Nil =>
//│     jump j$16(ys$2) -- #566
//│ )
//│ Def(42, j$16, [x$109], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$109 -- #540
//│ )
//│ Def(43, sum, [ls$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$114) = sumAux(ls$8,0) in -- #574
//│ x$114 -- #573
//│ )
//│ Def(44, sumAux, [ls$9,a$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$9 of -- #600
//│   Nil =>
//│     jump j$17(a$2) -- #578
//│   Cons =>
//│     let x$116 = Cons.t(ls$9) in -- #599
//│     let x$117 = Cons.h(ls$9) in -- #598
//│     let x$118 = +(a$2,x$117) in -- #597
//│     let* (x$119) = sumAux(x$116,x$118) in -- #596
//│     jump j$17(x$119) -- #595
//│ )
//│ Def(45, j$17, [x$115], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$115 -- #576
//│ )
//│ Def(46, atIndex, [n$1,ls$10], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$120 = <(n$1,0) in -- #648
//│ if x$120 -- #647
//│   true =>
//│     let* (x$122) = error() in -- #608
//│     jump j$18(x$122) -- #607
//│   false =>
//│     case ls$10 of -- #646
//│       Cons =>
//│         let x$124 = Cons.t(ls$10) in -- #641
//│         let x$125 = Cons.h(ls$10) in -- #640
//│         let x$126 = ==(n$1,0) in -- #639
//│         if x$126 -- #638
//│           true =>
//│             jump j$20(x$125) -- #626
//│           false =>
//│             let x$128 = -(n$1,1) in -- #637
//│             let* (x$129) = atIndex(x$128,x$124) in -- #636
//│             jump j$20(x$129) -- #635
//│       Nil =>
//│         let* (x$130) = error() in -- #645
//│         jump j$19(x$130) -- #644
//│ )
//│ Def(47, j$18, [x$121], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$121 -- #604
//│ )
//│ Def(48, j$19, [x$123], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$18(x$123) -- #611
//│ )
//│ Def(49, j$20, [x$127], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$19(x$127) -- #624
//│ )
//│ Def(50, concat, [lss$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case lss$0 of -- #676
//│   Cons =>
//│     let x$132 = Cons.t(lss$0) in -- #672
//│     let x$133 = Cons.h(lss$0) in -- #671
//│     let* (x$134) = concat(x$132) in -- #670
//│     let* (x$135) = mappend(x$133,x$134) in -- #669
//│     jump j$21(x$135) -- #668
//│   Nil =>
//│     let x$136 = Nil() in -- #675
//│     jump j$21(x$136) -- #674
//│ )
//│ Def(51, j$21, [x$131], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$131 -- #650
//│ )
//│ Def(52, reverse, [ls$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$137 = Nil() in -- #684
//│ let* (x$138) = reverse_helper(ls$11,x$137) in -- #683
//│ x$138 -- #682
//│ )
//│ Def(53, reverse_helper, [ls$12,a$3], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case ls$12 of -- #713
//│   Cons =>
//│     let x$140 = Cons.t(ls$12) in -- #710
//│     let x$141 = Cons.h(ls$12) in -- #709
//│     let x$142 = Cons(x$141,a$3) in -- #708
//│     let* (x$143) = reverse_helper(x$140,x$142) in -- #707
//│     jump j$22(x$143) -- #706
//│   Nil =>
//│     jump j$22(a$3) -- #712
//│ )
//│ Def(54, j$22, [x$139], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$139 -- #686
//│ )
//│ Def(55, const10000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$144) = z_of_int(10000) in -- #718
//│ x$144 -- #717
//│ )
//│ Def(56, f1, [f1_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f1_arg1$0 of -- #747
//│   Tuple2 =>
//│     let x$146 = Tuple2.y(f1_arg1$0) in -- #746
//│     let x$147 = Tuple2.x(f1_arg1$0) in -- #745
//│     let* (x$148) = gcdE(x$147,x$146) in -- #744
//│     let x$149 = Tuple3(x$147,x$146,x$148) in -- #743
//│     jump j$23(x$149) -- #742
//│ )
//│ Def(57, j$23, [x$145], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$145 -- #720
//│ )
//│ Def(58, quotRem, [quotRem_arg1$0,quotRem_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$150) = z_div(quotRem_arg1$0,quotRem_arg2$0) in -- #766
//│ let* (x$151) = z_mod(quotRem_arg1$0,quotRem_arg2$0) in -- #765
//│ let x$152 = Tuple2(x$150,x$151) in -- #764
//│ x$152 -- #763
//│ )
//│ Def(59, max', [max'_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case max'_arg1$0 of -- #829
//│   Cons =>
//│     let x$154 = Cons.t(max'_arg1$0) in -- #828
//│     let x$155 = Cons.h(max'_arg1$0) in -- #827
//│     case x$154 of -- #826
//│       Nil =>
//│         jump j$25(x$155) -- #781
//│       Cons =>
//│         let x$157 = Cons.t(x$154) in -- #825
//│         let x$158 = Cons.h(x$154) in -- #824
//│         let* (x$159) = z_lt(x$158,x$158) in -- #823
//│         if x$159 -- #822
//│           true =>
//│             let x$161 = Cons(x$158,x$157) in -- #809
//│             let* (x$162) = max'(x$161) in -- #808
//│             jump j$26(x$162) -- #807
//│           false =>
//│             let x$163 = Cons(x$158,x$157) in -- #821
//│             let* (x$164) = max'(x$163) in -- #820
//│             jump j$26(x$164) -- #819
//│ )
//│ Def(60, j$24, [x$153], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$153 -- #768
//│ )
//│ Def(61, j$25, [x$156], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$24(x$156) -- #779
//│ )
//│ Def(62, j$26, [x$160], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$25(x$160) -- #797
//│ )
//│ Def(63, g, [g_arg1$0,g_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case g_arg1$0 of -- #957
//│   Tuple3 =>
//│     let x$166 = Tuple3.z(g_arg1$0) in -- #956
//│     let x$167 = Tuple3.y(g_arg1$0) in -- #955
//│     let x$168 = Tuple3.x(g_arg1$0) in -- #954
//│     case g_arg2$0 of -- #953
//│       Tuple3 =>
//│         let x$170 = Tuple3.z(g_arg2$0) in -- #952
//│         let x$171 = Tuple3.y(g_arg2$0) in -- #951
//│         let x$172 = Tuple3.x(g_arg2$0) in -- #950
//│         let* (x$173) = const0() in -- #949
//│         let* (x$174) = z_equal(x$170,x$173) in -- #948
//│         if x$174 -- #947
//│           true =>
//│             let x$176 = Tuple3(x$170,x$172,x$171) in -- #877
//│             jump j$29(x$176) -- #876
//│           false =>
//│             let* (x$177) = quotRem(x$170,x$170) in -- #946
//│             case x$177 of -- #945
//│               Tuple2 =>
//│                 let x$179 = Tuple2.y(x$177) in -- #944
//│                 let x$180 = Tuple2.x(x$177) in -- #943
//│                 let x$181 = Tuple3(x$172,x$171,x$170) in -- #942
//│                 let* (x$182) = z_mul(x$180,x$172) in -- #941
//│                 let* (x$183) = z_sub(x$172,x$182) in -- #940
//│                 let* (x$184) = z_mul(x$180,x$171) in -- #939
//│                 let* (x$185) = z_sub(x$171,x$184) in -- #938
//│                 let x$186 = Tuple3(x$183,x$185,x$179) in -- #937
//│                 let* (x$187) = g(x$181,x$186) in -- #936
//│                 jump j$30(x$187) -- #935
//│ )
//│ Def(64, j$27, [x$165], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$165 -- #831
//│ )
//│ Def(65, j$28, [x$169], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$27(x$169) -- #846
//│ )
//│ Def(66, j$29, [x$175], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$28(x$175) -- #867
//│ )
//│ Def(67, j$30, [x$178], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$29(x$178) -- #886
//│ )
//│ Def(68, abs, [abs_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$188) = const0() in -- #980
//│ let* (x$189) = z_lt(abs_arg1$0,x$188) in -- #979
//│ if x$189 -- #978
//│   true =>
//│     let* (x$191) = const0() in -- #975
//│     let* (x$192) = z_sub(x$191,abs_arg1$0) in -- #974
//│     jump j$31(x$192) -- #973
//│   false =>
//│     jump j$31(abs_arg1$0) -- #977
//│ )
//│ Def(69, j$31, [x$190], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$190 -- #965
//│ )
//│ Def(70, f2, [f2_arg1$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case f2_arg1$0 of -- #1035
//│   Tuple3 =>
//│     let x$194 = Tuple3.z(f2_arg1$0) in -- #1034
//│     let x$195 = Tuple3.y(f2_arg1$0) in -- #1033
//│     let x$196 = Tuple3.x(f2_arg1$0) in -- #1032
//│     case x$194 of -- #1031
//│       Tuple3 =>
//│         let x$198 = Tuple3.z(x$194) in -- #1030
//│         let x$199 = Tuple3.y(x$194) in -- #1029
//│         let x$200 = Tuple3.x(x$194) in -- #1028
//│         let* (x$201) = z_add(x$200,x$199) in -- #1027
//│         let* (x$202) = z_add(x$201,x$198) in -- #1026
//│         let* (x$203) = abs(x$202) in -- #1025
//│         jump j$33(x$203) -- #1024
//│ )
//│ Def(71, j$32, [x$193], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$193 -- #982
//│ )
//│ Def(72, j$33, [x$197], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$32(x$197) -- #997
//│ )
//│ Def(73, const0, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$204) = z_of_int(0) in -- #1040
//│ x$204 -- #1039
//│ )
//│ Def(74, gcdE, [gcdE_arg1$0,gcdE_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$205) = const0() in -- #1097
//│ let* (x$206) = z_equal(gcdE_arg1$0,x$205) in -- #1096
//│ if x$206 -- #1095
//│   true =>
//│     let* (x$208) = const0() in -- #1062
//│     let* (x$209) = const1() in -- #1061
//│     let x$210 = Tuple3(gcdE_arg2$0,x$208,x$209) in -- #1060
//│     jump j$34(x$210) -- #1059
//│   false =>
//│     let* (x$211) = const1() in -- #1094
//│     let* (x$212) = const0() in -- #1093
//│     let x$213 = Tuple3(x$211,x$212,gcdE_arg1$0) in -- #1092
//│     let* (x$214) = const0() in -- #1091
//│     let* (x$215) = const1() in -- #1090
//│     let x$216 = Tuple3(x$214,x$215,gcdE_arg2$0) in -- #1089
//│     let* (x$217) = g(x$213,x$216) in -- #1088
//│     jump j$34(x$217) -- #1087
//│ )
//│ Def(75, j$34, [x$207], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$207 -- #1048
//│ )
//│ Def(76, const1, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$218) = z_of_int(1) in -- #1102
//│ x$218 -- #1101
//│ )
//│ Def(77, const5000, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$219) = z_of_int(5000) in -- #1107
//│ x$219 -- #1106
//│ )
//│ Def(78, z_enumFromTo, [z_enumFromTo_arg1$0,z_enumFromTo_arg2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$220) = z_leq(z_enumFromTo_arg1$0,z_enumFromTo_arg2$0) in -- #1141
//│ if x$220 -- #1140
//│   true =>
//│     let* (x$222) = const1() in -- #1136
//│     let* (x$223) = z_add(z_enumFromTo_arg1$0,x$222) in -- #1135
//│     let* (x$224) = z_enumFromTo(x$223,z_enumFromTo_arg2$0) in -- #1134
//│     let x$225 = Cons(z_enumFromTo_arg1$0,x$224) in -- #1133
//│     jump j$35(x$225) -- #1132
//│   false =>
//│     let x$226 = Nil() in -- #1139
//│     jump j$35(x$226) -- #1138
//│ )
//│ Def(79, j$35, [x$221], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$221 -- #1114
//│ )
//│ Def(80, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #1142
//│ )
//│ },
//│ let* (x$227) = main() in -- #1145
//│ x$227 -- #1144)
//│ 
//│ Interpreted:
//│ 0
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Tuple3;
//│ struct _mls_Tuple2;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_zipWith(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_error();
//│ _mlsValue _mls_z_equal(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_enumFromTo(_mlsValue, _mlsValue);
//│ _mlsValue _mls_enumFromTo(_mlsValue, _mlsValue);
//│ _mlsValue _mls_reverse(_mlsValue);
//│ _mlsValue _mls_j_35(_mlsValue);
//│ _mlsValue _mls_j_24(_mlsValue);
//│ _mlsValue _mls_j_33(_mlsValue);
//│ _mlsValue _mls_foldr(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_mappend(_mlsValue, _mlsValue);
//│ _mlsValue _mls_sum(_mlsValue);
//│ _mlsValue _mls_j_6(_mlsValue);
//│ _mlsValue _mls_j_17(_mlsValue);
//│ _mlsValue _mls_j_28(_mlsValue);
//│ _mlsValue _mls_zip(_mlsValue, _mlsValue);
//│ _mlsValue _mls_map(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_geq(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_5(_mlsValue);
//│ _mlsValue _mls_tail(_mlsValue);
//│ _mlsValue _mls_j_19(_mlsValue);
//│ _mlsValue _mls_z_add(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_4(_mlsValue);
//│ _mlsValue _mls_const10000();
//│ _mlsValue _mls_j_34(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_14(_mlsValue);
//│ _mlsValue _mls_j_12(_mlsValue);
//│ _mlsValue _mls_j_11(_mlsValue);
//│ _mlsValue _mls_j_9(_mlsValue);
//│ _mlsValue _mls_z_leq(_mlsValue, _mlsValue);
//│ _mlsValue _mls_quotRem(_mlsValue, _mlsValue);
//│ _mlsValue _mls_z_mul(_mlsValue, _mlsValue);
//│ _mlsValue _mls_atIndex(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_31(_mlsValue);
//│ _mlsValue _mls_j_25(_mlsValue);
//│ _mlsValue _mls_z_gt(_mlsValue, _mlsValue);
//│ _mlsValue _mls_gcdE(_mlsValue, _mlsValue);
//│ _mlsValue _mls_sumAux(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_26(_mlsValue);
//│ _mlsValue _mls_z_sub(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_29(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_z_to_int(_mlsValue);
//│ _mlsValue _mls_length(_mlsValue);
//│ _mlsValue _mls_f2(_mlsValue);
//│ _mlsValue _mls_foldl(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_const5000();
//│ _mlsValue _mls_j_23(_mlsValue);
//│ _mlsValue _mls_const1();
//│ _mlsValue _mls_concat(_mlsValue);
//│ _mlsValue _mls_j_8(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_j_32(_mlsValue);
//│ _mlsValue _mls_j_30(_mlsValue);
//│ _mlsValue _mls_f1(_mlsValue);
//│ _mlsValue _mls_j_18(_mlsValue);
//│ _mlsValue _mls_max_(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_15(_mlsValue);
//│ _mlsValue _mls_z_mod(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_21(_mlsValue);
//│ _mlsValue _mls_j_10(_mlsValue);
//│ _mlsValue _mls_z_lt(_mlsValue, _mlsValue);
//│ _mlsValue _mls_enumFromThenTo(_mlsValue, _mlsValue, _mlsValue);
//│ _mlsValue _mls_j_27(_mlsValue);
//│ _mlsValue _mls_j_13(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_const0();
//│ _mlsValue _mls_g(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_7(_mlsValue);
//│ _mlsValue _mls_abs(_mlsValue);
//│ _mlsValue _mls_head(_mlsValue);
//│ _mlsValue _mls_z_div(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_20(_mlsValue);
//│ _mlsValue _mls_j_22(_mlsValue);
//│ _mlsValue _mls_reverse_helper(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_16(_mlsValue);
//│ _mlsValue _mls_z_of_int(_mlsValue);
//│ _mlsValue _mls_filter(_mlsValue, _mlsValue);
//│ _mlsValue _mls_take(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Tuple3: public _mlsObject {
//│   _mlsValue _mls_x;
//│   _mlsValue _mls_y;
//│   _mlsValue _mls_z;
//│   constexpr static inline const char *typeName = "Tuple3";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print(); std::printf(", "); this->_mls_y.print(); std::printf(", "); this->_mls_z.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x); _mlsValue::destroy(this->_mls_y); _mlsValue::destroy(this->_mls_z);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x, _mlsValue _mls_y, _mlsValue _mls_z) { auto _mlsVal = new (std::align_val_t(align)) _mls_Tuple3; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x; _mlsVal->_mls_y = _mls_y; _mlsVal->_mls_z = _mls_z;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Tuple2: public _mlsObject {
//│   _mlsValue _mls_x;
//│   _mlsValue _mls_y;
//│   constexpr static inline const char *typeName = "Tuple2";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print(); std::printf(", "); this->_mls_y.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x); _mlsValue::destroy(this->_mls_y);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x, _mlsValue _mls_y) { auto _mlsVal = new (std::align_val_t(align)) _mls_Tuple2; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x; _mlsVal->_mls_y = _mls_y;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_25(_mlsValue _mls_x_156){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_24(_mls_x_156);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_error(){
//│   _mlsValue _mls_retval;
//│   throw std::runtime_error("Error");
//│   auto _mls_x_0 = _mlsValue::never();
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foldr(_mlsValue _mls_f_3, _mlsValue _mls_i_1, _mlsValue _mls_ls_3){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_3)){
//│     auto _mls_x_47 = _mlsValue::cast<_mls_Cons>(_mls_ls_3)->_mls_t;
//│     auto _mls_x_48 = _mlsValue::cast<_mls_Cons>(_mls_ls_3)->_mls_h;
//│     auto _mls_x_49 = _mls_foldr(_mls_f_3, _mls_i_1, _mls_x_47);
//│     auto _mls_x_50 = _mlsCall(_mls_f_3, _mls_x_48, _mls_x_49);
//│     _mls_retval = _mls_j_4(_mls_x_50);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_3)){
//│     _mls_retval = _mls_j_4(_mls_i_1);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_to_int(_mlsValue _mls_x_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = _mls_builtin_z_to_int(_mls_x_3);
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_41){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_41;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_35(_mlsValue _mls_x_221){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_221;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_28(_mlsValue _mls_x_169){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_27(_mls_x_169);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_max_(_mlsValue _mls_max__arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_max__arg1_0)){
//│     auto _mls_x_154 = _mlsValue::cast<_mls_Cons>(_mls_max__arg1_0)->_mls_t;
//│     auto _mls_x_155 = _mlsValue::cast<_mls_Cons>(_mls_max__arg1_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Nil>(_mls_x_154)){
//│       _mls_retval = _mls_j_25(_mls_x_155);
//│     } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_x_154)){
//│       auto _mls_x_157 = _mlsValue::cast<_mls_Cons>(_mls_x_154)->_mls_t;
//│       auto _mls_x_158 = _mlsValue::cast<_mls_Cons>(_mls_x_154)->_mls_h;
//│       auto _mls_x_159 = _mls_z_lt(_mls_x_158, _mls_x_158);
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_159)){
//│         auto _mls_x_161 = _mlsValue::create<_mls_Cons>(_mls_x_158, _mls_x_157);
//│         auto _mls_x_162 = _mls_max_(_mls_x_161);
//│         _mls_retval = _mls_j_26(_mls_x_162);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_159)){
//│         auto _mls_x_163 = _mlsValue::create<_mls_Cons>(_mls_x_158, _mls_x_157);
//│         auto _mls_x_164 = _mls_max_(_mls_x_163);
//│         _mls_retval = _mls_j_26(_mls_x_164);
//│       } else _mlsNonExhaustiveMatch();
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_6(_mlsValue _mls_x_54){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_5(_mls_x_54);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_mul(_mlsValue _mls_x_11, _mlsValue _mls_y_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_builtin_z_mul(_mls_x_11, _mls_y_3);
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_33(_mlsValue _mls_x_197){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_32(_mls_x_197);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_36){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_1(_mls_x_36);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_length(_mlsValue _mls_ls_7){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_7)){
//│     auto _mls_x_105 = _mlsValue::cast<_mls_Cons>(_mls_ls_7)->_mls_t;
//│     auto _mls_x_106 = _mlsValue::cast<_mls_Cons>(_mls_ls_7)->_mls_h;
//│     auto _mls_x_107 = _mls_length(_mls_x_105);
//│     auto _mls_x_108 = (_mlsValue::fromIntLit(1)+_mls_x_107);
//│     _mls_retval = _mls_j_15(_mls_x_108);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_7)){
//│     _mls_retval = _mls_j_15(_mlsValue::fromIntLit(0));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_atIndex(_mlsValue _mls_n_1, _mlsValue _mls_ls_10){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_120 = (_mls_n_1<_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_120)){
//│     auto _mls_x_122 = _mls_error();
//│     _mls_retval = _mls_j_18(_mls_x_122);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_120)){
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_10)){
//│       auto _mls_x_124 = _mlsValue::cast<_mls_Cons>(_mls_ls_10)->_mls_t;
//│       auto _mls_x_125 = _mlsValue::cast<_mls_Cons>(_mls_ls_10)->_mls_h;
//│       auto _mls_x_126 = (_mls_n_1==_mlsValue::fromIntLit(0));
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_126)){
//│         _mls_retval = _mls_j_20(_mls_x_125);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_126)){
//│         auto _mls_x_128 = (_mls_n_1-_mlsValue::fromIntLit(1));
//│         auto _mls_x_129 = _mls_atIndex(_mls_x_128, _mls_x_124);
//│         _mls_retval = _mls_j_20(_mls_x_129);
//│       } else _mlsNonExhaustiveMatch();
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_10)){
//│       auto _mls_x_130 = _mls_error();
//│       _mls_retval = _mls_j_19(_mls_x_130);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_zipWith(_mlsValue _mls_f_4, _mlsValue _mls_xs_1, _mlsValue _mls_ys_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_1)){
//│     auto _mls_x_63 = _mlsValue::cast<_mls_Cons>(_mls_xs_1)->_mls_t;
//│     auto _mls_x_64 = _mlsValue::cast<_mls_Cons>(_mls_xs_1)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ys_1)){
//│       auto _mls_x_66 = _mlsValue::cast<_mls_Cons>(_mls_ys_1)->_mls_t;
//│       auto _mls_x_67 = _mlsValue::cast<_mls_Cons>(_mls_ys_1)->_mls_h;
//│       auto _mls_x_68 = _mlsCall(_mls_f_4, _mls_x_64, _mls_x_67);
//│       auto _mls_x_69 = _mls_zipWith(_mls_f_4, _mls_x_63, _mls_x_66);
//│       auto _mls_x_70 = _mlsValue::create<_mls_Cons>(_mls_x_68, _mls_x_69);
//│       _mls_retval = _mls_j_8(_mls_x_70);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ys_1)){
//│       auto _mls_x_71 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_8(_mls_x_71);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_1)){
//│     auto _mls_x_72 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_7(_mls_x_72);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_11(_mlsValue _mls_x_82){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_82;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_15(_mlsValue _mls_x_104){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_104;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_g(_mlsValue _mls_g_arg1_0, _mlsValue _mls_g_arg2_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Tuple3>(_mls_g_arg1_0)){
//│     auto _mls_x_166 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg1_0)->_mls_z;
//│     auto _mls_x_167 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg1_0)->_mls_y;
//│     auto _mls_x_168 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg1_0)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Tuple3>(_mls_g_arg2_0)){
//│       auto _mls_x_170 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg2_0)->_mls_z;
//│       auto _mls_x_171 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg2_0)->_mls_y;
//│       auto _mls_x_172 = _mlsValue::cast<_mls_Tuple3>(_mls_g_arg2_0)->_mls_x;
//│       auto _mls_x_173 = _mls_const0();
//│       auto _mls_x_174 = _mls_z_equal(_mls_x_170, _mls_x_173);
//│       if (_mlsValue::isValueOf<_mls_True>(_mls_x_174)){
//│         auto _mls_x_176 = _mlsValue::create<_mls_Tuple3>(_mls_x_170, _mls_x_172, _mls_x_171);
//│         _mls_retval = _mls_j_29(_mls_x_176);
//│       } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_174)){
//│         auto _mls_x_177 = _mls_quotRem(_mls_x_170, _mls_x_170);
//│         if (_mlsValue::isValueOf<_mls_Tuple2>(_mls_x_177)){
//│           auto _mls_x_179 = _mlsValue::cast<_mls_Tuple2>(_mls_x_177)->_mls_y;
//│           auto _mls_x_180 = _mlsValue::cast<_mls_Tuple2>(_mls_x_177)->_mls_x;
//│           auto _mls_x_181 = _mlsValue::create<_mls_Tuple3>(_mls_x_172, _mls_x_171, _mls_x_170);
//│           auto _mls_x_182 = _mls_z_mul(_mls_x_180, _mls_x_172);
//│           auto _mls_x_183 = _mls_z_sub(_mls_x_172, _mls_x_182);
//│           auto _mls_x_184 = _mls_z_mul(_mls_x_180, _mls_x_171);
//│           auto _mls_x_185 = _mls_z_sub(_mls_x_171, _mls_x_184);
//│           auto _mls_x_186 = _mlsValue::create<_mls_Tuple3>(_mls_x_183, _mls_x_185, _mls_x_179);
//│           auto _mls_x_187 = _mls_g(_mls_x_181, _mls_x_186);
//│           _mls_retval = _mls_j_30(_mls_x_187);
//│         } else _mlsNonExhaustiveMatch();
//│       } else _mlsNonExhaustiveMatch();
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_19(_mlsValue _mls_x_123){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_18(_mls_x_123);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_filter(_mlsValue _mls_f_1, _mlsValue _mls_ls_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_1)){
//│     auto _mls_x_33 = _mlsValue::cast<_mls_Cons>(_mls_ls_1)->_mls_t;
//│     auto _mls_x_34 = _mlsValue::cast<_mls_Cons>(_mls_ls_1)->_mls_h;
//│     auto _mls_x_35 = _mlsCall(_mls_f_1, _mls_x_34);
//│     if (_mlsValue::isValueOf<_mls_True>(_mls_x_35)){
//│       auto _mls_x_37 = _mls_filter(_mls_f_1, _mls_x_33);
//│       auto _mls_x_38 = _mlsValue::create<_mls_Cons>(_mls_x_34, _mls_x_37);
//│       _mls_retval = _mls_j_2(_mls_x_38);
//│     } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_35)){
//│       auto _mls_x_39 = _mls_filter(_mls_f_1, _mls_x_33);
//│       _mls_retval = _mls_j_2(_mls_x_39);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_1)){
//│     auto _mls_x_40 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_1(_mls_x_40);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f2(_mlsValue _mls_f2_arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Tuple3>(_mls_f2_arg1_0)){
//│     auto _mls_x_194 = _mlsValue::cast<_mls_Tuple3>(_mls_f2_arg1_0)->_mls_z;
//│     auto _mls_x_195 = _mlsValue::cast<_mls_Tuple3>(_mls_f2_arg1_0)->_mls_y;
//│     auto _mls_x_196 = _mlsValue::cast<_mls_Tuple3>(_mls_f2_arg1_0)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Tuple3>(_mls_x_194)){
//│       auto _mls_x_198 = _mlsValue::cast<_mls_Tuple3>(_mls_x_194)->_mls_z;
//│       auto _mls_x_199 = _mlsValue::cast<_mls_Tuple3>(_mls_x_194)->_mls_y;
//│       auto _mls_x_200 = _mlsValue::cast<_mls_Tuple3>(_mls_x_194)->_mls_x;
//│       auto _mls_x_201 = _mls_z_add(_mls_x_200, _mls_x_199);
//│       auto _mls_x_202 = _mls_z_add(_mls_x_201, _mls_x_198);
//│       auto _mls_x_203 = _mls_abs(_mls_x_202);
//│       _mls_retval = _mls_j_33(_mls_x_203);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_tail(_mlsValue _mls_ls_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_5)){
//│     auto _mls_x_78 = _mlsValue::cast<_mls_Cons>(_mls_ls_5)->_mls_t;
//│     auto _mls_x_79 = _mlsValue::cast<_mls_Cons>(_mls_ls_5)->_mls_h;
//│     _mls_retval = _mls_j_10(_mls_x_78);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_5)){
//│     auto _mls_x_80 = _mls_error();
//│     _mls_retval = _mls_j_10(_mls_x_80);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_32(_mlsValue _mls_x_193){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_193;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_enumFromThenTo(_mlsValue _mls_a_1, _mlsValue _mls_t_0, _mlsValue _mls_b_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_87 = (_mls_a_1<=_mls_b_1);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_87)){
//│     auto _mls_x_89 = (_mlsValue::fromIntLit(2)*_mls_t_0);
//│     auto _mls_x_90 = (_mls_x_89-_mls_a_1);
//│     auto _mls_x_91 = _mls_enumFromThenTo(_mls_t_0, _mls_x_90, _mls_b_1);
//│     auto _mls_x_92 = _mlsValue::create<_mls_Cons>(_mls_a_1, _mls_x_91);
//│     _mls_retval = _mls_j_12(_mls_x_92);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_87)){
//│     auto _mls_x_93 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_12(_mls_x_93);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_27(_mlsValue _mls_x_165){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_165;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_mod(_mlsValue _mls_x_13, _mlsValue _mls_y_4){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_14 = _mls_builtin_z_mod(_mls_x_13, _mls_y_4);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_10(_mlsValue _mls_x_77){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_77;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_leq(_mlsValue _mls_x_17, _mlsValue _mls_y_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_18 = _mls_builtin_z_leq(_mls_x_17, _mls_y_6);
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_25){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_23(_mlsValue _mls_x_145){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_145;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_20(_mlsValue _mls_x_127){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_19(_mls_x_127);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_equal(_mlsValue _mls_x_19, _mlsValue _mls_y_7){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_builtin_z_equal(_mls_x_19, _mls_y_7);
//│   _mls_retval = _mls_x_20;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_lt(_mlsValue _mls_x_15, _mlsValue _mls_y_5){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_builtin_z_lt(_mls_x_15, _mls_y_5);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_26(_mlsValue _mls_x_160){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_25(_mls_x_160);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_18(_mlsValue _mls_x_121){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_121;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_quotRem(_mlsValue _mls_quotRem_arg1_0, _mlsValue _mls_quotRem_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_150 = _mls_z_div(_mls_quotRem_arg1_0, _mls_quotRem_arg2_0);
//│   auto _mls_x_151 = _mls_z_mod(_mls_quotRem_arg1_0, _mls_quotRem_arg2_0);
//│   auto _mls_x_152 = _mlsValue::create<_mls_Tuple2>(_mls_x_150, _mls_x_151);
//│   _mls_retval = _mls_x_152;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_22(_mlsValue _mls_x_139){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_139;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_24(_mlsValue _mls_x_153){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_153;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f1(_mlsValue _mls_f1_arg1_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Tuple2>(_mls_f1_arg1_0)){
//│     auto _mls_x_146 = _mlsValue::cast<_mls_Tuple2>(_mls_f1_arg1_0)->_mls_y;
//│     auto _mls_x_147 = _mlsValue::cast<_mls_Tuple2>(_mls_f1_arg1_0)->_mls_x;
//│     auto _mls_x_148 = _mls_gcdE(_mls_x_147, _mls_x_146);
//│     auto _mls_x_149 = _mlsValue::create<_mls_Tuple3>(_mls_x_147, _mls_x_146, _mls_x_148);
//│     _mls_retval = _mls_j_23(_mls_x_149);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_enumFromTo(_mlsValue _mls_z_enumFromTo_arg1_0, _mlsValue _mls_z_enumFromTo_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_220 = _mls_z_leq(_mls_z_enumFromTo_arg1_0, _mls_z_enumFromTo_arg2_0);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_220)){
//│     auto _mls_x_222 = _mls_const1();
//│     auto _mls_x_223 = _mls_z_add(_mls_z_enumFromTo_arg1_0, _mls_x_222);
//│     auto _mls_x_224 = _mls_z_enumFromTo(_mls_x_223, _mls_z_enumFromTo_arg2_0);
//│     auto _mls_x_225 = _mlsValue::create<_mls_Cons>(_mls_z_enumFromTo_arg1_0, _mls_x_224);
//│     _mls_retval = _mls_j_35(_mls_x_225);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_220)){
//│     auto _mls_x_226 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_35(_mls_x_226);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_sum(_mlsValue _mls_ls_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_114 = _mls_sumAux(_mls_ls_8, _mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_114;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_reverse(_mlsValue _mls_ls_11){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_137 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_138 = _mls_reverse_helper(_mls_ls_11, _mls_x_137);
//│   _mls_retval = _mls_x_138;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_34(_mlsValue _mls_x_207){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_207;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_16(_mlsValue _mls_x_109){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_109;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_sumAux(_mlsValue _mls_ls_9, _mlsValue _mls_a_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_9)){
//│     _mls_retval = _mls_j_17(_mls_a_2);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_9)){
//│     auto _mls_x_116 = _mlsValue::cast<_mls_Cons>(_mls_ls_9)->_mls_t;
//│     auto _mls_x_117 = _mlsValue::cast<_mls_Cons>(_mls_ls_9)->_mls_h;
//│     auto _mls_x_118 = (_mls_a_2+_mls_x_117);
//│     auto _mls_x_119 = _mls_sumAux(_mls_x_116, _mls_x_118);
//│     _mls_retval = _mls_j_17(_mls_x_119);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_29(_mlsValue _mls_x_175){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_28(_mls_x_175);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_12(_mlsValue _mls_x_88){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_88;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const5000(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_219 = _mls_z_of_int(_mlsValue::fromIntLit(5000));
//│   _mls_retval = _mls_x_219;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_4(_mlsValue _mls_x_46){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_46;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_concat(_mlsValue _mls_lss_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_lss_0)){
//│     auto _mls_x_132 = _mlsValue::cast<_mls_Cons>(_mls_lss_0)->_mls_t;
//│     auto _mls_x_133 = _mlsValue::cast<_mls_Cons>(_mls_lss_0)->_mls_h;
//│     auto _mls_x_134 = _mls_concat(_mls_x_132);
//│     auto _mls_x_135 = _mls_mappend(_mls_x_133, _mls_x_134);
//│     _mls_retval = _mls_j_21(_mls_x_135);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_lss_0)){
//│     auto _mls_x_136 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_21(_mls_x_136);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const0(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_204 = _mls_z_of_int(_mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_204;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_map(_mlsValue _mls_f_0, _mlsValue _mls_ls_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_0)){
//│     auto _mls_x_26 = _mlsValue::cast<_mls_Cons>(_mls_ls_0)->_mls_t;
//│     auto _mls_x_27 = _mlsValue::cast<_mls_Cons>(_mls_ls_0)->_mls_h;
//│     auto _mls_x_28 = _mlsCall(_mls_f_0, _mls_x_27);
//│     auto _mls_x_29 = _mls_map(_mls_f_0, _mls_x_26);
//│     auto _mls_x_30 = _mlsValue::create<_mls_Cons>(_mls_x_28, _mls_x_29);
//│     _mls_retval = _mls_j_0(_mls_x_30);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_0)){
//│     auto _mls_x_31 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_31);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_enumFromTo(_mlsValue _mls_a_0, _mlsValue _mls_b_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_81 = (_mls_a_0<=_mls_b_0);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_81)){
//│     auto _mls_x_83 = (_mls_a_0+_mlsValue::fromIntLit(1));
//│     auto _mls_x_84 = _mls_enumFromTo(_mls_x_83, _mls_b_0);
//│     auto _mls_x_85 = _mlsValue::create<_mls_Cons>(_mls_a_0, _mls_x_84);
//│     _mls_retval = _mls_j_11(_mls_x_85);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_81)){
//│     auto _mls_x_86 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_11(_mls_x_86);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_31(_mlsValue _mls_x_190){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_190;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_geq(_mlsValue _mls_x_23, _mlsValue _mls_y_9){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_24 = _mls_builtin_z_geq(_mls_x_23, _mls_y_9);
//│   _mls_retval = _mls_x_24;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head(_mlsValue _mls_ls_4){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_4)){
//│     auto _mls_x_74 = _mlsValue::cast<_mls_Cons>(_mls_ls_4)->_mls_t;
//│     auto _mls_x_75 = _mlsValue::cast<_mls_Cons>(_mls_ls_4)->_mls_h;
//│     _mls_retval = _mls_j_9(_mls_x_75);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_4)){
//│     auto _mls_x_76 = _mls_error();
//│     _mls_retval = _mls_j_9(_mls_x_76);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_div(_mlsValue _mls_x_9, _mlsValue _mls_y_2){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mls_builtin_z_div(_mls_x_9, _mls_y_2);
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_gcdE(_mlsValue _mls_gcdE_arg1_0, _mlsValue _mls_gcdE_arg2_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_205 = _mls_const0();
//│   auto _mls_x_206 = _mls_z_equal(_mls_gcdE_arg1_0, _mls_x_205);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_206)){
//│     auto _mls_x_208 = _mls_const0();
//│     auto _mls_x_209 = _mls_const1();
//│     auto _mls_x_210 = _mlsValue::create<_mls_Tuple3>(_mls_gcdE_arg2_0, _mls_x_208, _mls_x_209);
//│     _mls_retval = _mls_j_34(_mls_x_210);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_206)){
//│     auto _mls_x_211 = _mls_const1();
//│     auto _mls_x_212 = _mls_const0();
//│     auto _mls_x_213 = _mlsValue::create<_mls_Tuple3>(_mls_x_211, _mls_x_212, _mls_gcdE_arg1_0);
//│     auto _mls_x_214 = _mls_const0();
//│     auto _mls_x_215 = _mls_const1();
//│     auto _mls_x_216 = _mlsValue::create<_mls_Tuple3>(_mls_x_214, _mls_x_215, _mls_gcdE_arg2_0);
//│     auto _mls_x_217 = _mls_g(_mls_x_213, _mls_x_216);
//│     _mls_retval = _mls_j_34(_mls_x_217);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_14(_mlsValue _mls_x_96){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_13(_mls_x_96);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_5(_mlsValue _mls_x_51){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_51;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_17(_mlsValue _mls_x_115){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_115;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_32){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_32;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_take(_mlsValue _mls_n_0, _mlsValue _mls_ls_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_94 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_94)){
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_6)){
//│       auto _mls_x_97 = _mlsValue::cast<_mls_Cons>(_mls_ls_6)->_mls_t;
//│       auto _mls_x_98 = _mlsValue::cast<_mls_Cons>(_mls_ls_6)->_mls_h;
//│       auto _mls_x_99 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│       auto _mls_x_100 = _mls_take(_mls_x_99, _mls_x_97);
//│       auto _mls_x_101 = _mlsValue::create<_mls_Cons>(_mls_x_98, _mls_x_100);
//│       _mls_retval = _mls_j_14(_mls_x_101);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_6)){
//│       auto _mls_x_102 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_14(_mls_x_102);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_94)){
//│     auto _mls_x_103 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_13(_mls_x_103);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_abs(_mlsValue _mls_abs_arg1_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_188 = _mls_const0();
//│   auto _mls_x_189 = _mls_z_lt(_mls_abs_arg1_0, _mls_x_188);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_189)){
//│     auto _mls_x_191 = _mls_const0();
//│     auto _mls_x_192 = _mls_z_sub(_mls_x_191, _mls_abs_arg1_0);
//│     _mls_retval = _mls_j_31(_mls_x_192);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_189)){
//│     _mls_retval = _mls_j_31(_mls_abs_arg1_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_reverse_helper(_mlsValue _mls_ls_12, _mlsValue _mls_a_3){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_12)){
//│     auto _mls_x_140 = _mlsValue::cast<_mls_Cons>(_mls_ls_12)->_mls_t;
//│     auto _mls_x_141 = _mlsValue::cast<_mls_Cons>(_mls_ls_12)->_mls_h;
//│     auto _mls_x_142 = _mlsValue::create<_mls_Cons>(_mls_x_141, _mls_a_3);
//│     auto _mls_x_143 = _mls_reverse_helper(_mls_x_140, _mls_x_142);
//│     _mls_retval = _mls_j_22(_mls_x_143);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_12)){
//│     _mls_retval = _mls_j_22(_mls_a_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_21(_mlsValue _mls_x_131){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_131;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_gt(_mlsValue _mls_x_21, _mlsValue _mls_y_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_22 = _mls_builtin_z_gt(_mls_x_21, _mls_y_8);
//│   _mls_retval = _mls_x_22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_7(_mlsValue _mls_x_62){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_62;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_13(_mlsValue _mls_x_95){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_95;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_8(_mlsValue _mls_x_65){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_7(_mls_x_65);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foldl(_mlsValue _mls_f_2, _mlsValue _mls_i_0, _mlsValue _mls_ls_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_ls_2)){
//│     auto _mls_x_42 = _mlsValue::cast<_mls_Cons>(_mls_ls_2)->_mls_t;
//│     auto _mls_x_43 = _mlsValue::cast<_mls_Cons>(_mls_ls_2)->_mls_h;
//│     auto _mls_x_44 = _mlsCall(_mls_f_2, _mls_i_0, _mls_x_43);
//│     auto _mls_x_45 = _mls_foldl(_mls_f_2, _mls_x_44, _mls_x_42);
//│     _mls_retval = _mls_j_3(_mls_x_45);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ls_2)){
//│     _mls_retval = _mls_j_3(_mls_i_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_zip(_mlsValue _mls_xs_0, _mlsValue _mls_ys_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_0)){
//│     auto _mls_x_52 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_t;
//│     auto _mls_x_53 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Cons>(_mls_ys_0)){
//│       auto _mls_x_55 = _mlsValue::cast<_mls_Cons>(_mls_ys_0)->_mls_t;
//│       auto _mls_x_56 = _mlsValue::cast<_mls_Cons>(_mls_ys_0)->_mls_h;
//│       auto _mls_x_57 = _mlsValue::create<_mls_Tuple2>(_mls_x_53, _mls_x_56);
//│       auto _mls_x_58 = _mls_zip(_mls_x_52, _mls_x_55);
//│       auto _mls_x_59 = _mlsValue::create<_mls_Cons>(_mls_x_57, _mls_x_58);
//│       _mls_retval = _mls_j_6(_mls_x_59);
//│     } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_ys_0)){
//│       auto _mls_x_60 = _mlsValue::create<_mls_Nil>();
//│       _mls_retval = _mls_j_6(_mls_x_60);
//│     } else _mlsNonExhaustiveMatch();
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_0)){
//│     auto _mls_x_61 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_5(_mls_x_61);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_of_int(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_builtin_z_of_int(_mls_x_1);
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mlsValue::fromIntLit(0);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_30(_mlsValue _mls_x_178){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_29(_mls_x_178);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_sub(_mlsValue _mls_x_7, _mlsValue _mls_y_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_8 = _mls_builtin_z_sub(_mls_x_7, _mls_y_1);
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const10000(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_144 = _mls_z_of_int(_mlsValue::fromIntLit(10000));
//│   _mls_retval = _mls_x_144;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mappend(_mlsValue _mls_xs_2, _mlsValue _mls_ys_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_2)){
//│     auto _mls_x_110 = _mlsValue::cast<_mls_Cons>(_mls_xs_2)->_mls_t;
//│     auto _mls_x_111 = _mlsValue::cast<_mls_Cons>(_mls_xs_2)->_mls_h;
//│     auto _mls_x_112 = _mls_mappend(_mls_x_110, _mls_ys_2);
//│     auto _mls_x_113 = _mlsValue::create<_mls_Cons>(_mls_x_111, _mls_x_112);
//│     _mls_retval = _mls_j_16(_mls_x_113);
//│   } else if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_2)){
//│     _mls_retval = _mls_j_16(_mls_ys_2);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_const1(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_218 = _mls_z_of_int(_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_218;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_9(_mlsValue _mls_x_73){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_73;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_z_add(_mlsValue _mls_x_5, _mlsValue _mls_y_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_6 = _mls_builtin_z_add(_mls_x_5, _mls_y_0);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_227 = _mls_main();
//│   _mls_retval = _mls_x_227;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }

:interpIR
:genCpp
module Callable
module List
class Cons(h, t) extends List
module Nil extends List
module Option
class Some(x) extends Option
module None extends Option
class Box(inner)
fun map(f, xs) =
  if xs is
    Nil then Nil
    Cons(h, t) then Cons(Box.inner(f)(h), map(f, t))
fun inc(x) = x + 1
fun testMap() =
  let xs = Cons(1, Cons(2, Nil))
  let ys = map(Box(inc), xs)
  ys
testMap()
//│ |#module| |Callable|↵|#module| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#module| |Nil| |#extends| |List|↵|#module| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#module| |None| |#extends| |Option|↵|#class| |Box|(|inner|)|↵|#fun| |map|(|f|,| |xs|)| |#=|→|#if| |xs| |is|→|Nil| |#then| |Nil|↵|Cons|(|h|,| |t|)| |#then| |Cons|(|Box|.inner|(|f|)|(|h|)|,| |map|(|f|,| |t|)|)|←|←|↵|#fun| |inc|(|x|)| |#=| |x| |+| |1|↵|#fun| |testMap|(||)| |#=|→|#let| |xs| |#=| |Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|↵|#let| |ys| |#=| |map|(|Box|(|inc|)|,| |xs|)|↵|ys|←|↵|testMap|(||)|
//│ Parsed: {module Callable {}; module List {}; class Cons(h, t,): List {}; module Nil: List {}; module Option {}; class Some(x,): Option {}; module None: Option {}; class Box(inner,) {}; fun map = (f, xs,) => {if xs is ‹(Nil) then Nil; (Cons(h, t,)) then Cons((Box).inner(f,)(h,), map(f, t,),)›}; fun inc = (x,) => +(x,)(1,); fun testMap = () => {let xs = Cons(1, Cons(2, Nil,),); let ys = map(Box(inc,), xs,); ys}; testMap()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(1, List, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(3, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(4, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(5, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(6, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(7, Box, [inner], parents: , methods:
//│ ),
//│ ClassInfo(8, Lambda$0, [], parents: Callable, methods:
//│ apply1 -> Def(4, apply1, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = inc(x$16) in -- #58
//│ x$17 -- #57
//│ ))}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #38
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #37
//│     let x$3 = Cons.h(xs$0) in -- #36
//│     let x$4 = Box.inner(f$0) in -- #35
//│     let** (x$5) = x$4(x$3) in -- #34
//│     let* (x$6) = map(f$0,x$2) in -- #33
//│     let x$7 = Cons(x$5,x$6) in -- #32
//│     jump j$0(x$7) -- #31
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #42
//│ x$9 -- #41
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #75
//│ let x$11 = Cons(2,x$10) in -- #74
//│ let x$12 = Cons(1,x$11) in -- #73
//│ let x$18 = Lambda$0() in -- #72
//│ let x$19 = Box(x$18) in -- #71
//│ let* (x$20) = map(x$19,x$12) in -- #70
//│ x$20 -- #69
//│ )
//│ },
//│ let* (x$21) = testMap() in -- #78
//│ x$21 -- #77)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(1, List, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(3, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(4, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(5, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(6, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(7, Box, [inner], parents: , methods:
//│ ),
//│ ClassInfo(8, Lambda$0, [], parents: Callable, methods:
//│ apply1 -> Def(4, apply1, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = inc(x$16) in -- #58
//│ x$17 -- #57
//│ ))}, {
//│ Def(0, map, [f$0,xs$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case xs$0 of -- #38
//│   Nil =>
//│     let x$1 = Nil() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(xs$0) in -- #37
//│     let x$3 = Cons.h(xs$0) in -- #36
//│     let x$4 = Box.inner(f$0) in -- #35
//│     let** (x$5) = x$4(x$3) in -- #34
//│     let* (x$6) = map(f$0,x$2) in -- #33
//│     let x$7 = Cons(x$5,x$6) in -- #32
//│     jump j$0(x$7) -- #31
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, inc, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = +(x$8,1) in -- #42
//│ x$9 -- #41
//│ )
//│ Def(3, testMap, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = Nil() in -- #75
//│ let x$11 = Cons(2,x$10) in -- #74
//│ let x$12 = Cons(1,x$11) in -- #73
//│ let x$18 = Lambda$0() in -- #72
//│ let x$19 = Box(x$18) in -- #71
//│ let* (x$20) = map(x$19,x$12) in -- #70
//│ x$20 -- #69
//│ )
//│ },
//│ let* (x$21) = testMap() in -- #78
//│ x$21 -- #77)
//│ 
//│ Interpreted:
//│ Cons(2,Cons(3,Nil()))
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ struct _mls_Option;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_Callable;
//│ struct _mls_Lambda_0;
//│ _mlsValue _mls_map(_mlsValue, _mlsValue);
//│ _mlsValue _mls_inc(_mlsValue);
//│ _mlsValue _mls_testMap();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Lambda_0: public _mls_Callable {
//│ 
//│   constexpr static inline const char *typeName = "Lambda$0";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Lambda_0; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│   _mlsValue _mls_apply1(_mlsValue _mls_x_16) override{
//│     _mlsValue _mls_retval;
//│     auto _mls_x_17 = _mls_inc(_mls_x_16);
//│     _mls_retval = _mls_x_17;
//│     return _mls_retval;
//│   }
//│ };
//│ _mlsValue _mls_map(_mlsValue _mls_f_0, _mlsValue _mls_xs_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_xs_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_xs_0)){
//│     auto _mls_x_2 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::cast<_mls_Cons>(_mls_xs_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::cast<_mls_Box>(_mls_f_0)->_mls_inner;
//│     auto _mls_x_5 = _mlsCall(_mls_x_4, _mls_x_3);
//│     auto _mls_x_6 = _mls_map(_mls_f_0, _mls_x_2);
//│     auto _mls_x_7 = _mlsValue::create<_mls_Cons>(_mls_x_5, _mls_x_6);
//│     _mls_retval = _mls_j_0(_mls_x_7);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_inc(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_testMap(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_11 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_10);
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_11);
//│   auto _mls_x_18 = _mlsValue::create<_mls_Lambda_0>();
//│   auto _mls_x_19 = _mlsValue::create<_mls_Box>(_mls_x_18);
//│   auto _mls_x_20 = _mls_map(_mls_x_19, _mls_x_12);
//│   _mls_retval = _mls_x_20;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_21 = _mls_testMap();
//│   _mls_retval = _mls_x_21;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }


:interpIR
:genCpp
module C
fun testChar(x) =
  if x is
    char"a" then 1
    char"b" then 2
testChar(char"a")
//│ |#module| |C|↵|#fun| |testChar|(|x|)| |#=|→|#if| |x| |is|→|char"a"| |#then| |1|↵|char"b"| |#then| |2|←|←|↵|testChar|(|char"a"|)|
//│ Parsed: {module C {}; fun testChar = (x,) => {if x is ‹(char"a") then 1; (char"b") then 2›}; testChar(char"a",)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [], parents: , methods:
//│ )}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #11
//│ x$2 -- #10)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [], parents: , methods:
//│ )}, {
//│ Def(0, testChar, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #6
//│   CharLit(a) =>
//│     jump j$0(1) -- #3
//│   CharLit(b) =>
//│     jump j$0(2) -- #5
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testChar(a) in -- #11
//│ x$2 -- #10)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ _mlsValue _mls_testChar(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_testChar(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 97)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 98)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testChar(_mlsValue::fromIntLit(97));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }

:interpIR
:genCpp
module C
fun testMatch(x) =
  if x is
    0 then 1
    1 then 2
    C then 3
testMatch(0)
//│ |#module| |C|↵|#fun| |testMatch|(|x|)| |#=|→|#if| |x| |is|→|0| |#then| |1|↵|1| |#then| |2|↵|C| |#then| |3|←|←|↵|testMatch|(|0|)|
//│ Parsed: {module C {}; fun testMatch = (x,) => {if x is ‹(0) then 1; (1) then 2; (C) then 3›}; testMatch(0,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, C, [], parents: , methods:
//│ )}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #13
//│ x$2 -- #12)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, C, [], parents: , methods:
//│ )}, {
//│ Def(0, testMatch, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #8
//│   IntLit(0) =>
//│     jump j$0(1) -- #3
//│   IntLit(1) =>
//│     jump j$0(2) -- #5
//│   C =>
//│     jump j$0(3) -- #7
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ },
//│ let* (x$2) = testMatch(0) in -- #13
//│ x$2 -- #12)
//│ 
//│ Interpreted:
//│ 1
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_C;
//│ _mlsValue _mls_testMatch(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_C: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "C";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_C; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_testMatch(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isIntLit(_mls_x_0, 0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(1));
//│   } else if (_mlsValue::isIntLit(_mls_x_0, 1)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(2));
//│   } else if (_mlsValue::isValueOf<_mls_C>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mlsValue::fromIntLit(3));
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mls_testMatch(_mlsValue::fromIntLit(0));
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }

:interpIR
:genCpp
class Box(inner) 
fun unbox(x) = Box.inner(x)
fun f() =
  let a = Box(1)
  let b = unbox(a) + 1
  b
f()
//│ |#class| |Box|(|inner|)| |↵|#fun| |unbox|(|x|)| |#=| |Box|.inner|(|x|)|↵|#fun| |f|(||)| |#=|→|#let| |a| |#=| |Box|(|1|)|↵|#let| |b| |#=| |unbox|(|a|)| |+| |1|↵|b|←|↵|f|(||)|
//│ Parsed: {class Box(inner,) {}; fun unbox = (x,) => (Box).inner(x,); fun f = () => {let a = Box(1,); let b = +(unbox(a,),)(1,); b}; f()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Box, [inner], parents: , methods:
//│ )}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #18
//│ let* (x$3) = unbox(x$2) in -- #17
//│ let x$4 = +(x$3,1) in -- #16
//│ x$4 -- #15
//│ )
//│ },
//│ let* (x$5) = f() in -- #21
//│ x$5 -- #20)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Box, [inner], parents: , methods:
//│ )}, {
//│ Def(0, unbox, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = Box.inner(x$0) in -- #4
//│ x$1 -- #3
//│ )
//│ Def(1, f, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$2 = Box(1) in -- #18
//│ let* (x$3) = unbox(x$2) in -- #17
//│ let x$4 = +(x$3,1) in -- #16
//│ x$4 -- #15
//│ )
//│ },
//│ let* (x$5) = f() in -- #21
//│ x$5 -- #20)
//│ 
//│ Interpreted:
//│ 2
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Box;
//│ _mlsValue _mls_unbox(_mlsValue);
//│ _mlsValue _mls_f();
//│ _mlsValue _mlsMain();
//│ struct _mls_Box: public _mlsObject {
//│   _mlsValue _mls_inner;
//│   constexpr static inline const char *typeName = "Box";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_inner.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_inner);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_inner) { auto _mlsVal = new (std::align_val_t(align)) _mls_Box; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_inner = _mls_inner;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_unbox(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = _mlsValue::cast<_mls_Box>(_mls_x_0)->_mls_inner;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_2 = _mlsValue::create<_mls_Box>(_mlsValue::fromIntLit(1));
//│   auto _mls_x_3 = _mls_unbox(_mls_x_2);
//│   auto _mls_x_4 = (_mls_x_3+_mlsValue::fromIntLit(1));
//│   _mls_retval = _mls_x_4;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_5 = _mls_f();
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
