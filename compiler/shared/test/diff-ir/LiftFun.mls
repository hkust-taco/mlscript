:NewDefs
:ParseOnly
:UseIR

:genCpp
:runCpp
fun main(init, key) =
  fun r(x) = if x <= 0 then key else r(x - 1)
  r(init)
main(1, 42)
//│ |#fun| |main|(|init|,| |key|)| |#=|→|#fun| |r|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |key| |#else| |r|(|x| |-| |1|)|↵|r|(|init|)|←|↵|main|(|1|,| |42|)|
//│ Parsed: {fun main = (init, key,) => {fun r = (x,) => if (<=(x, 0,)) then key else r(-(x, 1,),); r(init,)}; main(1, 42,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #13
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #12
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #14
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = r(init$0,key$0) in -- #11
//│ x$1 -- #10
//│ )
//│ Def(7, r, [x$2,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = <=(x$2,0) in -- #40
//│ if x$3 -- #39
//│   true =>
//│     jump j$0(key$1) -- #26
//│   false =>
//│     let x$5 = -(x$2,1) in -- #38
//│     let* (x$6) = r(x$5,key$1) in -- #37
//│     jump j$0(x$6) -- #36
//│ )
//│ Def(8, j$0, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$4 -- #24
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #13
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #12
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #14
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = r(init$0,key$0) in -- #11
//│ x$1 -- #10
//│ )
//│ Def(7, r, [x$2,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = <=(x$2,0) in -- #40
//│ if x$3 -- #39
//│   true =>
//│     jump j$0(key$1) -- #26
//│   false =>
//│     let x$5 = -(x$2,1) in -- #38
//│     let* (x$6) = r(x$5,key$1) in -- #37
//│     jump j$0(x$6) -- #36
//│ )
//│ Def(8, j$0, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$4 -- #24
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ 
//│ Execution succeeded: 
//│ 42
//│ 

:genCpp
:runCpp
fun main(init, key) =
  fun pong(x) = if x <= 0 then key + 2 else ping(x - 1)
  fun ping(x) = if x <= 0 then key + 1 else pong(x - 1)
  ping(init)
main(1, 42)
//│ |#fun| |main|(|init|,| |key|)| |#=|→|#fun| |pong|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |key| |+| |2| |#else| |ping|(|x| |-| |1|)|↵|#fun| |ping|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |key| |+| |1| |#else| |pong|(|x| |-| |1|)|↵|ping|(|init|)|←|↵|main|(|1|,| |42|)|
//│ Parsed: {fun main = (init, key,) => {fun pong = (x,) => if (<=(x, 0,)) then +(key, 2,) else ping(-(x, 1,),); fun ping = (x,) => if (<=(x, 0,)) then +(key, 1,) else pong(-(x, 1,),); ping(init,)}; main(1, 42,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #13
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #12
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #14
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = ping(init$0,key$0) in -- #11
//│ x$1 -- #10
//│ )
//│ Def(7, pong, [x$2,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = <=(x$2,0) in -- #46
//│ if x$3 -- #45
//│   true =>
//│     let x$5 = +(key$1,2) in -- #32
//│     jump j$0(x$5) -- #31
//│   false =>
//│     let x$6 = -(x$2,1) in -- #44
//│     let* (x$7) = ping(x$6,key$1) in -- #43
//│     jump j$0(x$7) -- #42
//│ )
//│ Def(8, j$0, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$4 -- #24
//│ )
//│ Def(9, ping, [x$8,key$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = <=(x$8,0) in -- #75
//│ if x$9 -- #74
//│   true =>
//│     let x$11 = +(key$2,1) in -- #61
//│     jump j$1(x$11) -- #60
//│   false =>
//│     let x$12 = -(x$8,1) in -- #73
//│     let* (x$13) = pong(x$12,key$2) in -- #72
//│     jump j$1(x$13) -- #71
//│ )
//│ Def(10, j$1, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$10 -- #53
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #13
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #12
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #14
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$1) = ping(init$0,key$0) in -- #11
//│ x$1 -- #10
//│ )
//│ Def(7, pong, [x$2,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = <=(x$2,0) in -- #46
//│ if x$3 -- #45
//│   true =>
//│     let x$5 = +(key$1,2) in -- #32
//│     jump j$0(x$5) -- #31
//│   false =>
//│     let x$6 = -(x$2,1) in -- #44
//│     let* (x$7) = ping(x$6,key$1) in -- #43
//│     jump j$0(x$7) -- #42
//│ )
//│ Def(8, j$0, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$4 -- #24
//│ )
//│ Def(9, ping, [x$8,key$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$9 = <=(x$8,0) in -- #75
//│ if x$9 -- #74
//│   true =>
//│     let x$11 = +(key$2,1) in -- #61
//│     jump j$1(x$11) -- #60
//│   false =>
//│     let x$12 = -(x$8,1) in -- #73
//│     let* (x$13) = pong(x$12,key$2) in -- #72
//│     jump j$1(x$13) -- #71
//│ )
//│ Def(10, j$1, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$10 -- #53
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ 
//│ Execution succeeded: 
//│ 44
//│ 

:genCpp
:runCpp
:irVerbose
fun main(init, key) =
  let ping =
    fun ping(x) = if x <= 0 then key + 1 else pong(x - 1)
    fun pong(x) = if x <= 0 then key + 2 else ping(x - 1)
    ping
  ping(init)
main(1, 42)
//│ |#fun| |main|(|init|,| |key|)| |#=|→|#let| |ping| |#=|→|#fun| |ping|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |key| |+| |1| |#else| |pong|(|x| |-| |1|)|↵|#fun| |pong|(|x|)| |#=| |#if| |x| |<=| |0| |#then| |key| |+| |2| |#else| |ping|(|x| |-| |1|)|↵|ping|←|↵|ping|(|init|)|←|↵|main|(|1|,| |42|)|
//│ Parsed: {fun main = (init, key,) => {let ping = {fun ping = (x,) => if (<=(x, 0,)) then +(key, 1,) else pong(-(x, 1,),); fun pong = (x,) => if (<=(x, 0,)) then +(key, 2,) else ping(-(x, 1,),); ping}; ping(init,)}; main(1, 42,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #18
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Lambda$0, [key], parents: Callable, methods:
//│ apply1 -> Def(11, apply1, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$18) = ping(x$17,key) in -- #85
//│ x$18 -- #84
//│ ))}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Lambda$0(key$0) in -- #14
//│ let** (x$4) = x$3(init$0) in -- #13
//│ x$4 -- #12
//│ )
//│ Def(7, ping, [x$5,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$6 = <=(x$5,0) in -- #49
//│ if x$6 -- #48
//│   true =>
//│     let x$8 = +(key$1,1) in -- #35
//│     jump j$0(x$8) -- #34
//│   false =>
//│     let x$9 = -(x$5,1) in -- #47
//│     let* (x$10) = pong(x$9,key$1) in -- #46
//│     jump j$0(x$10) -- #45
//│ )
//│ Def(8, j$0, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #27
//│ )
//│ Def(9, pong, [x$11,key$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = <=(x$11,0) in -- #78
//│ if x$12 -- #77
//│   true =>
//│     let x$14 = +(key$2,2) in -- #64
//│     jump j$1(x$14) -- #63
//│   false =>
//│     let x$15 = -(x$11,1) in -- #76
//│     let* (x$16) = ping(x$15,key$2) in -- #75
//│     jump j$1(x$16) -- #74
//│ )
//│ Def(10, j$1, [x$13], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$13 -- #56
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ apply5 -> Def(6, apply5, [x0$5,x1$4,x2$3,x3$2,x4$1,x5$0], [{},{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #20
//│ ),
//│ apply1 -> Def(2, apply1, [x0$1,x1$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #16
//│ ),
//│ apply0 -> Def(1, apply0, [x0$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #15
//│ ),
//│ apply4 -> Def(5, apply4, [x0$4,x1$3,x2$2,x3$1,x4$0], [{},{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #19
//│ ),
//│ apply3 -> Def(4, apply3, [x0$3,x1$2,x2$1,x3$0], [{},{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #18
//│ ),
//│ apply2 -> Def(3, apply2, [x0$2,x1$1,x2$0], [{},{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ 0 -- #17
//│ )),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Lambda$0, [key], parents: Callable, methods:
//│ apply1 -> Def(11, apply1, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$18) = ping(x$17,key) in -- #85
//│ x$18 -- #84
//│ ))}, {
//│ Def(0, main, [init$0,key$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$3 = Lambda$0(key$0) in -- #14
//│ let** (x$4) = x$3(init$0) in -- #13
//│ x$4 -- #12
//│ )
//│ Def(7, ping, [x$5,key$1], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$6 = <=(x$5,0) in -- #49
//│ if x$6 -- #48
//│   true =>
//│     let x$8 = +(key$1,1) in -- #35
//│     jump j$0(x$8) -- #34
//│   false =>
//│     let x$9 = -(x$5,1) in -- #47
//│     let* (x$10) = pong(x$9,key$1) in -- #46
//│     jump j$0(x$10) -- #45
//│ )
//│ Def(8, j$0, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #27
//│ )
//│ Def(9, pong, [x$11,key$2], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = <=(x$11,0) in -- #78
//│ if x$12 -- #77
//│   true =>
//│     let x$14 = +(key$2,2) in -- #64
//│     jump j$1(x$14) -- #63
//│   false =>
//│     let x$15 = -(x$11,1) in -- #76
//│     let* (x$16) = ping(x$15,key$2) in -- #75
//│     jump j$1(x$16) -- #74
//│ )
//│ Def(10, j$1, [x$13], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$13 -- #56
//│ )
//│ },
//│ let* (x$0) = main(1,42) in -- #6
//│ x$0 -- #5)
//│ 
//│ 
//│ Execution succeeded: 
//│ 44
//│ 
