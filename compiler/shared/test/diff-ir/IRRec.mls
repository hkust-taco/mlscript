:NewDefs
:ParseOnly
:UseIR

:interpIR
:genCpp
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {fun fib = (n,) => if (<(n, 2,)) then n else +(fib(-(n, 1,),), fib(-(n, 2,),),); fib(20,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #38
//│ if x$0 -- #37
//│   true =>
//│     jump j$0(n$0) -- #8
//│   false =>
//│     let x$2 = -(n$0,1) in -- #36
//│     let* (x$3) = fib(x$2) in -- #35
//│     let x$4 = -(n$0,2) in -- #34
//│     let* (x$5) = fib(x$4) in -- #33
//│     let x$6 = +(x$3,x$5) in -- #32
//│     jump j$0(x$6) -- #31
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #43
//│ x$7 -- #42)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #38
//│ if x$0 -- #37
//│   true =>
//│     jump j$0(n$0) -- #8
//│   false =>
//│     let x$2 = -(n$0,1) in -- #36
//│     let* (x$3) = fib(x$2) in -- #35
//│     let x$4 = -(n$0,2) in -- #34
//│     let* (x$5) = fib(x$4) in -- #33
//│     let x$6 = +(x$3,x$5) in -- #32
//│     jump j$0(x$6) -- #31
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #43
//│ x$7 -- #42)
//│ 
//│ Interpreted:
//│ 277
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_fib(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_fib(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0<_mlsValue::fromIntLit(2));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mls_n_0);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_2 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_3 = _mls_fib(_mls_x_2);
//│     auto _mls_x_4 = (_mls_n_0-_mlsValue::fromIntLit(2));
//│     auto _mls_x_5 = _mls_fib(_mls_x_4);
//│     auto _mls_x_6 = (_mls_x_3+_mls_x_5);
//│     _mls_retval = _mls_j_0(_mls_x_6);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_fib(_mlsValue::fromIntLit(20));
//│   _mls_retval = _mls_x_7;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {fun odd = (x,) => if (==(x, 0,)) then False else even(-(x, 1,),); fun even = (x,) => if (==(x, 0,)) then True else odd(-(x, 1,),); fun foo = () => odd(10,); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #23
//│ if x$1 -- #22
//│   true =>
//│     let x$3 = False() in -- #9
//│     jump j$0(x$3) -- #8
//│   false =>
//│     let x$4 = -(x$0,1) in -- #21
//│     let* (x$5) = even(x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #47
//│ if x$7 -- #46
//│   true =>
//│     let x$9 = True() in -- #33
//│     jump j$1(x$9) -- #32
//│   false =>
//│     let x$10 = -(x$6,1) in -- #45
//│     let* (x$11) = odd(x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #30
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #52
//│ x$12 -- #51
//│ )
//│ },
//│ let* (x$13) = foo() in -- #55
//│ x$13 -- #54)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #23
//│ if x$1 -- #22
//│   true =>
//│     let x$3 = False() in -- #9
//│     jump j$0(x$3) -- #8
//│   false =>
//│     let x$4 = -(x$0,1) in -- #21
//│     let* (x$5) = even(x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #47
//│ if x$7 -- #46
//│   true =>
//│     let x$9 = True() in -- #33
//│     jump j$1(x$9) -- #32
//│   false =>
//│     let x$10 = -(x$6,1) in -- #45
//│     let* (x$11) = odd(x$10) in -- #44
//│     jump j$1(x$11) -- #43
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #30
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #52
//│ x$12 -- #51
//│ )
//│ },
//│ let* (x$13) = foo() in -- #55
//│ x$13 -- #54)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_odd(_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_x_6==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     auto _mls_x_10 = (_mls_x_6-_mlsValue::fromIntLit(1));
//│     auto _mls_x_11 = _mls_odd(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_2){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = (_mls_x_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_1)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_1)){
//│     auto _mls_x_4 = (_mls_x_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_5 = _mls_even(_mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_13 = _mls_foo();
//│   _mls_retval = _mls_x_13;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class AorB
class A extends AorB
class B(b) extends AorB
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #28
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #27
//│     let* (x$8) = foo(x$7) in -- #26
//│     let x$9 = B(x$8) in -- #25
//│     jump j$1(x$9) -- #24
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #34
//│ let* (x$11) = foo(x$10) in -- #33
//│ x$11 -- #32
//│ )
//│ },
//│ let* (x$12) = main() in -- #37
//│ x$12 -- #36)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #28
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #27
//│     let* (x$8) = foo(x$7) in -- #26
//│     let x$9 = B(x$8) in -- #25
//│     jump j$1(x$9) -- #24
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #34
//│ let* (x$11) = foo(x$10) in -- #33
//│ x$11 -- #32
//│ )
//│ },
//│ let* (x$12) = main() in -- #37
//│ x$12 -- #36)
//│ 
//│ Interpreted:
//│ B(A())
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_A;
//│ struct _mls_B;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_11 = _mls_foo(_mls_x_10);
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_4){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_4)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_4)){
//│     auto _mls_x_7 = _mls_not(_mls_x_4);
//│     auto _mls_x_8 = _mls_foo(_mls_x_7);
//│     auto _mls_x_9 = _mlsValue::create<_mls_B>(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_main();
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class AorB
class A() extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |AorB|↵|#class| |A|(||)| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class AorB {}; class A(): AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m, n,), p,), q,)}; fun bbb = () => {let x = aaa(); +(*(x, 100,), 4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #42
//│ let x$8 = *(x$7,100) in -- #41
//│ let x$9 = +(x$8,4) in -- #40
//│ x$9 -- #39
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #51
//│   true =>
//│     let x$12 = False() in -- #47
//│     jump j$0(x$12) -- #46
//│   false =>
//│     let x$13 = True() in -- #50
//│     jump j$0(x$13) -- #49
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #44
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #71
//│   true =>
//│     let x$16 = A() in -- #56
//│     jump j$1(x$16) -- #55
//│   false =>
//│     let* (x$17) = not(x$14) in -- #70
//│     let* (x$18) = foo(x$17) in -- #69
//│     let x$19 = B(x$18) in -- #68
//│     jump j$1(x$19) -- #67
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #53
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #93
//│ let* (x$21) = foo(x$20) in -- #92
//│ case x$21 of -- #91
//│   A =>
//│     let* (x$23) = aaa() in -- #81
//│     jump j$2(x$23) -- #80
//│   B =>
//│     let x$24 = B.b(x$21) in -- #90
//│     let* (x$25) = bbb() in -- #89
//│     jump j$2(x$25) -- #88
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #77
//│ )
//│ },
//│ let* (x$26) = main() in -- #96
//│ x$26 -- #95)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #42
//│ let x$8 = *(x$7,100) in -- #41
//│ let x$9 = +(x$8,4) in -- #40
//│ x$9 -- #39
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #51
//│   true =>
//│     let x$12 = False() in -- #47
//│     jump j$0(x$12) -- #46
//│   false =>
//│     let x$13 = True() in -- #50
//│     jump j$0(x$13) -- #49
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #44
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #71
//│   true =>
//│     let x$16 = A() in -- #56
//│     jump j$1(x$16) -- #55
//│   false =>
//│     let* (x$17) = not(x$14) in -- #70
//│     let* (x$18) = foo(x$17) in -- #69
//│     let x$19 = B(x$18) in -- #68
//│     jump j$1(x$19) -- #67
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #53
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #93
//│ let* (x$21) = foo(x$20) in -- #92
//│ case x$21 of -- #91
//│   A =>
//│     let* (x$23) = aaa() in -- #81
//│     jump j$2(x$23) -- #80
//│   B =>
//│     let x$24 = B.b(x$21) in -- #90
//│     let* (x$25) = bbb() in -- #89
//│     jump j$2(x$25) -- #88
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #77
//│ )
//│ },
//│ let* (x$26) = main() in -- #96
//│ x$26 -- #95)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_A;
//│ struct _mls_B;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_21 = _mls_foo(_mls_x_20);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_21)){
//│     auto _mls_x_23 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_23);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_21)){
//│     auto _mls_x_24 = _mlsValue::cast<_mls_B>(_mls_x_21)->_mls_b;
//│     auto _mls_x_25 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_25);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_26 = _mls_main();
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 


:interpIR
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #51
//│ let x$11 = S(x$10) in -- #50
//│ let x$12 = S(x$11) in -- #49
//│ let x$13 = S(x$12) in -- #48
//│ let* (x$14) = odd(x$13) in -- #47
//│ x$14 -- #46
//│ )
//│ },
//│ let* (x$15) = foo() in -- #54
//│ x$15 -- #53)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #51
//│ let x$11 = S(x$10) in -- #50
//│ let x$12 = S(x$11) in -- #49
//│ let x$13 = S(x$12) in -- #48
//│ let* (x$14) = odd(x$13) in -- #47
//│ x$14 -- #46
//│ )
//│ },
//│ let* (x$15) = foo() in -- #54
//│ x$15 -- #53)
//│ 
//│ Interpreted:
//│ True()
//│ 

:interpIR
:genCpp
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n, 0,)) then S(mk(-(n, 1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #61
//│ if x$10 -- #60
//│   true =>
//│     let x$12 = -(n$0,1) in -- #56
//│     let* (x$13) = mk(x$12) in -- #55
//│     let x$14 = S(x$13) in -- #54
//│     jump j$2(x$14) -- #53
//│   false =>
//│     let x$15 = O() in -- #59
//│     jump j$2(x$15) -- #58
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #40
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #70
//│ let* (x$17) = odd(x$16) in -- #69
//│ x$17 -- #68
//│ )
//│ },
//│ let* (x$18) = foo() in -- #73
//│ x$18 -- #72)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #61
//│ if x$10 -- #60
//│   true =>
//│     let x$12 = -(n$0,1) in -- #56
//│     let* (x$13) = mk(x$12) in -- #55
//│     let x$14 = S(x$13) in -- #54
//│     jump j$2(x$14) -- #53
//│   false =>
//│     let x$15 = O() in -- #59
//│     jump j$2(x$15) -- #58
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #40
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #70
//│ let* (x$17) = odd(x$16) in -- #69
//│ x$17 -- #68
//│ )
//│ },
//│ let* (x$18) = foo() in -- #73
//│ x$18 -- #72)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_O;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_S;
//│ struct _mls_Callable;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_mk(_mlsValue::fromIntLit(10));
//│   auto _mls_x_17 = _mls_odd(_mls_x_16);
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_13 = _mls_mk(_mls_x_12);
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_18 = _mls_foo();
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n, 0,)) then S(mk(-(n, 1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #61
//│ if x$10 -- #60
//│   true =>
//│     let x$12 = -(n$0,1) in -- #56
//│     let* (x$13) = mk(x$12) in -- #55
//│     let x$14 = S(x$13) in -- #54
//│     jump j$2(x$14) -- #53
//│   false =>
//│     let x$15 = O() in -- #59
//│     jump j$2(x$15) -- #58
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #40
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #78
//│ let x$17 = S(x$16) in -- #77
//│ let x$18 = S(x$17) in -- #76
//│ let* (x$19) = odd(x$18) in -- #75
//│ x$19 -- #74
//│ )
//│ },
//│ let* (x$20) = foo() in -- #81
//│ x$20 -- #80)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #61
//│ if x$10 -- #60
//│   true =>
//│     let x$12 = -(n$0,1) in -- #56
//│     let* (x$13) = mk(x$12) in -- #55
//│     let x$14 = S(x$13) in -- #54
//│     jump j$2(x$14) -- #53
//│   false =>
//│     let x$15 = O() in -- #59
//│     jump j$2(x$15) -- #58
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #40
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #78
//│ let x$17 = S(x$16) in -- #77
//│ let x$18 = S(x$17) in -- #76
//│ let* (x$19) = odd(x$18) in -- #75
//│ x$19 -- #74
//│ )
//│ },
//│ let* (x$20) = foo() in -- #81
//│ x$20 -- #80)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_O;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_S;
//│ struct _mls_Callable;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_mk(_mlsValue::fromIntLit(10));
//│   auto _mls_x_17 = _mlsValue::create<_mls_S>(_mls_x_16);
//│   auto _mls_x_18 = _mlsValue::create<_mls_S>(_mls_x_17);
//│   auto _mls_x_19 = _mls_odd(_mls_x_18);
//│   _mls_retval = _mls_x_19;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_13 = _mls_mk(_mls_x_12);
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_foo();
//│   _mls_retval = _mls_x_20;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10, 0,)) then S(O,) else O,); fun bar = () => if (>(10, 0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #56
//│ if x$10 -- #55
//│   true =>
//│     let x$13 = O() in -- #51
//│     let x$14 = S(x$13) in -- #50
//│     jump j$2(x$14) -- #49
//│   false =>
//│     let x$15 = O() in -- #54
//│     jump j$2(x$15) -- #53
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #44
//│ x$12 -- #43
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #83
//│ if x$16 -- #82
//│   true =>
//│     let x$18 = O() in -- #74
//│     let x$19 = S(x$18) in -- #73
//│     let* (x$20) = odd(x$19) in -- #72
//│     jump j$3(x$20) -- #71
//│   false =>
//│     let x$21 = O() in -- #81
//│     let* (x$22) = odd(x$21) in -- #80
//│     jump j$3(x$22) -- #79
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #63
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #89
//│ let* (x$24) = bar() in -- #88
//│ x$24 -- #87
//│ )
//│ },
//│ let* (x$25) = main() in -- #92
//│ x$25 -- #91)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [s], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, O, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #16
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #15
//│     let* (x$4) = even(x$3) in -- #14
//│     jump j$0(x$4) -- #13
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #33
//│   O =>
//│     let x$7 = True() in -- #21
//│     jump j$1(x$7) -- #20
//│   S =>
//│     let x$8 = S.s(x$5) in -- #32
//│     let* (x$9) = odd(x$8) in -- #31
//│     jump j$1(x$9) -- #30
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #18
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #56
//│ if x$10 -- #55
//│   true =>
//│     let x$13 = O() in -- #51
//│     let x$14 = S(x$13) in -- #50
//│     jump j$2(x$14) -- #49
//│   false =>
//│     let x$15 = O() in -- #54
//│     jump j$2(x$15) -- #53
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #44
//│ x$12 -- #43
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #83
//│ if x$16 -- #82
//│   true =>
//│     let x$18 = O() in -- #74
//│     let x$19 = S(x$18) in -- #73
//│     let* (x$20) = odd(x$19) in -- #72
//│     jump j$3(x$20) -- #71
//│   false =>
//│     let x$21 = O() in -- #81
//│     let* (x$22) = odd(x$21) in -- #80
//│     jump j$3(x$22) -- #79
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #63
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #89
//│ let* (x$24) = bar() in -- #88
//│ x$24 -- #87
//│ )
//│ },
//│ let* (x$25) = main() in -- #92
//│ x$25 -- #91)
//│ 
//│ Interpreted:
//│ True()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_O;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_S;
//│ struct _mls_Callable;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_bar();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mlsValue::fromIntLit(10)>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_odd(_mls_x_11);
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_23 = _mls_foo();
//│   auto _mls_x_24 = _mls_bar();
//│   _mls_retval = _mls_x_24;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bar(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = (_mlsValue::fromIntLit(10)>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_16)){
//│     auto _mls_x_18 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_19 = _mlsValue::create<_mls_S>(_mls_x_18);
//│     auto _mls_x_20 = _mls_odd(_mls_x_19);
//│     _mls_retval = _mls_j_3(_mls_x_20);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_16)){
//│     auto _mls_x_21 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_22 = _mls_odd(_mls_x_21);
//│     _mls_retval = _mls_j_3(_mls_x_22);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_17){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_25 = _mls_main();
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class AorB
class A extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m, n,), p,), q,)}; fun bbb = () => {let x = aaa(); +(*(x, 100,), 4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #42
//│ let x$8 = *(x$7,100) in -- #41
//│ let x$9 = +(x$8,4) in -- #40
//│ x$9 -- #39
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #51
//│   true =>
//│     let x$12 = False() in -- #47
//│     jump j$0(x$12) -- #46
//│   false =>
//│     let x$13 = True() in -- #50
//│     jump j$0(x$13) -- #49
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #44
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #71
//│   true =>
//│     let x$16 = A() in -- #56
//│     jump j$1(x$16) -- #55
//│   false =>
//│     let* (x$17) = not(x$14) in -- #70
//│     let* (x$18) = foo(x$17) in -- #69
//│     let x$19 = B(x$18) in -- #68
//│     jump j$1(x$19) -- #67
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #53
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #92
//│ case x$20 of -- #91
//│   A =>
//│     let* (x$22) = aaa() in -- #81
//│     jump j$2(x$22) -- #80
//│   B =>
//│     let x$23 = B.b(x$20) in -- #90
//│     let* (x$24) = bbb() in -- #89
//│     jump j$2(x$24) -- #88
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #77
//│ )
//│ },
//│ let x$25 = False() in -- #98
//│ let* (x$26) = main(x$25) in -- #97
//│ x$26 -- #96)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, AorB, [], parents: , methods:
//│ ),
//│ ClassInfo(10, A, [], parents: AorB, methods:
//│ ),
//│ ClassInfo(11, B, [b], parents: AorB, methods:
//│ )}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #42
//│ let x$8 = *(x$7,100) in -- #41
//│ let x$9 = +(x$8,4) in -- #40
//│ x$9 -- #39
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #51
//│   true =>
//│     let x$12 = False() in -- #47
//│     jump j$0(x$12) -- #46
//│   false =>
//│     let x$13 = True() in -- #50
//│     jump j$0(x$13) -- #49
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #44
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #71
//│   true =>
//│     let x$16 = A() in -- #56
//│     jump j$1(x$16) -- #55
//│   false =>
//│     let* (x$17) = not(x$14) in -- #70
//│     let* (x$18) = foo(x$17) in -- #69
//│     let x$19 = B(x$18) in -- #68
//│     jump j$1(x$19) -- #67
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #53
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #92
//│ case x$20 of -- #91
//│   A =>
//│     let* (x$22) = aaa() in -- #81
//│     jump j$2(x$22) -- #80
//│   B =>
//│     let x$23 = B.b(x$20) in -- #90
//│     let* (x$24) = bbb() in -- #89
//│     jump j$2(x$24) -- #88
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #77
//│ )
//│ },
//│ let x$25 = False() in -- #98
//│ let* (x$26) = main(x$25) in -- #97
//│ x$26 -- #96)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_A;
//│ struct _mls_B;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_21){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_21;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(_mlsValue _mls_flag_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_foo(_mls_flag_0);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_20)){
//│     auto _mls_x_22 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_20)){
//│     auto _mls_x_23 = _mlsValue::cast<_mls_B>(_mls_x_20)->_mls_b;
//│     auto _mls_x_24 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_24);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_25 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_26 = _mls_main(_mls_x_25);
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 


:interpIR
:genCpp
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ |#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|←|↵|main|(||)|
//│ Parsed: {class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #44
//│ let* (x$10) = is_none(x$9) in -- #43
//│ x$10 -- #42
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #62
//│ let x$12 = Cons(2,x$11) in -- #61
//│ let x$13 = Cons(1,x$12) in -- #60
//│ let* (x$14) = is_empty(x$13) in -- #59
//│ x$14 -- #58
//│ )
//│ },
//│ let* (x$15) = main() in -- #65
//│ x$15 -- #64)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #44
//│ let* (x$10) = is_none(x$9) in -- #43
//│ x$10 -- #42
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #62
//│ let x$12 = Cons(2,x$11) in -- #61
//│ let x$13 = Cons(1,x$12) in -- #60
//│ let* (x$14) = is_empty(x$13) in -- #59
//│ x$14 -- #58
//│ )
//│ },
//│ let* (x$15) = main() in -- #65
//│ x$15 -- #64)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_10 = _mls_is_none(_mls_x_9);
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_7 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_8 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_1(_mls_x_8);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_2 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::create<_mls_Some>(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_11);
//│   auto _mls_x_13 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_12);
//│   auto _mls_x_14 = _mls_is_empty(_mls_x_13);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_main();
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n, 0,)) then Nil else Cons(n, mk_list(-(n, 1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #29
//│ if x$0 -- #28
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #27
//│     let* (x$4) = mk_list(x$3) in -- #26
//│     let x$5 = Cons(n$0,x$4) in -- #25
//│     jump j$0(x$5) -- #24
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #51
//│   Nil =>
//│     let x$7 = None() in -- #34
//│     jump j$1(x$7) -- #33
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #50
//│     let x$9 = Cons.h(l$0) in -- #49
//│     let x$10 = Some(x$9) in -- #48
//│     jump j$1(x$10) -- #47
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #31
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #65
//│   None =>
//│     let x$12 = True() in -- #56
//│     jump j$2(x$12) -- #55
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #64
//│     let x$14 = False() in -- #63
//│     jump j$2(x$14) -- #62
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #53
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #74
//│ let* (x$16) = is_none(x$15) in -- #73
//│ x$16 -- #72
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #83
//│ let* (x$18) = is_empty(x$17) in -- #82
//│ x$18 -- #81
//│ )
//│ },
//│ let* (x$19) = main() in -- #86
//│ x$19 -- #85)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #29
//│ if x$0 -- #28
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #27
//│     let* (x$4) = mk_list(x$3) in -- #26
//│     let x$5 = Cons(n$0,x$4) in -- #25
//│     jump j$0(x$5) -- #24
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #51
//│   Nil =>
//│     let x$7 = None() in -- #34
//│     jump j$1(x$7) -- #33
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #50
//│     let x$9 = Cons.h(l$0) in -- #49
//│     let x$10 = Some(x$9) in -- #48
//│     jump j$1(x$10) -- #47
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #31
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #65
//│   None =>
//│     let x$12 = True() in -- #56
//│     jump j$2(x$12) -- #55
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #64
//│     let x$14 = False() in -- #63
//│     jump j$2(x$14) -- #62
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #53
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #74
//│ let* (x$16) = is_none(x$15) in -- #73
//│ x$16 -- #72
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #83
//│ let* (x$18) = is_empty(x$17) in -- #82
//│ x$18 -- #81
//│ )
//│ },
//│ let* (x$19) = main() in -- #86
//│ x$19 -- #85)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_18 = _mls_is_empty(_mls_x_17);
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_16 = _mls_is_none(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_2(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_13 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_14 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     _mls_retval = _mls_j_1(_mls_x_10);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_19 = _mls_main();
//│   _mls_retval = _mls_x_19;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ |#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |last_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then|→|#if| |t| |is|→|Nil| |#then| |Some|(|h|)|↵|Cons|(|h2|,| |t2|)| |#then| |last_opt|(|t|)|←|←|←|←|↵|#fun| |main|(||)| |#=|→|last_opt|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n, 0,)) then Nil else Cons(n, mk_list(-(n, 1,),),)}; fun last_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then {if t is ‹(Nil) then Some(h,); (Cons(h2, t2,)) then last_opt(t,)›}›}; fun main = () => {last_opt(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #29
//│ if x$0 -- #28
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #27
//│     let* (x$4) = mk_list(x$3) in -- #26
//│     let x$5 = Cons(n$0,x$4) in -- #25
//│     jump j$0(x$5) -- #24
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #71
//│   Nil =>
//│     let x$7 = None() in -- #34
//│     jump j$1(x$7) -- #33
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #70
//│     let x$9 = Cons.h(l$0) in -- #69
//│     case x$8 of -- #68
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #51
//│         jump j$2(x$11) -- #50
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #67
//│         let x$13 = Cons.h(x$8) in -- #66
//│         let* (x$14) = last_opt(x$8) in -- #65
//│         jump j$2(x$14) -- #64
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #31
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #45
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #80
//│ let* (x$16) = last_opt(x$15) in -- #79
//│ x$16 -- #78
//│ )
//│ },
//│ let* (x$17) = main() in -- #83
//│ x$17 -- #82)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #29
//│ if x$0 -- #28
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #27
//│     let* (x$4) = mk_list(x$3) in -- #26
//│     let x$5 = Cons(n$0,x$4) in -- #25
//│     jump j$0(x$5) -- #24
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #71
//│   Nil =>
//│     let x$7 = None() in -- #34
//│     jump j$1(x$7) -- #33
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #70
//│     let x$9 = Cons.h(l$0) in -- #69
//│     case x$8 of -- #68
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #51
//│         jump j$2(x$11) -- #50
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #67
//│         let x$13 = Cons.h(x$8) in -- #66
//│         let* (x$14) = last_opt(x$8) in -- #65
//│         jump j$2(x$14) -- #64
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #31
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #45
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #80
//│ let* (x$16) = last_opt(x$15) in -- #79
//│ x$16 -- #78
//│ )
//│ },
//│ let* (x$17) = main() in -- #83
//│ x$17 -- #82)
//│ 
//│ Interpreted:
//│ Some(0)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_last_opt(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_16 = _mls_last_opt(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_1(_mls_x_10);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_last_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Nil>(_mls_x_8)){
//│       auto _mls_x_11 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│       _mls_retval = _mls_j_2(_mls_x_11);
//│     } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_x_8)){
//│       auto _mls_x_12 = _mlsValue::cast<_mls_Cons>(_mls_x_8)->_mls_t;
//│       auto _mls_x_13 = _mlsValue::cast<_mls_Cons>(_mls_x_8)->_mls_h;
//│       auto _mls_x_14 = _mls_last_opt(_mls_x_8);
//│       _mls_retval = _mls_j_2(_mls_x_14);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_main();
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, c) =
  a + 1 + 2 + 3 + 4
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |c|)| |#=|→|a| |+| |1| |+| |2| |+| |3| |+| |4|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w, 8,), 9,), 10,)}; fun e1 = (a, c,) => {+(+(+(+(a, 1,), 2,), 3,), 4,)}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m, n,), p,), q,) else +(-(+(m, n,), p,), q,)}; fun e2 = (x,) => {+(+(+(x, 12,), 13,), 14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),), f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #57
//│ let x$8 = +(x$7,2) in -- #56
//│ let x$9 = +(x$8,3) in -- #55
//│ let x$10 = +(x$9,4) in -- #54
//│ x$10 -- #53
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #108
//│ let x$12 = 5 in -- #107
//│ let x$13 = 6 in -- #106
//│ let x$14 = 7 in -- #105
//│ if c$1 -- #104
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #83
//│     let x$17 = +(x$16,x$13) in -- #82
//│     let x$18 = +(x$17,x$14) in -- #81
//│     jump j$1(x$18) -- #80
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #103
//│     let x$20 = -(x$19,x$13) in -- #102
//│     let x$21 = +(x$20,x$14) in -- #101
//│     jump j$1(x$21) -- #100
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #63
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #127
//│ let x$24 = +(x$23,13) in -- #126
//│ let x$25 = +(x$24,14) in -- #125
//│ x$25 -- #124
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #164
//│ let* (x$28) = e3(x$27) in -- #163
//│ case x$26 of -- #162
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #155
//│     let* (x$32) = e1(x$31,x$28) in -- #154
//│     jump j$2(x$32) -- #153
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #161
//│     jump j$2(x$33) -- #160
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #142
//│ x$30 -- #141
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #184
//│ let* (x$35) = f(x$34) in -- #183
//│ let x$36 = None() in -- #182
//│ let* (x$37) = f(x$36) in -- #181
//│ let x$38 = +(x$35,x$37) in -- #180
//│ x$38 -- #179
//│ )
//│ },
//│ let* (x$39) = main() in -- #187
//│ x$39 -- #186)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #57
//│ let x$8 = +(x$7,2) in -- #56
//│ let x$9 = +(x$8,3) in -- #55
//│ let x$10 = +(x$9,4) in -- #54
//│ x$10 -- #53
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #108
//│ let x$12 = 5 in -- #107
//│ let x$13 = 6 in -- #106
//│ let x$14 = 7 in -- #105
//│ if c$1 -- #104
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #83
//│     let x$17 = +(x$16,x$13) in -- #82
//│     let x$18 = +(x$17,x$14) in -- #81
//│     jump j$1(x$18) -- #80
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #103
//│     let x$20 = -(x$19,x$13) in -- #102
//│     let x$21 = +(x$20,x$14) in -- #101
//│     jump j$1(x$21) -- #100
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #63
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #127
//│ let x$24 = +(x$23,13) in -- #126
//│ let x$25 = +(x$24,14) in -- #125
//│ x$25 -- #124
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #164
//│ let* (x$28) = e3(x$27) in -- #163
//│ case x$26 of -- #162
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #155
//│     let* (x$32) = e1(x$31,x$28) in -- #154
//│     jump j$2(x$32) -- #153
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #161
//│     jump j$2(x$33) -- #160
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #142
//│ x$30 -- #141
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #184
//│ let* (x$35) = f(x$34) in -- #183
//│ let x$36 = None() in -- #182
//│ let* (x$37) = f(x$36) in -- #181
//│ let x$38 = +(x$35,x$37) in -- #180
//│ x$38 -- #179
//│ )
//│ },
//│ let* (x$39) = main() in -- #187
//│ x$39 -- #186)
//│ 
//│ Interpreted:
//│ 115
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_12 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_1)){
//│     auto _mls_x_16 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_17 = (_mls_x_16+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_18);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_1)){
//│     auto _mls_x_19 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_20 = (_mls_x_19-_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_21);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_23 = (_mls_x_22+_mlsValue::fromIntLit(12));
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(13));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_29){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_30 = _mls_e0(_mls_x_29);
//│   _mls_retval = _mls_x_30;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_26){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_27 = _mls_is_some(_mls_x_26);
//│   auto _mls_x_28 = _mls_e3(_mls_x_27);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_26)){
//│     auto _mls_x_31 = _mlsValue::cast<_mls_Some>(_mls_x_26)->_mls_x;
//│     auto _mls_x_32 = _mls_e1(_mls_x_31, _mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_32);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_26)){
//│     auto _mls_x_33 = _mls_e2(_mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_33);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0+_mlsValue::fromIntLit(1));
//│   auto _mls_x_8 = (_mls_x_7+_mlsValue::fromIntLit(2));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(3));
//│   auto _mls_x_10 = (_mls_x_9+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_34 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_35 = _mls_f(_mls_x_34);
//│   auto _mls_x_36 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_37 = _mls_f(_mls_x_36);
//│   auto _mls_x_38 = (_mls_x_35+_mls_x_37);
//│   _mls_retval = _mls_x_38;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_39 = _mls_main();
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, z) =
  if a > 0 then f(Some(a - 1)) else z
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |z|)| |#=|→|#if| |a| |>| |0| |#then| |f|(|Some|(|a| |-| |1|)|)| |#else| |z|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w, 8,), 9,), 10,)}; fun e1 = (a, z,) => {if (>(a, 0,)) then f(Some(-(a, 1,),),) else z}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m, n,), p,), q,) else +(-(+(m, n,), p,), q,)}; fun e2 = (x,) => {+(+(+(x, 12,), 13,), 14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),), f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #59
//│ if x$7 -- #58
//│   true =>
//│     let x$9 = -(a$0,1) in -- #55
//│     let x$10 = Some(x$9) in -- #54
//│     let* (x$11) = f(x$10) in -- #53
//│     jump j$1(x$11) -- #52
//│   false =>
//│     jump j$1(z$0) -- #57
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #39
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #110
//│ let x$13 = 5 in -- #109
//│ let x$14 = 6 in -- #108
//│ let x$15 = 7 in -- #107
//│ if c$0 -- #106
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #85
//│     let x$18 = +(x$17,x$14) in -- #84
//│     let x$19 = +(x$18,x$15) in -- #83
//│     jump j$2(x$19) -- #82
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #105
//│     let x$21 = -(x$20,x$14) in -- #104
//│     let x$22 = +(x$21,x$15) in -- #103
//│     jump j$2(x$22) -- #102
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #65
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #129
//│ let x$25 = +(x$24,13) in -- #128
//│ let x$26 = +(x$25,14) in -- #127
//│ x$26 -- #126
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #166
//│ let* (x$29) = e3(x$28) in -- #165
//│ case x$27 of -- #164
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #157
//│     let* (x$33) = e1(x$32,x$29) in -- #156
//│     jump j$3(x$33) -- #155
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #163
//│     jump j$3(x$34) -- #162
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #144
//│ x$31 -- #143
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #186
//│ let* (x$36) = f(x$35) in -- #185
//│ let x$37 = None() in -- #184
//│ let* (x$38) = f(x$37) in -- #183
//│ let x$39 = +(x$36,x$38) in -- #182
//│ x$39 -- #181
//│ )
//│ },
//│ let* (x$40) = main() in -- #189
//│ x$40 -- #188)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, List, [], parents: , methods:
//│ ),
//│ ClassInfo(10, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(11, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(12, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(13, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(14, None, [], parents: Option, methods:
//│ )}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #59
//│ if x$7 -- #58
//│   true =>
//│     let x$9 = -(a$0,1) in -- #55
//│     let x$10 = Some(x$9) in -- #54
//│     let* (x$11) = f(x$10) in -- #53
//│     jump j$1(x$11) -- #52
//│   false =>
//│     jump j$1(z$0) -- #57
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #39
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #110
//│ let x$13 = 5 in -- #109
//│ let x$14 = 6 in -- #108
//│ let x$15 = 7 in -- #107
//│ if c$0 -- #106
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #85
//│     let x$18 = +(x$17,x$14) in -- #84
//│     let x$19 = +(x$18,x$15) in -- #83
//│     jump j$2(x$19) -- #82
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #105
//│     let x$21 = -(x$20,x$14) in -- #104
//│     let x$22 = +(x$21,x$15) in -- #103
//│     jump j$2(x$22) -- #102
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #65
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #129
//│ let x$25 = +(x$24,13) in -- #128
//│ let x$26 = +(x$25,14) in -- #127
//│ x$26 -- #126
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #166
//│ let* (x$29) = e3(x$28) in -- #165
//│ case x$27 of -- #164
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #157
//│     let* (x$33) = e1(x$32,x$29) in -- #156
//│     jump j$3(x$33) -- #155
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #163
//│     jump j$3(x$34) -- #162
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #144
//│ x$31 -- #143
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #186
//│ let* (x$36) = f(x$35) in -- #185
//│ let x$37 = None() in -- #184
//│ let* (x$38) = f(x$37) in -- #183
//│ let x$39 = +(x$36,x$38) in -- #182
//│ x$39 -- #181
//│ )
//│ },
//│ let* (x$40) = main() in -- #189
//│ x$40 -- #188)
//│ 
//│ Interpreted:
//│ 179
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_Callable;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_15 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_0)){
//│     auto _mls_x_17 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     auto _mls_x_19 = (_mls_x_18+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_19);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_0)){
//│     auto _mls_x_20 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20-_mls_x_14);
//│     auto _mls_x_22 = (_mls_x_21+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_27){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_28 = _mls_is_some(_mls_x_27);
//│   auto _mls_x_29 = _mls_e3(_mls_x_28);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_27)){
//│     auto _mls_x_32 = _mlsValue::cast<_mls_Some>(_mls_x_27)->_mls_x;
//│     auto _mls_x_33 = _mls_e1(_mls_x_32, _mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_33);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_27)){
//│     auto _mls_x_34 = _mls_e2(_mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_34);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_z_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = (_mls_a_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     auto _mls_x_11 = _mls_f(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     _mls_retval = _mls_j_1(_mls_z_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_16){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_23){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(12));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(13));
//│   auto _mls_x_26 = (_mls_x_25+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_35 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_36 = _mls_f(_mls_x_35);
//│   auto _mls_x_37 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_38 = _mls_f(_mls_x_37);
//│   auto _mls_x_39 = (_mls_x_36+_mls_x_38);
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_30){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_31 = _mls_e0(_mls_x_30);
//│   _mls_retval = _mls_x_31;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_40 = _mls_main();
//│   _mls_retval = _mls_x_40;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:genCpp
class Nat
class S(x) extends Nat
class Z extends Nat
fun pred(n) =
  if n is
    S(p) then p
    Z then Z
fun plus(n1, n2) =
  if n1 is
    Z then n2
    S(p) then S(plus(p, n2))
fun fib(n) =
  if n is
    Z then S(Z)
    S(p) then
      if p is
        Z then S(Z)
        S(q) then plus(fib(p), fib(q))
fun to_int(n) =
  if n is
    Z then 0
    S(p) then 1 + to_int(p)
fun to_nat(n) =
  if n == 0 then Z
  else S(to_nat(n - 1))
fun main() =
  to_int(fib(to_nat(30)))
main()
//│ |#class| |Nat|↵|#class| |S|(|x|)| |#extends| |Nat|↵|#class| |Z| |#extends| |Nat|↵|#fun| |pred|(|n|)| |#=|→|#if| |n| |is|→|S|(|p|)| |#then| |p|↵|Z| |#then| |Z|←|←|↵|#fun| |plus|(|n1|,| |n2|)| |#=|→|#if| |n1| |is|→|Z| |#then| |n2|↵|S|(|p|)| |#then| |S|(|plus|(|p|,| |n2|)|)|←|←|↵|#fun| |fib|(|n|)| |#=|→|#if| |n| |is|→|Z| |#then| |S|(|Z|)|↵|S|(|p|)| |#then|→|#if| |p| |is|→|Z| |#then| |S|(|Z|)|↵|S|(|q|)| |#then| |plus|(|fib|(|p|)|,| |fib|(|q|)|)|←|←|←|←|↵|#fun| |to_int|(|n|)| |#=|→|#if| |n| |is|→|Z| |#then| |0|↵|S|(|p|)| |#then| |1| |+| |to_int|(|p|)|←|←|↵|#fun| |to_nat|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Z|↵|#else| |S|(|to_nat|(|n| |-| |1|)|)|←|↵|#fun| |main|(||)| |#=|→|to_int|(|fib|(|to_nat|(|30|)|)|)|←|↵|main|(||)|
//│ Parsed: {class Nat {}; class S(x,): Nat {}; class Z: Nat {}; fun pred = (n,) => {if n is ‹(S(p,)) then p; (Z) then Z›}; fun plus = (n1, n2,) => {if n1 is ‹(Z) then n2; (S(p,)) then S(plus(p, n2,),)›}; fun fib = (n,) => {if n is ‹(Z) then S(Z,); (S(p,)) then {if p is ‹(Z) then S(Z,); (S(q,)) then plus(fib(p,), fib(q,),)›}›}; fun to_int = (n,) => {if n is ‹(Z) then 0; (S(p,)) then +(1, to_int(p,),)›}; fun to_nat = (n,) => {if (==(n, 0,)) then Z else S(to_nat(-(n, 1,),),)}; fun main = () => {to_int(fib(to_nat(30,),),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [x], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, Z, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, pred, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$0 of -- #12
//│   S =>
//│     let x$1 = S.x(n$0) in -- #8
//│     jump j$0(x$1) -- #7
//│   Z =>
//│     let x$2 = Z() in -- #11
//│     jump j$0(x$2) -- #10
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, plus, [n1$0,n2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n1$0 of -- #34
//│   Z =>
//│     jump j$1(n2$0) -- #16
//│   S =>
//│     let x$4 = S.x(n1$0) in -- #33
//│     let* (x$5) = plus(x$4,n2$0) in -- #32
//│     let x$6 = S(x$5) in -- #31
//│     jump j$1(x$6) -- #30
//│ )
//│ Def(3, j$1, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$3 -- #14
//│ )
//│ Def(4, fib, [n$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$1 of -- #81
//│   Z =>
//│     let x$8 = Z() in -- #43
//│     let x$9 = S(x$8) in -- #42
//│     jump j$2(x$9) -- #41
//│   S =>
//│     let x$10 = S.x(n$1) in -- #80
//│     case x$10 of -- #79
//│       Z =>
//│         let x$12 = Z() in -- #57
//│         let x$13 = S(x$12) in -- #56
//│         jump j$3(x$13) -- #55
//│       S =>
//│         let x$14 = S.x(x$10) in -- #78
//│         let* (x$15) = fib(x$10) in -- #77
//│         let* (x$16) = fib(x$14) in -- #76
//│         let* (x$17) = plus(x$15,x$16) in -- #75
//│         jump j$3(x$17) -- #74
//│ )
//│ Def(5, j$2, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #36
//│ )
//│ Def(6, j$3, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$2(x$11) -- #50
//│ )
//│ Def(7, to_int, [n$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$2 of -- #103
//│   Z =>
//│     jump j$4(0) -- #85
//│   S =>
//│     let x$19 = S.x(n$2) in -- #102
//│     let* (x$20) = to_int(x$19) in -- #101
//│     let x$21 = +(1,x$20) in -- #100
//│     jump j$4(x$21) -- #99
//│ )
//│ Def(8, j$4, [x$18], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$18 -- #83
//│ )
//│ Def(9, to_nat, [n$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$22 = ==(n$3,0) in -- #131
//│ if x$22 -- #130
//│   true =>
//│     let x$24 = Z() in -- #113
//│     jump j$5(x$24) -- #112
//│   false =>
//│     let x$25 = -(n$3,1) in -- #129
//│     let* (x$26) = to_nat(x$25) in -- #128
//│     let x$27 = S(x$26) in -- #127
//│     jump j$5(x$27) -- #126
//│ )
//│ Def(10, j$5, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$23 -- #110
//│ )
//│ Def(11, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = to_nat(30) in -- #144
//│ let* (x$29) = fib(x$28) in -- #143
//│ let* (x$30) = to_int(x$29) in -- #142
//│ x$30 -- #141
//│ )
//│ },
//│ let* (x$31) = main() in -- #147
//│ x$31 -- #146)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, True, [], parents: , methods:
//│ ),
//│ ClassInfo(1, False, [], parents: , methods:
//│ ),
//│ ClassInfo(2, Callable, [], parents: , methods:
//│ ),
//│ ClassInfo(3, List, [], parents: , methods:
//│ ),
//│ ClassInfo(4, Cons, [h,t], parents: List, methods:
//│ ),
//│ ClassInfo(5, Nil, [], parents: List, methods:
//│ ),
//│ ClassInfo(6, Option, [], parents: , methods:
//│ ),
//│ ClassInfo(7, Some, [x], parents: Option, methods:
//│ ),
//│ ClassInfo(8, None, [], parents: Option, methods:
//│ ),
//│ ClassInfo(9, Nat, [], parents: , methods:
//│ ),
//│ ClassInfo(10, S, [x], parents: Nat, methods:
//│ ),
//│ ClassInfo(11, Z, [], parents: Nat, methods:
//│ )}, {
//│ Def(0, pred, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$0 of -- #12
//│   S =>
//│     let x$1 = S.x(n$0) in -- #8
//│     jump j$0(x$1) -- #7
//│   Z =>
//│     let x$2 = Z() in -- #11
//│     jump j$0(x$2) -- #10
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, plus, [n1$0,n2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n1$0 of -- #34
//│   Z =>
//│     jump j$1(n2$0) -- #16
//│   S =>
//│     let x$4 = S.x(n1$0) in -- #33
//│     let* (x$5) = plus(x$4,n2$0) in -- #32
//│     let x$6 = S(x$5) in -- #31
//│     jump j$1(x$6) -- #30
//│ )
//│ Def(3, j$1, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$3 -- #14
//│ )
//│ Def(4, fib, [n$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$1 of -- #81
//│   Z =>
//│     let x$8 = Z() in -- #43
//│     let x$9 = S(x$8) in -- #42
//│     jump j$2(x$9) -- #41
//│   S =>
//│     let x$10 = S.x(n$1) in -- #80
//│     case x$10 of -- #79
//│       Z =>
//│         let x$12 = Z() in -- #57
//│         let x$13 = S(x$12) in -- #56
//│         jump j$3(x$13) -- #55
//│       S =>
//│         let x$14 = S.x(x$10) in -- #78
//│         let* (x$15) = fib(x$10) in -- #77
//│         let* (x$16) = fib(x$14) in -- #76
//│         let* (x$17) = plus(x$15,x$16) in -- #75
//│         jump j$3(x$17) -- #74
//│ )
//│ Def(5, j$2, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #36
//│ )
//│ Def(6, j$3, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$2(x$11) -- #50
//│ )
//│ Def(7, to_int, [n$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$2 of -- #103
//│   Z =>
//│     jump j$4(0) -- #85
//│   S =>
//│     let x$19 = S.x(n$2) in -- #102
//│     let* (x$20) = to_int(x$19) in -- #101
//│     let x$21 = +(1,x$20) in -- #100
//│     jump j$4(x$21) -- #99
//│ )
//│ Def(8, j$4, [x$18], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$18 -- #83
//│ )
//│ Def(9, to_nat, [n$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$22 = ==(n$3,0) in -- #131
//│ if x$22 -- #130
//│   true =>
//│     let x$24 = Z() in -- #113
//│     jump j$5(x$24) -- #112
//│   false =>
//│     let x$25 = -(n$3,1) in -- #129
//│     let* (x$26) = to_nat(x$25) in -- #128
//│     let x$27 = S(x$26) in -- #127
//│     jump j$5(x$27) -- #126
//│ )
//│ Def(10, j$5, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$23 -- #110
//│ )
//│ Def(11, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = to_nat(30) in -- #144
//│ let* (x$29) = fib(x$28) in -- #143
//│ let* (x$30) = to_int(x$29) in -- #142
//│ x$30 -- #141
//│ )
//│ },
//│ let* (x$31) = main() in -- #147
//│ x$31 -- #146)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_Z;
//│ struct _mls_S;
//│ struct _mls_Callable;
//│ _mlsValue _mls_pred(_mlsValue);
//│ _mlsValue _mls_fib(_mlsValue);
//│ _mlsValue _mls_j_5(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_j_4(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_to_nat(_mlsValue);
//│ _mlsValue _mls_to_int(_mlsValue);
//│ _mlsValue _mls_plus(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Z: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "Z";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create() { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_Z; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(_mlsAlignment)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_3){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_3;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_5(_mlsValue _mls_x_23){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_23;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_2(_mls_x_11);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_pred(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_S>(_mls_n_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_S>(_mls_n_0)->_mls_x;
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Z>(_mls_n_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Z>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_7){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_7;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_28 = _mls_to_nat(_mlsValue::fromIntLit(30));
//│   auto _mls_x_29 = _mls_fib(_mls_x_28);
//│   auto _mls_x_30 = _mls_to_int(_mls_x_29);
//│   _mls_retval = _mls_x_30;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_to_int(_mlsValue _mls_n_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n_2)){
//│     _mls_retval = _mls_j_4(_mlsValue::fromIntLit(0));
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n_2)){
//│     auto _mls_x_19 = _mlsValue::cast<_mls_S>(_mls_n_2)->_mls_x;
//│     auto _mls_x_20 = _mls_to_int(_mls_x_19);
//│     auto _mls_x_21 = (_mlsValue::fromIntLit(1)+_mls_x_20);
//│     _mls_retval = _mls_j_4(_mls_x_21);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_to_nat(_mlsValue _mls_n_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_22 = (_mls_n_3==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_22)){
//│     auto _mls_x_24 = _mlsValue::create<_mls_Z>();
//│     _mls_retval = _mls_j_5(_mls_x_24);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_22)){
//│     auto _mls_x_25 = (_mls_n_3-_mlsValue::fromIntLit(1));
//│     auto _mls_x_26 = _mls_to_nat(_mls_x_25);
//│     auto _mls_x_27 = _mlsValue::create<_mls_S>(_mls_x_26);
//│     _mls_retval = _mls_j_5(_mls_x_27);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_plus(_mlsValue _mls_n1_0, _mlsValue _mls_n2_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n1_0)){
//│     _mls_retval = _mls_j_1(_mls_n2_0);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n1_0)){
//│     auto _mls_x_4 = _mlsValue::cast<_mls_S>(_mls_n1_0)->_mls_x;
//│     auto _mls_x_5 = _mls_plus(_mls_x_4, _mls_n2_0);
//│     auto _mls_x_6 = _mlsValue::create<_mls_S>(_mls_x_5);
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_4(_mlsValue _mls_x_18){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_fib(_mlsValue _mls_n_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n_1)){
//│     auto _mls_x_8 = _mlsValue::create<_mls_Z>();
//│     auto _mls_x_9 = _mlsValue::create<_mls_S>(_mls_x_8);
//│     _mls_retval = _mls_j_2(_mls_x_9);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n_1)){
//│     auto _mls_x_10 = _mlsValue::cast<_mls_S>(_mls_n_1)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Z>(_mls_x_10)){
//│       auto _mls_x_12 = _mlsValue::create<_mls_Z>();
//│       auto _mls_x_13 = _mlsValue::create<_mls_S>(_mls_x_12);
//│       _mls_retval = _mls_j_3(_mls_x_13);
//│     } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_10)){
//│       auto _mls_x_14 = _mlsValue::cast<_mls_S>(_mls_x_10)->_mls_x;
//│       auto _mls_x_15 = _mls_fib(_mls_x_10);
//│       auto _mls_x_16 = _mls_fib(_mls_x_14);
//│       auto _mls_x_17 = _mls_plus(_mls_x_15, _mls_x_16);
//│       _mls_retval = _mls_j_3(_mls_x_17);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_31 = _mls_main();
//│   _mls_retval = _mls_x_31;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
