:NewDefs
:ParseOnly
:UseIR

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; fun fib = (n,) => if (<(n, 2,)) then n else +(fib(-(n, 1,),), fib(-(n, 2,),),); fib(20,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #40
//│ if x$0 -- #39
//│   true =>
//│     jump j$0(n$0) -- #8
//│   false =>
//│     let x$2 = -(n$0,1) in -- #38
//│     let* (x$3) = fib(x$2) in -- #37
//│     let x$4 = -(n$0,2) in -- #36
//│     let* (x$5) = fib(x$4) in -- #35
//│     let x$6 = +(x$3,x$5) in -- #34
//│     jump j$0(x$6) -- #33
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #46
//│ x$7 -- #45)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #40
//│ if x$0 -- #39
//│   true =>
//│     jump j$0(n$0) -- #8
//│   false =>
//│     let x$2 = -(n$0,1) in -- #38
//│     let* (x$3) = fib(x$2) in -- #37
//│     let x$4 = -(n$0,2) in -- #36
//│     let* (x$5) = fib(x$4) in -- #35
//│     let x$6 = +(x$3,x$5) in -- #34
//│     jump j$0(x$6) -- #33
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #46
//│ x$7 -- #45)
//│ 
//│ Interpreted:
//│ 277
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_fib;
//│ struct _mls_j_0;
//│ _mlsValue _mls_fib(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mlsFn__mls_fib: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<fib>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_fib mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_fib(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_fib(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0<_mlsValue::fromIntLit(2));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mls_n_0);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_2 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_3 = _mls_fib(_mls_x_2);
//│     auto _mls_x_4 = (_mls_n_0-_mlsValue::fromIntLit(2));
//│     auto _mls_x_5 = _mls_fib(_mls_x_4);
//│     auto _mls_x_6 = (_mls_x_3+_mls_x_5);
//│     _mls_retval = _mls_j_0(_mls_x_6);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_fib(_mlsValue::fromIntLit(20));
//│   _mls_retval = _mls_x_7;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; fun odd = (x,) => if (==(x, 0,)) then False else even(-(x, 1,),); fun even = (x,) => if (==(x, 0,)) then True else odd(-(x, 1,),); fun foo = () => odd(10,); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #24
//│ if x$1 -- #23
//│   true =>
//│     let x$3 = False() in -- #9
//│     jump j$0(x$3) -- #8
//│   false =>
//│     let x$4 = -(x$0,1) in -- #22
//│     let* (x$5) = even(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #49
//│ if x$7 -- #48
//│   true =>
//│     let x$9 = True() in -- #34
//│     jump j$1(x$9) -- #33
//│   false =>
//│     let x$10 = -(x$6,1) in -- #47
//│     let* (x$11) = odd(x$10) in -- #46
//│     jump j$1(x$11) -- #45
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #31
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #55
//│ x$12 -- #54
//│ )
//│ },
//│ let* (x$13) = foo() in -- #59
//│ x$13 -- #58)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #24
//│ if x$1 -- #23
//│   true =>
//│     let x$3 = False() in -- #9
//│     jump j$0(x$3) -- #8
//│   false =>
//│     let x$4 = -(x$0,1) in -- #22
//│     let* (x$5) = even(x$4) in -- #21
//│     jump j$0(x$5) -- #20
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #6
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #49
//│ if x$7 -- #48
//│   true =>
//│     let x$9 = True() in -- #34
//│     jump j$1(x$9) -- #33
//│   false =>
//│     let x$10 = -(x$6,1) in -- #47
//│     let* (x$11) = odd(x$10) in -- #46
//│     jump j$1(x$11) -- #45
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #31
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #55
//│ x$12 -- #54
//│ )
//│ },
//│ let* (x$13) = foo() in -- #59
//│ x$13 -- #58)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_j_0;
//│ struct _mls_odd;
//│ struct _mls_even;
//│ struct _mls_foo;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_foo();
//│   }
//│ };
//│ struct _mlsFn__mls_even: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<even>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_even mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_even(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_odd: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<odd>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_odd mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_odd(arg0);
//│   }
//│ };
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_odd(_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_x_6==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     auto _mls_x_10 = (_mls_x_6-_mlsValue::fromIntLit(1));
//│     auto _mls_x_11 = _mls_odd(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_2){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = (_mls_x_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_1)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_1)){
//│     auto _mls_x_4 = (_mls_x_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_5 = _mls_even(_mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_13 = _mls_foo();
//│   _mls_retval = _mls_x_13;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A extends AorB
class B(b) extends AorB
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #30
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #29
//│     let* (x$8) = foo(x$7) in -- #28
//│     let x$9 = B(x$8) in -- #27
//│     jump j$1(x$9) -- #26
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #37
//│ let* (x$11) = foo(x$10) in -- #36
//│ x$11 -- #35
//│ )
//│ },
//│ let* (x$12) = main() in -- #41
//│ x$12 -- #40)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #30
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #29
//│     let* (x$8) = foo(x$7) in -- #28
//│     let x$9 = B(x$8) in -- #27
//│     jump j$1(x$9) -- #26
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #37
//│ let* (x$11) = foo(x$10) in -- #36
//│ x$11 -- #35
//│ )
//│ },
//│ let* (x$12) = main() in -- #41
//│ x$12 -- #40)
//│ 
//│ Interpreted:
//│ B(A())
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_j_1;
//│ struct _mls_j_0;
//│ struct _mls_not;
//│ struct _mls_foo;
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_foo(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_not: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<not>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_not mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_not(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_not(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_11 = _mls_foo(_mls_x_10);
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_4){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_4)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_4)){
//│     auto _mls_x_7 = _mls_not(_mls_x_4);
//│     auto _mls_x_8 = _mls_foo(_mls_x_7);
//│     auto _mls_x_9 = _mlsValue::create<_mls_B>(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_main();
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A() extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A|(||)| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A(): AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m, n,), p,), q,)}; fun bbb = () => {let x = aaa(); +(*(x, 100,), 4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #43
//│ let x$8 = *(x$7,100) in -- #42
//│ let x$9 = +(x$8,4) in -- #41
//│ x$9 -- #40
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #52
//│   true =>
//│     let x$12 = False() in -- #48
//│     jump j$0(x$12) -- #47
//│   false =>
//│     let x$13 = True() in -- #51
//│     jump j$0(x$13) -- #50
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #45
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #74
//│   true =>
//│     let x$16 = A() in -- #57
//│     jump j$1(x$16) -- #56
//│   false =>
//│     let* (x$17) = not(x$14) in -- #73
//│     let* (x$18) = foo(x$17) in -- #72
//│     let x$19 = B(x$18) in -- #71
//│     jump j$1(x$19) -- #70
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #54
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #99
//│ let* (x$21) = foo(x$20) in -- #98
//│ case x$21 of -- #97
//│   A =>
//│     let* (x$23) = aaa() in -- #86
//│     jump j$2(x$23) -- #85
//│   B =>
//│     let x$24 = B.b(x$21) in -- #96
//│     let* (x$25) = bbb() in -- #95
//│     jump j$2(x$25) -- #94
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #81
//│ )
//│ },
//│ let* (x$26) = main() in -- #103
//│ x$26 -- #102)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #43
//│ let x$8 = *(x$7,100) in -- #42
//│ let x$9 = +(x$8,4) in -- #41
//│ x$9 -- #40
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #52
//│   true =>
//│     let x$12 = False() in -- #48
//│     jump j$0(x$12) -- #47
//│   false =>
//│     let x$13 = True() in -- #51
//│     jump j$0(x$13) -- #50
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #45
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #74
//│   true =>
//│     let x$16 = A() in -- #57
//│     jump j$1(x$16) -- #56
//│   false =>
//│     let* (x$17) = not(x$14) in -- #73
//│     let* (x$18) = foo(x$17) in -- #72
//│     let x$19 = B(x$18) in -- #71
//│     jump j$1(x$19) -- #70
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #54
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #99
//│ let* (x$21) = foo(x$20) in -- #98
//│ case x$21 of -- #97
//│   A =>
//│     let* (x$23) = aaa() in -- #86
//│     jump j$2(x$23) -- #85
//│   B =>
//│     let x$24 = B.b(x$21) in -- #96
//│     let* (x$25) = bbb() in -- #95
//│     jump j$2(x$25) -- #94
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #81
//│ )
//│ },
//│ let* (x$26) = main() in -- #103
//│ x$26 -- #102)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_bbb;
//│ struct _mls_j_1;
//│ struct _mls_aaa;
//│ struct _mls_not;
//│ struct _mls_foo;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_foo(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_bbb: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<bbb>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_bbb mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_bbb();
//│   }
//│ };
//│ struct _mlsFn__mls_not: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<not>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_not mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_not(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_aaa: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<aaa>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_aaa mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_aaa();
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_21 = _mls_foo(_mls_x_20);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_21)){
//│     auto _mls_x_23 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_23);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_21)){
//│     auto _mls_x_24 = _mlsValue::cast<_mls_B>(_mls_x_21)->_mls_b;
//│     auto _mls_x_25 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_25);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_26 = _mls_main();
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 


:interpIR
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #54
//│ let x$11 = S(x$10) in -- #53
//│ let x$12 = S(x$11) in -- #52
//│ let x$13 = S(x$12) in -- #51
//│ let* (x$14) = odd(x$13) in -- #50
//│ x$14 -- #49
//│ )
//│ },
//│ let* (x$15) = foo() in -- #58
//│ x$15 -- #57)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #54
//│ let x$11 = S(x$10) in -- #53
//│ let x$12 = S(x$11) in -- #52
//│ let x$13 = S(x$12) in -- #51
//│ let* (x$14) = odd(x$13) in -- #50
//│ x$14 -- #49
//│ )
//│ },
//│ let* (x$15) = foo() in -- #58
//│ x$15 -- #57)
//│ 
//│ Interpreted:
//│ True()
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n, 0,)) then S(mk(-(n, 1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #64
//│ if x$10 -- #63
//│   true =>
//│     let x$12 = -(n$0,1) in -- #59
//│     let* (x$13) = mk(x$12) in -- #58
//│     let x$14 = S(x$13) in -- #57
//│     jump j$2(x$14) -- #56
//│   false =>
//│     let x$15 = O() in -- #62
//│     jump j$2(x$15) -- #61
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #42
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #75
//│ let* (x$17) = odd(x$16) in -- #74
//│ x$17 -- #73
//│ )
//│ },
//│ let* (x$18) = foo() in -- #79
//│ x$18 -- #78)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #64
//│ if x$10 -- #63
//│   true =>
//│     let x$12 = -(n$0,1) in -- #59
//│     let* (x$13) = mk(x$12) in -- #58
//│     let x$14 = S(x$13) in -- #57
//│     jump j$2(x$14) -- #56
//│   false =>
//│     let x$15 = O() in -- #62
//│     jump j$2(x$15) -- #61
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #42
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #75
//│ let* (x$17) = odd(x$16) in -- #74
//│ x$17 -- #73
//│ )
//│ },
//│ let* (x$18) = foo() in -- #79
//│ x$18 -- #78)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Boolean;
//│ struct _mls_O;
//│ struct _mls_S;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_odd;
//│ struct _mls_mk;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_even;
//│ struct _mls_foo;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(align)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_foo();
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_even: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<even>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_even mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_even(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_mk: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<mk>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_mk mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_mk(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_odd: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<odd>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_odd mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_odd(arg0);
//│   }
//│ };
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_mk(_mlsValue::fromIntLit(10));
//│   auto _mls_x_17 = _mls_odd(_mls_x_16);
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_13 = _mls_mk(_mls_x_12);
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_18 = _mls_foo();
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n, 0,)) then S(mk(-(n, 1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #64
//│ if x$10 -- #63
//│   true =>
//│     let x$12 = -(n$0,1) in -- #59
//│     let* (x$13) = mk(x$12) in -- #58
//│     let x$14 = S(x$13) in -- #57
//│     jump j$2(x$14) -- #56
//│   false =>
//│     let x$15 = O() in -- #62
//│     jump j$2(x$15) -- #61
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #42
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #83
//│ let x$17 = S(x$16) in -- #82
//│ let x$18 = S(x$17) in -- #81
//│ let* (x$19) = odd(x$18) in -- #80
//│ x$19 -- #79
//│ )
//│ },
//│ let* (x$20) = foo() in -- #87
//│ x$20 -- #86)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #64
//│ if x$10 -- #63
//│   true =>
//│     let x$12 = -(n$0,1) in -- #59
//│     let* (x$13) = mk(x$12) in -- #58
//│     let x$14 = S(x$13) in -- #57
//│     jump j$2(x$14) -- #56
//│   false =>
//│     let x$15 = O() in -- #62
//│     jump j$2(x$15) -- #61
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #42
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #83
//│ let x$17 = S(x$16) in -- #82
//│ let x$18 = S(x$17) in -- #81
//│ let* (x$19) = odd(x$18) in -- #80
//│ x$19 -- #79
//│ )
//│ },
//│ let* (x$20) = foo() in -- #87
//│ x$20 -- #86)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Boolean;
//│ struct _mls_O;
//│ struct _mls_S;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_odd;
//│ struct _mls_mk;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_even;
//│ struct _mls_foo;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(align)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_foo();
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_even: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<even>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_even mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_even(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_mk: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<mk>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_mk mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_mk(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_odd: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<odd>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_odd mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_odd(arg0);
//│   }
//│ };
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_mk(_mlsValue::fromIntLit(10));
//│   auto _mls_x_17 = _mlsValue::create<_mls_S>(_mls_x_16);
//│   auto _mls_x_18 = _mlsValue::create<_mls_S>(_mls_x_17);
//│   auto _mls_x_19 = _mls_odd(_mls_x_18);
//│   _mls_retval = _mls_x_19;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_13 = _mls_mk(_mls_x_12);
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_foo();
//│   _mls_retval = _mls_x_20;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10, 0,)) then S(O,) else O,); fun bar = () => if (>(10, 0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #59
//│ if x$10 -- #58
//│   true =>
//│     let x$13 = O() in -- #54
//│     let x$14 = S(x$13) in -- #53
//│     jump j$2(x$14) -- #52
//│   false =>
//│     let x$15 = O() in -- #57
//│     jump j$2(x$15) -- #56
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #47
//│ x$12 -- #46
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #88
//│ if x$16 -- #87
//│   true =>
//│     let x$18 = O() in -- #78
//│     let x$19 = S(x$18) in -- #77
//│     let* (x$20) = odd(x$19) in -- #76
//│     jump j$3(x$20) -- #75
//│   false =>
//│     let x$21 = O() in -- #86
//│     let* (x$22) = odd(x$21) in -- #85
//│     jump j$3(x$22) -- #84
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #66
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #96
//│ let* (x$24) = bar() in -- #95
//│ x$24 -- #94
//│ )
//│ },
//│ let* (x$25) = main() in -- #100
//│ x$25 -- #99)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #59
//│ if x$10 -- #58
//│   true =>
//│     let x$13 = O() in -- #54
//│     let x$14 = S(x$13) in -- #53
//│     jump j$2(x$14) -- #52
//│   false =>
//│     let x$15 = O() in -- #57
//│     jump j$2(x$15) -- #56
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #47
//│ x$12 -- #46
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #88
//│ if x$16 -- #87
//│   true =>
//│     let x$18 = O() in -- #78
//│     let x$19 = S(x$18) in -- #77
//│     let* (x$20) = odd(x$19) in -- #76
//│     jump j$3(x$20) -- #75
//│   false =>
//│     let x$21 = O() in -- #86
//│     let* (x$22) = odd(x$21) in -- #85
//│     jump j$3(x$22) -- #84
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #66
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #96
//│ let* (x$24) = bar() in -- #95
//│ x$24 -- #94
//│ )
//│ },
//│ let* (x$25) = main() in -- #100
//│ x$25 -- #99)
//│ 
//│ Interpreted:
//│ True()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Boolean;
//│ struct _mls_O;
//│ struct _mls_S;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_j_3;
//│ struct _mls_odd;
//│ struct _mls_main;
//│ struct _mls_bar;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_even;
//│ struct _mls_foo;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_bar();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_O: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "O";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_O; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_s;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_s.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_s);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(align)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_s = _mls_s;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_foo();
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_even: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<even>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_even mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_even(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_bar: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<bar>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_bar mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_bar();
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ struct _mlsFn__mls_odd: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<odd>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_odd mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_odd(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_23 = _mls_foo();
//│   auto _mls_x_24 = _mls_bar();
//│   _mls_retval = _mls_x_24;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::cast<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_odd(_mls_x_11);
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bar(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = (_mlsValue::fromIntLit(10)>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_16)){
//│     auto _mls_x_18 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_19 = _mlsValue::create<_mls_S>(_mls_x_18);
//│     auto _mls_x_20 = _mls_odd(_mls_x_19);
//│     _mls_retval = _mls_j_3(_mls_x_20);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_16)){
//│     auto _mls_x_21 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_22 = _mls_odd(_mls_x_21);
//│     _mls_retval = _mls_j_3(_mls_x_22);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mlsValue::fromIntLit(10)>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_O>();
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_17){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_25 = _mls_main();
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m, n,), p,), q,)}; fun bbb = () => {let x = aaa(); +(*(x, 100,), 4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #43
//│ let x$8 = *(x$7,100) in -- #42
//│ let x$9 = +(x$8,4) in -- #41
//│ x$9 -- #40
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #52
//│   true =>
//│     let x$12 = False() in -- #48
//│     jump j$0(x$12) -- #47
//│   false =>
//│     let x$13 = True() in -- #51
//│     jump j$0(x$13) -- #50
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #45
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #74
//│   true =>
//│     let x$16 = A() in -- #57
//│     jump j$1(x$16) -- #56
//│   false =>
//│     let* (x$17) = not(x$14) in -- #73
//│     let* (x$18) = foo(x$17) in -- #72
//│     let x$19 = B(x$18) in -- #71
//│     jump j$1(x$19) -- #70
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #54
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #98
//│ case x$20 of -- #97
//│   A =>
//│     let* (x$22) = aaa() in -- #86
//│     jump j$2(x$22) -- #85
//│   B =>
//│     let x$23 = B.b(x$20) in -- #96
//│     let* (x$24) = bbb() in -- #95
//│     jump j$2(x$24) -- #94
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #81
//│ )
//│ },
//│ let x$25 = False() in -- #105
//│ let* (x$26) = main(x$25) in -- #104
//│ x$26 -- #103)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #26
//│ let x$1 = 2 in -- #25
//│ let x$2 = 3 in -- #24
//│ let x$3 = 4 in -- #23
//│ let x$4 = +(x$0,x$1) in -- #22
//│ let x$5 = -(x$4,x$2) in -- #21
//│ let x$6 = +(x$5,x$3) in -- #20
//│ x$6 -- #19
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #43
//│ let x$8 = *(x$7,100) in -- #42
//│ let x$9 = +(x$8,4) in -- #41
//│ x$9 -- #40
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #52
//│   true =>
//│     let x$12 = False() in -- #48
//│     jump j$0(x$12) -- #47
//│   false =>
//│     let x$13 = True() in -- #51
//│     jump j$0(x$13) -- #50
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #45
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #74
//│   true =>
//│     let x$16 = A() in -- #57
//│     jump j$1(x$16) -- #56
//│   false =>
//│     let* (x$17) = not(x$14) in -- #73
//│     let* (x$18) = foo(x$17) in -- #72
//│     let x$19 = B(x$18) in -- #71
//│     jump j$1(x$19) -- #70
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #54
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #98
//│ case x$20 of -- #97
//│   A =>
//│     let* (x$22) = aaa() in -- #86
//│     jump j$2(x$22) -- #85
//│   B =>
//│     let x$23 = B.b(x$20) in -- #96
//│     let* (x$24) = bbb() in -- #95
//│     jump j$2(x$24) -- #94
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #81
//│ )
//│ },
//│ let x$25 = False() in -- #105
//│ let* (x$26) = main(x$25) in -- #104
//│ x$26 -- #103)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_bbb;
//│ struct _mls_j_1;
//│ struct _mls_aaa;
//│ struct _mls_not;
//│ struct _mls_foo;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "AorB";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_B: public _mls_AorB {
//│   _mlsValue _mls_b;
//│   constexpr static inline const char *typeName = "B";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_b.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_b);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_b = _mls_b;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_A: public _mls_AorB {
//│ 
//│   constexpr static inline const char *typeName = "A";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_foo: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<foo>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_foo mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_foo(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_bbb: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<bbb>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_bbb mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_bbb();
//│   }
//│ };
//│ struct _mlsFn__mls_not: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<not>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_not mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_not(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_aaa: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<aaa>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_aaa mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_aaa();
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_main(arg0);
//│   }
//│ };
//│ _mlsValue _mls_main(_mlsValue _mls_flag_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_foo(_mls_flag_0);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_20)){
//│     auto _mls_x_22 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_20)){
//│     auto _mls_x_23 = _mlsValue::cast<_mls_B>(_mls_x_20)->_mls_b;
//│     auto _mls_x_24 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_24);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_21){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_21;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_25 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_26 = _mls_main(_mls_x_25);
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 


:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #46
//│ let* (x$10) = is_none(x$9) in -- #45
//│ x$10 -- #44
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #65
//│ let x$12 = Cons(2,x$11) in -- #64
//│ let x$13 = Cons(1,x$12) in -- #63
//│ let* (x$14) = is_empty(x$13) in -- #62
//│ x$14 -- #61
//│ )
//│ },
//│ let* (x$15) = main() in -- #69
//│ x$15 -- #68)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #46
//│ let* (x$10) = is_none(x$9) in -- #45
//│ x$10 -- #44
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #65
//│ let x$12 = Cons(2,x$11) in -- #64
//│ let x$13 = Cons(1,x$12) in -- #63
//│ let* (x$14) = is_empty(x$13) in -- #62
//│ x$14 -- #61
//│ )
//│ },
//│ let* (x$15) = main() in -- #69
//│ x$15 -- #68)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_j_1;
//│ struct _mls_is_empty;
//│ struct _mls_j_0;
//│ struct _mls_is_none;
//│ struct _mls_head_opt;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_none: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_none>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_none mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_none(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_empty: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_empty>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_empty mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_empty(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_head_opt: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<head_opt>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_head_opt mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_head_opt(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_10 = _mls_is_none(_mls_x_9);
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_2 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::create<_mls_Some>(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_7 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_8 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_1(_mls_x_8);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_11);
//│   auto _mls_x_13 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_12);
//│   auto _mls_x_14 = _mls_is_empty(_mls_x_13);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_main();
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n, 0,)) then Nil else Cons(n, mk_list(-(n, 1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #30
//│ if x$0 -- #29
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #28
//│     let* (x$4) = mk_list(x$3) in -- #27
//│     let x$5 = Cons(n$0,x$4) in -- #26
//│     jump j$0(x$5) -- #25
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #52
//│   Nil =>
//│     let x$7 = None() in -- #35
//│     jump j$1(x$7) -- #34
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #51
//│     let x$9 = Cons.h(l$0) in -- #50
//│     let x$10 = Some(x$9) in -- #49
//│     jump j$1(x$10) -- #48
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #32
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #66
//│   None =>
//│     let x$12 = True() in -- #57
//│     jump j$2(x$12) -- #56
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #65
//│     let x$14 = False() in -- #64
//│     jump j$2(x$14) -- #63
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #54
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #77
//│ let* (x$16) = is_none(x$15) in -- #76
//│ x$16 -- #75
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #88
//│ let* (x$18) = is_empty(x$17) in -- #87
//│ x$18 -- #86
//│ )
//│ },
//│ let* (x$19) = main() in -- #92
//│ x$19 -- #91)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #30
//│ if x$0 -- #29
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #28
//│     let* (x$4) = mk_list(x$3) in -- #27
//│     let x$5 = Cons(n$0,x$4) in -- #26
//│     jump j$0(x$5) -- #25
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #52
//│   Nil =>
//│     let x$7 = None() in -- #35
//│     jump j$1(x$7) -- #34
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #51
//│     let x$9 = Cons.h(l$0) in -- #50
//│     let x$10 = Some(x$9) in -- #49
//│     jump j$1(x$10) -- #48
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #32
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #66
//│   None =>
//│     let x$12 = True() in -- #57
//│     jump j$2(x$12) -- #56
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #65
//│     let x$14 = False() in -- #64
//│     jump j$2(x$14) -- #63
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #54
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #77
//│ let* (x$16) = is_none(x$15) in -- #76
//│ x$16 -- #75
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #88
//│ let* (x$18) = is_empty(x$17) in -- #87
//│ x$18 -- #86
//│ )
//│ },
//│ let* (x$19) = main() in -- #92
//│ x$19 -- #91)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_j_1;
//│ struct _mls_is_empty;
//│ struct _mls_is_none;
//│ struct _mls_head_opt;
//│ struct _mls_mk_list;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_none: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_none>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_none mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_none(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_empty: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_empty>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_empty mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_empty(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_mk_list: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<mk_list>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_mk_list mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_mk_list(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_head_opt: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<head_opt>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_head_opt mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_head_opt(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_16 = _mls_is_none(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_18 = _mls_is_empty(_mls_x_17);
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_2(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_13 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_14 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     _mls_retval = _mls_j_1(_mls_x_10);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_19 = _mls_main();
//│   _mls_retval = _mls_x_19;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |last_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then|→|#if| |t| |is|→|Nil| |#then| |Some|(|h|)|↵|Cons|(|h2|,| |t2|)| |#then| |last_opt|(|t|)|←|←|←|←|↵|#fun| |main|(||)| |#=|→|last_opt|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n, 0,)) then Nil else Cons(n, mk_list(-(n, 1,),),)}; fun last_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then {if t is ‹(Nil) then Some(h,); (Cons(h2, t2,)) then last_opt(t,)›}›}; fun main = () => {last_opt(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #30
//│ if x$0 -- #29
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #28
//│     let* (x$4) = mk_list(x$3) in -- #27
//│     let x$5 = Cons(n$0,x$4) in -- #26
//│     jump j$0(x$5) -- #25
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #73
//│   Nil =>
//│     let x$7 = None() in -- #35
//│     jump j$1(x$7) -- #34
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #72
//│     let x$9 = Cons.h(l$0) in -- #71
//│     case x$8 of -- #70
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #52
//│         jump j$2(x$11) -- #51
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #69
//│         let x$13 = Cons.h(x$8) in -- #68
//│         let* (x$14) = last_opt(x$8) in -- #67
//│         jump j$2(x$14) -- #66
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #32
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #46
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #84
//│ let* (x$16) = last_opt(x$15) in -- #83
//│ x$16 -- #82
//│ )
//│ },
//│ let* (x$17) = main() in -- #88
//│ x$17 -- #87)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #30
//│ if x$0 -- #29
//│   true =>
//│     let x$2 = Nil() in -- #9
//│     jump j$0(x$2) -- #8
//│   false =>
//│     let x$3 = -(n$0,1) in -- #28
//│     let* (x$4) = mk_list(x$3) in -- #27
//│     let x$5 = Cons(n$0,x$4) in -- #26
//│     jump j$0(x$5) -- #25
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #6
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #73
//│   Nil =>
//│     let x$7 = None() in -- #35
//│     jump j$1(x$7) -- #34
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #72
//│     let x$9 = Cons.h(l$0) in -- #71
//│     case x$8 of -- #70
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #52
//│         jump j$2(x$11) -- #51
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #69
//│         let x$13 = Cons.h(x$8) in -- #68
//│         let* (x$14) = last_opt(x$8) in -- #67
//│         jump j$2(x$14) -- #66
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #32
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #46
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #84
//│ let* (x$16) = last_opt(x$15) in -- #83
//│ x$16 -- #82
//│ )
//│ },
//│ let* (x$17) = main() in -- #88
//│ x$17 -- #87)
//│ 
//│ Interpreted:
//│ Some(0)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_main;
//│ struct _mls_j_1;
//│ struct _mls_last_opt;
//│ struct _mls_mk_list;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ _mlsValue _mls_last_opt(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ struct _mlsFn__mls_last_opt: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<last_opt>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_last_opt mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_last_opt(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_mk_list: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<mk_list>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_mk_list mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_mk_list(arg0);
//│   }
//│ };
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_16 = _mls_last_opt(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_last_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::cast<_mls_Cons>(_mls_l_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Nil>(_mls_x_8)){
//│       auto _mls_x_11 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│       _mls_retval = _mls_j_2(_mls_x_11);
//│     } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_x_8)){
//│       auto _mls_x_12 = _mlsValue::cast<_mls_Cons>(_mls_x_8)->_mls_t;
//│       auto _mls_x_13 = _mlsValue::cast<_mls_Cons>(_mls_x_8)->_mls_h;
//│       auto _mls_x_14 = _mls_last_opt(_mls_x_8);
//│       _mls_retval = _mls_j_2(_mls_x_14);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_1(_mls_x_10);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_main();
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, c) =
  a + 1 + 2 + 3 + 4
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |c|)| |#=|→|a| |+| |1| |+| |2| |+| |3| |+| |4|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w, 8,), 9,), 10,)}; fun e1 = (a, c,) => {+(+(+(+(a, 1,), 2,), 3,), 4,)}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m, n,), p,), q,) else +(-(+(m, n,), p,), q,)}; fun e2 = (x,) => {+(+(+(x, 12,), 13,), 14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),), f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #57
//│ let x$8 = +(x$7,2) in -- #56
//│ let x$9 = +(x$8,3) in -- #55
//│ let x$10 = +(x$9,4) in -- #54
//│ x$10 -- #53
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #108
//│ let x$12 = 5 in -- #107
//│ let x$13 = 6 in -- #106
//│ let x$14 = 7 in -- #105
//│ if c$1 -- #104
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #83
//│     let x$17 = +(x$16,x$13) in -- #82
//│     let x$18 = +(x$17,x$14) in -- #81
//│     jump j$1(x$18) -- #80
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #103
//│     let x$20 = -(x$19,x$13) in -- #102
//│     let x$21 = +(x$20,x$14) in -- #101
//│     jump j$1(x$21) -- #100
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #63
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #127
//│ let x$24 = +(x$23,13) in -- #126
//│ let x$25 = +(x$24,14) in -- #125
//│ x$25 -- #124
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #169
//│ let* (x$28) = e3(x$27) in -- #168
//│ case x$26 of -- #167
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #159
//│     let* (x$32) = e1(x$31,x$28) in -- #158
//│     jump j$2(x$32) -- #157
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #166
//│     jump j$2(x$33) -- #165
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #145
//│ x$30 -- #144
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #191
//│ let* (x$35) = f(x$34) in -- #190
//│ let x$36 = None() in -- #189
//│ let* (x$37) = f(x$36) in -- #188
//│ let x$38 = +(x$35,x$37) in -- #187
//│ x$38 -- #186
//│ )
//│ },
//│ let* (x$39) = main() in -- #195
//│ x$39 -- #194)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #57
//│ let x$8 = +(x$7,2) in -- #56
//│ let x$9 = +(x$8,3) in -- #55
//│ let x$10 = +(x$9,4) in -- #54
//│ x$10 -- #53
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #108
//│ let x$12 = 5 in -- #107
//│ let x$13 = 6 in -- #106
//│ let x$14 = 7 in -- #105
//│ if c$1 -- #104
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #83
//│     let x$17 = +(x$16,x$13) in -- #82
//│     let x$18 = +(x$17,x$14) in -- #81
//│     jump j$1(x$18) -- #80
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #103
//│     let x$20 = -(x$19,x$13) in -- #102
//│     let x$21 = +(x$20,x$14) in -- #101
//│     jump j$1(x$21) -- #100
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #63
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #127
//│ let x$24 = +(x$23,13) in -- #126
//│ let x$25 = +(x$24,14) in -- #125
//│ x$25 -- #124
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #169
//│ let* (x$28) = e3(x$27) in -- #168
//│ case x$26 of -- #167
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #159
//│     let* (x$32) = e1(x$31,x$28) in -- #158
//│     jump j$2(x$32) -- #157
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #166
//│     jump j$2(x$33) -- #165
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #145
//│ x$30 -- #144
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #191
//│ let* (x$35) = f(x$34) in -- #190
//│ let x$36 = None() in -- #189
//│ let* (x$37) = f(x$36) in -- #188
//│ let x$38 = +(x$35,x$37) in -- #187
//│ x$38 -- #186
//│ )
//│ },
//│ let* (x$39) = main() in -- #195
//│ x$39 -- #194)
//│ 
//│ Interpreted:
//│ 115
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_e1;
//│ struct _mls_is_some;
//│ struct _mls_e0;
//│ struct _mls_main;
//│ struct _mls_f;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_e3;
//│ struct _mls_e2;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_e1(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_e0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_some: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_some>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_some mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_some(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_f(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0+_mlsValue::fromIntLit(1));
//│   auto _mls_x_8 = (_mls_x_7+_mlsValue::fromIntLit(2));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(3));
//│   auto _mls_x_10 = (_mls_x_9+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_34 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_35 = _mls_f(_mls_x_34);
//│   auto _mls_x_36 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_37 = _mls_f(_mls_x_36);
//│   auto _mls_x_38 = (_mls_x_35+_mls_x_37);
//│   _mls_retval = _mls_x_38;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_12 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_1)){
//│     auto _mls_x_16 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_17 = (_mls_x_16+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_18);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_1)){
//│     auto _mls_x_19 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_20 = (_mls_x_19-_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_21);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_23 = (_mls_x_22+_mlsValue::fromIntLit(12));
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(13));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_26){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_27 = _mls_is_some(_mls_x_26);
//│   auto _mls_x_28 = _mls_e3(_mls_x_27);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_26)){
//│     auto _mls_x_31 = _mlsValue::cast<_mls_Some>(_mls_x_26)->_mls_x;
//│     auto _mls_x_32 = _mls_e1(_mls_x_31, _mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_32);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_26)){
//│     auto _mls_x_33 = _mls_e2(_mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_33);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_29){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_30 = _mls_e0(_mls_x_29);
//│   _mls_retval = _mls_x_30;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_39 = _mls_main();
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, z) =
  if a > 0 then f(Some(a - 1)) else z
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |z|)| |#=|→|#if| |a| |>| |0| |#then| |f|(|Some|(|a| |-| |1|)|)| |#else| |z|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w, 8,), 9,), 10,)}; fun e1 = (a, z,) => {if (>(a, 0,)) then f(Some(-(a, 1,),),) else z}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m, n,), p,), q,) else +(-(+(m, n,), p,), q,)}; fun e2 = (x,) => {+(+(+(x, 12,), 13,), 14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),), f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #60
//│ if x$7 -- #59
//│   true =>
//│     let x$9 = -(a$0,1) in -- #56
//│     let x$10 = Some(x$9) in -- #55
//│     let* (x$11) = f(x$10) in -- #54
//│     jump j$1(x$11) -- #53
//│   false =>
//│     jump j$1(z$0) -- #58
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #39
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #111
//│ let x$13 = 5 in -- #110
//│ let x$14 = 6 in -- #109
//│ let x$15 = 7 in -- #108
//│ if c$0 -- #107
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #86
//│     let x$18 = +(x$17,x$14) in -- #85
//│     let x$19 = +(x$18,x$15) in -- #84
//│     jump j$2(x$19) -- #83
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #106
//│     let x$21 = -(x$20,x$14) in -- #105
//│     let x$22 = +(x$21,x$15) in -- #104
//│     jump j$2(x$22) -- #103
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #66
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #130
//│ let x$25 = +(x$24,13) in -- #129
//│ let x$26 = +(x$25,14) in -- #128
//│ x$26 -- #127
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #172
//│ let* (x$29) = e3(x$28) in -- #171
//│ case x$27 of -- #170
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #162
//│     let* (x$33) = e1(x$32,x$29) in -- #161
//│     jump j$3(x$33) -- #160
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #169
//│     jump j$3(x$34) -- #168
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #148
//│ x$31 -- #147
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #194
//│ let* (x$36) = f(x$35) in -- #193
//│ let x$37 = None() in -- #192
//│ let* (x$38) = f(x$37) in -- #191
//│ let x$39 = +(x$36,x$38) in -- #190
//│ x$39 -- #189
//│ )
//│ },
//│ let* (x$40) = main() in -- #198
//│ x$40 -- #197)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #32
//│ let x$5 = +(x$4,9) in -- #31
//│ let x$6 = +(x$5,10) in -- #30
//│ x$6 -- #29
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #60
//│ if x$7 -- #59
//│   true =>
//│     let x$9 = -(a$0,1) in -- #56
//│     let x$10 = Some(x$9) in -- #55
//│     let* (x$11) = f(x$10) in -- #54
//│     jump j$1(x$11) -- #53
//│   false =>
//│     jump j$1(z$0) -- #58
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #39
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #111
//│ let x$13 = 5 in -- #110
//│ let x$14 = 6 in -- #109
//│ let x$15 = 7 in -- #108
//│ if c$0 -- #107
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #86
//│     let x$18 = +(x$17,x$14) in -- #85
//│     let x$19 = +(x$18,x$15) in -- #84
//│     jump j$2(x$19) -- #83
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #106
//│     let x$21 = -(x$20,x$14) in -- #105
//│     let x$22 = +(x$21,x$15) in -- #104
//│     jump j$2(x$22) -- #103
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #66
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #130
//│ let x$25 = +(x$24,13) in -- #129
//│ let x$26 = +(x$25,14) in -- #128
//│ x$26 -- #127
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #172
//│ let* (x$29) = e3(x$28) in -- #171
//│ case x$27 of -- #170
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #162
//│     let* (x$33) = e1(x$32,x$29) in -- #161
//│     jump j$3(x$33) -- #160
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #169
//│     jump j$3(x$34) -- #168
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #148
//│ x$31 -- #147
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #194
//│ let* (x$36) = f(x$35) in -- #193
//│ let x$37 = None() in -- #192
//│ let* (x$38) = f(x$37) in -- #191
//│ let x$39 = +(x$36,x$38) in -- #190
//│ x$39 -- #189
//│ )
//│ },
//│ let* (x$40) = main() in -- #198
//│ x$40 -- #197)
//│ 
//│ Interpreted:
//│ 179
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_j_1;
//│ struct _mls_e1;
//│ struct _mls_is_some;
//│ struct _mls_j_3;
//│ struct _mls_e0;
//│ struct _mls_main;
//│ struct _mls_f;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ struct _mls_e3;
//│ struct _mls_e2;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Option";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Some: public _mls_Option {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "Some";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_None: public _mls_Option {
//│ 
//│   constexpr static inline const char *typeName = "None";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_List: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "List";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Nil: public _mls_List {
//│ 
//│   constexpr static inline const char *typeName = "Nil";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Cons: public _mls_List {
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   constexpr static inline const char *typeName = "Cons";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_h.print(); std::printf(", "); this->_mls_t.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_h); _mlsValue::destroy(this->_mls_t);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_h = _mls_h; _mlsVal->_mls_t = _mls_t;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_e1(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_e0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_is_some: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<is_some>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_is_some mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_is_some(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_e2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<e2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_e2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_e2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_f: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<f>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_f mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_f(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_z_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = (_mls_a_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     auto _mls_x_11 = _mls_f(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     _mls_retval = _mls_j_1(_mls_z_0);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_35 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_36 = _mls_f(_mls_x_35);
//│   auto _mls_x_37 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_38 = _mls_f(_mls_x_37);
//│   auto _mls_x_39 = (_mls_x_36+_mls_x_38);
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_15 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_0)){
//│     auto _mls_x_17 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     auto _mls_x_19 = (_mls_x_18+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_19);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_0)){
//│     auto _mls_x_20 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20-_mls_x_14);
//│     auto _mls_x_22 = (_mls_x_21+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_16){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_27){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_28 = _mls_is_some(_mls_x_27);
//│   auto _mls_x_29 = _mls_e3(_mls_x_28);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_27)){
//│     auto _mls_x_32 = _mlsValue::cast<_mls_Some>(_mls_x_27)->_mls_x;
//│     auto _mls_x_33 = _mls_e1(_mls_x_32, _mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_33);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_27)){
//│     auto _mls_x_34 = _mls_e2(_mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_34);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_23){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(12));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(13));
//│   auto _mls_x_26 = (_mls_x_25+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_30){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_31 = _mls_e0(_mls_x_30);
//│   _mls_retval = _mls_x_31;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_40 = _mls_main();
//│   _mls_retval = _mls_x_40;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 

:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(x) extends Nat
class Z extends Nat
fun pred(n) =
  if n is
    S(p) then p
    Z then Z
fun plus(n1, n2) =
  if n1 is
    Z then n2
    S(p) then S(plus(p, n2))
fun fib(n) =
  if n is
    Z then S(Z)
    S(p) then
      if p is
        Z then S(Z)
        S(q) then plus(fib(p), fib(q))
fun to_int(n) =
  if n is
    Z then 0
    S(p) then 1 + to_int(p)
fun to_nat(n) =
  if n == 0 then Z
  else S(to_nat(n - 1))
fun main() =
  to_int(fib(to_nat(30)))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|x|)| |#extends| |Nat|↵|#class| |Z| |#extends| |Nat|↵|#fun| |pred|(|n|)| |#=|→|#if| |n| |is|→|S|(|p|)| |#then| |p|↵|Z| |#then| |Z|←|←|↵|#fun| |plus|(|n1|,| |n2|)| |#=|→|#if| |n1| |is|→|Z| |#then| |n2|↵|S|(|p|)| |#then| |S|(|plus|(|p|,| |n2|)|)|←|←|↵|#fun| |fib|(|n|)| |#=|→|#if| |n| |is|→|Z| |#then| |S|(|Z|)|↵|S|(|p|)| |#then|→|#if| |p| |is|→|Z| |#then| |S|(|Z|)|↵|S|(|q|)| |#then| |plus|(|fib|(|p|)|,| |fib|(|q|)|)|←|←|←|←|↵|#fun| |to_int|(|n|)| |#=|→|#if| |n| |is|→|Z| |#then| |0|↵|S|(|p|)| |#then| |1| |+| |to_int|(|p|)|←|←|↵|#fun| |to_nat|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Z|↵|#else| |S|(|to_nat|(|n| |-| |1|)|)|←|↵|#fun| |main|(||)| |#=|→|to_int|(|fib|(|to_nat|(|30|)|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(x,): Nat {}; class Z: Nat {}; fun pred = (n,) => {if n is ‹(S(p,)) then p; (Z) then Z›}; fun plus = (n1, n2,) => {if n1 is ‹(Z) then n2; (S(p,)) then S(plus(p, n2,),)›}; fun fib = (n,) => {if n is ‹(Z) then S(Z,); (S(p,)) then {if p is ‹(Z) then S(Z,); (S(q,)) then plus(fib(p,), fib(q,),)›}›}; fun to_int = (n,) => {if n is ‹(Z) then 0; (S(p,)) then +(1, to_int(p,),)›}; fun to_nat = (n,) => {if (==(n, 0,)) then Z else S(to_nat(-(n, 1,),),)}; fun main = () => {to_int(fib(to_nat(30,),),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [x]),ClassInfo(5, Z, [])}, {
//│ Def(0, pred, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$0 of -- #12
//│   S =>
//│     let x$1 = S.x(n$0) in -- #8
//│     jump j$0(x$1) -- #7
//│   Z =>
//│     let x$2 = Z() in -- #11
//│     jump j$0(x$2) -- #10
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, plus, [n1$0,n2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n1$0 of -- #35
//│   Z =>
//│     jump j$1(n2$0) -- #16
//│   S =>
//│     let x$4 = S.x(n1$0) in -- #34
//│     let* (x$5) = plus(x$4,n2$0) in -- #33
//│     let x$6 = S(x$5) in -- #32
//│     jump j$1(x$6) -- #31
//│ )
//│ Def(3, j$1, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$3 -- #14
//│ )
//│ Def(4, fib, [n$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$1 of -- #85
//│   Z =>
//│     let x$8 = Z() in -- #44
//│     let x$9 = S(x$8) in -- #43
//│     jump j$2(x$9) -- #42
//│   S =>
//│     let x$10 = S.x(n$1) in -- #84
//│     case x$10 of -- #83
//│       Z =>
//│         let x$12 = Z() in -- #58
//│         let x$13 = S(x$12) in -- #57
//│         jump j$3(x$13) -- #56
//│       S =>
//│         let x$14 = S.x(x$10) in -- #82
//│         let* (x$15) = fib(x$10) in -- #81
//│         let* (x$16) = fib(x$14) in -- #80
//│         let* (x$17) = plus(x$15,x$16) in -- #79
//│         jump j$3(x$17) -- #78
//│ )
//│ Def(5, j$2, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #37
//│ )
//│ Def(6, j$3, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$2(x$11) -- #51
//│ )
//│ Def(7, to_int, [n$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$2 of -- #108
//│   Z =>
//│     jump j$4(0) -- #89
//│   S =>
//│     let x$19 = S.x(n$2) in -- #107
//│     let* (x$20) = to_int(x$19) in -- #106
//│     let x$21 = +(1,x$20) in -- #105
//│     jump j$4(x$21) -- #104
//│ )
//│ Def(8, j$4, [x$18], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$18 -- #87
//│ )
//│ Def(9, to_nat, [n$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$22 = ==(n$3,0) in -- #137
//│ if x$22 -- #136
//│   true =>
//│     let x$24 = Z() in -- #118
//│     jump j$5(x$24) -- #117
//│   false =>
//│     let x$25 = -(n$3,1) in -- #135
//│     let* (x$26) = to_nat(x$25) in -- #134
//│     let x$27 = S(x$26) in -- #133
//│     jump j$5(x$27) -- #132
//│ )
//│ Def(10, j$5, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$23 -- #115
//│ )
//│ Def(11, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = to_nat(30) in -- #153
//│ let* (x$29) = fib(x$28) in -- #152
//│ let* (x$30) = to_int(x$29) in -- #151
//│ x$30 -- #150
//│ )
//│ },
//│ let* (x$31) = main() in -- #157
//│ x$31 -- #156)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [x]),ClassInfo(5, Z, [])}, {
//│ Def(0, pred, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$0 of -- #12
//│   S =>
//│     let x$1 = S.x(n$0) in -- #8
//│     jump j$0(x$1) -- #7
//│   Z =>
//│     let x$2 = Z() in -- #11
//│     jump j$0(x$2) -- #10
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, plus, [n1$0,n2$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n1$0 of -- #35
//│   Z =>
//│     jump j$1(n2$0) -- #16
//│   S =>
//│     let x$4 = S.x(n1$0) in -- #34
//│     let* (x$5) = plus(x$4,n2$0) in -- #33
//│     let x$6 = S(x$5) in -- #32
//│     jump j$1(x$6) -- #31
//│ )
//│ Def(3, j$1, [x$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$3 -- #14
//│ )
//│ Def(4, fib, [n$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$1 of -- #85
//│   Z =>
//│     let x$8 = Z() in -- #44
//│     let x$9 = S(x$8) in -- #43
//│     jump j$2(x$9) -- #42
//│   S =>
//│     let x$10 = S.x(n$1) in -- #84
//│     case x$10 of -- #83
//│       Z =>
//│         let x$12 = Z() in -- #58
//│         let x$13 = S(x$12) in -- #57
//│         jump j$3(x$13) -- #56
//│       S =>
//│         let x$14 = S.x(x$10) in -- #82
//│         let* (x$15) = fib(x$10) in -- #81
//│         let* (x$16) = fib(x$14) in -- #80
//│         let* (x$17) = plus(x$15,x$16) in -- #79
//│         jump j$3(x$17) -- #78
//│ )
//│ Def(5, j$2, [x$7], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$7 -- #37
//│ )
//│ Def(6, j$3, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$2(x$11) -- #51
//│ )
//│ Def(7, to_int, [n$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case n$2 of -- #108
//│   Z =>
//│     jump j$4(0) -- #89
//│   S =>
//│     let x$19 = S.x(n$2) in -- #107
//│     let* (x$20) = to_int(x$19) in -- #106
//│     let x$21 = +(1,x$20) in -- #105
//│     jump j$4(x$21) -- #104
//│ )
//│ Def(8, j$4, [x$18], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$18 -- #87
//│ )
//│ Def(9, to_nat, [n$3], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$22 = ==(n$3,0) in -- #137
//│ if x$22 -- #136
//│   true =>
//│     let x$24 = Z() in -- #118
//│     jump j$5(x$24) -- #117
//│   false =>
//│     let x$25 = -(n$3,1) in -- #135
//│     let* (x$26) = to_nat(x$25) in -- #134
//│     let x$27 = S(x$26) in -- #133
//│     jump j$5(x$27) -- #132
//│ )
//│ Def(10, j$5, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$23 -- #115
//│ )
//│ Def(11, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = to_nat(30) in -- #153
//│ let* (x$29) = fib(x$28) in -- #152
//│ let* (x$30) = to_int(x$29) in -- #151
//│ x$30 -- #150
//│ )
//│ },
//│ let* (x$31) = main() in -- #157
//│ x$31 -- #156)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Boolean;
//│ struct _mls_Z;
//│ struct _mls_S;
//│ struct _mls_True;
//│ struct _mls_False;
//│ struct _mls_fib;
//│ struct _mls_main;
//│ struct _mls_to_nat;
//│ struct _mls_j_5;
//│ struct _mls_j_3;
//│ struct _mls_to_int;
//│ struct _mls_pred;
//│ struct _mls_plus;
//│ struct _mls_j_4;
//│ struct _mls_j_1;
//│ struct _mls_j_0;
//│ struct _mls_j_2;
//│ _mlsValue _mls_pred(_mlsValue);
//│ _mlsValue _mls_fib(_mlsValue);
//│ _mlsValue _mls_j_5(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_j_4(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_to_nat(_mlsValue);
//│ _mlsValue _mls_to_int(_mlsValue);
//│ _mlsValue _mls_plus(_mlsValue, _mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject {
//│ 
//│   constexpr static inline const char *typeName = "Nat";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nat; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_Z: public _mls_Nat {
//│ 
//│   constexpr static inline const char *typeName = "Z";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   virtual void destroy() override {  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Z; _mlsVal->refCount = 1; _mlsVal->tag = typeTag;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mls_S: public _mls_Nat {
//│   _mlsValue _mls_x;
//│   constexpr static inline const char *typeName = "S";
//│   constexpr static inline uint32_t typeTag = nextTypeTag();
//│   virtual void print() const override { std::printf("%s", typeName); std::printf("("); this->_mls_x.print();  std::printf(")"); }
//│   virtual void destroy() override { _mlsValue::destroy(this->_mls_x);  operator delete (this, std::align_val_t(_mlsAlignment)); }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_S; _mlsVal->refCount = 1; _mlsVal->tag = typeTag; _mlsVal->_mls_x = _mls_x;  return _mlsValue(_mlsVal); }
//│ };
//│ struct _mlsFn__mls_j_1: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$1>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_1 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_1(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_fib: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<fib>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_fib mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_fib(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_to_nat: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<to_nat>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_to_nat mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_to_nat(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_5: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$5>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_5 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_5(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_pred: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<pred>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_pred mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_pred(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_plus: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<plus>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_plus mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply2(_mlsValue arg0, _mlsValue arg1) override{
//│     return _mls_plus(arg0, arg1);
//│   }
//│ };
//│ struct _mlsFn__mls_j_2: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$2>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_2 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_2(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_4: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$4>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_4 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_4(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_to_int: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<to_int>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_to_int mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_to_int(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_main: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<main>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_main mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply0() override{
//│     return _mls_main();
//│   }
//│ };
//│ struct _mlsFn__mls_j_3: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$3>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_3 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_3(arg0);
//│   }
//│ };
//│ struct _mlsFn__mls_j_0: public _mlsCallable {
//│ 
//│   constexpr static inline const char *typeName = "<j$0>";
//│   constexpr static inline uint32_t typeTag = -1;
//│   virtual void print() const override { std::printf("%s", typeName); }
//│   template <std::size_t align> static _mlsValue create() { static _mlsFn__mls_j_0 mlsFn alignas(align); mlsFn.refCount = stickyRefCount; mlsFn.tag = typeTag; return _mlsValue(&mlsFn); }
//│   _mlsValue virtual apply1(_mlsValue arg0) override{
//│     return _mls_j_0(arg0);
//│   }
//│ };
//│ _mlsValue _mls_to_int(_mlsValue _mls_n_2){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n_2)){
//│     _mls_retval = _mls_j_4(_mlsValue::fromIntLit(0));
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n_2)){
//│     auto _mls_x_19 = _mlsValue::cast<_mls_S>(_mls_n_2)->_mls_x;
//│     auto _mls_x_20 = _mls_to_int(_mls_x_19);
//│     auto _mls_x_21 = (_mlsValue::fromIntLit(1)+_mls_x_20);
//│     _mls_retval = _mls_j_4(_mls_x_21);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_7){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_7;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_3){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_3;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_to_nat(_mlsValue _mls_n_3){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_22 = (_mls_n_3==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_22)){
//│     auto _mls_x_24 = _mlsValue::create<_mls_Z>();
//│     _mls_retval = _mls_j_5(_mls_x_24);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_22)){
//│     auto _mls_x_25 = (_mls_n_3-_mlsValue::fromIntLit(1));
//│     auto _mls_x_26 = _mls_to_nat(_mls_x_25);
//│     auto _mls_x_27 = _mlsValue::create<_mls_S>(_mls_x_26);
//│     _mls_retval = _mls_j_5(_mls_x_27);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_2(_mls_x_11);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_5(_mlsValue _mls_x_23){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_23;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_28 = _mls_to_nat(_mlsValue::fromIntLit(30));
//│   auto _mls_x_29 = _mls_fib(_mls_x_28);
//│   auto _mls_x_30 = _mls_to_int(_mls_x_29);
//│   _mls_retval = _mls_x_30;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_4(_mlsValue _mls_x_18){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_fib(_mlsValue _mls_n_1){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n_1)){
//│     auto _mls_x_8 = _mlsValue::create<_mls_Z>();
//│     auto _mls_x_9 = _mlsValue::create<_mls_S>(_mls_x_8);
//│     _mls_retval = _mls_j_2(_mls_x_9);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n_1)){
//│     auto _mls_x_10 = _mlsValue::cast<_mls_S>(_mls_n_1)->_mls_x;
//│     if (_mlsValue::isValueOf<_mls_Z>(_mls_x_10)){
//│       auto _mls_x_12 = _mlsValue::create<_mls_Z>();
//│       auto _mls_x_13 = _mlsValue::create<_mls_S>(_mls_x_12);
//│       _mls_retval = _mls_j_3(_mls_x_13);
//│     } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_10)){
//│       auto _mls_x_14 = _mlsValue::cast<_mls_S>(_mls_x_10)->_mls_x;
//│       auto _mls_x_15 = _mls_fib(_mls_x_10);
//│       auto _mls_x_16 = _mls_fib(_mls_x_14);
//│       auto _mls_x_17 = _mls_plus(_mls_x_15, _mls_x_16);
//│       _mls_retval = _mls_j_3(_mls_x_17);
//│     } else _mlsNonExhaustiveMatch();
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_pred(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_S>(_mls_n_0)){
//│     auto _mls_x_1 = _mlsValue::cast<_mls_S>(_mls_n_0)->_mls_x;
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Z>(_mls_n_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Z>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_plus(_mlsValue _mls_n1_0, _mlsValue _mls_n2_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Z>(_mls_n1_0)){
//│     _mls_retval = _mls_j_1(_mls_n2_0);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_n1_0)){
//│     auto _mls_x_4 = _mlsValue::cast<_mls_S>(_mls_n1_0)->_mls_x;
//│     auto _mls_x_5 = _mls_plus(_mls_x_4, _mls_n2_0);
//│     auto _mls_x_6 = _mlsValue::create<_mls_S>(_mls_x_5);
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else _mlsNonExhaustiveMatch();
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_31 = _mls_main();
//│   _mls_retval = _mls_x_31;
//│   return _mls_retval;
//│ }
//│ int main() { return _mlsLargeStack(_mlsMainWrapper); }
//│ 
