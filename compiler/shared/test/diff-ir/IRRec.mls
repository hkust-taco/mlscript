:NewParser
:ParseOnly
:UseIR

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
fun fib(n) = if n < 2 then n else fib(n-1) + fib(n-2)
fib(20)
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#fun| |fib|(|n|)| |#=| |#if| |n| |<| |2| |#then| |n| |#else| |fib|(|n|-|1|)| |+| |fib|(|n|-|2|)|↵|fib|(|20|)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; fun fib = (n,) => if (<(n,)(2,)) then n else +(fib(-(n,)(1,),),)(fib(-(n,)(2,),),); fib(20,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #28
//│ if x$0 -- #27
//│   true =>
//│     jump j$0(n$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #26
//│     let* (x$3) = fib(x$2) in -- #25
//│     let x$4 = -(n$0,2) in -- #24
//│     let* (x$5) = fib(x$4) in -- #23
//│     let x$6 = +(x$3,x$5) in -- #22
//│     jump j$0(x$6) -- #21
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #34
//│ x$7 -- #33)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, fib, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = <(n$0,2) in -- #28
//│ if x$0 -- #27
//│   true =>
//│     jump j$0(n$0) -- #5
//│   false =>
//│     let x$2 = -(n$0,1) in -- #26
//│     let* (x$3) = fib(x$2) in -- #25
//│     let x$4 = -(n$0,2) in -- #24
//│     let* (x$5) = fib(x$4) in -- #23
//│     let x$6 = +(x$3,x$5) in -- #22
//│     jump j$0(x$6) -- #21
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ },
//│ let* (x$7) = fib(20) in -- #34
//│ x$7 -- #33)
//│ 
//│ Interpreted:
//│ 6765
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_fib(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_fib(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0<_mlsValue::fromIntLit(2));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     _mls_retval = _mls_j_0(_mls_n_0);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_2 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_3 = _mls_fib(_mls_x_2);
//│     auto _mls_x_4 = (_mls_n_0-_mlsValue::fromIntLit(2));
//│     auto _mls_x_5 = _mls_fib(_mls_x_4);
//│     auto _mls_x_6 = (_mls_x_3+_mls_x_5);
//│     _mls_retval = _mls_j_0(_mls_x_6);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_fib(_mlsValue::fromIntLit(20));
//│   _mls_retval = _mls_x_7;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
fun odd(x) = if x == 0 then False else even(x-1)
fun even(x) = if x == 0 then True else odd(x-1)
fun foo() = odd(10)
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#fun| |odd|(|x|)| |#=| |#if| |x| |==| |0| |#then| |False| |#else| |even|(|x|-|1|)|↵|#fun| |even|(|x|)| |#=| |#if| |x| |==| |0| |#then| |True| |#else| |odd|(|x|-|1|)|↵|#fun| |foo|(||)| |#=| |odd|(|10|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; fun odd = (x,) => if (==(x,)(0,)) then False else even(-(x,)(1,),); fun even = (x,) => if (==(x,)(0,)) then True else odd(-(x,)(1,),); fun foo = () => odd(10,); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #18
//│ if x$1 -- #17
//│   true =>
//│     let x$3 = False() in -- #6
//│     jump j$0(x$3) -- #5
//│   false =>
//│     let x$4 = -(x$0,1) in -- #16
//│     let* (x$5) = even(x$4) in -- #15
//│     jump j$0(x$5) -- #14
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #3
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #37
//│ if x$7 -- #36
//│   true =>
//│     let x$9 = True() in -- #25
//│     jump j$1(x$9) -- #24
//│   false =>
//│     let x$10 = -(x$6,1) in -- #35
//│     let* (x$11) = odd(x$10) in -- #34
//│     jump j$1(x$11) -- #33
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #22
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #43
//│ x$12 -- #42
//│ )
//│ },
//│ let* (x$13) = foo() in -- #47
//│ x$13 -- #46)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$1 = ==(x$0,0) in -- #18
//│ if x$1 -- #17
//│   true =>
//│     let x$3 = False() in -- #6
//│     jump j$0(x$3) -- #5
//│   false =>
//│     let x$4 = -(x$0,1) in -- #16
//│     let* (x$5) = even(x$4) in -- #15
//│     jump j$0(x$5) -- #14
//│ )
//│ Def(1, j$0, [x$2], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$2 -- #3
//│ )
//│ Def(2, even, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = ==(x$6,0) in -- #37
//│ if x$7 -- #36
//│   true =>
//│     let x$9 = True() in -- #25
//│     jump j$1(x$9) -- #24
//│   false =>
//│     let x$10 = -(x$6,1) in -- #35
//│     let* (x$11) = odd(x$10) in -- #34
//│     jump j$1(x$11) -- #33
//│ )
//│ Def(3, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #22
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(10) in -- #43
//│ x$12 -- #42
//│ )
//│ },
//│ let* (x$13) = foo() in -- #47
//│ x$13 -- #46)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mlsMain();
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_odd(_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_2){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_2;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_even(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_x_6==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     auto _mls_x_10 = (_mls_x_6-_mlsValue::fromIntLit(1));
//│     auto _mls_x_11 = _mls_odd(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_1 = (_mls_x_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_1)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_1)){
//│     auto _mls_x_4 = (_mls_x_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_5 = _mls_even(_mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_13 = _mls_foo();
//│   _mls_retval = _mls_x_13;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A extends AorB
class B(b) extends AorB
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() = foo(False)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=| |foo|(|False|)|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => foo(False,); main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #30
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #29
//│     let* (x$8) = foo(x$7) in -- #28
//│     let x$9 = B(x$8) in -- #27
//│     jump j$1(x$9) -- #26
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #37
//│ let* (x$11) = foo(x$10) in -- #36
//│ x$11 -- #35
//│ )
//│ },
//│ let* (x$12) = main() in -- #41
//│ x$12 -- #40)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, not, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$0 -- #8
//│   true =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   false =>
//│     let x$3 = True() in -- #7
//│     jump j$0(x$3) -- #6
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, foo, [x$4], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$4 -- #30
//│   true =>
//│     let x$6 = A() in -- #13
//│     jump j$1(x$6) -- #12
//│   false =>
//│     let* (x$7) = not(x$4) in -- #29
//│     let* (x$8) = foo(x$7) in -- #28
//│     let x$9 = B(x$8) in -- #27
//│     jump j$1(x$9) -- #26
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #10
//│ )
//│ Def(4, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = False() in -- #37
//│ let* (x$11) = foo(x$10) in -- #36
//│ x$11 -- #35
//│ )
//│ },
//│ let* (x$12) = main() in -- #41
//│ x$12 -- #40)
//│ 
//│ Interpreted:
//│ B(A())
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "AorB"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB;  return _mlsVal; }
//│ };
//│ struct _mls_B: public _mls_AorB{
//│   _mlsValue _mls_b;
//│   virtual const char *name() const override { return "B"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->_mls_b = _mls_b; return _mlsVal; }
//│ };
//│ struct _mls_A: public _mls_AorB{
//│ 
//│   virtual const char *name() const override { return "A"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A;  return _mlsVal; }
//│ };
//│ _mlsValue _mls_foo(_mlsValue _mls_x_4){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_4)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_4)){
//│     auto _mls_x_7 = _mls_not(_mls_x_4);
//│     auto _mls_x_8 = _mls_foo(_mls_x_7);
//│     auto _mls_x_9 = _mlsValue::create<_mls_B>(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_11 = _mls_foo(_mls_x_10);
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mls_main();
//│   _mls_retval = _mls_x_12;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A() extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A
       else B(foo(not(x)))
fun main() =
  let x = foo(False)
  if x is
    A then aaa()
    B(b1) then bbb()
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A|(||)| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A|→|#else| |B|(|foo|(|not|(|x|)|)|)|←|←|↵|#fun| |main|(||)| |#=|→|#let| |x| |#=| |foo|(|False|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A(): AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = () => {let x = foo(False,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #17
//│ let x$1 = 2 in -- #16
//│ let x$2 = 3 in -- #15
//│ let x$3 = 4 in -- #14
//│ let x$4 = +(x$0,x$1) in -- #13
//│ let x$5 = -(x$4,x$2) in -- #12
//│ let x$6 = +(x$5,x$3) in -- #11
//│ x$6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #28
//│ let x$8 = *(x$7,100) in -- #27
//│ let x$9 = +(x$8,4) in -- #26
//│ x$9 -- #25
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #37
//│   true =>
//│     let x$12 = False() in -- #33
//│     jump j$0(x$12) -- #32
//│   false =>
//│     let x$13 = True() in -- #36
//│     jump j$0(x$13) -- #35
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #30
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #59
//│   true =>
//│     let x$16 = A() in -- #42
//│     jump j$1(x$16) -- #41
//│   false =>
//│     let* (x$17) = not(x$14) in -- #58
//│     let* (x$18) = foo(x$17) in -- #57
//│     let x$19 = B(x$18) in -- #56
//│     jump j$1(x$19) -- #55
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #39
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #84
//│ let* (x$21) = foo(x$20) in -- #83
//│ case x$21 of -- #82
//│   A =>
//│     let* (x$23) = aaa() in -- #71
//│     jump j$2(x$23) -- #70
//│   B =>
//│     let x$24 = B.b(x$21) in -- #81
//│     let* (x$25) = bbb() in -- #80
//│     jump j$2(x$25) -- #79
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #66
//│ )
//│ },
//│ let* (x$26) = main() in -- #88
//│ x$26 -- #87)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #17
//│ let x$1 = 2 in -- #16
//│ let x$2 = 3 in -- #15
//│ let x$3 = 4 in -- #14
//│ let x$4 = +(x$0,x$1) in -- #13
//│ let x$5 = -(x$4,x$2) in -- #12
//│ let x$6 = +(x$5,x$3) in -- #11
//│ x$6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #28
//│ let x$8 = *(x$7,100) in -- #27
//│ let x$9 = +(x$8,4) in -- #26
//│ x$9 -- #25
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #37
//│   true =>
//│     let x$12 = False() in -- #33
//│     jump j$0(x$12) -- #32
//│   false =>
//│     let x$13 = True() in -- #36
//│     jump j$0(x$13) -- #35
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #30
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #59
//│   true =>
//│     let x$16 = A() in -- #42
//│     jump j$1(x$16) -- #41
//│   false =>
//│     let* (x$17) = not(x$14) in -- #58
//│     let* (x$18) = foo(x$17) in -- #57
//│     let x$19 = B(x$18) in -- #56
//│     jump j$1(x$19) -- #55
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #39
//│ )
//│ Def(6, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$20 = False() in -- #84
//│ let* (x$21) = foo(x$20) in -- #83
//│ case x$21 of -- #82
//│   A =>
//│     let* (x$23) = aaa() in -- #71
//│     jump j$2(x$23) -- #70
//│   B =>
//│     let x$24 = B.b(x$21) in -- #81
//│     let* (x$25) = bbb() in -- #80
//│     jump j$2(x$25) -- #79
//│ )
//│ Def(7, j$2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$22 -- #66
//│ )
//│ },
//│ let* (x$26) = main() in -- #88
//│ x$26 -- #87)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "AorB"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB;  return _mlsVal; }
//│ };
//│ struct _mls_B: public _mls_AorB{
//│   _mlsValue _mls_b;
//│   virtual const char *name() const override { return "B"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->_mls_b = _mls_b; return _mlsVal; }
//│ };
//│ struct _mls_A: public _mls_AorB{
//│ 
//│   virtual const char *name() const override { return "A"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A;  return _mlsVal; }
//│ };
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_22;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_21 = _mls_foo(_mls_x_20);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_21)){
//│     auto _mls_x_23 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_23);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_21)){
//│     auto _mls_x_24 = _mlsValue::as<_mls_B>(_mls_x_21)->_mls_b;
//│     auto _mls_x_25 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_25);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_26 = _mls_main();
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }


:interpIR
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(S(S(S(O))))
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|S|(|O|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(S(S(S(O,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #54
//│ let x$11 = S(x$10) in -- #53
//│ let x$12 = S(x$11) in -- #52
//│ let x$13 = S(x$12) in -- #51
//│ let* (x$14) = odd(x$13) in -- #50
//│ x$14 -- #49
//│ )
//│ },
//│ let* (x$15) = foo() in -- #58
//│ x$15 -- #57)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = O() in -- #54
//│ let x$11 = S(x$10) in -- #53
//│ let x$12 = S(x$11) in -- #52
//│ let x$13 = S(x$12) in -- #51
//│ let* (x$14) = odd(x$13) in -- #50
//│ x$14 -- #49
//│ )
//│ },
//│ let* (x$15) = foo() in -- #58
//│ x$15 -- #57)
//│ 
//│ Interpreted:
//│ True()

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class Nat
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(mk(10))
foo() 
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |Nat|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|mk|(|10|)|)|↵|foo|(||)| |
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class Nat {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(mk(10,),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #58
//│ if x$10 -- #57
//│   true =>
//│     let x$12 = -(n$0,1) in -- #53
//│     let* (x$13) = mk(x$12) in -- #52
//│     let x$14 = S(x$13) in -- #51
//│     jump j$2(x$14) -- #50
//│   false =>
//│     let x$15 = O() in -- #56
//│     jump j$2(x$15) -- #55
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #69
//│ let* (x$17) = odd(x$16) in -- #68
//│ x$17 -- #67
//│ )
//│ },
//│ let* (x$18) = foo() in -- #73
//│ x$18 -- #72)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, Nat, []),ClassInfo(4, S, [s]),ClassInfo(5, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #58
//│ if x$10 -- #57
//│   true =>
//│     let x$12 = -(n$0,1) in -- #53
//│     let* (x$13) = mk(x$12) in -- #52
//│     let x$14 = S(x$13) in -- #51
//│     jump j$2(x$14) -- #50
//│   false =>
//│     let x$15 = O() in -- #56
//│     jump j$2(x$15) -- #55
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #69
//│ let* (x$17) = odd(x$16) in -- #68
//│ x$17 -- #67
//│ )
//│ },
//│ let* (x$18) = foo() in -- #73
//│ x$18 -- #72)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Nat;
//│ struct _mls_Boolean;
//│ struct _mls_O;
//│ struct _mls_S;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_odd(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_foo();
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk(_mlsValue);
//│ _mlsValue _mls_even(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Nat: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Nat"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nat;  return _mlsVal; }
//│ };
//│ struct _mls_O: public _mls_Nat{
//│ 
//│   virtual const char *name() const override { return "O"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_O;  return _mlsVal; }
//│ };
//│ struct _mls_S: public _mls_Nat{
//│   _mlsValue _mls_s;
//│   virtual const char *name() const override { return "S"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_s) { auto _mlsVal = new (std::align_val_t(align)) _mls_S; _mlsVal->_mls_s = _mls_s; return _mlsVal; }
//│ };
//│ _mlsValue _mls_even(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_5)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_5)){
//│     auto _mls_x_8 = _mlsValue::as<_mls_S>(_mls_x_5)->_mls_s;
//│     auto _mls_x_9 = _mls_odd(_mls_x_8);
//│     _mls_retval = _mls_j_1(_mls_x_9);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_odd(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_O>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_S>(_mls_x_0)){
//│     auto _mls_x_3 = _mlsValue::as<_mls_S>(_mls_x_0)->_mls_s;
//│     auto _mls_x_4 = _mls_even(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_16 = _mls_mk(_mlsValue::fromIntLit(10));
//│   auto _mls_x_17 = _mls_odd(_mls_x_16);
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_10 = (_mls_n_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_13 = _mls_mk(_mls_x_12);
//│     auto _mls_x_14 = _mlsValue::create<_mls_S>(_mls_x_13);
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_15 = _mlsValue::create<_mls_O>();
//│     _mls_retval = _mls_j_2(_mls_x_15);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_18 = _mls_foo();
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun mk(n) = if n > 0 then S(mk(n - 1)) else O
fun foo() = odd(S(S(mk(10))))
foo()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |mk|(|n|)| |#=| |#if| |n| |>| |0| |#then| |S|(|mk|(|n| |-| |1|)|)| |#else| |O|↵|#fun| |foo|(||)| |#=| |odd|(|S|(|S|(|mk|(|10|)|)|)|)|↵|foo|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun mk = (n,) => if (>(n,)(0,)) then S(mk(-(n,)(1,),),) else O; fun foo = () => odd(S(S(mk(10,),),),); foo()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, S, [s]),ClassInfo(4, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #58
//│ if x$10 -- #57
//│   true =>
//│     let x$12 = -(n$0,1) in -- #53
//│     let* (x$13) = mk(x$12) in -- #52
//│     let x$14 = S(x$13) in -- #51
//│     jump j$2(x$14) -- #50
//│   false =>
//│     let x$15 = O() in -- #56
//│     jump j$2(x$15) -- #55
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #77
//│ let x$17 = S(x$16) in -- #76
//│ let x$18 = S(x$17) in -- #75
//│ let* (x$19) = odd(x$18) in -- #74
//│ x$19 -- #73
//│ )
//│ },
//│ let* (x$20) = foo() in -- #81
//│ x$20 -- #80)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, S, [s]),ClassInfo(4, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, mk, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(n$0,0) in -- #58
//│ if x$10 -- #57
//│   true =>
//│     let x$12 = -(n$0,1) in -- #53
//│     let* (x$13) = mk(x$12) in -- #52
//│     let x$14 = S(x$13) in -- #51
//│     jump j$2(x$14) -- #50
//│   false =>
//│     let x$15 = O() in -- #56
//│     jump j$2(x$15) -- #55
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #39
//│ )
//│ Def(6, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$16) = mk(10) in -- #77
//│ let x$17 = S(x$16) in -- #76
//│ let x$18 = S(x$17) in -- #75
//│ let* (x$19) = odd(x$18) in -- #74
//│ x$19 -- #73
//│ )
//│ },
//│ let* (x$20) = foo() in -- #81
//│ x$20 -- #80)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ 
//│ IR Processing Failed: Cycle detected in class hierarchy: O, S
//│ 
//│ mlscript.compiler.codegen.cpp.CppCodeGen.sortClasses(CppCodeGen.scala:164)
//│ mlscript.compiler.codegen.cpp.CppCodeGen.codegen(CppCodeGen.scala:169)
//│ mlscript.compiler.IRDiffTestCompiler.postProcess(TestIR.scala:32)
//│ mlscript.DiffTests.rec$1(DiffTests.scala:454)
//│ mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1053)
//│ org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ org.scalatest.Transformer.apply(Transformer.scala:22)
//│ org.scalatest.Transformer.apply(Transformer.scala:20)
//│ org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:226)
//│ org.scalatest.TestSuite.withFixture(TestSuite.scala:196)
//│ org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)
//│ mlscript.DiffTests.org$scalatest$concurrent$TimeLimitedTests$$super$withFixture(DiffTests.scala:49)
//│ org.scalatest.concurrent.TimeLimitedTests.$anonfun$withFixture$3(TimeLimitedTests.scala:154)
//│ org.scalatest.enablers.Timed$$anon$1.timeoutAfter(Timed.scala:127)
//│ org.scalatest.concurrent.TimeLimits$.failAfterImpl(TimeLimits.scala:282)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture(TimeLimitedTests.scala:153)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture$(TimeLimitedTests.scala:150)
//│ mlscript.DiffTests.withFixture(DiffTests.scala:49)
//│ org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:224)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:236)
//│ org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:236)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:218)
//│ mlscript.DiffTests.org$scalatest$OneInstancePerTest$$super$runTest(DiffTests.scala:49)
//│ org.scalatest.OneInstancePerTest.runTest(OneInstancePerTest.scala:131)
//│ org.scalatest.OneInstancePerTest.runTest$(OneInstancePerTest.scala:123)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTest(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.runTest(ParallelTestExecution.scala:164)
//│ org.scalatest.ParallelTestExecution.runTest$(ParallelTestExecution.scala:148)
//│ mlscript.DiffTests.runTest(DiffTests.scala:49)
//│ org.scalatest.OneInstancePerTest.runTests(OneInstancePerTest.scala:181)
//│ org.scalatest.OneInstancePerTest.runTests$(OneInstancePerTest.scala:172)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTests(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.runTests(ParallelTestExecution.scala:97)
//│ org.scalatest.ParallelTestExecution.runTests$(ParallelTestExecution.scala:79)
//│ mlscript.DiffTests.runTests(DiffTests.scala:49)
//│ org.scalatest.Suite.run(Suite.scala:1114)
//│ org.scalatest.Suite.run$(Suite.scala:1096)
//│ org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1563)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:273)
//│ org.scalatest.SuperEngine.runImpl(Engine.scala:535)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:273)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:272)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$run(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.run(ParallelTestExecution.scala:261)
//│ org.scalatest.ParallelTestExecution.run$(ParallelTestExecution.scala:258)
//│ mlscript.DiffTests.run(DiffTests.scala:49)
//│ org.scalatest.tools.DistributedTestRunnerSuite.run(DistributedTestRunnerSuite.scala:22)
//│ org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:47)
//│ java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
//│ java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
//│ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
//│ java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
//│ java.base/java.lang.Thread.run(Thread.java:829)

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class S(s) extends Nat
class O extends Nat
fun odd(x) =
  if x is
    O then False
    S(s) then even(s)
fun even(x) =
  if x is
    O then True
    S(s) then odd(s)
fun foo() = odd(if 10 > 0 then S(O) else O)
fun bar() = if 10 > 0 then odd(S(O)) else odd(O)
fun main() =
  foo()
  bar()
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |S|(|s|)| |#extends| |Nat|↵|#class| |O| |#extends| |Nat|↵|#fun| |odd|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |False|↵|S|(|s|)| |#then| |even|(|s|)|←|←|↵|#fun| |even|(|x|)| |#=|→|#if| |x| |is|→|O| |#then| |True|↵|S|(|s|)| |#then| |odd|(|s|)|←|←|↵|#fun| |foo|(||)| |#=| |odd|(|#if| |10| |>| |0| |#then| |S|(|O|)| |#else| |O|)|↵|#fun| |bar|(||)| |#=| |#if| |10| |>| |0| |#then| |odd|(|S|(|O|)|)| |#else| |odd|(|O|)|↵|#fun| |main|(||)| |#=|→|foo|(||)|↵|bar|(||)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class S(s,): Nat {}; class O: Nat {}; fun odd = (x,) => {if x is ‹(O) then False; (S(s,)) then even(s,)›}; fun even = (x,) => {if x is ‹(O) then True; (S(s,)) then odd(s,)›}; fun foo = () => odd(if (>(10,)(0,)) then S(O,) else O,); fun bar = () => if (>(10,)(0,)) then odd(S(O,),) else odd(O,); fun main = () => {foo(); bar()}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, S, [s]),ClassInfo(4, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #56
//│ if x$10 -- #55
//│   true =>
//│     let x$13 = O() in -- #51
//│     let x$14 = S(x$13) in -- #50
//│     jump j$2(x$14) -- #49
//│   false =>
//│     let x$15 = O() in -- #54
//│     jump j$2(x$15) -- #53
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #44
//│ x$12 -- #43
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #82
//│ if x$16 -- #81
//│   true =>
//│     let x$18 = O() in -- #72
//│     let x$19 = S(x$18) in -- #71
//│     let* (x$20) = odd(x$19) in -- #70
//│     jump j$3(x$20) -- #69
//│   false =>
//│     let x$21 = O() in -- #80
//│     let* (x$22) = odd(x$21) in -- #79
//│     jump j$3(x$22) -- #78
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #60
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #90
//│ let* (x$24) = bar() in -- #89
//│ x$24 -- #88
//│ )
//│ },
//│ let* (x$25) = main() in -- #94
//│ x$25 -- #93)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, S, [s]),ClassInfo(4, O, [])}, {
//│ Def(0, odd, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$0 of -- #17
//│   O =>
//│     let x$2 = False() in -- #4
//│     jump j$0(x$2) -- #3
//│   S =>
//│     let x$3 = S.s(x$0) in -- #16
//│     let* (x$4) = even(x$3) in -- #15
//│     jump j$0(x$4) -- #14
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #1
//│ )
//│ Def(2, even, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case x$5 of -- #35
//│   O =>
//│     let x$7 = True() in -- #22
//│     jump j$1(x$7) -- #21
//│   S =>
//│     let x$8 = S.s(x$5) in -- #34
//│     let* (x$9) = odd(x$8) in -- #33
//│     jump j$1(x$9) -- #32
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #19
//│ )
//│ Def(4, foo, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$10 = >(10,0) in -- #56
//│ if x$10 -- #55
//│   true =>
//│     let x$13 = O() in -- #51
//│     let x$14 = S(x$13) in -- #50
//│     jump j$2(x$14) -- #49
//│   false =>
//│     let x$15 = O() in -- #54
//│     jump j$2(x$15) -- #53
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$12) = odd(x$11) in -- #44
//│ x$12 -- #43
//│ )
//│ Def(6, bar, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$16 = >(10,0) in -- #82
//│ if x$16 -- #81
//│   true =>
//│     let x$18 = O() in -- #72
//│     let x$19 = S(x$18) in -- #71
//│     let* (x$20) = odd(x$19) in -- #70
//│     jump j$3(x$20) -- #69
//│   false =>
//│     let x$21 = O() in -- #80
//│     let* (x$22) = odd(x$21) in -- #79
//│     jump j$3(x$22) -- #78
//│ )
//│ Def(7, j$3, [x$17], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$17 -- #60
//│ )
//│ Def(8, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$23) = foo() in -- #90
//│ let* (x$24) = bar() in -- #89
//│ x$24 -- #88
//│ )
//│ },
//│ let* (x$25) = main() in -- #94
//│ x$25 -- #93)
//│ 
//│ Interpreted:
//│ True()
//│ 
//│ Cpp:
//│ 
//│ IR Processing Failed: Cycle detected in class hierarchy: O, S
//│ 
//│ mlscript.compiler.codegen.cpp.CppCodeGen.sortClasses(CppCodeGen.scala:164)
//│ mlscript.compiler.codegen.cpp.CppCodeGen.codegen(CppCodeGen.scala:169)
//│ mlscript.compiler.IRDiffTestCompiler.postProcess(TestIR.scala:32)
//│ mlscript.DiffTests.rec$1(DiffTests.scala:454)
//│ mlscript.DiffTests.$anonfun$new$3(DiffTests.scala:1053)
//│ org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)
//│ org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)
//│ org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
//│ org.scalatest.Transformer.apply(Transformer.scala:22)
//│ org.scalatest.Transformer.apply(Transformer.scala:20)
//│ org.scalatest.funsuite.AnyFunSuiteLike$$anon$1.apply(AnyFunSuiteLike.scala:226)
//│ org.scalatest.TestSuite.withFixture(TestSuite.scala:196)
//│ org.scalatest.TestSuite.withFixture$(TestSuite.scala:195)
//│ mlscript.DiffTests.org$scalatest$concurrent$TimeLimitedTests$$super$withFixture(DiffTests.scala:49)
//│ org.scalatest.concurrent.TimeLimitedTests.$anonfun$withFixture$3(TimeLimitedTests.scala:154)
//│ org.scalatest.enablers.Timed$$anon$1.timeoutAfter(Timed.scala:127)
//│ org.scalatest.concurrent.TimeLimits$.failAfterImpl(TimeLimits.scala:282)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture(TimeLimitedTests.scala:153)
//│ org.scalatest.concurrent.TimeLimitedTests.withFixture$(TimeLimitedTests.scala:150)
//│ mlscript.DiffTests.withFixture(DiffTests.scala:49)
//│ org.scalatest.funsuite.AnyFunSuiteLike.invokeWithFixture$1(AnyFunSuiteLike.scala:224)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$runTest$1(AnyFunSuiteLike.scala:236)
//│ org.scalatest.SuperEngine.runTestImpl(Engine.scala:306)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest(AnyFunSuiteLike.scala:236)
//│ org.scalatest.funsuite.AnyFunSuiteLike.runTest$(AnyFunSuiteLike.scala:218)
//│ mlscript.DiffTests.org$scalatest$OneInstancePerTest$$super$runTest(DiffTests.scala:49)
//│ org.scalatest.OneInstancePerTest.runTest(OneInstancePerTest.scala:131)
//│ org.scalatest.OneInstancePerTest.runTest$(OneInstancePerTest.scala:123)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTest(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.runTest(ParallelTestExecution.scala:164)
//│ org.scalatest.ParallelTestExecution.runTest$(ParallelTestExecution.scala:148)
//│ mlscript.DiffTests.runTest(DiffTests.scala:49)
//│ org.scalatest.OneInstancePerTest.runTests(OneInstancePerTest.scala:181)
//│ org.scalatest.OneInstancePerTest.runTests$(OneInstancePerTest.scala:172)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$runTests(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.runTests(ParallelTestExecution.scala:97)
//│ org.scalatest.ParallelTestExecution.runTests$(ParallelTestExecution.scala:79)
//│ mlscript.DiffTests.runTests(DiffTests.scala:49)
//│ org.scalatest.Suite.run(Suite.scala:1114)
//│ org.scalatest.Suite.run$(Suite.scala:1096)
//│ org.scalatest.funsuite.AnyFunSuite.org$scalatest$funsuite$AnyFunSuiteLike$$super$run(AnyFunSuite.scala:1563)
//│ org.scalatest.funsuite.AnyFunSuiteLike.$anonfun$run$1(AnyFunSuiteLike.scala:273)
//│ org.scalatest.SuperEngine.runImpl(Engine.scala:535)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run(AnyFunSuiteLike.scala:273)
//│ org.scalatest.funsuite.AnyFunSuiteLike.run$(AnyFunSuiteLike.scala:272)
//│ mlscript.DiffTests.org$scalatest$ParallelTestExecution$$super$run(DiffTests.scala:49)
//│ org.scalatest.ParallelTestExecution.run(ParallelTestExecution.scala:261)
//│ org.scalatest.ParallelTestExecution.run$(ParallelTestExecution.scala:258)
//│ mlscript.DiffTests.run(DiffTests.scala:49)
//│ org.scalatest.tools.DistributedTestRunnerSuite.run(DistributedTestRunnerSuite.scala:22)
//│ org.scalatest.tools.SuiteRunner.run(SuiteRunner.scala:47)
//│ java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
//│ java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
//│ java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
//│ java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
//│ java.base/java.lang.Thread.run(Thread.java:829)

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class AorB
class A extends AorB
class B(b) extends AorB
fun aaa() =
  let m = 1
  let n = 2
  let p = 3
  let q = 4
  m + n - p + q
fun bbb() =
  let x = aaa()
  x * 100 + 4
fun not(x) =
  if x then False else True
fun foo(x) =
  if x then A else B(foo(not(x)))
fun main(flag) =
  let x = foo(flag)
  if x is
    A then aaa()
    B(b1) then bbb()
main(False)
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |AorB|↵|#class| |A| |#extends| |AorB|↵|#class| |B|(|b|)| |#extends| |AorB|↵|#fun| |aaa|(||)| |#=|→|#let| |m| |#=| |1|↵|#let| |n| |#=| |2|↵|#let| |p| |#=| |3|↵|#let| |q| |#=| |4|↵|m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |bbb|(||)| |#=|→|#let| |x| |#=| |aaa|(||)|↵|x| |*| |100| |+| |4|←|↵|#fun| |not|(|x|)| |#=|→|#if| |x| |#then| |False| |#else| |True|←|↵|#fun| |foo|(|x|)| |#=|→|#if| |x| |#then| |A| |#else| |B|(|foo|(|not|(|x|)|)|)|←|↵|#fun| |main|(|flag|)| |#=|→|#let| |x| |#=| |foo|(|flag|)|↵|#if| |x| |is|→|A| |#then| |aaa|(||)|↵|B|(|b1|)| |#then| |bbb|(||)|←|←|↵|main|(|False|)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class AorB {}; class A: AorB {}; class B(b,): AorB {}; fun aaa = () => {let m = 1; let n = 2; let p = 3; let q = 4; +(-(+(m,)(n,),)(p,),)(q,)}; fun bbb = () => {let x = aaa(); +(*(x,)(100,),)(4,)}; fun not = (x,) => {if (x) then False else True}; fun foo = (x,) => {if (x) then A else B(foo(not(x,),),)}; fun main = (flag,) => {let x = foo(flag,); if x is ‹(A) then aaa(); (B(b1,)) then bbb()›}; main(False,)}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #17
//│ let x$1 = 2 in -- #16
//│ let x$2 = 3 in -- #15
//│ let x$3 = 4 in -- #14
//│ let x$4 = +(x$0,x$1) in -- #13
//│ let x$5 = -(x$4,x$2) in -- #12
//│ let x$6 = +(x$5,x$3) in -- #11
//│ x$6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #28
//│ let x$8 = *(x$7,100) in -- #27
//│ let x$9 = +(x$8,4) in -- #26
//│ x$9 -- #25
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #37
//│   true =>
//│     let x$12 = False() in -- #33
//│     jump j$0(x$12) -- #32
//│   false =>
//│     let x$13 = True() in -- #36
//│     jump j$0(x$13) -- #35
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #30
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #59
//│   true =>
//│     let x$16 = A() in -- #42
//│     jump j$1(x$16) -- #41
//│   false =>
//│     let* (x$17) = not(x$14) in -- #58
//│     let* (x$18) = foo(x$17) in -- #57
//│     let x$19 = B(x$18) in -- #56
//│     jump j$1(x$19) -- #55
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #39
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #83
//│ case x$20 of -- #82
//│   A =>
//│     let* (x$22) = aaa() in -- #71
//│     jump j$2(x$22) -- #70
//│   B =>
//│     let x$23 = B.b(x$20) in -- #81
//│     let* (x$24) = bbb() in -- #80
//│     jump j$2(x$24) -- #79
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #66
//│ )
//│ },
//│ let x$25 = False() in -- #90
//│ let* (x$26) = main(x$25) in -- #89
//│ x$26 -- #88)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, AorB, []),ClassInfo(4, A, []),ClassInfo(5, B, [b])}, {
//│ Def(0, aaa, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = 1 in -- #17
//│ let x$1 = 2 in -- #16
//│ let x$2 = 3 in -- #15
//│ let x$3 = 4 in -- #14
//│ let x$4 = +(x$0,x$1) in -- #13
//│ let x$5 = -(x$4,x$2) in -- #12
//│ let x$6 = +(x$5,x$3) in -- #11
//│ x$6 -- #10
//│ )
//│ Def(1, bbb, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$7) = aaa() in -- #28
//│ let x$8 = *(x$7,100) in -- #27
//│ let x$9 = +(x$8,4) in -- #26
//│ x$9 -- #25
//│ )
//│ Def(2, not, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$10 -- #37
//│   true =>
//│     let x$12 = False() in -- #33
//│     jump j$0(x$12) -- #32
//│   false =>
//│     let x$13 = True() in -- #36
//│     jump j$0(x$13) -- #35
//│ )
//│ Def(3, j$0, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #30
//│ )
//│ Def(4, foo, [x$14], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ if x$14 -- #59
//│   true =>
//│     let x$16 = A() in -- #42
//│     jump j$1(x$16) -- #41
//│   false =>
//│     let* (x$17) = not(x$14) in -- #58
//│     let* (x$18) = foo(x$17) in -- #57
//│     let x$19 = B(x$18) in -- #56
//│     jump j$1(x$19) -- #55
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #39
//│ )
//│ Def(6, main, [flag$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$20) = foo(flag$0) in -- #83
//│ case x$20 of -- #82
//│   A =>
//│     let* (x$22) = aaa() in -- #71
//│     jump j$2(x$22) -- #70
//│   B =>
//│     let x$23 = B.b(x$20) in -- #81
//│     let* (x$24) = bbb() in -- #80
//│     jump j$2(x$24) -- #79
//│ )
//│ Def(7, j$2, [x$21], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$21 -- #66
//│ )
//│ },
//│ let x$25 = False() in -- #90
//│ let* (x$26) = main(x$25) in -- #89
//│ x$26 -- #88)
//│ 
//│ Interpreted:
//│ 404
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_AorB;
//│ struct _mls_Boolean;
//│ struct _mls_B;
//│ struct _mls_A;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_aaa();
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_bbb();
//│ _mlsValue _mls_not(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_foo(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_AorB: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "AorB"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_AorB;  return _mlsVal; }
//│ };
//│ struct _mls_B: public _mls_AorB{
//│   _mlsValue _mls_b;
//│   virtual const char *name() const override { return "B"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_b) { auto _mlsVal = new (std::align_val_t(align)) _mls_B; _mlsVal->_mls_b = _mls_b; return _mlsVal; }
//│ };
//│ struct _mls_A: public _mls_AorB{
//│ 
//│   virtual const char *name() const override { return "A"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_A;  return _mlsVal; }
//│ };
//│ _mlsValue _mls_main(_mlsValue _mls_flag_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_20 = _mls_foo(_mls_flag_0);
//│   if (_mlsValue::isValueOf<_mls_A>(_mls_x_20)){
//│     auto _mls_x_22 = _mls_aaa();
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else if (_mlsValue::isValueOf<_mls_B>(_mls_x_20)){
//│     auto _mls_x_23 = _mlsValue::as<_mls_B>(_mls_x_20)->_mls_b;
//│     auto _mls_x_24 = _mls_bbb();
//│     _mls_retval = _mls_j_2(_mls_x_24);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_21){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_21;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_foo(_mlsValue _mls_x_14){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_14)){
//│     auto _mls_x_16 = _mlsValue::create<_mls_A>();
//│     _mls_retval = _mls_j_1(_mls_x_16);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_14)){
//│     auto _mls_x_17 = _mls_not(_mls_x_14);
//│     auto _mls_x_18 = _mls_foo(_mls_x_17);
//│     auto _mls_x_19 = _mlsValue::create<_mls_B>(_mls_x_18);
//│     _mls_retval = _mls_j_1(_mls_x_19);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_aaa(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = _mlsValue::fromIntLit(1);
//│   auto _mls_x_1 = _mlsValue::fromIntLit(2);
//│   auto _mls_x_2 = _mlsValue::fromIntLit(3);
//│   auto _mls_x_3 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_4 = (_mls_x_0+_mls_x_1);
//│   auto _mls_x_5 = (_mls_x_4-_mls_x_2);
//│   auto _mls_x_6 = (_mls_x_5+_mls_x_3);
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_not(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_10)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_10)){
//│     auto _mls_x_13 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_13);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_bbb(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = _mls_aaa();
//│   auto _mls_x_8 = (_mls_x_7*_mlsValue::fromIntLit(100));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_9;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_25 = _mlsValue::create<_mls_False>();
//│   auto _mls_x_26 = _mls_main(_mls_x_25);
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }


:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(Cons(1, Cons(2, Nil)))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|Cons|(|1|,| |Cons|(|2|,| |Nil|)|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(Cons(1, Cons(2, Nil,),),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #46
//│ let* (x$10) = is_none(x$9) in -- #45
//│ x$10 -- #44
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #65
//│ let x$12 = Cons(2,x$11) in -- #64
//│ let x$13 = Cons(1,x$12) in -- #63
//│ let* (x$14) = is_empty(x$13) in -- #62
//│ x$14 -- #61
//│ )
//│ },
//│ let* (x$15) = main() in -- #69
//│ x$15 -- #68)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #21
//│   Nil =>
//│     let x$1 = None() in -- #4
//│     jump j$0(x$1) -- #3
//│   Cons =>
//│     let x$2 = Cons.t(l$0) in -- #20
//│     let x$3 = Cons.h(l$0) in -- #19
//│     let x$4 = Some(x$3) in -- #18
//│     jump j$0(x$4) -- #17
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #35
//│   None =>
//│     let x$6 = True() in -- #26
//│     jump j$1(x$6) -- #25
//│   Some =>
//│     let x$7 = Some.x(o$0) in -- #34
//│     let x$8 = False() in -- #33
//│     jump j$1(x$8) -- #32
//│ )
//│ Def(3, j$1, [x$5], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$5 -- #23
//│ )
//│ Def(4, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$9) = head_opt(l$1) in -- #46
//│ let* (x$10) = is_none(x$9) in -- #45
//│ x$10 -- #44
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = Nil() in -- #65
//│ let x$12 = Cons(2,x$11) in -- #64
//│ let x$13 = Cons(1,x$12) in -- #63
//│ let* (x$14) = is_empty(x$13) in -- #62
//│ x$14 -- #61
//│ )
//│ },
//│ let* (x$15) = main() in -- #69
//│ x$15 -- #68)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Option"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option;  return _mlsVal; }
//│ };
//│ struct _mls_Some: public _mls_Option{
//│   _mlsValue _mls_x;
//│   virtual const char *name() const override { return "Some"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->_mls_x = _mls_x; return _mlsVal; }
//│ };
//│ struct _mls_None: public _mls_Option{
//│ 
//│   virtual const char *name() const override { return "None"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None;  return _mlsVal; }
//│ };
//│ struct _mls_List: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "List"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List;  return _mlsVal; }
//│ };
//│ struct _mls_Nil: public _mls_List{
//│ 
//│   virtual const char *name() const override { return "Nil"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil;  return _mlsVal; }
//│ };
//│ struct _mls_Cons: public _mls_List{
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   virtual const char *name() const override { return "Cons"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->_mls_h = _mls_h;_mlsVal->_mls_t = _mls_t; return _mlsVal; }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_5){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_5;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_9 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_10 = _mls_is_none(_mls_x_9);
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_1 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_0(_mls_x_1);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_2 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_3 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_4 = _mlsValue::create<_mls_Some>(_mls_x_3);
//│     _mls_retval = _mls_j_0(_mls_x_4);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_6 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_1(_mls_x_6);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_7 = _mlsValue::as<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_8 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_1(_mls_x_8);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::create<_mls_Nil>();
//│   auto _mls_x_12 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(2), _mls_x_11);
//│   auto _mls_x_13 = _mlsValue::create<_mls_Cons>(_mlsValue::fromIntLit(1), _mls_x_12);
//│   auto _mls_x_14 = _mls_is_empty(_mls_x_13);
//│   _mls_retval = _mls_x_14;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_main();
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun head_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then Some(h)
fun is_none(o) =
  if o is
    None then True
    Some(x) then False
fun is_empty(l) =
  is_none(head_opt(l))
fun main() =
  is_empty(mk_list(10))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |head_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then| |Some|(|h|)|←|←|↵|#fun| |is_none|(|o|)| |#=|→|#if| |o| |is|→|None| |#then| |True|↵|Some|(|x|)| |#then| |False|←|←|↵|#fun| |is_empty|(|l|)| |#=|→|is_none|(|head_opt|(|l|)|)|←|↵|#fun| |main|(||)| |#=|→|is_empty|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun head_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then Some(h,)›}; fun is_none = (o,) => {if o is ‹(None) then True; (Some(x,)) then False›}; fun is_empty = (l,) => {is_none(head_opt(l,),)}; fun main = () => {is_empty(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #24
//│ if x$0 -- #23
//│   true =>
//│     let x$2 = Nil() in -- #6
//│     jump j$0(x$2) -- #5
//│   false =>
//│     let x$3 = -(n$0,1) in -- #22
//│     let* (x$4) = mk_list(x$3) in -- #21
//│     let x$5 = Cons(n$0,x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #46
//│   Nil =>
//│     let x$7 = None() in -- #29
//│     jump j$1(x$7) -- #28
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #45
//│     let x$9 = Cons.h(l$0) in -- #44
//│     let x$10 = Some(x$9) in -- #43
//│     jump j$1(x$10) -- #42
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #60
//│   None =>
//│     let x$12 = True() in -- #51
//│     jump j$2(x$12) -- #50
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #59
//│     let x$14 = False() in -- #58
//│     jump j$2(x$14) -- #57
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #48
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #71
//│ let* (x$16) = is_none(x$15) in -- #70
//│ x$16 -- #69
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #82
//│ let* (x$18) = is_empty(x$17) in -- #81
//│ x$18 -- #80
//│ )
//│ },
//│ let* (x$19) = main() in -- #86
//│ x$19 -- #85)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #24
//│ if x$0 -- #23
//│   true =>
//│     let x$2 = Nil() in -- #6
//│     jump j$0(x$2) -- #5
//│   false =>
//│     let x$3 = -(n$0,1) in -- #22
//│     let* (x$4) = mk_list(x$3) in -- #21
//│     let x$5 = Cons(n$0,x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, head_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #46
//│   Nil =>
//│     let x$7 = None() in -- #29
//│     jump j$1(x$7) -- #28
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #45
//│     let x$9 = Cons.h(l$0) in -- #44
//│     let x$10 = Some(x$9) in -- #43
//│     jump j$1(x$10) -- #42
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, is_none, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #60
//│   None =>
//│     let x$12 = True() in -- #51
//│     jump j$2(x$12) -- #50
//│   Some =>
//│     let x$13 = Some.x(o$0) in -- #59
//│     let x$14 = False() in -- #58
//│     jump j$2(x$14) -- #57
//│ )
//│ Def(5, j$2, [x$11], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$11 -- #48
//│ )
//│ Def(6, is_empty, [l$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = head_opt(l$1) in -- #71
//│ let* (x$16) = is_none(x$15) in -- #70
//│ x$16 -- #69
//│ )
//│ Def(7, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$17) = mk_list(10) in -- #82
//│ let* (x$18) = is_empty(x$17) in -- #81
//│ x$18 -- #80
//│ )
//│ },
//│ let* (x$19) = main() in -- #86
//│ x$19 -- #85)
//│ 
//│ Interpreted:
//│ False()
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_is_empty(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_is_none(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mls_head_opt(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Option"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option;  return _mlsVal; }
//│ };
//│ struct _mls_Some: public _mls_Option{
//│   _mlsValue _mls_x;
//│   virtual const char *name() const override { return "Some"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->_mls_x = _mls_x; return _mlsVal; }
//│ };
//│ struct _mls_None: public _mls_Option{
//│ 
//│   virtual const char *name() const override { return "None"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None;  return _mlsVal; }
//│ };
//│ struct _mls_List: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "List"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List;  return _mlsVal; }
//│ };
//│ struct _mls_Nil: public _mls_List{
//│ 
//│   virtual const char *name() const override { return "Nil"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil;  return _mlsVal; }
//│ };
//│ struct _mls_Cons: public _mls_List{
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   virtual const char *name() const override { return "Cons"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->_mls_h = _mls_h;_mlsVal->_mls_t = _mls_t; return _mlsVal; }
//│ };
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_18 = _mls_is_empty(_mls_x_17);
//│   _mls_retval = _mls_x_18;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_empty(_mlsValue _mls_l_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_head_opt(_mls_l_1);
//│   auto _mls_x_16 = _mls_is_none(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_none(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_12 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_2(_mls_x_12);
//│   } else if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_13 = _mlsValue::as<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_14 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_2(_mls_x_14);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_11){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_11;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_head_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_h;
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     _mls_retval = _mls_j_1(_mls_x_10);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_19 = _mls_main();
//│   _mls_retval = _mls_x_19;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun mk_list(n) =
  if n == 0 then Nil else Cons(n, mk_list(n - 1))
fun last_opt(l) =
  if l is
    Nil then None
    Cons(h, t) then
      if t is
        Nil then Some(h)
        Cons(h2, t2) then last_opt(t)
fun main() =
  last_opt(mk_list(10))
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |mk_list|(|n|)| |#=|→|#if| |n| |==| |0| |#then| |Nil| |#else| |Cons|(|n|,| |mk_list|(|n| |-| |1|)|)|←|↵|#fun| |last_opt|(|l|)| |#=|→|#if| |l| |is|→|Nil| |#then| |None|↵|Cons|(|h|,| |t|)| |#then|→|#if| |t| |is|→|Nil| |#then| |Some|(|h|)|↵|Cons|(|h2|,| |t2|)| |#then| |last_opt|(|t|)|←|←|←|←|↵|#fun| |main|(||)| |#=|→|last_opt|(|mk_list|(|10|)|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun mk_list = (n,) => {if (==(n,)(0,)) then Nil else Cons(n, mk_list(-(n,)(1,),),)}; fun last_opt = (l,) => {if l is ‹(Nil) then None; (Cons(h, t,)) then {if t is ‹(Nil) then Some(h,); (Cons(h2, t2,)) then last_opt(t,)›}›}; fun main = () => {last_opt(mk_list(10,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #24
//│ if x$0 -- #23
//│   true =>
//│     let x$2 = Nil() in -- #6
//│     jump j$0(x$2) -- #5
//│   false =>
//│     let x$3 = -(n$0,1) in -- #22
//│     let* (x$4) = mk_list(x$3) in -- #21
//│     let x$5 = Cons(n$0,x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #67
//│   Nil =>
//│     let x$7 = None() in -- #29
//│     jump j$1(x$7) -- #28
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #66
//│     let x$9 = Cons.h(l$0) in -- #65
//│     case x$8 of -- #64
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #46
//│         jump j$2(x$11) -- #45
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #63
//│         let x$13 = Cons.h(x$8) in -- #62
//│         let* (x$14) = last_opt(x$8) in -- #61
//│         jump j$2(x$14) -- #60
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #40
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #78
//│ let* (x$16) = last_opt(x$15) in -- #77
//│ x$16 -- #76
//│ )
//│ },
//│ let* (x$17) = main() in -- #82
//│ x$17 -- #81)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, mk_list, [n$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$0 = ==(n$0,0) in -- #24
//│ if x$0 -- #23
//│   true =>
//│     let x$2 = Nil() in -- #6
//│     jump j$0(x$2) -- #5
//│   false =>
//│     let x$3 = -(n$0,1) in -- #22
//│     let* (x$4) = mk_list(x$3) in -- #21
//│     let x$5 = Cons(n$0,x$4) in -- #20
//│     jump j$0(x$5) -- #19
//│ )
//│ Def(1, j$0, [x$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$1 -- #3
//│ )
//│ Def(2, last_opt, [l$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case l$0 of -- #67
//│   Nil =>
//│     let x$7 = None() in -- #29
//│     jump j$1(x$7) -- #28
//│   Cons =>
//│     let x$8 = Cons.t(l$0) in -- #66
//│     let x$9 = Cons.h(l$0) in -- #65
//│     case x$8 of -- #64
//│       Nil =>
//│         let x$11 = Some(x$9) in -- #46
//│         jump j$2(x$11) -- #45
//│       Cons =>
//│         let x$12 = Cons.t(x$8) in -- #63
//│         let x$13 = Cons.h(x$8) in -- #62
//│         let* (x$14) = last_opt(x$8) in -- #61
//│         jump j$2(x$14) -- #60
//│ )
//│ Def(3, j$1, [x$6], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$6 -- #26
//│ )
//│ Def(4, j$2, [x$10], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ jump j$1(x$10) -- #40
//│ )
//│ Def(5, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$15) = mk_list(10) in -- #78
//│ let* (x$16) = last_opt(x$15) in -- #77
//│ x$16 -- #76
//│ )
//│ },
//│ let* (x$17) = main() in -- #82
//│ x$17 -- #81)
//│ 
//│ Interpreted:
//│ Some(1)
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_last_opt(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_mk_list(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Option"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option;  return _mlsVal; }
//│ };
//│ struct _mls_Some: public _mls_Option{
//│   _mlsValue _mls_x;
//│   virtual const char *name() const override { return "Some"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->_mls_x = _mls_x; return _mlsVal; }
//│ };
//│ struct _mls_None: public _mls_Option{
//│ 
//│   virtual const char *name() const override { return "None"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None;  return _mlsVal; }
//│ };
//│ struct _mls_List: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "List"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List;  return _mlsVal; }
//│ };
//│ struct _mls_Nil: public _mls_List{
//│ 
//│   virtual const char *name() const override { return "Nil"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil;  return _mlsVal; }
//│ };
//│ struct _mls_Cons: public _mls_List{
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   virtual const char *name() const override { return "Cons"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->_mls_h = _mls_h;_mlsVal->_mls_t = _mls_t; return _mlsVal; }
//│ };
//│ _mlsValue _mls_last_opt(_mlsValue _mls_l_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Nil>(_mls_l_0)){
//│     auto _mls_x_7 = _mlsValue::create<_mls_None>();
//│     _mls_retval = _mls_j_1(_mls_x_7);
//│   } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_l_0)){
//│     auto _mls_x_8 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_t;
//│     auto _mls_x_9 = _mlsValue::as<_mls_Cons>(_mls_l_0)->_mls_h;
//│     if (_mlsValue::isValueOf<_mls_Nil>(_mls_x_8)){
//│       auto _mls_x_11 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│       _mls_retval = _mls_j_2(_mls_x_11);
//│     } else if (_mlsValue::isValueOf<_mls_Cons>(_mls_x_8)){
//│       auto _mls_x_12 = _mlsValue::as<_mls_Cons>(_mls_x_8)->_mls_t;
//│       auto _mls_x_13 = _mlsValue::as<_mls_Cons>(_mls_x_8)->_mls_h;
//│       auto _mls_x_14 = _mls_last_opt(_mls_x_8);
//│       _mls_retval = _mls_j_2(_mls_x_14);
//│     } else throw std::runtime_error("Non-exhaustive match");
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_6){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_mk_list(_mlsValue _mls_n_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_0 = (_mls_n_0==_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_0)){
//│     auto _mls_x_2 = _mlsValue::create<_mls_Nil>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_0)){
//│     auto _mls_x_3 = (_mls_n_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_4 = _mls_mk_list(_mls_x_3);
//│     auto _mls_x_5 = _mlsValue::create<_mls_Cons>(_mls_n_0, _mls_x_4);
//│     _mls_retval = _mls_j_0(_mls_x_5);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_1){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_1;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_15 = _mls_mk_list(_mlsValue::fromIntLit(10));
//│   auto _mls_x_16 = _mls_last_opt(_mls_x_15);
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_10){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_j_1(_mls_x_10);
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_17 = _mls_main();
//│   _mls_retval = _mls_x_17;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, c) =
  a + 1 + 2 + 3 + 4
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |c|)| |#=|→|a| |+| |1| |+| |2| |+| |3| |+| |4|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w,)(8,),)(9,),)(10,)}; fun e1 = (a, c,) => {+(+(+(+(a,)(1,),)(2,),)(3,),)(4,)}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m,)(n,),)(p,),)(q,) else +(-(+(m,)(n,),)(p,),)(q,)}; fun e2 = (x,) => {+(+(+(x,)(12,),)(13,),)(14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),),)(f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #23
//│ let x$5 = +(x$4,9) in -- #22
//│ let x$6 = +(x$5,10) in -- #21
//│ x$6 -- #20
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #36
//│ let x$8 = +(x$7,2) in -- #35
//│ let x$9 = +(x$8,3) in -- #34
//│ let x$10 = +(x$9,4) in -- #33
//│ x$10 -- #32
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #69
//│ let x$12 = 5 in -- #68
//│ let x$13 = 6 in -- #67
//│ let x$14 = 7 in -- #66
//│ if c$1 -- #65
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #53
//│     let x$17 = +(x$16,x$13) in -- #52
//│     let x$18 = +(x$17,x$14) in -- #51
//│     jump j$1(x$18) -- #50
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #64
//│     let x$20 = -(x$19,x$13) in -- #63
//│     let x$21 = +(x$20,x$14) in -- #62
//│     jump j$1(x$21) -- #61
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #42
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #79
//│ let x$24 = +(x$23,13) in -- #78
//│ let x$25 = +(x$24,14) in -- #77
//│ x$25 -- #76
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #121
//│ let* (x$28) = e3(x$27) in -- #120
//│ case x$26 of -- #119
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #111
//│     let* (x$32) = e1(x$31,x$28) in -- #110
//│     jump j$2(x$32) -- #109
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #118
//│     jump j$2(x$33) -- #117
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #97
//│ x$30 -- #96
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #140
//│ let* (x$35) = f(x$34) in -- #139
//│ let x$36 = None() in -- #138
//│ let* (x$37) = f(x$36) in -- #137
//│ let x$38 = +(x$35,x$37) in -- #136
//│ x$38 -- #135
//│ )
//│ },
//│ let* (x$39) = main() in -- #144
//│ x$39 -- #143)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #23
//│ let x$5 = +(x$4,9) in -- #22
//│ let x$6 = +(x$5,10) in -- #21
//│ x$6 -- #20
//│ )
//│ Def(3, e1, [a$0,c$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = +(a$0,1) in -- #36
//│ let x$8 = +(x$7,2) in -- #35
//│ let x$9 = +(x$8,3) in -- #34
//│ let x$10 = +(x$9,4) in -- #33
//│ x$10 -- #32
//│ )
//│ Def(4, e3, [c$1], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$11 = 4 in -- #69
//│ let x$12 = 5 in -- #68
//│ let x$13 = 6 in -- #67
//│ let x$14 = 7 in -- #66
//│ if c$1 -- #65
//│   true =>
//│     let x$16 = +(x$11,x$12) in -- #53
//│     let x$17 = +(x$16,x$13) in -- #52
//│     let x$18 = +(x$17,x$14) in -- #51
//│     jump j$1(x$18) -- #50
//│   false =>
//│     let x$19 = +(x$11,x$12) in -- #64
//│     let x$20 = -(x$19,x$13) in -- #63
//│     let x$21 = +(x$20,x$14) in -- #62
//│     jump j$1(x$21) -- #61
//│ )
//│ Def(5, j$1, [x$15], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$15 -- #42
//│ )
//│ Def(6, e2, [x$22], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$23 = +(x$22,12) in -- #79
//│ let x$24 = +(x$23,13) in -- #78
//│ let x$25 = +(x$24,14) in -- #77
//│ x$25 -- #76
//│ )
//│ Def(7, f, [x$26], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$27) = is_some(x$26) in -- #121
//│ let* (x$28) = e3(x$27) in -- #120
//│ case x$26 of -- #119
//│   Some =>
//│     let x$31 = Some.x(x$26) in -- #111
//│     let* (x$32) = e1(x$31,x$28) in -- #110
//│     jump j$2(x$32) -- #109
//│   None =>
//│     let* (x$33) = e2(x$28) in -- #118
//│     jump j$2(x$33) -- #117
//│ )
//│ Def(8, j$2, [x$29], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$30) = e0(x$29) in -- #97
//│ x$30 -- #96
//│ )
//│ Def(9, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$34 = Some(2) in -- #140
//│ let* (x$35) = f(x$34) in -- #139
//│ let x$36 = None() in -- #138
//│ let* (x$37) = f(x$36) in -- #137
//│ let x$38 = +(x$35,x$37) in -- #136
//│ x$38 -- #135
//│ )
//│ },
//│ let* (x$39) = main() in -- #144
//│ x$39 -- #143)
//│ 
//│ Interpreted:
//│ 115
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Option"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option;  return _mlsVal; }
//│ };
//│ struct _mls_Some: public _mls_Option{
//│   _mlsValue _mls_x;
//│   virtual const char *name() const override { return "Some"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->_mls_x = _mls_x; return _mlsVal; }
//│ };
//│ struct _mls_None: public _mls_Option{
//│ 
//│   virtual const char *name() const override { return "None"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None;  return _mlsVal; }
//│ };
//│ struct _mls_List: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "List"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List;  return _mlsVal; }
//│ };
//│ struct _mls_Nil: public _mls_List{
//│ 
//│   virtual const char *name() const override { return "Nil"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil;  return _mlsVal; }
//│ };
//│ struct _mls_Cons: public _mls_List{
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   virtual const char *name() const override { return "Cons"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->_mls_h = _mls_h;_mlsVal->_mls_t = _mls_t; return _mlsVal; }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_1){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_11 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_12 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_1)){
//│     auto _mls_x_16 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_17 = (_mls_x_16+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_18);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_1)){
//│     auto _mls_x_19 = (_mls_x_11+_mls_x_12);
//│     auto _mls_x_20 = (_mls_x_19-_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20+_mls_x_14);
//│     _mls_retval = _mls_j_1(_mls_x_21);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_29){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_30 = _mls_e0(_mls_x_29);
//│   _mls_retval = _mls_x_30;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::as<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_34 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_35 = _mls_f(_mls_x_34);
//│   auto _mls_x_36 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_37 = _mls_f(_mls_x_36);
//│   auto _mls_x_38 = (_mls_x_35+_mls_x_37);
//│   _mls_retval = _mls_x_38;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0+_mlsValue::fromIntLit(1));
//│   auto _mls_x_8 = (_mls_x_7+_mlsValue::fromIntLit(2));
//│   auto _mls_x_9 = (_mls_x_8+_mlsValue::fromIntLit(3));
//│   auto _mls_x_10 = (_mls_x_9+_mlsValue::fromIntLit(4));
//│   _mls_retval = _mls_x_10;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_26){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_27 = _mls_is_some(_mls_x_26);
//│   auto _mls_x_28 = _mls_e3(_mls_x_27);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_26)){
//│     auto _mls_x_31 = _mlsValue::as<_mls_Some>(_mls_x_26)->_mls_x;
//│     auto _mls_x_32 = _mls_e1(_mls_x_31, _mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_32);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_26)){
//│     auto _mls_x_33 = _mls_e2(_mls_x_28);
//│     _mls_retval = _mls_j_2(_mls_x_33);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_22){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_23 = (_mls_x_22+_mlsValue::fromIntLit(12));
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(13));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_25;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_15){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_15;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_39 = _mls_main();
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }

:interpIR
:genCpp
class Boolean
class True extends Boolean
class False extends Boolean
class List
class Cons(h, t) extends List
class Nil extends List
class Option
class Some(x) extends Option
class None extends Option
fun is_some(o) =
  if o is
    Some(x) then True
    None then False
fun e0(w) =
  w + 8 + 9 + 10
fun e1(a, z) =
  if a > 0 then f(Some(a - 1)) else z
fun e3(c) =
  let m = 4
  let n = 5
  let p = 6
  let q = 7
  if c then m + n + p + q else m + n - p + q
fun e2(x) =
  x + 12 + 13 + 14
fun f(x) =
  let c1 = is_some(x)
  let z = e3(c1)
  let w = if x is
    Some(a) then e1(a, z)
    None then e2(z)
  e0(w)
fun main() =
  f(Some(2)) + f(None)
main()
//│ |#class| |Boolean|↵|#class| |True| |#extends| |Boolean|↵|#class| |False| |#extends| |Boolean|↵|#class| |List|↵|#class| |Cons|(|h|,| |t|)| |#extends| |List|↵|#class| |Nil| |#extends| |List|↵|#class| |Option|↵|#class| |Some|(|x|)| |#extends| |Option|↵|#class| |None| |#extends| |Option|↵|#fun| |is_some|(|o|)| |#=|→|#if| |o| |is|→|Some|(|x|)| |#then| |True|↵|None| |#then| |False|←|←|↵|#fun| |e0|(|w|)| |#=|→|w| |+| |8| |+| |9| |+| |10|←|↵|#fun| |e1|(|a|,| |z|)| |#=|→|#if| |a| |>| |0| |#then| |f|(|Some|(|a| |-| |1|)|)| |#else| |z|←|↵|#fun| |e3|(|c|)| |#=|→|#let| |m| |#=| |4|↵|#let| |n| |#=| |5|↵|#let| |p| |#=| |6|↵|#let| |q| |#=| |7|↵|#if| |c| |#then| |m| |+| |n| |+| |p| |+| |q| |#else| |m| |+| |n| |-| |p| |+| |q|←|↵|#fun| |e2|(|x|)| |#=|→|x| |+| |12| |+| |13| |+| |14|←|↵|#fun| |f|(|x|)| |#=|→|#let| |c1| |#=| |is_some|(|x|)|↵|#let| |z| |#=| |e3|(|c1|)|↵|#let| |w| |#=| |#if| |x| |is|→|Some|(|a|)| |#then| |e1|(|a|,| |z|)|↵|None| |#then| |e2|(|z|)|←|↵|e0|(|w|)|←|↵|#fun| |main|(||)| |#=|→|f|(|Some|(|2|)|)| |+| |f|(|None|)|←|↵|main|(||)|
//│ Parsed: {class Boolean {}; class True: Boolean {}; class False: Boolean {}; class List {}; class Cons(h, t,): List {}; class Nil: List {}; class Option {}; class Some(x,): Option {}; class None: Option {}; fun is_some = (o,) => {if o is ‹(Some(x,)) then True; (None) then False›}; fun e0 = (w,) => {+(+(+(w,)(8,),)(9,),)(10,)}; fun e1 = (a, z,) => {if (>(a,)(0,)) then f(Some(-(a,)(1,),),) else z}; fun e3 = (c,) => {let m = 4; let n = 5; let p = 6; let q = 7; if (c) then +(+(+(m,)(n,),)(p,),)(q,) else +(-(+(m,)(n,),)(p,),)(q,)}; fun e2 = (x,) => {+(+(+(x,)(12,),)(13,),)(14,)}; fun f = (x,) => {let c1 = is_some(x,); let z = e3(c1,); let w = if x is ‹(Some(a,)) then e1(a, z,); (None) then e2(z,)›; e0(w,)}; fun main = () => {+(f(Some(2,),),)(f(None,),)}; main()}
//│ 
//│ 
//│ IR:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #23
//│ let x$5 = +(x$4,9) in -- #22
//│ let x$6 = +(x$5,10) in -- #21
//│ x$6 -- #20
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #45
//│ if x$7 -- #44
//│   true =>
//│     let x$9 = -(a$0,1) in -- #41
//│     let x$10 = Some(x$9) in -- #40
//│     let* (x$11) = f(x$10) in -- #39
//│     jump j$1(x$11) -- #38
//│   false =>
//│     jump j$1(z$0) -- #43
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #27
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #78
//│ let x$13 = 5 in -- #77
//│ let x$14 = 6 in -- #76
//│ let x$15 = 7 in -- #75
//│ if c$0 -- #74
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #62
//│     let x$18 = +(x$17,x$14) in -- #61
//│     let x$19 = +(x$18,x$15) in -- #60
//│     jump j$2(x$19) -- #59
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #73
//│     let x$21 = -(x$20,x$14) in -- #72
//│     let x$22 = +(x$21,x$15) in -- #71
//│     jump j$2(x$22) -- #70
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #51
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #88
//│ let x$25 = +(x$24,13) in -- #87
//│ let x$26 = +(x$25,14) in -- #86
//│ x$26 -- #85
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #130
//│ let* (x$29) = e3(x$28) in -- #129
//│ case x$27 of -- #128
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #120
//│     let* (x$33) = e1(x$32,x$29) in -- #119
//│     jump j$3(x$33) -- #118
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #127
//│     jump j$3(x$34) -- #126
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #106
//│ x$31 -- #105
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #149
//│ let* (x$36) = f(x$35) in -- #148
//│ let x$37 = None() in -- #147
//│ let* (x$38) = f(x$37) in -- #146
//│ let x$39 = +(x$36,x$38) in -- #145
//│ x$39 -- #144
//│ )
//│ },
//│ let* (x$40) = main() in -- #153
//│ x$40 -- #152)
//│ 
//│ Promoted:
//│ Program({ClassInfo(0, Boolean, []),ClassInfo(1, True, []),ClassInfo(2, False, []),ClassInfo(3, List, []),ClassInfo(4, Cons, [h,t]),ClassInfo(5, Nil, []),ClassInfo(6, Option, []),ClassInfo(7, Some, [x]),ClassInfo(8, None, [])}, {
//│ Def(0, is_some, [o$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ case o$0 of -- #13
//│   Some =>
//│     let x$1 = Some.x(o$0) in -- #9
//│     let x$2 = True() in -- #8
//│     jump j$0(x$2) -- #7
//│   None =>
//│     let x$3 = False() in -- #12
//│     jump j$0(x$3) -- #11
//│ )
//│ Def(1, j$0, [x$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$0 -- #1
//│ )
//│ Def(2, e0, [w$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$4 = +(w$0,8) in -- #23
//│ let x$5 = +(x$4,9) in -- #22
//│ let x$6 = +(x$5,10) in -- #21
//│ x$6 -- #20
//│ )
//│ Def(3, e1, [a$0,z$0], [{},{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$7 = >(a$0,0) in -- #45
//│ if x$7 -- #44
//│   true =>
//│     let x$9 = -(a$0,1) in -- #41
//│     let x$10 = Some(x$9) in -- #40
//│     let* (x$11) = f(x$10) in -- #39
//│     jump j$1(x$11) -- #38
//│   false =>
//│     jump j$1(z$0) -- #43
//│ )
//│ Def(4, j$1, [x$8], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$8 -- #27
//│ )
//│ Def(5, e3, [c$0], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$12 = 4 in -- #78
//│ let x$13 = 5 in -- #77
//│ let x$14 = 6 in -- #76
//│ let x$15 = 7 in -- #75
//│ if c$0 -- #74
//│   true =>
//│     let x$17 = +(x$12,x$13) in -- #62
//│     let x$18 = +(x$17,x$14) in -- #61
//│     let x$19 = +(x$18,x$15) in -- #60
//│     jump j$2(x$19) -- #59
//│   false =>
//│     let x$20 = +(x$12,x$13) in -- #73
//│     let x$21 = -(x$20,x$14) in -- #72
//│     let x$22 = +(x$21,x$15) in -- #71
//│     jump j$2(x$22) -- #70
//│ )
//│ Def(6, j$2, [x$16], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ x$16 -- #51
//│ )
//│ Def(7, e2, [x$23], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$24 = +(x$23,12) in -- #88
//│ let x$25 = +(x$24,13) in -- #87
//│ let x$26 = +(x$25,14) in -- #86
//│ x$26 -- #85
//│ )
//│ Def(8, f, [x$27], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$28) = is_some(x$27) in -- #130
//│ let* (x$29) = e3(x$28) in -- #129
//│ case x$27 of -- #128
//│   Some =>
//│     let x$32 = Some.x(x$27) in -- #120
//│     let* (x$33) = e1(x$32,x$29) in -- #119
//│     jump j$3(x$33) -- #118
//│   None =>
//│     let* (x$34) = e2(x$29) in -- #127
//│     jump j$3(x$34) -- #126
//│ )
//│ Def(9, j$3, [x$30], [{}],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let* (x$31) = e0(x$30) in -- #106
//│ x$31 -- #105
//│ )
//│ Def(10, main, [], [],
//│ I: [],
//│ R: [None],
//│ Rec: None,
//│ 1, 
//│ let x$35 = Some(2) in -- #149
//│ let* (x$36) = f(x$35) in -- #148
//│ let x$37 = None() in -- #147
//│ let* (x$38) = f(x$37) in -- #146
//│ let x$39 = +(x$36,x$38) in -- #145
//│ x$39 -- #144
//│ )
//│ },
//│ let* (x$40) = main() in -- #153
//│ x$40 -- #152)
//│ 
//│ Interpreted:
//│ 179
//│ 
//│ Cpp:
//│ #include "mlsprelude.h"
//│ struct _mls_Boolean;
//│ struct _mls_Option;
//│ struct _mls_Some;
//│ struct _mls_None;
//│ struct _mls_List;
//│ struct _mls_Nil;
//│ struct _mls_Cons;
//│ struct _mls_True;
//│ struct _mls_False;
//│ _mlsValue _mls_e0(_mlsValue);
//│ _mlsValue _mls_e2(_mlsValue);
//│ _mlsValue _mls_j_0(_mlsValue);
//│ _mlsValue _mls_e1(_mlsValue, _mlsValue);
//│ _mlsValue _mls_j_2(_mlsValue);
//│ _mlsValue _mls_j_3(_mlsValue);
//│ _mlsValue _mls_main();
//│ _mlsValue _mls_e3(_mlsValue);
//│ _mlsValue _mls_is_some(_mlsValue);
//│ _mlsValue _mls_j_1(_mlsValue);
//│ _mlsValue _mls_f(_mlsValue);
//│ _mlsValue _mlsMain();
//│ struct _mls_Option: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "Option"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Option;  return _mlsVal; }
//│ };
//│ struct _mls_Some: public _mls_Option{
//│   _mlsValue _mls_x;
//│   virtual const char *name() const override { return "Some"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_x) { auto _mlsVal = new (std::align_val_t(align)) _mls_Some; _mlsVal->_mls_x = _mls_x; return _mlsVal; }
//│ };
//│ struct _mls_None: public _mls_Option{
//│ 
//│   virtual const char *name() const override { return "None"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_None;  return _mlsVal; }
//│ };
//│ struct _mls_List: public _mlsObject{
//│ 
//│   virtual const char *name() const override { return "List"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_List;  return _mlsVal; }
//│ };
//│ struct _mls_Nil: public _mls_List{
//│ 
//│   virtual const char *name() const override { return "Nil"; }
//│   template <std::size_t align> static _mlsValue create() { auto _mlsVal = new (std::align_val_t(align)) _mls_Nil;  return _mlsVal; }
//│ };
//│ struct _mls_Cons: public _mls_List{
//│   _mlsValue _mls_h;
//│   _mlsValue _mls_t;
//│   virtual const char *name() const override { return "Cons"; }
//│   template <std::size_t align> static _mlsValue create(_mlsValue _mls_h, _mlsValue _mls_t) { auto _mlsVal = new (std::align_val_t(align)) _mls_Cons; _mlsVal->_mls_h = _mls_h;_mlsVal->_mls_t = _mls_t; return _mlsVal; }
//│ };
//│ _mlsValue _mls_j_0(_mlsValue _mls_x_0){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_0;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e3(_mlsValue _mls_c_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_12 = _mlsValue::fromIntLit(4);
//│   auto _mls_x_13 = _mlsValue::fromIntLit(5);
//│   auto _mls_x_14 = _mlsValue::fromIntLit(6);
//│   auto _mls_x_15 = _mlsValue::fromIntLit(7);
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_c_0)){
//│     auto _mls_x_17 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_18 = (_mls_x_17+_mls_x_14);
//│     auto _mls_x_19 = (_mls_x_18+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_19);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_c_0)){
//│     auto _mls_x_20 = (_mls_x_12+_mls_x_13);
//│     auto _mls_x_21 = (_mls_x_20-_mls_x_14);
//│     auto _mls_x_22 = (_mls_x_21+_mls_x_15);
//│     _mls_retval = _mls_j_2(_mls_x_22);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_1(_mlsValue _mls_x_8){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_8;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e2(_mlsValue _mls_x_23){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_24 = (_mls_x_23+_mlsValue::fromIntLit(12));
//│   auto _mls_x_25 = (_mls_x_24+_mlsValue::fromIntLit(13));
//│   auto _mls_x_26 = (_mls_x_25+_mlsValue::fromIntLit(14));
//│   _mls_retval = _mls_x_26;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_is_some(_mlsValue _mls_o_0){
//│   _mlsValue _mls_retval;
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_o_0)){
//│     auto _mls_x_1 = _mlsValue::as<_mls_Some>(_mls_o_0)->_mls_x;
//│     auto _mls_x_2 = _mlsValue::create<_mls_True>();
//│     _mls_retval = _mls_j_0(_mls_x_2);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_o_0)){
//│     auto _mls_x_3 = _mlsValue::create<_mls_False>();
//│     _mls_retval = _mls_j_0(_mls_x_3);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_2(_mlsValue _mls_x_16){
//│   _mlsValue _mls_retval;
//│   _mls_retval = _mls_x_16;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_j_3(_mlsValue _mls_x_30){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_31 = _mls_e0(_mls_x_30);
//│   _mls_retval = _mls_x_31;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e0(_mlsValue _mls_w_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_4 = (_mls_w_0+_mlsValue::fromIntLit(8));
//│   auto _mls_x_5 = (_mls_x_4+_mlsValue::fromIntLit(9));
//│   auto _mls_x_6 = (_mls_x_5+_mlsValue::fromIntLit(10));
//│   _mls_retval = _mls_x_6;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_e1(_mlsValue _mls_a_0, _mlsValue _mls_z_0){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_7 = (_mls_a_0>_mlsValue::fromIntLit(0));
//│   if (_mlsValue::isValueOf<_mls_True>(_mls_x_7)){
//│     auto _mls_x_9 = (_mls_a_0-_mlsValue::fromIntLit(1));
//│     auto _mls_x_10 = _mlsValue::create<_mls_Some>(_mls_x_9);
//│     auto _mls_x_11 = _mls_f(_mls_x_10);
//│     _mls_retval = _mls_j_1(_mls_x_11);
//│   } else if (_mlsValue::isValueOf<_mls_False>(_mls_x_7)){
//│     _mls_retval = _mls_j_1(_mls_z_0);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_main(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_35 = _mlsValue::create<_mls_Some>(_mlsValue::fromIntLit(2));
//│   auto _mls_x_36 = _mls_f(_mls_x_35);
//│   auto _mls_x_37 = _mlsValue::create<_mls_None>();
//│   auto _mls_x_38 = _mls_f(_mls_x_37);
//│   auto _mls_x_39 = (_mls_x_36+_mls_x_38);
//│   _mls_retval = _mls_x_39;
//│   return _mls_retval;
//│ }
//│ _mlsValue _mls_f(_mlsValue _mls_x_27){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_28 = _mls_is_some(_mls_x_27);
//│   auto _mls_x_29 = _mls_e3(_mls_x_28);
//│   if (_mlsValue::isValueOf<_mls_Some>(_mls_x_27)){
//│     auto _mls_x_32 = _mlsValue::as<_mls_Some>(_mls_x_27)->_mls_x;
//│     auto _mls_x_33 = _mls_e1(_mls_x_32, _mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_33);
//│   } else if (_mlsValue::isValueOf<_mls_None>(_mls_x_27)){
//│     auto _mls_x_34 = _mls_e2(_mls_x_29);
//│     _mls_retval = _mls_j_3(_mls_x_34);
//│   } else throw std::runtime_error("Non-exhaustive match");
//│   return _mls_retval;
//│ }
//│ _mlsValue _mlsMain(){
//│   _mlsValue _mls_retval;
//│   auto _mls_x_40 = _mls_main();
//│   _mls_retval = _mls_x_40;
//│   return _mls_retval;
//│ }
